function _mergeNamespaces(n2, m4) {
  for (var i3 = 0; i3 < m4.length; i3++) {
    const e3 = m4[i3];
    if (typeof e3 !== "string" && !Array.isArray(e3)) {
      for (const k3 in e3) {
        if (k3 !== "default" && !(k3 in n2)) {
          const d4 = Object.getOwnPropertyDescriptor(e3, k3);
          if (d4) {
            Object.defineProperty(n2, k3, d4.get ? d4 : {
              enumerable: true,
              get: () => e3[k3]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x3) {
  return x3 && x3.__esModule && Object.prototype.hasOwnProperty.call(x3, "default") ? x3["default"] : x3;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element"), n$3 = Symbol.for("react.portal"), p$3 = Symbol.for("react.fragment"), q$1 = Symbol.for("react.strict_mode"), r$2 = Symbol.for("react.profiler"), t$2 = Symbol.for("react.provider"), u$2 = Symbol.for("react.context"), v$2 = Symbol.for("react.forward_ref"), w = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$1 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a4) {
  if (null === a4 || "object" !== typeof a4) return null;
  a4 = z$2 && a4[z$2] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$1 = Object.assign, D$1 = {};
function E$1(a4, b2, e3) {
  this.props = a4;
  this.context = b2;
  this.refs = D$1;
  this.updater = e3 || B$1;
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(a4, b2) {
  if ("object" !== typeof a4 && "function" !== typeof a4 && null != a4) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a4, b2, "setState");
};
E$1.prototype.forceUpdate = function(a4) {
  this.updater.enqueueForceUpdate(this, a4, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$1.prototype;
function G$1(a4, b2, e3) {
  this.props = a4;
  this.context = b2;
  this.refs = D$1;
  this.updater = e3 || B$1;
}
var H$1 = G$1.prototype = new F$1();
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = true;
var I$1 = Array.isArray, J$1 = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$1 = { key: true, ref: true, __self: true, __source: true };
function M$3(a4, b2, e3) {
  var d4, c3 = {}, k3 = null, h4 = null;
  if (null != b2) for (d4 in void 0 !== b2.ref && (h4 = b2.ref), void 0 !== b2.key && (k3 = "" + b2.key), b2) J$1.call(b2, d4) && !L$1.hasOwnProperty(d4) && (c3[d4] = b2[d4]);
  var g2 = arguments.length - 2;
  if (1 === g2) c3.children = e3;
  else if (1 < g2) {
    for (var f2 = Array(g2), m4 = 0; m4 < g2; m4++) f2[m4] = arguments[m4 + 2];
    c3.children = f2;
  }
  if (a4 && a4.defaultProps) for (d4 in g2 = a4.defaultProps, g2) void 0 === c3[d4] && (c3[d4] = g2[d4]);
  return { $$typeof: l$2, type: a4, key: k3, ref: h4, props: c3, _owner: K$1.current };
}
function N$1(a4, b2) {
  return { $$typeof: l$2, type: a4.type, key: b2, ref: a4.ref, props: a4.props, _owner: a4._owner };
}
function O$1(a4) {
  return "object" === typeof a4 && null !== a4 && a4.$$typeof === l$2;
}
function escape(a4) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a4.replace(/[=:]/g, function(a5) {
    return b2[a5];
  });
}
var P$2 = /\/+/g;
function Q$1(a4, b2) {
  return "object" === typeof a4 && null !== a4 && null != a4.key ? escape("" + a4.key) : b2.toString(36);
}
function R$1(a4, b2, e3, d4, c3) {
  var k3 = typeof a4;
  if ("undefined" === k3 || "boolean" === k3) a4 = null;
  var h4 = false;
  if (null === a4) h4 = true;
  else switch (k3) {
    case "string":
    case "number":
      h4 = true;
      break;
    case "object":
      switch (a4.$$typeof) {
        case l$2:
        case n$3:
          h4 = true;
      }
  }
  if (h4) return h4 = a4, c3 = c3(h4), a4 = "" === d4 ? "." + Q$1(h4, 0) : d4, I$1(c3) ? (e3 = "", null != a4 && (e3 = a4.replace(P$2, "$&/") + "/"), R$1(c3, b2, e3, "", function(a5) {
    return a5;
  })) : null != c3 && (O$1(c3) && (c3 = N$1(c3, e3 + (!c3.key || h4 && h4.key === c3.key ? "" : ("" + c3.key).replace(P$2, "$&/") + "/") + a4)), b2.push(c3)), 1;
  h4 = 0;
  d4 = "" === d4 ? "." : d4 + ":";
  if (I$1(a4)) for (var g2 = 0; g2 < a4.length; g2++) {
    k3 = a4[g2];
    var f2 = d4 + Q$1(k3, g2);
    h4 += R$1(k3, b2, e3, f2, c3);
  }
  else if (f2 = A$2(a4), "function" === typeof f2) for (a4 = f2.call(a4), g2 = 0; !(k3 = a4.next()).done; ) k3 = k3.value, f2 = d4 + Q$1(k3, g2++), h4 += R$1(k3, b2, e3, f2, c3);
  else if ("object" === k3) throw b2 = String(a4), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a4).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h4;
}
function S$1(a4, b2, e3) {
  if (null == a4) return a4;
  var d4 = [], c3 = 0;
  R$1(a4, d4, "", "", function(a5) {
    return b2.call(e3, a5, c3++);
  });
  return d4;
}
function T$1(a4) {
  if (-1 === a4._status) {
    var b2 = a4._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a4._status || -1 === a4._status) a4._status = 1, a4._result = b3;
    }, function(b3) {
      if (0 === a4._status || -1 === a4._status) a4._status = 2, a4._result = b3;
    });
    -1 === a4._status && (a4._status = 0, a4._result = b2);
  }
  if (1 === a4._status) return a4._result.default;
  throw a4._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$2 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$1 };
function X$2() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$1, forEach: function(a4, b2, e3) {
  S$1(a4, function() {
    b2.apply(this, arguments);
  }, e3);
}, count: function(a4) {
  var b2 = 0;
  S$1(a4, function() {
    b2++;
  });
  return b2;
}, toArray: function(a4) {
  return S$1(a4, function(a5) {
    return a5;
  }) || [];
}, only: function(a4) {
  if (!O$1(a4)) throw Error("React.Children.only expected to receive a single React element child.");
  return a4;
} };
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$1;
react_production_min.Suspense = w;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.act = X$2;
react_production_min.cloneElement = function(a4, b2, e3) {
  if (null === a4 || void 0 === a4) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a4 + ".");
  var d4 = C$1({}, a4.props), c3 = a4.key, k3 = a4.ref, h4 = a4._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k3 = b2.ref, h4 = K$1.current);
    void 0 !== b2.key && (c3 = "" + b2.key);
    if (a4.type && a4.type.defaultProps) var g2 = a4.type.defaultProps;
    for (f2 in b2) J$1.call(b2, f2) && !L$1.hasOwnProperty(f2) && (d4[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d4.children = e3;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m4 = 0; m4 < f2; m4++) g2[m4] = arguments[m4 + 2];
    d4.children = g2;
  }
  return { $$typeof: l$2, type: a4.type, key: c3, ref: k3, props: d4, _owner: h4 };
};
react_production_min.createContext = function(a4) {
  a4 = { $$typeof: u$2, _currentValue: a4, _currentValue2: a4, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a4.Provider = { $$typeof: t$2, _context: a4 };
  return a4.Consumer = a4;
};
react_production_min.createElement = M$3;
react_production_min.createFactory = function(a4) {
  var b2 = M$3.bind(null, a4);
  b2.type = a4;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a4) {
  return { $$typeof: v$2, render: a4 };
};
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(a4) {
  return { $$typeof: y$1, _payload: { _status: -1, _result: a4 }, _init: T$1 };
};
react_production_min.memo = function(a4, b2) {
  return { $$typeof: x$1, type: a4, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a4) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a4();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = X$2;
react_production_min.useCallback = function(a4, b2) {
  return U$2.current.useCallback(a4, b2);
};
react_production_min.useContext = function(a4) {
  return U$2.current.useContext(a4);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a4) {
  return U$2.current.useDeferredValue(a4);
};
react_production_min.useEffect = function(a4, b2) {
  return U$2.current.useEffect(a4, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a4, b2, e3) {
  return U$2.current.useImperativeHandle(a4, b2, e3);
};
react_production_min.useInsertionEffect = function(a4, b2) {
  return U$2.current.useInsertionEffect(a4, b2);
};
react_production_min.useLayoutEffect = function(a4, b2) {
  return U$2.current.useLayoutEffect(a4, b2);
};
react_production_min.useMemo = function(a4, b2) {
  return U$2.current.useMemo(a4, b2);
};
react_production_min.useReducer = function(a4, b2, e3) {
  return U$2.current.useReducer(a4, b2, e3);
};
react_production_min.useRef = function(a4) {
  return U$2.current.useRef(a4);
};
react_production_min.useState = function(a4) {
  return U$2.current.useState(a4);
};
react_production_min.useSyncExternalStore = function(a4, b2, e3) {
  return U$2.current.useSyncExternalStore(a4, b2, e3);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React$1 = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$2 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React$1
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$2 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$2 = { key: true, ref: true, __self: true, __source: true };
function q(c3, a4, g2) {
  var b2, d4 = {}, e3 = null, h4 = null;
  void 0 !== g2 && (e3 = "" + g2);
  void 0 !== a4.key && (e3 = "" + a4.key);
  void 0 !== a4.ref && (h4 = a4.ref);
  for (b2 in a4) m$2.call(a4, b2) && !p$2.hasOwnProperty(b2) && (d4[b2] = a4[b2]);
  if (c3 && c3.defaultProps) for (b2 in a4 = c3.defaultProps, a4) void 0 === d4[b2] && (d4[b2] = a4[b2]);
  return { $$typeof: k$1, type: c3, key: e3, ref: h4, props: d4, _owner: n$2.current };
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q;
reactJsxRuntime_production_min.jsxs = q;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a4, b2) {
    var c3 = a4.length;
    a4.push(b2);
    a: for (; 0 < c3; ) {
      var d4 = c3 - 1 >>> 1, e3 = a4[d4];
      if (0 < g2(e3, b2)) a4[d4] = b2, a4[c3] = e3, c3 = d4;
      else break a;
    }
  }
  function h4(a4) {
    return 0 === a4.length ? null : a4[0];
  }
  function k3(a4) {
    if (0 === a4.length) return null;
    var b2 = a4[0], c3 = a4.pop();
    if (c3 !== b2) {
      a4[0] = c3;
      a: for (var d4 = 0, e3 = a4.length, w3 = e3 >>> 1; d4 < w3; ) {
        var m4 = 2 * (d4 + 1) - 1, C2 = a4[m4], n2 = m4 + 1, x3 = a4[n2];
        if (0 > g2(C2, c3)) n2 < e3 && 0 > g2(x3, C2) ? (a4[d4] = x3, a4[n2] = c3, d4 = n2) : (a4[d4] = C2, a4[m4] = c3, d4 = m4);
        else if (n2 < e3 && 0 > g2(x3, c3)) a4[d4] = x3, a4[n2] = c3, d4 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a4, b2) {
    var c3 = a4.sortIndex - b2.sortIndex;
    return 0 !== c3 ? c3 : a4.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q3 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q3;
    };
  }
  var r2 = [], t3 = [], u3 = 1, v2 = null, y4 = 3, z3 = false, A2 = false, B3 = false, D3 = "function" === typeof setTimeout ? setTimeout : null, E3 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G3(a4) {
    for (var b2 = h4(t3); null !== b2; ) {
      if (null === b2.callback) k3(t3);
      else if (b2.startTime <= a4) k3(t3), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h4(t3);
    }
  }
  function H4(a4) {
    B3 = false;
    G3(a4);
    if (!A2) if (null !== h4(r2)) A2 = true, I3(J2);
    else {
      var b2 = h4(t3);
      null !== b2 && K3(H4, b2.startTime - a4);
    }
  }
  function J2(a4, b2) {
    A2 = false;
    B3 && (B3 = false, E3(L3), L3 = -1);
    z3 = true;
    var c3 = y4;
    try {
      G3(b2);
      for (v2 = h4(r2); null !== v2 && (!(v2.expirationTime > b2) || a4 && !M4()); ) {
        var d4 = v2.callback;
        if ("function" === typeof d4) {
          v2.callback = null;
          y4 = v2.priorityLevel;
          var e3 = d4(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e3 ? v2.callback = e3 : v2 === h4(r2) && k3(r2);
          G3(b2);
        } else k3(r2);
        v2 = h4(r2);
      }
      if (null !== v2) var w3 = true;
      else {
        var m4 = h4(t3);
        null !== m4 && K3(H4, m4.startTime - b2);
        w3 = false;
      }
      return w3;
    } finally {
      v2 = null, y4 = c3, z3 = false;
    }
  }
  var N2 = false, O3 = null, L3 = -1, P2 = 5, Q3 = -1;
  function M4() {
    return exports.unstable_now() - Q3 < P2 ? false : true;
  }
  function R3() {
    if (null !== O3) {
      var a4 = exports.unstable_now();
      Q3 = a4;
      var b2 = true;
      try {
        b2 = O3(true, a4);
      } finally {
        b2 ? S4() : (N2 = false, O3 = null);
      }
    } else N2 = false;
  }
  var S4;
  if ("function" === typeof F2) S4 = function() {
    F2(R3);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T3 = new MessageChannel(), U2 = T3.port2;
    T3.port1.onmessage = R3;
    S4 = function() {
      U2.postMessage(null);
    };
  } else S4 = function() {
    D3(R3, 0);
  };
  function I3(a4) {
    O3 = a4;
    N2 || (N2 = true, S4());
  }
  function K3(a4, b2) {
    L3 = D3(function() {
      a4(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a4) {
    a4.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z3 || (A2 = true, I3(J2));
  };
  exports.unstable_forceFrameRate = function(a4) {
    0 > a4 || 125 < a4 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a4 ? Math.floor(1e3 / a4) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y4;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h4(r2);
  };
  exports.unstable_next = function(a4) {
    switch (y4) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y4;
    }
    var c3 = y4;
    y4 = b2;
    try {
      return a4();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a4, b2) {
    switch (a4) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a4 = 3;
    }
    var c3 = y4;
    y4 = a4;
    try {
      return b2();
    } finally {
      y4 = c3;
    }
  };
  exports.unstable_scheduleCallback = function(a4, b2, c3) {
    var d4 = exports.unstable_now();
    "object" === typeof c3 && null !== c3 ? (c3 = c3.delay, c3 = "number" === typeof c3 && 0 < c3 ? d4 + c3 : d4) : c3 = d4;
    switch (a4) {
      case 1:
        var e3 = -1;
        break;
      case 2:
        e3 = 250;
        break;
      case 5:
        e3 = 1073741823;
        break;
      case 4:
        e3 = 1e4;
        break;
      default:
        e3 = 5e3;
    }
    e3 = c3 + e3;
    a4 = { id: u3++, callback: b2, priorityLevel: a4, startTime: c3, expirationTime: e3, sortIndex: -1 };
    c3 > d4 ? (a4.sortIndex = c3, f2(t3, a4), null === h4(r2) && a4 === h4(t3) && (B3 ? (E3(L3), L3 = -1) : B3 = true, K3(H4, c3 - d4))) : (a4.sortIndex = e3, f2(r2, a4), A2 || z3 || (A2 = true, I3(J2)));
    return a4;
  };
  exports.unstable_shouldYield = M4;
  exports.unstable_wrapCallback = function(a4) {
    var b2 = y4;
    return function() {
      var c3 = y4;
      y4 = b2;
      try {
        return a4.apply(this, arguments);
      } finally {
        y4 = c3;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$1(a4) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a4, c3 = 1; c3 < arguments.length; c3++) b2 += "&args[]=" + encodeURIComponent(arguments[c3]);
  return "Minified React error #" + a4 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a4, b2) {
  ha(a4, b2);
  ha(a4 + "Capture", b2);
}
function ha(a4, b2) {
  ea[a4] = b2;
  for (a4 = 0; a4 < b2.length; a4++) da.add(b2[a4]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a4) {
  if (ja.call(ma, a4)) return true;
  if (ja.call(la, a4)) return false;
  if (ka.test(a4)) return ma[a4] = true;
  la[a4] = true;
  return false;
}
function pa(a4, b2, c3, d4) {
  if (null !== c3 && 0 === c3.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d4) return false;
      if (null !== c3) return !c3.acceptsBooleans;
      a4 = a4.toLowerCase().slice(0, 5);
      return "data-" !== a4 && "aria-" !== a4;
    default:
      return false;
  }
}
function qa(a4, b2, c3, d4) {
  if (null === b2 || "undefined" === typeof b2 || pa(a4, b2, c3, d4)) return true;
  if (d4) return false;
  if (null !== c3) switch (c3.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$1(a4, b2, c3, d4, e3, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d4;
  this.attributeNamespace = e3;
  this.mustUseProperty = c3;
  this.propertyName = a4;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a4) {
  z$1[a4] = new v$1(a4, 0, false, a4, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a4) {
  var b2 = a4[0];
  z$1[b2] = new v$1(b2, 1, false, a4[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 2, false, a4.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 2, false, a4, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a4) {
  z$1[a4] = new v$1(a4, 3, false, a4.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 3, true, a4, null, false, false);
});
["capture", "download"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 4, false, a4, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 6, false, a4, null, false, false);
});
["rowSpan", "start"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 5, false, a4.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a4) {
  return a4[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a4) {
  var b2 = a4.replace(
    ra,
    sa
  );
  z$1[b2] = new v$1(b2, 1, false, a4, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a4) {
  var b2 = a4.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a4, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a4) {
  var b2 = a4.replace(ra, sa);
  z$1[b2] = new v$1(b2, 1, false, a4, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 1, false, a4.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$1("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a4) {
  z$1[a4] = new v$1(a4, 1, false, a4.toLowerCase(), null, true, true);
});
function ta(a4, b2, c3, d4) {
  var e3 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e3 ? 0 !== e3.type : d4 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c3, e3, d4) && (c3 = null), d4 || null === e3 ? oa(b2) && (null === c3 ? a4.removeAttribute(b2) : a4.setAttribute(b2, "" + c3)) : e3.mustUseProperty ? a4[e3.propertyName] = null === c3 ? 3 === e3.type ? false : "" : c3 : (b2 = e3.attributeName, d4 = e3.attributeNamespace, null === c3 ? a4.removeAttribute(b2) : (e3 = e3.type, c3 = 3 === e3 || 4 === e3 && true === c3 ? "" : "" + c3, d4 ? a4.setAttributeNS(d4, b2, c3) : a4.setAttribute(b2, c3)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a4) {
  if (null === a4 || "object" !== typeof a4) return null;
  a4 = Ja && a4[Ja] || a4["@@iterator"];
  return "function" === typeof a4 ? a4 : null;
}
var A$1 = Object.assign, La;
function Ma(a4) {
  if (void 0 === La) try {
    throw Error();
  } catch (c3) {
    var b2 = c3.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a4;
}
var Na = false;
function Oa(a4, b2) {
  if (!a4 || Na) return "";
  Na = true;
  var c3 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d4 = l2;
      }
      Reflect.construct(a4, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d4 = l2;
      }
      a4.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d4 = l2;
      }
      a4();
    }
  } catch (l2) {
    if (l2 && d4 && "string" === typeof l2.stack) {
      for (var e3 = l2.stack.split("\n"), f2 = d4.stack.split("\n"), g2 = e3.length - 1, h4 = f2.length - 1; 1 <= g2 && 0 <= h4 && e3[g2] !== f2[h4]; ) h4--;
      for (; 1 <= g2 && 0 <= h4; g2--, h4--) if (e3[g2] !== f2[h4]) {
        if (1 !== g2 || 1 !== h4) {
          do
            if (g2--, h4--, 0 > h4 || e3[g2] !== f2[h4]) {
              var k3 = "\n" + e3[g2].replace(" at new ", " at ");
              a4.displayName && k3.includes("<anonymous>") && (k3 = k3.replace("<anonymous>", a4.displayName));
              return k3;
            }
          while (1 <= g2 && 0 <= h4);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c3;
  }
  return (a4 = a4 ? a4.displayName || a4.name : "") ? Ma(a4) : "";
}
function Pa(a4) {
  switch (a4.tag) {
    case 5:
      return Ma(a4.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a4 = Oa(a4.type, false), a4;
    case 11:
      return a4 = Oa(a4.type.render, false), a4;
    case 1:
      return a4 = Oa(a4.type, true), a4;
    default:
      return "";
  }
}
function Qa(a4) {
  if (null == a4) return null;
  if ("function" === typeof a4) return a4.displayName || a4.name || null;
  if ("string" === typeof a4) return a4;
  switch (a4) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a4) switch (a4.$$typeof) {
    case Ca:
      return (a4.displayName || "Context") + ".Consumer";
    case Ba:
      return (a4._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a4.render;
      a4 = a4.displayName;
      a4 || (a4 = b2.displayName || b2.name || "", a4 = "" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
      return a4;
    case Ga:
      return b2 = a4.displayName || null, null !== b2 ? b2 : Qa(a4.type) || "Memo";
    case Ha:
      b2 = a4._payload;
      a4 = a4._init;
      try {
        return Qa(a4(b2));
      } catch (c3) {
      }
  }
  return null;
}
function Ra(a4) {
  var b2 = a4.type;
  switch (a4.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a4 = b2.render, a4 = a4.displayName || a4.name || "", b2.displayName || ("" !== a4 ? "ForwardRef(" + a4 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a4) {
  switch (typeof a4) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a4;
    case "object":
      return a4;
    default:
      return "";
  }
}
function Ta(a4) {
  var b2 = a4.type;
  return (a4 = a4.nodeName) && "input" === a4.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a4) {
  var b2 = Ta(a4) ? "checked" : "value", c3 = Object.getOwnPropertyDescriptor(a4.constructor.prototype, b2), d4 = "" + a4[b2];
  if (!a4.hasOwnProperty(b2) && "undefined" !== typeof c3 && "function" === typeof c3.get && "function" === typeof c3.set) {
    var e3 = c3.get, f2 = c3.set;
    Object.defineProperty(a4, b2, { configurable: true, get: function() {
      return e3.call(this);
    }, set: function(a5) {
      d4 = "" + a5;
      f2.call(this, a5);
    } });
    Object.defineProperty(a4, b2, { enumerable: c3.enumerable });
    return { getValue: function() {
      return d4;
    }, setValue: function(a5) {
      d4 = "" + a5;
    }, stopTracking: function() {
      a4._valueTracker = null;
      delete a4[b2];
    } };
  }
}
function Va(a4) {
  a4._valueTracker || (a4._valueTracker = Ua(a4));
}
function Wa(a4) {
  if (!a4) return false;
  var b2 = a4._valueTracker;
  if (!b2) return true;
  var c3 = b2.getValue();
  var d4 = "";
  a4 && (d4 = Ta(a4) ? a4.checked ? "true" : "false" : a4.value);
  a4 = d4;
  return a4 !== c3 ? (b2.setValue(a4), true) : false;
}
function Xa(a4) {
  a4 = a4 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a4) return null;
  try {
    return a4.activeElement || a4.body;
  } catch (b2) {
    return a4.body;
  }
}
function Ya(a4, b2) {
  var c3 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c3 ? c3 : a4._wrapperState.initialChecked });
}
function Za(a4, b2) {
  var c3 = null == b2.defaultValue ? "" : b2.defaultValue, d4 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c3 = Sa(null != b2.value ? b2.value : c3);
  a4._wrapperState = { initialChecked: d4, initialValue: c3, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a4, b2) {
  b2 = b2.checked;
  null != b2 && ta(a4, "checked", b2, false);
}
function bb(a4, b2) {
  ab(a4, b2);
  var c3 = Sa(b2.value), d4 = b2.type;
  if (null != c3) if ("number" === d4) {
    if (0 === c3 && "" === a4.value || a4.value != c3) a4.value = "" + c3;
  } else a4.value !== "" + c3 && (a4.value = "" + c3);
  else if ("submit" === d4 || "reset" === d4) {
    a4.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a4, b2.type, c3) : b2.hasOwnProperty("defaultValue") && cb(a4, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a4.defaultChecked = !!b2.defaultChecked);
}
function db(a4, b2, c3) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d4 = b2.type;
    if (!("submit" !== d4 && "reset" !== d4 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a4._wrapperState.initialValue;
    c3 || b2 === a4.value || (a4.value = b2);
    a4.defaultValue = b2;
  }
  c3 = a4.name;
  "" !== c3 && (a4.name = "");
  a4.defaultChecked = !!a4._wrapperState.initialChecked;
  "" !== c3 && (a4.name = c3);
}
function cb(a4, b2, c3) {
  if ("number" !== b2 || Xa(a4.ownerDocument) !== a4) null == c3 ? a4.defaultValue = "" + a4._wrapperState.initialValue : a4.defaultValue !== "" + c3 && (a4.defaultValue = "" + c3);
}
var eb = Array.isArray;
function fb(a4, b2, c3, d4) {
  a4 = a4.options;
  if (b2) {
    b2 = {};
    for (var e3 = 0; e3 < c3.length; e3++) b2["$" + c3[e3]] = true;
    for (c3 = 0; c3 < a4.length; c3++) e3 = b2.hasOwnProperty("$" + a4[c3].value), a4[c3].selected !== e3 && (a4[c3].selected = e3), e3 && d4 && (a4[c3].defaultSelected = true);
  } else {
    c3 = "" + Sa(c3);
    b2 = null;
    for (e3 = 0; e3 < a4.length; e3++) {
      if (a4[e3].value === c3) {
        a4[e3].selected = true;
        d4 && (a4[e3].defaultSelected = true);
        return;
      }
      null !== b2 || a4[e3].disabled || (b2 = a4[e3]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a4, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$1(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a4._wrapperState.initialValue });
}
function hb(a4, b2) {
  var c3 = b2.value;
  if (null == c3) {
    c3 = b2.children;
    b2 = b2.defaultValue;
    if (null != c3) {
      if (null != b2) throw Error(p$1(92));
      if (eb(c3)) {
        if (1 < c3.length) throw Error(p$1(93));
        c3 = c3[0];
      }
      b2 = c3;
    }
    null == b2 && (b2 = "");
    c3 = b2;
  }
  a4._wrapperState = { initialValue: Sa(c3) };
}
function ib(a4, b2) {
  var c3 = Sa(b2.value), d4 = Sa(b2.defaultValue);
  null != c3 && (c3 = "" + c3, c3 !== a4.value && (a4.value = c3), null == b2.defaultValue && a4.defaultValue !== c3 && (a4.defaultValue = c3));
  null != d4 && (a4.defaultValue = "" + d4);
}
function jb(a4) {
  var b2 = a4.textContent;
  b2 === a4._wrapperState.initialValue && "" !== b2 && null !== b2 && (a4.value = b2);
}
function kb(a4) {
  switch (a4) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a4, b2) {
  return null == a4 || "http://www.w3.org/1999/xhtml" === a4 ? kb(b2) : "http://www.w3.org/2000/svg" === a4 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a4;
}
var mb, nb = function(a4) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c3, d4, e3) {
    MSApp.execUnsafeLocalFunction(function() {
      return a4(b2, c3, d4, e3);
    });
  } : a4;
}(function(a4, b2) {
  if ("http://www.w3.org/2000/svg" !== a4.namespaceURI || "innerHTML" in a4) a4.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a4.firstChild; ) a4.removeChild(a4.firstChild);
    for (; b2.firstChild; ) a4.appendChild(b2.firstChild);
  }
});
function ob(a4, b2) {
  if (b2) {
    var c3 = a4.firstChild;
    if (c3 && c3 === a4.lastChild && 3 === c3.nodeType) {
      c3.nodeValue = b2;
      return;
    }
  }
  a4.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a4) {
  qb.forEach(function(b2) {
    b2 = b2 + a4.charAt(0).toUpperCase() + a4.substring(1);
    pb[b2] = pb[a4];
  });
});
function rb(a4, b2, c3) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c3 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a4) && pb[a4] ? ("" + b2).trim() : b2 + "px";
}
function sb(a4, b2) {
  a4 = a4.style;
  for (var c3 in b2) if (b2.hasOwnProperty(c3)) {
    var d4 = 0 === c3.indexOf("--"), e3 = rb(c3, b2[c3], d4);
    "float" === c3 && (c3 = "cssFloat");
    d4 ? a4.setProperty(c3, e3) : a4[c3] = e3;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a4, b2) {
  if (b2) {
    if (tb[a4] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$1(137, a4));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$1(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$1(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$1(62));
  }
}
function vb(a4, b2) {
  if (-1 === a4.indexOf("-")) return "string" === typeof b2.is;
  switch (a4) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a4) {
  a4 = a4.target || a4.srcElement || window;
  a4.correspondingUseElement && (a4 = a4.correspondingUseElement);
  return 3 === a4.nodeType ? a4.parentNode : a4;
}
var yb = null, zb = null, Ab = null;
function Bb(a4) {
  if (a4 = Cb(a4)) {
    if ("function" !== typeof yb) throw Error(p$1(280));
    var b2 = a4.stateNode;
    b2 && (b2 = Db(b2), yb(a4.stateNode, a4.type, b2));
  }
}
function Eb(a4) {
  zb ? Ab ? Ab.push(a4) : Ab = [a4] : zb = a4;
}
function Fb() {
  if (zb) {
    var a4 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a4);
    if (b2) for (a4 = 0; a4 < b2.length; a4++) Bb(b2[a4]);
  }
}
function Gb(a4, b2) {
  return a4(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a4, b2, c3) {
  if (Ib) return a4(b2, c3);
  Ib = true;
  try {
    return Gb(a4, b2, c3);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a4, b2) {
  var c3 = a4.stateNode;
  if (null === c3) return null;
  var d4 = Db(c3);
  if (null === d4) return null;
  c3 = d4[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d4 = !d4.disabled) || (a4 = a4.type, d4 = !("button" === a4 || "input" === a4 || "select" === a4 || "textarea" === a4));
      a4 = !d4;
      break a;
    default:
      a4 = false;
  }
  if (a4) return null;
  if (c3 && "function" !== typeof c3) throw Error(p$1(231, b2, typeof c3));
  return c3;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a4) {
  Lb = false;
}
function Nb(a4, b2, c3, d4, e3, f2, g2, h4, k3) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c3, l2);
  } catch (m4) {
    this.onError(m4);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a4) {
  Ob = true;
  Pb = a4;
} };
function Tb(a4, b2, c3, d4, e3, f2, g2, h4, k3) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a4, b2, c3, d4, e3, f2, g2, h4, k3) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$1(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a4) {
  var b2 = a4, c3 = a4;
  if (a4.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a4 = b2;
    do
      b2 = a4, 0 !== (b2.flags & 4098) && (c3 = b2.return), a4 = b2.return;
    while (a4);
  }
  return 3 === b2.tag ? c3 : null;
}
function Wb(a4) {
  if (13 === a4.tag) {
    var b2 = a4.memoizedState;
    null === b2 && (a4 = a4.alternate, null !== a4 && (b2 = a4.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a4) {
  if (Vb(a4) !== a4) throw Error(p$1(188));
}
function Yb(a4) {
  var b2 = a4.alternate;
  if (!b2) {
    b2 = Vb(a4);
    if (null === b2) throw Error(p$1(188));
    return b2 !== a4 ? null : a4;
  }
  for (var c3 = a4, d4 = b2; ; ) {
    var e3 = c3.return;
    if (null === e3) break;
    var f2 = e3.alternate;
    if (null === f2) {
      d4 = e3.return;
      if (null !== d4) {
        c3 = d4;
        continue;
      }
      break;
    }
    if (e3.child === f2.child) {
      for (f2 = e3.child; f2; ) {
        if (f2 === c3) return Xb(e3), a4;
        if (f2 === d4) return Xb(e3), b2;
        f2 = f2.sibling;
      }
      throw Error(p$1(188));
    }
    if (c3.return !== d4.return) c3 = e3, d4 = f2;
    else {
      for (var g2 = false, h4 = e3.child; h4; ) {
        if (h4 === c3) {
          g2 = true;
          c3 = e3;
          d4 = f2;
          break;
        }
        if (h4 === d4) {
          g2 = true;
          d4 = e3;
          c3 = f2;
          break;
        }
        h4 = h4.sibling;
      }
      if (!g2) {
        for (h4 = f2.child; h4; ) {
          if (h4 === c3) {
            g2 = true;
            c3 = f2;
            d4 = e3;
            break;
          }
          if (h4 === d4) {
            g2 = true;
            d4 = f2;
            c3 = e3;
            break;
          }
          h4 = h4.sibling;
        }
        if (!g2) throw Error(p$1(189));
      }
    }
    if (c3.alternate !== d4) throw Error(p$1(190));
  }
  if (3 !== c3.tag) throw Error(p$1(188));
  return c3.stateNode.current === c3 ? a4 : b2;
}
function Zb(a4) {
  a4 = Yb(a4);
  return null !== a4 ? $b(a4) : null;
}
function $b(a4) {
  if (5 === a4.tag || 6 === a4.tag) return a4;
  for (a4 = a4.child; null !== a4; ) {
    var b2 = $b(a4);
    if (null !== b2) return b2;
    a4 = a4.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a4) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a4, void 0, 128 === (a4.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a4) {
  a4 >>>= 0;
  return 0 === a4 ? 32 : 31 - (pc(a4) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a4) {
  switch (a4 & -a4) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a4 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a4 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a4;
  }
}
function uc(a4, b2) {
  var c3 = a4.pendingLanes;
  if (0 === c3) return 0;
  var d4 = 0, e3 = a4.suspendedLanes, f2 = a4.pingedLanes, g2 = c3 & 268435455;
  if (0 !== g2) {
    var h4 = g2 & ~e3;
    0 !== h4 ? d4 = tc(h4) : (f2 &= g2, 0 !== f2 && (d4 = tc(f2)));
  } else g2 = c3 & ~e3, 0 !== g2 ? d4 = tc(g2) : 0 !== f2 && (d4 = tc(f2));
  if (0 === d4) return 0;
  if (0 !== b2 && b2 !== d4 && 0 === (b2 & e3) && (e3 = d4 & -d4, f2 = b2 & -b2, e3 >= f2 || 16 === e3 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d4 & 4) && (d4 |= c3 & 16);
  b2 = a4.entangledLanes;
  if (0 !== b2) for (a4 = a4.entanglements, b2 &= d4; 0 < b2; ) c3 = 31 - oc(b2), e3 = 1 << c3, d4 |= a4[c3], b2 &= ~e3;
  return d4;
}
function vc(a4, b2) {
  switch (a4) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a4, b2) {
  for (var c3 = a4.suspendedLanes, d4 = a4.pingedLanes, e3 = a4.expirationTimes, f2 = a4.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h4 = 1 << g2, k3 = e3[g2];
    if (-1 === k3) {
      if (0 === (h4 & c3) || 0 !== (h4 & d4)) e3[g2] = vc(h4, b2);
    } else k3 <= b2 && (a4.expiredLanes |= h4);
    f2 &= ~h4;
  }
}
function xc(a4) {
  a4 = a4.pendingLanes & -1073741825;
  return 0 !== a4 ? a4 : a4 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a4 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a4;
}
function zc(a4) {
  for (var b2 = [], c3 = 0; 31 > c3; c3++) b2.push(a4);
  return b2;
}
function Ac(a4, b2, c3) {
  a4.pendingLanes |= b2;
  536870912 !== b2 && (a4.suspendedLanes = 0, a4.pingedLanes = 0);
  a4 = a4.eventTimes;
  b2 = 31 - oc(b2);
  a4[b2] = c3;
}
function Bc(a4, b2) {
  var c3 = a4.pendingLanes & ~b2;
  a4.pendingLanes = b2;
  a4.suspendedLanes = 0;
  a4.pingedLanes = 0;
  a4.expiredLanes &= b2;
  a4.mutableReadLanes &= b2;
  a4.entangledLanes &= b2;
  b2 = a4.entanglements;
  var d4 = a4.eventTimes;
  for (a4 = a4.expirationTimes; 0 < c3; ) {
    var e3 = 31 - oc(c3), f2 = 1 << e3;
    b2[e3] = 0;
    d4[e3] = -1;
    a4[e3] = -1;
    c3 &= ~f2;
  }
}
function Cc(a4, b2) {
  var c3 = a4.entangledLanes |= b2;
  for (a4 = a4.entanglements; c3; ) {
    var d4 = 31 - oc(c3), e3 = 1 << d4;
    e3 & b2 | a4[d4] & b2 && (a4[d4] |= b2);
    c3 &= ~e3;
  }
}
var C = 0;
function Dc(a4) {
  a4 &= -a4;
  return 1 < a4 ? 4 < a4 ? 0 !== (a4 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a4, b2) {
  switch (a4) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a4, b2, c3, d4, e3, f2) {
  if (null === a4 || a4.nativeEvent !== f2) return a4 = { blockedOn: b2, domEventName: c3, eventSystemFlags: d4, nativeEvent: f2, targetContainers: [e3] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a4;
  a4.eventSystemFlags |= d4;
  b2 = a4.targetContainers;
  null !== e3 && -1 === b2.indexOf(e3) && b2.push(e3);
  return a4;
}
function Uc(a4, b2, c3, d4, e3) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a4, b2, c3, d4, e3), true;
    case "dragenter":
      return Mc = Tc(Mc, a4, b2, c3, d4, e3), true;
    case "mouseover":
      return Nc = Tc(Nc, a4, b2, c3, d4, e3), true;
    case "pointerover":
      var f2 = e3.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a4, b2, c3, d4, e3));
      return true;
    case "gotpointercapture":
      return f2 = e3.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a4, b2, c3, d4, e3)), true;
  }
  return false;
}
function Vc(a4) {
  var b2 = Wc(a4.target);
  if (null !== b2) {
    var c3 = Vb(b2);
    if (null !== c3) {
      if (b2 = c3.tag, 13 === b2) {
        if (b2 = Wb(c3), null !== b2) {
          a4.blockedOn = b2;
          Ic(a4.priority, function() {
            Gc(c3);
          });
          return;
        }
      } else if (3 === b2 && c3.stateNode.current.memoizedState.isDehydrated) {
        a4.blockedOn = 3 === c3.tag ? c3.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a4.blockedOn = null;
}
function Xc(a4) {
  if (null !== a4.blockedOn) return false;
  for (var b2 = a4.targetContainers; 0 < b2.length; ) {
    var c3 = Yc(a4.domEventName, a4.eventSystemFlags, b2[0], a4.nativeEvent);
    if (null === c3) {
      c3 = a4.nativeEvent;
      var d4 = new c3.constructor(c3.type, c3);
      wb = d4;
      c3.target.dispatchEvent(d4);
      wb = null;
    } else return b2 = Cb(c3), null !== b2 && Fc(b2), a4.blockedOn = c3, false;
    b2.shift();
  }
  return true;
}
function Zc(a4, b2, c3) {
  Xc(a4) && c3.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a4, b2) {
  a4.blockedOn === b2 && (a4.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a4) {
  function b2(b3) {
    return ad(b3, a4);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a4);
    for (var c3 = 1; c3 < Kc.length; c3++) {
      var d4 = Kc[c3];
      d4.blockedOn === a4 && (d4.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a4);
  null !== Mc && ad(Mc, a4);
  null !== Nc && ad(Nc, a4);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c3 = 0; c3 < Qc.length; c3++) d4 = Qc[c3], d4.blockedOn === a4 && (d4.blockedOn = null);
  for (; 0 < Qc.length && (c3 = Qc[0], null === c3.blockedOn); ) Vc(c3), null === c3.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a4, b2, c3, d4) {
  var e3 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 1, fd(a4, b2, c3, d4);
  } finally {
    C = e3, cd.transition = f2;
  }
}
function gd(a4, b2, c3, d4) {
  var e3 = C, f2 = cd.transition;
  cd.transition = null;
  try {
    C = 4, fd(a4, b2, c3, d4);
  } finally {
    C = e3, cd.transition = f2;
  }
}
function fd(a4, b2, c3, d4) {
  if (dd) {
    var e3 = Yc(a4, b2, c3, d4);
    if (null === e3) hd(a4, b2, d4, id, c3), Sc(a4, d4);
    else if (Uc(e3, a4, b2, c3, d4)) d4.stopPropagation();
    else if (Sc(a4, d4), b2 & 4 && -1 < Rc.indexOf(a4)) {
      for (; null !== e3; ) {
        var f2 = Cb(e3);
        null !== f2 && Ec(f2);
        f2 = Yc(a4, b2, c3, d4);
        null === f2 && hd(a4, b2, d4, id, c3);
        if (f2 === e3) break;
        e3 = f2;
      }
      null !== e3 && d4.stopPropagation();
    } else hd(a4, b2, d4, null, c3);
  }
}
var id = null;
function Yc(a4, b2, c3, d4) {
  id = null;
  a4 = xb(d4);
  a4 = Wc(a4);
  if (null !== a4) if (b2 = Vb(a4), null === b2) a4 = null;
  else if (c3 = b2.tag, 13 === c3) {
    a4 = Wb(b2);
    if (null !== a4) return a4;
    a4 = null;
  } else if (3 === c3) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a4 = null;
  } else b2 !== a4 && (a4 = null);
  id = a4;
  return null;
}
function jd(a4) {
  switch (a4) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a4, b2 = ld, c3 = b2.length, d4, e3 = "value" in kd ? kd.value : kd.textContent, f2 = e3.length;
  for (a4 = 0; a4 < c3 && b2[a4] === e3[a4]; a4++) ;
  var g2 = c3 - a4;
  for (d4 = 1; d4 <= g2 && b2[c3 - d4] === e3[f2 - d4]; d4++) ;
  return md = e3.slice(a4, 1 < d4 ? 1 - d4 : void 0);
}
function od(a4) {
  var b2 = a4.keyCode;
  "charCode" in a4 ? (a4 = a4.charCode, 0 === a4 && 13 === b2 && (a4 = 13)) : a4 = b2;
  10 === a4 && (a4 = 13);
  return 32 <= a4 || 13 === a4 ? a4 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a4) {
  function b2(b3, d4, e3, f2, g2) {
    this._reactName = b3;
    this._targetInst = e3;
    this.type = d4;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c3 in a4) a4.hasOwnProperty(c3) && (b3 = a4[c3], this[c3] = b3 ? b3(f2) : f2[c3]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a5 = this.nativeEvent;
    a5 && (a5.preventDefault ? a5.preventDefault() : "unknown" !== typeof a5.returnValue && (a5.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a5 = this.nativeEvent;
    a5 && (a5.stopPropagation ? a5.stopPropagation() : "unknown" !== typeof a5.cancelBubble && (a5.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a4) {
  return a4.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a4) {
  return void 0 === a4.relatedTarget ? a4.fromElement === a4.srcElement ? a4.toElement : a4.fromElement : a4.relatedTarget;
}, movementX: function(a4) {
  if ("movementX" in a4) return a4.movementX;
  a4 !== yd && (yd && "mousemove" === a4.type ? (wd = a4.screenX - yd.screenX, xd = a4.screenY - yd.screenY) : xd = wd = 0, yd = a4);
  return wd;
}, movementY: function(a4) {
  return "movementY" in a4 ? a4.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a4) {
  return "clipboardData" in a4 ? a4.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a4) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a4) : (a4 = Od[a4]) ? !!b2[a4] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a4) {
  if (a4.key) {
    var b2 = Md[a4.key] || a4.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a4.type ? (a4 = od(a4), 13 === a4 ? "Enter" : String.fromCharCode(a4)) : "keydown" === a4.type || "keyup" === a4.type ? Nd[a4.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a4) {
  return "keypress" === a4.type ? od(a4) : 0;
}, keyCode: function(a4) {
  return "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
}, which: function(a4) {
  return "keypress" === a4.type ? od(a4) : "keydown" === a4.type || "keyup" === a4.type ? a4.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a4) {
    return "deltaX" in a4 ? a4.deltaX : "wheelDeltaX" in a4 ? -a4.wheelDeltaX : 0;
  },
  deltaY: function(a4) {
    return "deltaY" in a4 ? a4.deltaY : "wheelDeltaY" in a4 ? -a4.wheelDeltaY : "wheelDelta" in a4 ? -a4.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae$1 = ia && "CompositionEvent" in window, be$2 = null;
ia && "documentMode" in document && (be$2 = document.documentMode);
var ce$1 = ia && "TextEvent" in window && !be$2, de$2 = ia && (!ae$1 || be$2 && 8 < be$2 && 11 >= be$2), ee$1 = String.fromCharCode(32), fe$1 = false;
function ge$2(a4, b2) {
  switch (a4) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he$2(a4) {
  a4 = a4.detail;
  return "object" === typeof a4 && "data" in a4 ? a4.data : null;
}
var ie$1 = false;
function je(a4, b2) {
  switch (a4) {
    case "compositionend":
      return he$2(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe$1 = true;
      return ee$1;
    case "textInput":
      return a4 = b2.data, a4 === ee$1 && fe$1 ? null : a4;
    default:
      return null;
  }
}
function ke(a4, b2) {
  if (ie$1) return "compositionend" === a4 || !ae$1 && ge$2(a4, b2) ? (a4 = nd(), md = ld = kd = null, ie$1 = false, a4) : null;
  switch (a4) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de$2 && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le$2 = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me$1(a4) {
  var b2 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return "input" === b2 ? !!le$2[a4.type] : "textarea" === b2 ? true : false;
}
function ne$2(a4, b2, c3, d4) {
  Eb(d4);
  b2 = oe$2(b2, "onChange");
  0 < b2.length && (c3 = new td("onChange", "change", null, c3, d4), a4.push({ event: c3, listeners: b2 }));
}
var pe$2 = null, qe = null;
function re$1(a4) {
  se$2(a4, 0);
}
function te$1(a4) {
  var b2 = ue$2(a4);
  if (Wa(b2)) return a4;
}
function ve$1(a4, b2) {
  if ("change" === a4) return b2;
}
var we$1 = false;
if (ia) {
  var xe$2;
  if (ia) {
    var ye$2 = "oninput" in document;
    if (!ye$2) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye$2 = "function" === typeof ze.oninput;
    }
    xe$2 = ye$2;
  } else xe$2 = false;
  we$1 = xe$2 && (!document.documentMode || 9 < document.documentMode);
}
function Ae$1() {
  pe$2 && (pe$2.detachEvent("onpropertychange", Be), qe = pe$2 = null);
}
function Be(a4) {
  if ("value" === a4.propertyName && te$1(qe)) {
    var b2 = [];
    ne$2(b2, qe, a4, xb(a4));
    Jb(re$1, b2);
  }
}
function Ce(a4, b2, c3) {
  "focusin" === a4 ? (Ae$1(), pe$2 = b2, qe = c3, pe$2.attachEvent("onpropertychange", Be)) : "focusout" === a4 && Ae$1();
}
function De(a4) {
  if ("selectionchange" === a4 || "keyup" === a4 || "keydown" === a4) return te$1(qe);
}
function Ee(a4, b2) {
  if ("click" === a4) return te$1(b2);
}
function Fe(a4, b2) {
  if ("input" === a4 || "change" === a4) return te$1(b2);
}
function Ge(a4, b2) {
  return a4 === b2 && (0 !== a4 || 1 / a4 === 1 / b2) || a4 !== a4 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a4, b2) {
  if (He(a4, b2)) return true;
  if ("object" !== typeof a4 || null === a4 || "object" !== typeof b2 || null === b2) return false;
  var c3 = Object.keys(a4), d4 = Object.keys(b2);
  if (c3.length !== d4.length) return false;
  for (d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    if (!ja.call(b2, e3) || !He(a4[e3], b2[e3])) return false;
  }
  return true;
}
function Je(a4) {
  for (; a4 && a4.firstChild; ) a4 = a4.firstChild;
  return a4;
}
function Ke(a4, b2) {
  var c3 = Je(a4);
  a4 = 0;
  for (var d4; c3; ) {
    if (3 === c3.nodeType) {
      d4 = a4 + c3.textContent.length;
      if (a4 <= b2 && d4 >= b2) return { node: c3, offset: b2 - a4 };
      a4 = d4;
    }
    a: {
      for (; c3; ) {
        if (c3.nextSibling) {
          c3 = c3.nextSibling;
          break a;
        }
        c3 = c3.parentNode;
      }
      c3 = void 0;
    }
    c3 = Je(c3);
  }
}
function Le(a4, b2) {
  return a4 && b2 ? a4 === b2 ? true : a4 && 3 === a4.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a4, b2.parentNode) : "contains" in a4 ? a4.contains(b2) : a4.compareDocumentPosition ? !!(a4.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a4 = window, b2 = Xa(); b2 instanceof a4.HTMLIFrameElement; ) {
    try {
      var c3 = "string" === typeof b2.contentWindow.location.href;
    } catch (d4) {
      c3 = false;
    }
    if (c3) a4 = b2.contentWindow;
    else break;
    b2 = Xa(a4.document);
  }
  return b2;
}
function Ne(a4) {
  var b2 = a4 && a4.nodeName && a4.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a4.type || "search" === a4.type || "tel" === a4.type || "url" === a4.type || "password" === a4.type) || "textarea" === b2 || "true" === a4.contentEditable);
}
function Oe(a4) {
  var b2 = Me(), c3 = a4.focusedElem, d4 = a4.selectionRange;
  if (b2 !== c3 && c3 && c3.ownerDocument && Le(c3.ownerDocument.documentElement, c3)) {
    if (null !== d4 && Ne(c3)) {
      if (b2 = d4.start, a4 = d4.end, void 0 === a4 && (a4 = b2), "selectionStart" in c3) c3.selectionStart = b2, c3.selectionEnd = Math.min(a4, c3.value.length);
      else if (a4 = (b2 = c3.ownerDocument || document) && b2.defaultView || window, a4.getSelection) {
        a4 = a4.getSelection();
        var e3 = c3.textContent.length, f2 = Math.min(d4.start, e3);
        d4 = void 0 === d4.end ? f2 : Math.min(d4.end, e3);
        !a4.extend && f2 > d4 && (e3 = d4, d4 = f2, f2 = e3);
        e3 = Ke(c3, f2);
        var g2 = Ke(
          c3,
          d4
        );
        e3 && g2 && (1 !== a4.rangeCount || a4.anchorNode !== e3.node || a4.anchorOffset !== e3.offset || a4.focusNode !== g2.node || a4.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e3.node, e3.offset), a4.removeAllRanges(), f2 > d4 ? (a4.addRange(b2), a4.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a4.addRange(b2)));
      }
    }
    b2 = [];
    for (a4 = c3; a4 = a4.parentNode; ) 1 === a4.nodeType && b2.push({ element: a4, left: a4.scrollLeft, top: a4.scrollTop });
    "function" === typeof c3.focus && c3.focus();
    for (c3 = 0; c3 < b2.length; c3++) a4 = b2[c3], a4.element.scrollLeft = a4.left, a4.element.scrollTop = a4.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se$1 = null, Te$2 = false;
function Ue(a4, b2, c3) {
  var d4 = c3.window === c3 ? c3.document : 9 === c3.nodeType ? c3 : c3.ownerDocument;
  Te$2 || null == Qe || Qe !== Xa(d4) || (d4 = Qe, "selectionStart" in d4 && Ne(d4) ? d4 = { start: d4.selectionStart, end: d4.selectionEnd } : (d4 = (d4.ownerDocument && d4.ownerDocument.defaultView || window).getSelection(), d4 = { anchorNode: d4.anchorNode, anchorOffset: d4.anchorOffset, focusNode: d4.focusNode, focusOffset: d4.focusOffset }), Se$1 && Ie(Se$1, d4) || (Se$1 = d4, d4 = oe$2(Re, "onSelect"), 0 < d4.length && (b2 = new td("onSelect", "select", null, b2, c3), a4.push({ event: b2, listeners: d4 }), b2.target = Qe)));
}
function Ve(a4, b2) {
  var c3 = {};
  c3[a4.toLowerCase()] = b2.toLowerCase();
  c3["Webkit" + a4] = "webkit" + b2;
  c3["Moz" + a4] = "moz" + b2;
  return c3;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a4) {
  if (Xe[a4]) return Xe[a4];
  if (!We[a4]) return a4;
  var b2 = We[a4], c3;
  for (c3 in b2) if (b2.hasOwnProperty(c3) && c3 in Ye) return Xe[a4] = b2[c3];
  return a4;
}
var $e$1 = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a4, b2) {
  df.set(a4, b2);
  fa(b2, [a4]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e$1, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a4, b2, c3) {
  var d4 = a4.type || "unknown-event";
  a4.currentTarget = c3;
  Ub(d4, b2, void 0, a4);
  a4.currentTarget = null;
}
function se$2(a4, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c3 = 0; c3 < a4.length; c3++) {
    var d4 = a4[c3], e3 = d4.event;
    d4 = d4.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d4.length - 1; 0 <= g2; g2--) {
        var h4 = d4[g2], k3 = h4.instance, l2 = h4.currentTarget;
        h4 = h4.listener;
        if (k3 !== f2 && e3.isPropagationStopped()) break a;
        nf(e3, h4, l2);
        f2 = k3;
      }
      else for (g2 = 0; g2 < d4.length; g2++) {
        h4 = d4[g2];
        k3 = h4.instance;
        l2 = h4.currentTarget;
        h4 = h4.listener;
        if (k3 !== f2 && e3.isPropagationStopped()) break a;
        nf(e3, h4, l2);
        f2 = k3;
      }
    }
  }
  if (Qb) throw a4 = Rb, Qb = false, Rb = null, a4;
}
function D(a4, b2) {
  var c3 = b2[of];
  void 0 === c3 && (c3 = b2[of] = /* @__PURE__ */ new Set());
  var d4 = a4 + "__bubble";
  c3.has(d4) || (pf(b2, a4, 2, false), c3.add(d4));
}
function qf(a4, b2, c3) {
  var d4 = 0;
  b2 && (d4 |= 4);
  pf(c3, a4, d4, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a4) {
  if (!a4[rf]) {
    a4[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a4), qf(b3, true, a4));
    });
    var b2 = 9 === a4.nodeType ? a4 : a4.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a4, b2, c3, d4) {
  switch (jd(b2)) {
    case 1:
      var e3 = ed;
      break;
    case 4:
      e3 = gd;
      break;
    default:
      e3 = fd;
  }
  c3 = e3.bind(null, b2, c3, a4);
  e3 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e3 = true);
  d4 ? void 0 !== e3 ? a4.addEventListener(b2, c3, { capture: true, passive: e3 }) : a4.addEventListener(b2, c3, true) : void 0 !== e3 ? a4.addEventListener(b2, c3, { passive: e3 }) : a4.addEventListener(b2, c3, false);
}
function hd(a4, b2, c3, d4, e3) {
  var f2 = d4;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d4) a: for (; ; ) {
    if (null === d4) return;
    var g2 = d4.tag;
    if (3 === g2 || 4 === g2) {
      var h4 = d4.stateNode.containerInfo;
      if (h4 === e3 || 8 === h4.nodeType && h4.parentNode === e3) break;
      if (4 === g2) for (g2 = d4.return; null !== g2; ) {
        var k3 = g2.tag;
        if (3 === k3 || 4 === k3) {
          if (k3 = g2.stateNode.containerInfo, k3 === e3 || 8 === k3.nodeType && k3.parentNode === e3) return;
        }
        g2 = g2.return;
      }
      for (; null !== h4; ) {
        g2 = Wc(h4);
        if (null === g2) return;
        k3 = g2.tag;
        if (5 === k3 || 6 === k3) {
          d4 = f2 = g2;
          continue a;
        }
        h4 = h4.parentNode;
      }
    }
    d4 = d4.return;
  }
  Jb(function() {
    var d5 = f2, e4 = xb(c3), g3 = [];
    a: {
      var h5 = df.get(a4);
      if (void 0 !== h5) {
        var k4 = td, n2 = a4;
        switch (a4) {
          case "keypress":
            if (0 === od(c3)) break a;
          case "keydown":
          case "keyup":
            k4 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k4 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k4 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k4 = Fd;
            break;
          case "click":
            if (2 === c3.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k4 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k4 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k4 = Vd;
            break;
          case $e$1:
          case af:
          case bf:
            k4 = Hd;
            break;
          case cf:
            k4 = Xd;
            break;
          case "scroll":
            k4 = vd;
            break;
          case "wheel":
            k4 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k4 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k4 = Td;
        }
        var t3 = 0 !== (b2 & 4), J2 = !t3 && "scroll" === a4, x3 = t3 ? null !== h5 ? h5 + "Capture" : null : h5;
        t3 = [];
        for (var w3 = d5, u3; null !== w3; ) {
          u3 = w3;
          var F2 = u3.stateNode;
          5 === u3.tag && null !== F2 && (u3 = F2, null !== x3 && (F2 = Kb(w3, x3), null != F2 && t3.push(tf(w3, F2, u3))));
          if (J2) break;
          w3 = w3.return;
        }
        0 < t3.length && (h5 = new k4(h5, n2, null, c3, e4), g3.push({ event: h5, listeners: t3 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h5 = "mouseover" === a4 || "pointerover" === a4;
        k4 = "mouseout" === a4 || "pointerout" === a4;
        if (h5 && c3 !== wb && (n2 = c3.relatedTarget || c3.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k4 || h5) {
          h5 = e4.window === e4 ? e4 : (h5 = e4.ownerDocument) ? h5.defaultView || h5.parentWindow : window;
          if (k4) {
            if (n2 = c3.relatedTarget || c3.toElement, k4 = d5, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k4 = null, n2 = d5;
          if (k4 !== n2) {
            t3 = Bd;
            F2 = "onMouseLeave";
            x3 = "onMouseEnter";
            w3 = "mouse";
            if ("pointerout" === a4 || "pointerover" === a4) t3 = Td, F2 = "onPointerLeave", x3 = "onPointerEnter", w3 = "pointer";
            J2 = null == k4 ? h5 : ue$2(k4);
            u3 = null == n2 ? h5 : ue$2(n2);
            h5 = new t3(F2, w3 + "leave", k4, c3, e4);
            h5.target = J2;
            h5.relatedTarget = u3;
            F2 = null;
            Wc(e4) === d5 && (t3 = new t3(x3, w3 + "enter", n2, c3, e4), t3.target = u3, t3.relatedTarget = J2, F2 = t3);
            J2 = F2;
            if (k4 && n2) b: {
              t3 = k4;
              x3 = n2;
              w3 = 0;
              for (u3 = t3; u3; u3 = vf(u3)) w3++;
              u3 = 0;
              for (F2 = x3; F2; F2 = vf(F2)) u3++;
              for (; 0 < w3 - u3; ) t3 = vf(t3), w3--;
              for (; 0 < u3 - w3; ) x3 = vf(x3), u3--;
              for (; w3--; ) {
                if (t3 === x3 || null !== x3 && t3 === x3.alternate) break b;
                t3 = vf(t3);
                x3 = vf(x3);
              }
              t3 = null;
            }
            else t3 = null;
            null !== k4 && wf(g3, h5, k4, t3, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t3, true);
          }
        }
      }
      a: {
        h5 = d5 ? ue$2(d5) : window;
        k4 = h5.nodeName && h5.nodeName.toLowerCase();
        if ("select" === k4 || "input" === k4 && "file" === h5.type) var na = ve$1;
        else if (me$1(h5)) if (we$1) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k4 = h5.nodeName) && "input" === k4.toLowerCase() && ("checkbox" === h5.type || "radio" === h5.type) && (na = Ee);
        if (na && (na = na(a4, d5))) {
          ne$2(g3, na, c3, e4);
          break a;
        }
        xa && xa(a4, h5, d5);
        "focusout" === a4 && (xa = h5._wrapperState) && xa.controlled && "number" === h5.type && cb(h5, "number", h5.value);
      }
      xa = d5 ? ue$2(d5) : window;
      switch (a4) {
        case "focusin":
          if (me$1(xa) || "true" === xa.contentEditable) Qe = xa, Re = d5, Se$1 = null;
          break;
        case "focusout":
          Se$1 = Re = Qe = null;
          break;
        case "mousedown":
          Te$2 = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te$2 = false;
          Ue(g3, c3, e4);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c3, e4);
      }
      var $a;
      if (ae$1) b: {
        switch (a4) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie$1 ? ge$2(a4, c3) && (ba = "onCompositionEnd") : "keydown" === a4 && 229 === c3.keyCode && (ba = "onCompositionStart");
      ba && (de$2 && "ko" !== c3.locale && (ie$1 || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie$1 && ($a = nd()) : (kd = e4, ld = "value" in kd ? kd.value : kd.textContent, ie$1 = true)), xa = oe$2(d5, ba), 0 < xa.length && (ba = new Ld(ba, a4, null, c3, e4), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he$2(c3), null !== $a && (ba.data = $a))));
      if ($a = ce$1 ? je(a4, c3) : ke(a4, c3)) d5 = oe$2(d5, "onBeforeInput"), 0 < d5.length && (e4 = new Ld("onBeforeInput", "beforeinput", null, c3, e4), g3.push({ event: e4, listeners: d5 }), e4.data = $a);
    }
    se$2(g3, b2);
  });
}
function tf(a4, b2, c3) {
  return { instance: a4, listener: b2, currentTarget: c3 };
}
function oe$2(a4, b2) {
  for (var c3 = b2 + "Capture", d4 = []; null !== a4; ) {
    var e3 = a4, f2 = e3.stateNode;
    5 === e3.tag && null !== f2 && (e3 = f2, f2 = Kb(a4, c3), null != f2 && d4.unshift(tf(a4, f2, e3)), f2 = Kb(a4, b2), null != f2 && d4.push(tf(a4, f2, e3)));
    a4 = a4.return;
  }
  return d4;
}
function vf(a4) {
  if (null === a4) return null;
  do
    a4 = a4.return;
  while (a4 && 5 !== a4.tag);
  return a4 ? a4 : null;
}
function wf(a4, b2, c3, d4, e3) {
  for (var f2 = b2._reactName, g2 = []; null !== c3 && c3 !== d4; ) {
    var h4 = c3, k3 = h4.alternate, l2 = h4.stateNode;
    if (null !== k3 && k3 === d4) break;
    5 === h4.tag && null !== l2 && (h4 = l2, e3 ? (k3 = Kb(c3, f2), null != k3 && g2.unshift(tf(c3, k3, h4))) : e3 || (k3 = Kb(c3, f2), null != k3 && g2.push(tf(c3, k3, h4))));
    c3 = c3.return;
  }
  0 !== g2.length && a4.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a4) {
  return ("string" === typeof a4 ? a4 : "" + a4).replace(xf, "\n").replace(yf, "");
}
function Af(a4, b2, c3) {
  b2 = zf(b2);
  if (zf(a4) !== b2 && c3) throw Error(p$1(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a4, b2) {
  return "textarea" === a4 || "noscript" === a4 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a4) {
  return Hf.resolve(null).then(a4).catch(If);
} : Ff;
function If(a4) {
  setTimeout(function() {
    throw a4;
  });
}
function Kf(a4, b2) {
  var c3 = b2, d4 = 0;
  do {
    var e3 = c3.nextSibling;
    a4.removeChild(c3);
    if (e3 && 8 === e3.nodeType) if (c3 = e3.data, "/$" === c3) {
      if (0 === d4) {
        a4.removeChild(e3);
        bd(b2);
        return;
      }
      d4--;
    } else "$" !== c3 && "$?" !== c3 && "$!" !== c3 || d4++;
    c3 = e3;
  } while (c3);
  bd(b2);
}
function Lf(a4) {
  for (; null != a4; a4 = a4.nextSibling) {
    var b2 = a4.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a4.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a4;
}
function Mf(a4) {
  a4 = a4.previousSibling;
  for (var b2 = 0; a4; ) {
    if (8 === a4.nodeType) {
      var c3 = a4.data;
      if ("$" === c3 || "$!" === c3 || "$?" === c3) {
        if (0 === b2) return a4;
        b2--;
      } else "/$" === c3 && b2++;
    }
    a4 = a4.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a4) {
  var b2 = a4[Of];
  if (b2) return b2;
  for (var c3 = a4.parentNode; c3; ) {
    if (b2 = c3[uf] || c3[Of]) {
      c3 = b2.alternate;
      if (null !== b2.child || null !== c3 && null !== c3.child) for (a4 = Mf(a4); null !== a4; ) {
        if (c3 = a4[Of]) return c3;
        a4 = Mf(a4);
      }
      return b2;
    }
    a4 = c3;
    c3 = a4.parentNode;
  }
  return null;
}
function Cb(a4) {
  a4 = a4[Of] || a4[uf];
  return !a4 || 5 !== a4.tag && 6 !== a4.tag && 13 !== a4.tag && 3 !== a4.tag ? null : a4;
}
function ue$2(a4) {
  if (5 === a4.tag || 6 === a4.tag) return a4.stateNode;
  throw Error(p$1(33));
}
function Db(a4) {
  return a4[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a4) {
  return { current: a4 };
}
function E(a4) {
  0 > Tf || (a4.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a4, b2) {
  Tf++;
  Sf[Tf] = a4.current;
  a4.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a4, b2) {
  var c3 = a4.type.contextTypes;
  if (!c3) return Vf;
  var d4 = a4.stateNode;
  if (d4 && d4.__reactInternalMemoizedUnmaskedChildContext === b2) return d4.__reactInternalMemoizedMaskedChildContext;
  var e3 = {}, f2;
  for (f2 in c3) e3[f2] = b2[f2];
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = b2, a4.__reactInternalMemoizedMaskedChildContext = e3);
  return e3;
}
function Zf(a4) {
  a4 = a4.childContextTypes;
  return null !== a4 && void 0 !== a4;
}
function $f() {
  E(Wf);
  E(H);
}
function ag(a4, b2, c3) {
  if (H.current !== Vf) throw Error(p$1(168));
  G(H, b2);
  G(Wf, c3);
}
function bg(a4, b2, c3) {
  var d4 = a4.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d4.getChildContext) return c3;
  d4 = d4.getChildContext();
  for (var e3 in d4) if (!(e3 in b2)) throw Error(p$1(108, Ra(a4) || "Unknown", e3));
  return A$1({}, c3, d4);
}
function cg(a4) {
  a4 = (a4 = a4.stateNode) && a4.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a4);
  G(Wf, Wf.current);
  return true;
}
function dg(a4, b2, c3) {
  var d4 = a4.stateNode;
  if (!d4) throw Error(p$1(169));
  c3 ? (a4 = bg(a4, b2, Xf), d4.__reactInternalMemoizedMergedChildContext = a4, E(Wf), E(H), G(H, a4)) : E(Wf);
  G(Wf, c3);
}
var eg = null, fg = false, gg = false;
function hg(a4) {
  null === eg ? eg = [a4] : eg.push(a4);
}
function ig(a4) {
  fg = true;
  hg(a4);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a4 = 0, b2 = C;
    try {
      var c3 = eg;
      for (C = 1; a4 < c3.length; a4++) {
        var d4 = c3[a4];
        do
          d4 = d4(true);
        while (null !== d4);
      }
      eg = null;
      fg = false;
    } catch (e3) {
      throw null !== eg && (eg = eg.slice(a4 + 1)), ac(fc, jg), e3;
    } finally {
      C = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a4, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a4;
  ng = b2;
}
function ug(a4, b2, c3) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a4;
  var d4 = rg;
  a4 = sg;
  var e3 = 32 - oc(d4) - 1;
  d4 &= ~(1 << e3);
  c3 += 1;
  var f2 = 32 - oc(b2) + e3;
  if (30 < f2) {
    var g2 = e3 - e3 % 5;
    f2 = (d4 & (1 << g2) - 1).toString(32);
    d4 >>= g2;
    e3 -= g2;
    rg = 1 << 32 - oc(b2) + e3 | c3 << e3 | d4;
    sg = f2 + a4;
  } else rg = 1 << f2 | c3 << e3 | d4, sg = a4;
}
function vg(a4) {
  null !== a4.return && (tg(a4, 1), ug(a4, 1, 0));
}
function wg(a4) {
  for (; a4 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a4 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I = false, zg = null;
function Ag(a4, b2) {
  var c3 = Bg(5, null, null, 0);
  c3.elementType = "DELETED";
  c3.stateNode = b2;
  c3.return = a4;
  b2 = a4.deletions;
  null === b2 ? (a4.deletions = [c3], a4.flags |= 16) : b2.push(c3);
}
function Cg(a4, b2) {
  switch (a4.tag) {
    case 5:
      var c3 = a4.type;
      b2 = 1 !== b2.nodeType || c3.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a4.stateNode = b2, xg = a4, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a4.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a4.stateNode = b2, xg = a4, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c3 = null !== qg ? { id: rg, overflow: sg } : null, a4.memoizedState = { dehydrated: b2, treeContext: c3, retryLane: 1073741824 }, c3 = Bg(18, null, null, 0), c3.stateNode = b2, c3.return = a4, a4.child = c3, xg = a4, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a4) {
  return 0 !== (a4.mode & 1) && 0 === (a4.flags & 128);
}
function Eg(a4) {
  if (I) {
    var b2 = yg;
    if (b2) {
      var c3 = b2;
      if (!Cg(a4, b2)) {
        if (Dg(a4)) throw Error(p$1(418));
        b2 = Lf(c3.nextSibling);
        var d4 = xg;
        b2 && Cg(a4, b2) ? Ag(d4, c3) : (a4.flags = a4.flags & -4097 | 2, I = false, xg = a4);
      }
    } else {
      if (Dg(a4)) throw Error(p$1(418));
      a4.flags = a4.flags & -4097 | 2;
      I = false;
      xg = a4;
    }
  }
}
function Fg(a4) {
  for (a4 = a4.return; null !== a4 && 5 !== a4.tag && 3 !== a4.tag && 13 !== a4.tag; ) a4 = a4.return;
  xg = a4;
}
function Gg(a4) {
  if (a4 !== xg) return false;
  if (!I) return Fg(a4), I = true, false;
  var b2;
  (b2 = 3 !== a4.tag) && !(b2 = 5 !== a4.tag) && (b2 = a4.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a4.type, a4.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a4)) throw Hg(), Error(p$1(418));
    for (; b2; ) Ag(a4, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a4);
  if (13 === a4.tag) {
    a4 = a4.memoizedState;
    a4 = null !== a4 ? a4.dehydrated : null;
    if (!a4) throw Error(p$1(317));
    a: {
      a4 = a4.nextSibling;
      for (b2 = 0; a4; ) {
        if (8 === a4.nodeType) {
          var c3 = a4.data;
          if ("/$" === c3) {
            if (0 === b2) {
              yg = Lf(a4.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c3 && "$!" !== c3 && "$?" !== c3 || b2++;
        }
        a4 = a4.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a4.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a4 = yg; a4; ) a4 = Lf(a4.nextSibling);
}
function Ig() {
  yg = xg = null;
  I = false;
}
function Jg(a4) {
  null === zg ? zg = [a4] : zg.push(a4);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a4, b2, c3) {
  a4 = c3.ref;
  if (null !== a4 && "function" !== typeof a4 && "object" !== typeof a4) {
    if (c3._owner) {
      c3 = c3._owner;
      if (c3) {
        if (1 !== c3.tag) throw Error(p$1(309));
        var d4 = c3.stateNode;
      }
      if (!d4) throw Error(p$1(147, a4));
      var e3 = d4, f2 = "" + a4;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a5) {
        var b3 = e3.refs;
        null === a5 ? delete b3[f2] : b3[f2] = a5;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a4) throw Error(p$1(284));
    if (!c3._owner) throw Error(p$1(290, a4));
  }
  return a4;
}
function Mg(a4, b2) {
  a4 = Object.prototype.toString.call(b2);
  throw Error(p$1(31, "[object Object]" === a4 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a4));
}
function Ng(a4) {
  var b2 = a4._init;
  return b2(a4._payload);
}
function Og(a4) {
  function b2(b3, c4) {
    if (a4) {
      var d5 = b3.deletions;
      null === d5 ? (b3.deletions = [c4], b3.flags |= 16) : d5.push(c4);
    }
  }
  function c3(c4, d5) {
    if (!a4) return null;
    for (; null !== d5; ) b2(c4, d5), d5 = d5.sibling;
    return null;
  }
  function d4(a5, b3) {
    for (a5 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a5.set(b3.key, b3) : a5.set(b3.index, b3), b3 = b3.sibling;
    return a5;
  }
  function e3(a5, b3) {
    a5 = Pg(a5, b3);
    a5.index = 0;
    a5.sibling = null;
    return a5;
  }
  function f2(b3, c4, d5) {
    b3.index = d5;
    if (!a4) return b3.flags |= 1048576, c4;
    d5 = b3.alternate;
    if (null !== d5) return d5 = d5.index, d5 < c4 ? (b3.flags |= 2, c4) : d5;
    b3.flags |= 2;
    return c4;
  }
  function g2(b3) {
    a4 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h4(a5, b3, c4, d5) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c4, a5.mode, d5), b3.return = a5, b3;
    b3 = e3(b3, c4);
    b3.return = a5;
    return b3;
  }
  function k3(a5, b3, c4, d5) {
    var f3 = c4.type;
    if (f3 === ya) return m4(a5, b3, c4.props.children, d5, c4.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d5 = e3(b3, c4.props), d5.ref = Lg(a5, b3, c4), d5.return = a5, d5;
    d5 = Rg(c4.type, c4.key, c4.props, null, a5.mode, d5);
    d5.ref = Lg(a5, b3, c4);
    d5.return = a5;
    return d5;
  }
  function l2(a5, b3, c4, d5) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c4.containerInfo || b3.stateNode.implementation !== c4.implementation) return b3 = Sg(c4, a5.mode, d5), b3.return = a5, b3;
    b3 = e3(b3, c4.children || []);
    b3.return = a5;
    return b3;
  }
  function m4(a5, b3, c4, d5, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c4, a5.mode, d5, f3), b3.return = a5, b3;
    b3 = e3(b3, c4);
    b3.return = a5;
    return b3;
  }
  function q3(a5, b3, c4) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a5.mode, c4), b3.return = a5, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c4 = Rg(b3.type, b3.key, b3.props, null, a5.mode, c4), c4.ref = Lg(a5, null, b3), c4.return = a5, c4;
        case wa:
          return b3 = Sg(b3, a5.mode, c4), b3.return = a5, b3;
        case Ha:
          var d5 = b3._init;
          return q3(a5, d5(b3._payload), c4);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a5.mode, c4, null), b3.return = a5, b3;
      Mg(a5, b3);
    }
    return null;
  }
  function r2(a5, b3, c4, d5) {
    var e4 = null !== b3 ? b3.key : null;
    if ("string" === typeof c4 && "" !== c4 || "number" === typeof c4) return null !== e4 ? null : h4(a5, b3, "" + c4, d5);
    if ("object" === typeof c4 && null !== c4) {
      switch (c4.$$typeof) {
        case va:
          return c4.key === e4 ? k3(a5, b3, c4, d5) : null;
        case wa:
          return c4.key === e4 ? l2(a5, b3, c4, d5) : null;
        case Ha:
          return e4 = c4._init, r2(
            a5,
            b3,
            e4(c4._payload),
            d5
          );
      }
      if (eb(c4) || Ka(c4)) return null !== e4 ? null : m4(a5, b3, c4, d5, null);
      Mg(a5, c4);
    }
    return null;
  }
  function y4(a5, b3, c4, d5, e4) {
    if ("string" === typeof d5 && "" !== d5 || "number" === typeof d5) return a5 = a5.get(c4) || null, h4(b3, a5, "" + d5, e4);
    if ("object" === typeof d5 && null !== d5) {
      switch (d5.$$typeof) {
        case va:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, k3(b3, a5, d5, e4);
        case wa:
          return a5 = a5.get(null === d5.key ? c4 : d5.key) || null, l2(b3, a5, d5, e4);
        case Ha:
          var f3 = d5._init;
          return y4(a5, b3, c4, f3(d5._payload), e4);
      }
      if (eb(d5) || Ka(d5)) return a5 = a5.get(c4) || null, m4(b3, a5, d5, e4, null);
      Mg(b3, d5);
    }
    return null;
  }
  function n2(e4, g3, h5, k4) {
    for (var l3 = null, m5 = null, u3 = g3, w3 = g3 = 0, x3 = null; null !== u3 && w3 < h5.length; w3++) {
      u3.index > w3 ? (x3 = u3, u3 = null) : x3 = u3.sibling;
      var n3 = r2(e4, u3, h5[w3], k4);
      if (null === n3) {
        null === u3 && (u3 = x3);
        break;
      }
      a4 && u3 && null === n3.alternate && b2(e4, u3);
      g3 = f2(n3, g3, w3);
      null === m5 ? l3 = n3 : m5.sibling = n3;
      m5 = n3;
      u3 = x3;
    }
    if (w3 === h5.length) return c3(e4, u3), I && tg(e4, w3), l3;
    if (null === u3) {
      for (; w3 < h5.length; w3++) u3 = q3(e4, h5[w3], k4), null !== u3 && (g3 = f2(u3, g3, w3), null === m5 ? l3 = u3 : m5.sibling = u3, m5 = u3);
      I && tg(e4, w3);
      return l3;
    }
    for (u3 = d4(e4, u3); w3 < h5.length; w3++) x3 = y4(u3, e4, w3, h5[w3], k4), null !== x3 && (a4 && null !== x3.alternate && u3.delete(null === x3.key ? w3 : x3.key), g3 = f2(x3, g3, w3), null === m5 ? l3 = x3 : m5.sibling = x3, m5 = x3);
    a4 && u3.forEach(function(a5) {
      return b2(e4, a5);
    });
    I && tg(e4, w3);
    return l3;
  }
  function t3(e4, g3, h5, k4) {
    var l3 = Ka(h5);
    if ("function" !== typeof l3) throw Error(p$1(150));
    h5 = l3.call(h5);
    if (null == h5) throw Error(p$1(151));
    for (var u3 = l3 = null, m5 = g3, w3 = g3 = 0, x3 = null, n3 = h5.next(); null !== m5 && !n3.done; w3++, n3 = h5.next()) {
      m5.index > w3 ? (x3 = m5, m5 = null) : x3 = m5.sibling;
      var t4 = r2(e4, m5, n3.value, k4);
      if (null === t4) {
        null === m5 && (m5 = x3);
        break;
      }
      a4 && m5 && null === t4.alternate && b2(e4, m5);
      g3 = f2(t4, g3, w3);
      null === u3 ? l3 = t4 : u3.sibling = t4;
      u3 = t4;
      m5 = x3;
    }
    if (n3.done) return c3(
      e4,
      m5
    ), I && tg(e4, w3), l3;
    if (null === m5) {
      for (; !n3.done; w3++, n3 = h5.next()) n3 = q3(e4, n3.value, k4), null !== n3 && (g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
      I && tg(e4, w3);
      return l3;
    }
    for (m5 = d4(e4, m5); !n3.done; w3++, n3 = h5.next()) n3 = y4(m5, e4, w3, n3.value, k4), null !== n3 && (a4 && null !== n3.alternate && m5.delete(null === n3.key ? w3 : n3.key), g3 = f2(n3, g3, w3), null === u3 ? l3 = n3 : u3.sibling = n3, u3 = n3);
    a4 && m5.forEach(function(a5) {
      return b2(e4, a5);
    });
    I && tg(e4, w3);
    return l3;
  }
  function J2(a5, d5, f3, h5) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k4 = f3.key, l3 = d5; null !== l3; ) {
              if (l3.key === k4) {
                k4 = f3.type;
                if (k4 === ya) {
                  if (7 === l3.tag) {
                    c3(a5, l3.sibling);
                    d5 = e3(l3, f3.props.children);
                    d5.return = a5;
                    a5 = d5;
                    break a;
                  }
                } else if (l3.elementType === k4 || "object" === typeof k4 && null !== k4 && k4.$$typeof === Ha && Ng(k4) === l3.type) {
                  c3(a5, l3.sibling);
                  d5 = e3(l3, f3.props);
                  d5.ref = Lg(a5, l3, f3);
                  d5.return = a5;
                  a5 = d5;
                  break a;
                }
                c3(a5, l3);
                break;
              } else b2(a5, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d5 = Tg(f3.props.children, a5.mode, h5, f3.key), d5.return = a5, a5 = d5) : (h5 = Rg(f3.type, f3.key, f3.props, null, a5.mode, h5), h5.ref = Lg(a5, d5, f3), h5.return = a5, a5 = h5);
          }
          return g2(a5);
        case wa:
          a: {
            for (l3 = f3.key; null !== d5; ) {
              if (d5.key === l3) if (4 === d5.tag && d5.stateNode.containerInfo === f3.containerInfo && d5.stateNode.implementation === f3.implementation) {
                c3(a5, d5.sibling);
                d5 = e3(d5, f3.children || []);
                d5.return = a5;
                a5 = d5;
                break a;
              } else {
                c3(a5, d5);
                break;
              }
              else b2(a5, d5);
              d5 = d5.sibling;
            }
            d5 = Sg(f3, a5.mode, h5);
            d5.return = a5;
            a5 = d5;
          }
          return g2(a5);
        case Ha:
          return l3 = f3._init, J2(a5, d5, l3(f3._payload), h5);
      }
      if (eb(f3)) return n2(a5, d5, f3, h5);
      if (Ka(f3)) return t3(a5, d5, f3, h5);
      Mg(a5, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d5 && 6 === d5.tag ? (c3(a5, d5.sibling), d5 = e3(d5, f3), d5.return = a5, a5 = d5) : (c3(a5, d5), d5 = Qg(f3, a5.mode, h5), d5.return = a5, a5 = d5), g2(a5)) : c3(a5, d5);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a4) {
  var b2 = Wg.current;
  E(Wg);
  a4._currentValue = b2;
}
function bh(a4, b2, c3) {
  for (; null !== a4; ) {
    var d4 = a4.alternate;
    (a4.childLanes & b2) !== b2 ? (a4.childLanes |= b2, null !== d4 && (d4.childLanes |= b2)) : null !== d4 && (d4.childLanes & b2) !== b2 && (d4.childLanes |= b2);
    if (a4 === c3) break;
    a4 = a4.return;
  }
}
function ch(a4, b2) {
  Xg = a4;
  Zg = Yg = null;
  a4 = a4.dependencies;
  null !== a4 && null !== a4.firstContext && (0 !== (a4.lanes & b2) && (dh = true), a4.firstContext = null);
}
function eh(a4) {
  var b2 = a4._currentValue;
  if (Zg !== a4) if (a4 = { context: a4, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$1(308));
    Yg = a4;
    Xg.dependencies = { lanes: 0, firstContext: a4 };
  } else Yg = Yg.next = a4;
  return b2;
}
var fh = null;
function gh(a4) {
  null === fh ? fh = [a4] : fh.push(a4);
}
function hh(a4, b2, c3, d4) {
  var e3 = b2.interleaved;
  null === e3 ? (c3.next = c3, gh(b2)) : (c3.next = e3.next, e3.next = c3);
  b2.interleaved = c3;
  return ih(a4, d4);
}
function ih(a4, b2) {
  a4.lanes |= b2;
  var c3 = a4.alternate;
  null !== c3 && (c3.lanes |= b2);
  c3 = a4;
  for (a4 = a4.return; null !== a4; ) a4.childLanes |= b2, c3 = a4.alternate, null !== c3 && (c3.childLanes |= b2), c3 = a4, a4 = a4.return;
  return 3 === c3.tag ? c3.stateNode : null;
}
var jh = false;
function kh(a4) {
  a4.updateQueue = { baseState: a4.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a4, b2) {
  a4 = a4.updateQueue;
  b2.updateQueue === a4 && (b2.updateQueue = { baseState: a4.baseState, firstBaseUpdate: a4.firstBaseUpdate, lastBaseUpdate: a4.lastBaseUpdate, shared: a4.shared, effects: a4.effects });
}
function mh(a4, b2) {
  return { eventTime: a4, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a4, b2, c3) {
  var d4 = a4.updateQueue;
  if (null === d4) return null;
  d4 = d4.shared;
  if (0 !== (K & 2)) {
    var e3 = d4.pending;
    null === e3 ? b2.next = b2 : (b2.next = e3.next, e3.next = b2);
    d4.pending = b2;
    return ih(a4, c3);
  }
  e3 = d4.interleaved;
  null === e3 ? (b2.next = b2, gh(d4)) : (b2.next = e3.next, e3.next = b2);
  d4.interleaved = b2;
  return ih(a4, c3);
}
function oh(a4, b2, c3) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c3 & 4194240))) {
    var d4 = b2.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b2.lanes = c3;
    Cc(a4, c3);
  }
}
function ph(a4, b2) {
  var c3 = a4.updateQueue, d4 = a4.alternate;
  if (null !== d4 && (d4 = d4.updateQueue, c3 === d4)) {
    var e3 = null, f2 = null;
    c3 = c3.firstBaseUpdate;
    if (null !== c3) {
      do {
        var g2 = { eventTime: c3.eventTime, lane: c3.lane, tag: c3.tag, payload: c3.payload, callback: c3.callback, next: null };
        null === f2 ? e3 = f2 = g2 : f2 = f2.next = g2;
        c3 = c3.next;
      } while (null !== c3);
      null === f2 ? e3 = f2 = b2 : f2 = f2.next = b2;
    } else e3 = f2 = b2;
    c3 = { baseState: d4.baseState, firstBaseUpdate: e3, lastBaseUpdate: f2, shared: d4.shared, effects: d4.effects };
    a4.updateQueue = c3;
    return;
  }
  a4 = c3.lastBaseUpdate;
  null === a4 ? c3.firstBaseUpdate = b2 : a4.next = b2;
  c3.lastBaseUpdate = b2;
}
function qh(a4, b2, c3, d4) {
  var e3 = a4.updateQueue;
  jh = false;
  var f2 = e3.firstBaseUpdate, g2 = e3.lastBaseUpdate, h4 = e3.shared.pending;
  if (null !== h4) {
    e3.shared.pending = null;
    var k3 = h4, l2 = k3.next;
    k3.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k3;
    var m4 = a4.alternate;
    null !== m4 && (m4 = m4.updateQueue, h4 = m4.lastBaseUpdate, h4 !== g2 && (null === h4 ? m4.firstBaseUpdate = l2 : h4.next = l2, m4.lastBaseUpdate = k3));
  }
  if (null !== f2) {
    var q3 = e3.baseState;
    g2 = 0;
    m4 = l2 = k3 = null;
    h4 = f2;
    do {
      var r2 = h4.lane, y4 = h4.eventTime;
      if ((d4 & r2) === r2) {
        null !== m4 && (m4 = m4.next = {
          eventTime: y4,
          lane: 0,
          tag: h4.tag,
          payload: h4.payload,
          callback: h4.callback,
          next: null
        });
        a: {
          var n2 = a4, t3 = h4;
          r2 = b2;
          y4 = c3;
          switch (t3.tag) {
            case 1:
              n2 = t3.payload;
              if ("function" === typeof n2) {
                q3 = n2.call(y4, q3, r2);
                break a;
              }
              q3 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t3.payload;
              r2 = "function" === typeof n2 ? n2.call(y4, q3, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q3 = A$1({}, q3, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h4.callback && 0 !== h4.lane && (a4.flags |= 64, r2 = e3.effects, null === r2 ? e3.effects = [h4] : r2.push(h4));
      } else y4 = { eventTime: y4, lane: r2, tag: h4.tag, payload: h4.payload, callback: h4.callback, next: null }, null === m4 ? (l2 = m4 = y4, k3 = q3) : m4 = m4.next = y4, g2 |= r2;
      h4 = h4.next;
      if (null === h4) if (h4 = e3.shared.pending, null === h4) break;
      else r2 = h4, h4 = r2.next, r2.next = null, e3.lastBaseUpdate = r2, e3.shared.pending = null;
    } while (1);
    null === m4 && (k3 = q3);
    e3.baseState = k3;
    e3.firstBaseUpdate = l2;
    e3.lastBaseUpdate = m4;
    b2 = e3.shared.interleaved;
    if (null !== b2) {
      e3 = b2;
      do
        g2 |= e3.lane, e3 = e3.next;
      while (e3 !== b2);
    } else null === f2 && (e3.shared.lanes = 0);
    rh |= g2;
    a4.lanes = g2;
    a4.memoizedState = q3;
  }
}
function sh(a4, b2, c3) {
  a4 = b2.effects;
  b2.effects = null;
  if (null !== a4) for (b2 = 0; b2 < a4.length; b2++) {
    var d4 = a4[b2], e3 = d4.callback;
    if (null !== e3) {
      d4.callback = null;
      d4 = c3;
      if ("function" !== typeof e3) throw Error(p$1(191, e3));
      e3.call(d4);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a4) {
  if (a4 === th) throw Error(p$1(174));
  return a4;
}
function yh(a4, b2) {
  G(wh, b2);
  G(vh, a4);
  G(uh, th);
  a4 = b2.nodeType;
  switch (a4) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a4 = 8 === a4 ? b2.parentNode : b2, b2 = a4.namespaceURI || null, a4 = a4.tagName, b2 = lb(b2, a4);
  }
  E(uh);
  G(uh, b2);
}
function zh() {
  E(uh);
  E(vh);
  E(wh);
}
function Ah(a4) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c3 = lb(b2, a4.type);
  b2 !== c3 && (G(vh, a4), G(uh, c3));
}
function Bh(a4) {
  vh.current === a4 && (E(uh), E(vh));
}
var L = Uf(0);
function Ch(a4) {
  for (var b2 = a4; null !== b2; ) {
    if (13 === b2.tag) {
      var c3 = b2.memoizedState;
      if (null !== c3 && (c3 = c3.dehydrated, null === c3 || "$?" === c3.data || "$!" === c3.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a4) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a4) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a4 = 0; a4 < Dh.length; a4++) Dh[a4]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$2 = null, N = null, O = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$1() {
  throw Error(p$1(321));
}
function Mh(a4, b2) {
  if (null === b2) return false;
  for (var c3 = 0; c3 < b2.length && c3 < a4.length; c3++) if (!He(a4[c3], b2[c3])) return false;
  return true;
}
function Nh(a4, b2, c3, d4, e3, f2) {
  Hh = f2;
  M$2 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a4 || null === a4.memoizedState ? Oh : Ph;
  a4 = c3(d4, e3);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$1(301));
      f2 += 1;
      O = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a4 = c3(d4, e3);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O = N = M$2 = null;
  Ih = false;
  if (b2) throw Error(p$1(300));
  return a4;
}
function Sh() {
  var a4 = 0 !== Kh;
  Kh = 0;
  return a4;
}
function Th() {
  var a4 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O ? M$2.memoizedState = O = a4 : O = O.next = a4;
  return O;
}
function Uh() {
  if (null === N) {
    var a4 = M$2.alternate;
    a4 = null !== a4 ? a4.memoizedState : null;
  } else a4 = N.next;
  var b2 = null === O ? M$2.memoizedState : O.next;
  if (null !== b2) O = b2, N = a4;
  else {
    if (null === a4) throw Error(p$1(310));
    N = a4;
    a4 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O ? M$2.memoizedState = O = a4 : O = O.next = a4;
  }
  return O;
}
function Vh(a4, b2) {
  return "function" === typeof b2 ? b2(a4) : b2;
}
function Wh(a4) {
  var b2 = Uh(), c3 = b2.queue;
  if (null === c3) throw Error(p$1(311));
  c3.lastRenderedReducer = a4;
  var d4 = N, e3 = d4.baseQueue, f2 = c3.pending;
  if (null !== f2) {
    if (null !== e3) {
      var g2 = e3.next;
      e3.next = f2.next;
      f2.next = g2;
    }
    d4.baseQueue = e3 = f2;
    c3.pending = null;
  }
  if (null !== e3) {
    f2 = e3.next;
    d4 = d4.baseState;
    var h4 = g2 = null, k3 = null, l2 = f2;
    do {
      var m4 = l2.lane;
      if ((Hh & m4) === m4) null !== k3 && (k3 = k3.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d4 = l2.hasEagerState ? l2.eagerState : a4(d4, l2.action);
      else {
        var q3 = {
          lane: m4,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k3 ? (h4 = k3 = q3, g2 = d4) : k3 = k3.next = q3;
        M$2.lanes |= m4;
        rh |= m4;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k3 ? g2 = d4 : k3.next = h4;
    He(d4, b2.memoizedState) || (dh = true);
    b2.memoizedState = d4;
    b2.baseState = g2;
    b2.baseQueue = k3;
    c3.lastRenderedState = d4;
  }
  a4 = c3.interleaved;
  if (null !== a4) {
    e3 = a4;
    do
      f2 = e3.lane, M$2.lanes |= f2, rh |= f2, e3 = e3.next;
    while (e3 !== a4);
  } else null === e3 && (c3.lanes = 0);
  return [b2.memoizedState, c3.dispatch];
}
function Xh(a4) {
  var b2 = Uh(), c3 = b2.queue;
  if (null === c3) throw Error(p$1(311));
  c3.lastRenderedReducer = a4;
  var d4 = c3.dispatch, e3 = c3.pending, f2 = b2.memoizedState;
  if (null !== e3) {
    c3.pending = null;
    var g2 = e3 = e3.next;
    do
      f2 = a4(f2, g2.action), g2 = g2.next;
    while (g2 !== e3);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c3.lastRenderedState = f2;
  }
  return [f2, d4];
}
function Yh() {
}
function Zh(a4, b2) {
  var c3 = M$2, d4 = Uh(), e3 = b2(), f2 = !He(d4.memoizedState, e3);
  f2 && (d4.memoizedState = e3, dh = true);
  d4 = d4.queue;
  $h(ai.bind(null, c3, d4, a4), [a4]);
  if (d4.getSnapshot !== b2 || f2 || null !== O && O.memoizedState.tag & 1) {
    c3.flags |= 2048;
    bi(9, ci.bind(null, c3, d4, e3, b2), void 0, null);
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(c3, b2, e3);
  }
  return e3;
}
function di(a4, b2, c3) {
  a4.flags |= 16384;
  a4 = { getSnapshot: b2, value: c3 };
  b2 = M$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$2.updateQueue = b2, b2.stores = [a4]) : (c3 = b2.stores, null === c3 ? b2.stores = [a4] : c3.push(a4));
}
function ci(a4, b2, c3, d4) {
  b2.value = c3;
  b2.getSnapshot = d4;
  ei(b2) && fi(a4);
}
function ai(a4, b2, c3) {
  return c3(function() {
    ei(b2) && fi(a4);
  });
}
function ei(a4) {
  var b2 = a4.getSnapshot;
  a4 = a4.value;
  try {
    var c3 = b2();
    return !He(a4, c3);
  } catch (d4) {
    return true;
  }
}
function fi(a4) {
  var b2 = ih(a4, 1);
  null !== b2 && gi(b2, a4, 1, -1);
}
function hi(a4) {
  var b2 = Th();
  "function" === typeof a4 && (a4 = a4());
  b2.memoizedState = b2.baseState = a4;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a4 };
  b2.queue = a4;
  a4 = a4.dispatch = ii.bind(null, M$2, a4);
  return [b2.memoizedState, a4];
}
function bi(a4, b2, c3, d4) {
  a4 = { tag: a4, create: b2, destroy: c3, deps: d4, next: null };
  b2 = M$2.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$2.updateQueue = b2, b2.lastEffect = a4.next = a4) : (c3 = b2.lastEffect, null === c3 ? b2.lastEffect = a4.next = a4 : (d4 = c3.next, c3.next = a4, a4.next = d4, b2.lastEffect = a4));
  return a4;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a4, b2, c3, d4) {
  var e3 = Th();
  M$2.flags |= a4;
  e3.memoizedState = bi(1 | b2, c3, void 0, void 0 === d4 ? null : d4);
}
function li(a4, b2, c3, d4) {
  var e3 = Uh();
  d4 = void 0 === d4 ? null : d4;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d4 && Mh(d4, g2.deps)) {
      e3.memoizedState = bi(b2, c3, f2, d4);
      return;
    }
  }
  M$2.flags |= a4;
  e3.memoizedState = bi(1 | b2, c3, f2, d4);
}
function mi(a4, b2) {
  return ki(8390656, 8, a4, b2);
}
function $h(a4, b2) {
  return li(2048, 8, a4, b2);
}
function ni(a4, b2) {
  return li(4, 2, a4, b2);
}
function oi(a4, b2) {
  return li(4, 4, a4, b2);
}
function pi(a4, b2) {
  if ("function" === typeof b2) return a4 = a4(), b2(a4), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a4 = a4(), b2.current = a4, function() {
    b2.current = null;
  };
}
function qi(a4, b2, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return li(4, 4, pi.bind(null, b2, a4), c3);
}
function ri() {
}
function si(a4, b2) {
  var c3 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b2 && Mh(b2, d4[1])) return d4[0];
  c3.memoizedState = [a4, b2];
  return a4;
}
function ti(a4, b2) {
  var c3 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d4 = c3.memoizedState;
  if (null !== d4 && null !== b2 && Mh(b2, d4[1])) return d4[0];
  a4 = a4();
  c3.memoizedState = [a4, b2];
  return a4;
}
function ui(a4, b2, c3) {
  if (0 === (Hh & 21)) return a4.baseState && (a4.baseState = false, dh = true), a4.memoizedState = c3;
  He(c3, b2) || (c3 = yc(), M$2.lanes |= c3, rh |= c3, a4.baseState = true);
  return b2;
}
function vi(a4, b2) {
  var c3 = C;
  C = 0 !== c3 && 4 > c3 ? c3 : 4;
  a4(true);
  var d4 = Gh.transition;
  Gh.transition = {};
  try {
    a4(false), b2();
  } finally {
    C = c3, Gh.transition = d4;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a4, b2, c3) {
  var d4 = yi(a4);
  c3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (zi(a4)) Ai(b2, c3);
  else if (c3 = hh(a4, b2, c3, d4), null !== c3) {
    var e3 = R();
    gi(c3, a4, d4, e3);
    Bi(c3, b2, d4);
  }
}
function ii(a4, b2, c3) {
  var d4 = yi(a4), e3 = { lane: d4, action: c3, hasEagerState: false, eagerState: null, next: null };
  if (zi(a4)) Ai(b2, e3);
  else {
    var f2 = a4.alternate;
    if (0 === a4.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h4 = f2(g2, c3);
      e3.hasEagerState = true;
      e3.eagerState = h4;
      if (He(h4, g2)) {
        var k3 = b2.interleaved;
        null === k3 ? (e3.next = e3, gh(b2)) : (e3.next = k3.next, k3.next = e3);
        b2.interleaved = e3;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c3 = hh(a4, b2, e3, d4);
    null !== c3 && (e3 = R(), gi(c3, a4, d4, e3), Bi(c3, b2, d4));
  }
}
function zi(a4) {
  var b2 = a4.alternate;
  return a4 === M$2 || null !== b2 && b2 === M$2;
}
function Ai(a4, b2) {
  Jh = Ih = true;
  var c3 = a4.pending;
  null === c3 ? b2.next = b2 : (b2.next = c3.next, c3.next = b2);
  a4.pending = b2;
}
function Bi(a4, b2, c3) {
  if (0 !== (c3 & 4194240)) {
    var d4 = b2.lanes;
    d4 &= a4.pendingLanes;
    c3 |= d4;
    b2.lanes = c3;
    Cc(a4, c3);
  }
}
var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a4, b2) {
  Th().memoizedState = [a4, void 0 === b2 ? null : b2];
  return a4;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a4, b2, c3) {
  c3 = null !== c3 && void 0 !== c3 ? c3.concat([a4]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a4),
    c3
  );
}, useLayoutEffect: function(a4, b2) {
  return ki(4194308, 4, a4, b2);
}, useInsertionEffect: function(a4, b2) {
  return ki(4, 2, a4, b2);
}, useMemo: function(a4, b2) {
  var c3 = Th();
  b2 = void 0 === b2 ? null : b2;
  a4 = a4();
  c3.memoizedState = [a4, b2];
  return a4;
}, useReducer: function(a4, b2, c3) {
  var d4 = Th();
  b2 = void 0 !== c3 ? c3(b2) : b2;
  d4.memoizedState = d4.baseState = b2;
  a4 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a4, lastRenderedState: b2 };
  d4.queue = a4;
  a4 = a4.dispatch = xi.bind(null, M$2, a4);
  return [d4.memoizedState, a4];
}, useRef: function(a4) {
  var b2 = Th();
  a4 = { current: a4 };
  return b2.memoizedState = a4;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a4) {
  return Th().memoizedState = a4;
}, useTransition: function() {
  var a4 = hi(false), b2 = a4[0];
  a4 = vi.bind(null, a4[1]);
  Th().memoizedState = a4;
  return [b2, a4];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a4, b2, c3) {
  var d4 = M$2, e3 = Th();
  if (I) {
    if (void 0 === c3) throw Error(p$1(407));
    c3 = c3();
  } else {
    c3 = b2();
    if (null === Q) throw Error(p$1(349));
    0 !== (Hh & 30) || di(d4, b2, c3);
  }
  e3.memoizedState = c3;
  var f2 = { value: c3, getSnapshot: b2 };
  e3.queue = f2;
  mi(ai.bind(
    null,
    d4,
    f2,
    a4
  ), [a4]);
  d4.flags |= 2048;
  bi(9, ci.bind(null, d4, f2, c3, b2), void 0, null);
  return c3;
}, useId: function() {
  var a4 = Th(), b2 = Q.identifierPrefix;
  if (I) {
    var c3 = sg;
    var d4 = rg;
    c3 = (d4 & ~(1 << 32 - oc(d4) - 1)).toString(32) + c3;
    b2 = ":" + b2 + "R" + c3;
    c3 = Kh++;
    0 < c3 && (b2 += "H" + c3.toString(32));
    b2 += ":";
  } else c3 = Lh++, b2 = ":" + b2 + "r" + c3.toString(32) + ":";
  return a4.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a4) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a4);
  },
  useTransition: function() {
    var a4 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a4, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a4) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a4 : ui(b2, N.memoizedState, a4);
}, useTransition: function() {
  var a4 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a4, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a4, b2) {
  if (a4 && a4.defaultProps) {
    b2 = A$1({}, b2);
    a4 = a4.defaultProps;
    for (var c3 in a4) void 0 === b2[c3] && (b2[c3] = a4[c3]);
    return b2;
  }
  return b2;
}
function Di(a4, b2, c3, d4) {
  b2 = a4.memoizedState;
  c3 = c3(d4, b2);
  c3 = null === c3 || void 0 === c3 ? b2 : A$1({}, b2, c3);
  a4.memoizedState = c3;
  0 === a4.lanes && (a4.updateQueue.baseState = c3);
}
var Ei = { isMounted: function(a4) {
  return (a4 = a4._reactInternals) ? Vb(a4) === a4 : false;
}, enqueueSetState: function(a4, b2, c3) {
  a4 = a4._reactInternals;
  var d4 = R(), e3 = yi(a4), f2 = mh(d4, e3);
  f2.payload = b2;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b2 = nh(a4, f2, e3);
  null !== b2 && (gi(b2, a4, e3, d4), oh(b2, a4, e3));
}, enqueueReplaceState: function(a4, b2, c3) {
  a4 = a4._reactInternals;
  var d4 = R(), e3 = yi(a4), f2 = mh(d4, e3);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c3 && null !== c3 && (f2.callback = c3);
  b2 = nh(a4, f2, e3);
  null !== b2 && (gi(b2, a4, e3, d4), oh(b2, a4, e3));
}, enqueueForceUpdate: function(a4, b2) {
  a4 = a4._reactInternals;
  var c3 = R(), d4 = yi(a4), e3 = mh(c3, d4);
  e3.tag = 2;
  void 0 !== b2 && null !== b2 && (e3.callback = b2);
  b2 = nh(a4, e3, d4);
  null !== b2 && (gi(b2, a4, d4, c3), oh(b2, a4, d4));
} };
function Fi(a4, b2, c3, d4, e3, f2, g2) {
  a4 = a4.stateNode;
  return "function" === typeof a4.shouldComponentUpdate ? a4.shouldComponentUpdate(d4, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c3, d4) || !Ie(e3, f2) : true;
}
function Gi(a4, b2, c3) {
  var d4 = false, e3 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e3 = Zf(b2) ? Xf : H.current, d4 = b2.contextTypes, f2 = (d4 = null !== d4 && void 0 !== d4) ? Yf(a4, e3) : Vf);
  b2 = new b2(c3, f2);
  a4.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a4.stateNode = b2;
  b2._reactInternals = a4;
  d4 && (a4 = a4.stateNode, a4.__reactInternalMemoizedUnmaskedChildContext = e3, a4.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a4, b2, c3, d4) {
  a4 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c3, d4);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c3, d4);
  b2.state !== a4 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a4, b2, c3, d4) {
  var e3 = a4.stateNode;
  e3.props = c3;
  e3.state = a4.memoizedState;
  e3.refs = {};
  kh(a4);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e3.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e3.context = Yf(a4, f2));
  e3.state = a4.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a4, b2, f2, c3), e3.state = a4.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e3.getSnapshotBeforeUpdate || "function" !== typeof e3.UNSAFE_componentWillMount && "function" !== typeof e3.componentWillMount || (b2 = e3.state, "function" === typeof e3.componentWillMount && e3.componentWillMount(), "function" === typeof e3.UNSAFE_componentWillMount && e3.UNSAFE_componentWillMount(), b2 !== e3.state && Ei.enqueueReplaceState(e3, e3.state, null), qh(a4, c3, e3, d4), e3.state = a4.memoizedState);
  "function" === typeof e3.componentDidMount && (a4.flags |= 4194308);
}
function Ji(a4, b2) {
  try {
    var c3 = "", d4 = b2;
    do
      c3 += Pa(d4), d4 = d4.return;
    while (d4);
    var e3 = c3;
  } catch (f2) {
    e3 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a4, source: b2, stack: e3, digest: null };
}
function Ki(a4, b2, c3) {
  return { value: a4, source: null, stack: null != c3 ? c3 : null, digest: null != b2 ? b2 : null };
}
function Li(a4, b2) {
  try {
    console.error(b2.value);
  } catch (c3) {
    setTimeout(function() {
      throw c3;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a4, b2, c3) {
  c3 = mh(-1, c3);
  c3.tag = 3;
  c3.payload = { element: null };
  var d4 = b2.value;
  c3.callback = function() {
    Oi || (Oi = true, Pi = d4);
    Li(a4, b2);
  };
  return c3;
}
function Qi(a4, b2, c3) {
  c3 = mh(-1, c3);
  c3.tag = 3;
  var d4 = a4.type.getDerivedStateFromError;
  if ("function" === typeof d4) {
    var e3 = b2.value;
    c3.payload = function() {
      return d4(e3);
    };
    c3.callback = function() {
      Li(a4, b2);
    };
  }
  var f2 = a4.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c3.callback = function() {
    Li(a4, b2);
    "function" !== typeof d4 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c4 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c4 ? c4 : "" });
  });
  return c3;
}
function Si(a4, b2, c3) {
  var d4 = a4.pingCache;
  if (null === d4) {
    d4 = a4.pingCache = new Mi();
    var e3 = /* @__PURE__ */ new Set();
    d4.set(b2, e3);
  } else e3 = d4.get(b2), void 0 === e3 && (e3 = /* @__PURE__ */ new Set(), d4.set(b2, e3));
  e3.has(c3) || (e3.add(c3), a4 = Ti.bind(null, a4, b2, c3), b2.then(a4, a4));
}
function Ui(a4) {
  do {
    var b2;
    if (b2 = 13 === a4.tag) b2 = a4.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a4;
    a4 = a4.return;
  } while (null !== a4);
  return null;
}
function Vi(a4, b2, c3, d4, e3) {
  if (0 === (a4.mode & 1)) return a4 === b2 ? a4.flags |= 65536 : (a4.flags |= 128, c3.flags |= 131072, c3.flags &= -52805, 1 === c3.tag && (null === c3.alternate ? c3.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c3, b2, 1))), c3.lanes |= 1), a4;
  a4.flags |= 65536;
  a4.lanes = e3;
  return a4;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a4, b2, c3, d4) {
  b2.child = null === a4 ? Vg(b2, null, c3, d4) : Ug(b2, a4.child, c3, d4);
}
function Yi(a4, b2, c3, d4, e3) {
  c3 = c3.render;
  var f2 = b2.ref;
  ch(b2, e3);
  d4 = Nh(a4, b2, c3, d4, f2, e3);
  c3 = Sh();
  if (null !== a4 && !dh) return b2.updateQueue = a4.updateQueue, b2.flags &= -2053, a4.lanes &= ~e3, Zi(a4, b2, e3);
  I && c3 && vg(b2);
  b2.flags |= 1;
  Xi(a4, b2, d4, e3);
  return b2.child;
}
function $i(a4, b2, c3, d4, e3) {
  if (null === a4) {
    var f2 = c3.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c3.compare && void 0 === c3.defaultProps) return b2.tag = 15, b2.type = f2, bj(a4, b2, f2, d4, e3);
    a4 = Rg(c3.type, null, d4, b2, b2.mode, e3);
    a4.ref = b2.ref;
    a4.return = b2;
    return b2.child = a4;
  }
  f2 = a4.child;
  if (0 === (a4.lanes & e3)) {
    var g2 = f2.memoizedProps;
    c3 = c3.compare;
    c3 = null !== c3 ? c3 : Ie;
    if (c3(g2, d4) && a4.ref === b2.ref) return Zi(a4, b2, e3);
  }
  b2.flags |= 1;
  a4 = Pg(f2, d4);
  a4.ref = b2.ref;
  a4.return = b2;
  return b2.child = a4;
}
function bj(a4, b2, c3, d4, e3) {
  if (null !== a4) {
    var f2 = a4.memoizedProps;
    if (Ie(f2, d4) && a4.ref === b2.ref) if (dh = false, b2.pendingProps = d4 = f2, 0 !== (a4.lanes & e3)) 0 !== (a4.flags & 131072) && (dh = true);
    else return b2.lanes = a4.lanes, Zi(a4, b2, e3);
  }
  return cj(a4, b2, c3, d4, e3);
}
function dj(a4, b2, c3) {
  var d4 = b2.pendingProps, e3 = d4.children, f2 = null !== a4 ? a4.memoizedState : null;
  if ("hidden" === d4.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c3;
  else {
    if (0 === (c3 & 1073741824)) return a4 = null !== f2 ? f2.baseLanes | c3 : c3, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a4, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a4, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d4 = null !== f2 ? f2.baseLanes : c3;
    G(ej, fj);
    fj |= d4;
  }
  else null !== f2 ? (d4 = f2.baseLanes | c3, b2.memoizedState = null) : d4 = c3, G(ej, fj), fj |= d4;
  Xi(a4, b2, e3, c3);
  return b2.child;
}
function gj(a4, b2) {
  var c3 = b2.ref;
  if (null === a4 && null !== c3 || null !== a4 && a4.ref !== c3) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a4, b2, c3, d4, e3) {
  var f2 = Zf(c3) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e3);
  c3 = Nh(a4, b2, c3, d4, f2, e3);
  d4 = Sh();
  if (null !== a4 && !dh) return b2.updateQueue = a4.updateQueue, b2.flags &= -2053, a4.lanes &= ~e3, Zi(a4, b2, e3);
  I && d4 && vg(b2);
  b2.flags |= 1;
  Xi(a4, b2, c3, e3);
  return b2.child;
}
function hj(a4, b2, c3, d4, e3) {
  if (Zf(c3)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e3);
  if (null === b2.stateNode) ij(a4, b2), Gi(b2, c3, d4), Ii(b2, c3, d4, e3), d4 = true;
  else if (null === a4) {
    var g2 = b2.stateNode, h4 = b2.memoizedProps;
    g2.props = h4;
    var k3 = g2.context, l2 = c3.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c3) ? Xf : H.current, l2 = Yf(b2, l2));
    var m4 = c3.getDerivedStateFromProps, q3 = "function" === typeof m4 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q3 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== d4 || k3 !== l2) && Hi(b2, g2, d4, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d4, g2, e3);
    k3 = b2.memoizedState;
    h4 !== d4 || r2 !== k3 || Wf.current || jh ? ("function" === typeof m4 && (Di(b2, c3, m4, d4), k3 = b2.memoizedState), (h4 = jh || Fi(b2, c3, h4, d4, r2, k3, l2)) ? (q3 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d4, b2.memoizedState = k3), g2.props = d4, g2.state = k3, g2.context = l2, d4 = h4) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d4 = false);
  } else {
    g2 = b2.stateNode;
    lh(a4, b2);
    h4 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h4 : Ci(b2.type, h4);
    g2.props = l2;
    q3 = b2.pendingProps;
    r2 = g2.context;
    k3 = c3.contextType;
    "object" === typeof k3 && null !== k3 ? k3 = eh(k3) : (k3 = Zf(c3) ? Xf : H.current, k3 = Yf(b2, k3));
    var y4 = c3.getDerivedStateFromProps;
    (m4 = "function" === typeof y4 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h4 !== q3 || r2 !== k3) && Hi(b2, g2, d4, k3);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d4, g2, e3);
    var n2 = b2.memoizedState;
    h4 !== q3 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y4 && (Di(b2, c3, y4, d4), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c3, l2, d4, r2, n2, k3) || false) ? (m4 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d4, n2, k3), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d4, n2, k3)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d4, b2.memoizedState = n2), g2.props = d4, g2.state = n2, g2.context = k3, d4 = l2) : ("function" !== typeof g2.componentDidUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h4 === a4.memoizedProps && r2 === a4.memoizedState || (b2.flags |= 1024), d4 = false);
  }
  return jj(a4, b2, c3, d4, f2, e3);
}
function jj(a4, b2, c3, d4, e3, f2) {
  gj(a4, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d4 && !g2) return e3 && dg(b2, c3, false), Zi(a4, b2, f2);
  d4 = b2.stateNode;
  Wi.current = b2;
  var h4 = g2 && "function" !== typeof c3.getDerivedStateFromError ? null : d4.render();
  b2.flags |= 1;
  null !== a4 && g2 ? (b2.child = Ug(b2, a4.child, null, f2), b2.child = Ug(b2, null, h4, f2)) : Xi(a4, b2, h4, f2);
  b2.memoizedState = d4.state;
  e3 && dg(b2, c3, true);
  return b2.child;
}
function kj(a4) {
  var b2 = a4.stateNode;
  b2.pendingContext ? ag(a4, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a4, b2.context, false);
  yh(a4, b2.containerInfo);
}
function lj(a4, b2, c3, d4, e3) {
  Ig();
  Jg(e3);
  b2.flags |= 256;
  Xi(a4, b2, c3, d4);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a4) {
  return { baseLanes: a4, cachePool: null, transitions: null };
}
function oj(a4, b2, c3) {
  var d4 = b2.pendingProps, e3 = L.current, f2 = false, g2 = 0 !== (b2.flags & 128), h4;
  (h4 = g2) || (h4 = null !== a4 && null === a4.memoizedState ? false : 0 !== (e3 & 2));
  if (h4) f2 = true, b2.flags &= -129;
  else if (null === a4 || null !== a4.memoizedState) e3 |= 1;
  G(L, e3 & 1);
  if (null === a4) {
    Eg(b2);
    a4 = b2.memoizedState;
    if (null !== a4 && (a4 = a4.dehydrated, null !== a4)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a4.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d4.children;
    a4 = d4.fallback;
    return f2 ? (d4 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d4 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d4, 0, null), a4 = Tg(a4, d4, c3, null), f2.return = b2, a4.return = b2, f2.sibling = a4, b2.child = f2, b2.child.memoizedState = nj(c3), b2.memoizedState = mj, a4) : qj(b2, g2);
  }
  e3 = a4.memoizedState;
  if (null !== e3 && (h4 = e3.dehydrated, null !== h4)) return rj(a4, b2, g2, d4, h4, e3, c3);
  if (f2) {
    f2 = d4.fallback;
    g2 = b2.mode;
    e3 = a4.child;
    h4 = e3.sibling;
    var k3 = { mode: "hidden", children: d4.children };
    0 === (g2 & 1) && b2.child !== e3 ? (d4 = b2.child, d4.childLanes = 0, d4.pendingProps = k3, b2.deletions = null) : (d4 = Pg(e3, k3), d4.subtreeFlags = e3.subtreeFlags & 14680064);
    null !== h4 ? f2 = Pg(h4, f2) : (f2 = Tg(f2, g2, c3, null), f2.flags |= 2);
    f2.return = b2;
    d4.return = b2;
    d4.sibling = f2;
    b2.child = d4;
    d4 = f2;
    f2 = b2.child;
    g2 = a4.child.memoizedState;
    g2 = null === g2 ? nj(c3) : { baseLanes: g2.baseLanes | c3, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a4.childLanes & ~c3;
    b2.memoizedState = mj;
    return d4;
  }
  f2 = a4.child;
  a4 = f2.sibling;
  d4 = Pg(f2, { mode: "visible", children: d4.children });
  0 === (b2.mode & 1) && (d4.lanes = c3);
  d4.return = b2;
  d4.sibling = null;
  null !== a4 && (c3 = b2.deletions, null === c3 ? (b2.deletions = [a4], b2.flags |= 16) : c3.push(a4));
  b2.child = d4;
  b2.memoizedState = null;
  return d4;
}
function qj(a4, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a4.mode, 0, null);
  b2.return = a4;
  return a4.child = b2;
}
function sj(a4, b2, c3, d4) {
  null !== d4 && Jg(d4);
  Ug(b2, a4.child, null, c3);
  a4 = qj(b2, b2.pendingProps.children);
  a4.flags |= 2;
  b2.memoizedState = null;
  return a4;
}
function rj(a4, b2, c3, d4, e3, f2, g2) {
  if (c3) {
    if (b2.flags & 256) return b2.flags &= -257, d4 = Ki(Error(p$1(422))), sj(a4, b2, g2, d4);
    if (null !== b2.memoizedState) return b2.child = a4.child, b2.flags |= 128, null;
    f2 = d4.fallback;
    e3 = b2.mode;
    d4 = pj({ mode: "visible", children: d4.children }, e3, 0, null);
    f2 = Tg(f2, e3, g2, null);
    f2.flags |= 2;
    d4.return = b2;
    f2.return = b2;
    d4.sibling = f2;
    b2.child = d4;
    0 !== (b2.mode & 1) && Ug(b2, a4.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a4, b2, g2, null);
  if ("$!" === e3.data) {
    d4 = e3.nextSibling && e3.nextSibling.dataset;
    if (d4) var h4 = d4.dgst;
    d4 = h4;
    f2 = Error(p$1(419));
    d4 = Ki(f2, d4, void 0);
    return sj(a4, b2, g2, d4);
  }
  h4 = 0 !== (g2 & a4.childLanes);
  if (dh || h4) {
    d4 = Q;
    if (null !== d4) {
      switch (g2 & -g2) {
        case 4:
          e3 = 2;
          break;
        case 16:
          e3 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e3 = 32;
          break;
        case 536870912:
          e3 = 268435456;
          break;
        default:
          e3 = 0;
      }
      e3 = 0 !== (e3 & (d4.suspendedLanes | g2)) ? 0 : e3;
      0 !== e3 && e3 !== f2.retryLane && (f2.retryLane = e3, ih(a4, e3), gi(d4, a4, e3, -1));
    }
    tj();
    d4 = Ki(Error(p$1(421)));
    return sj(a4, b2, g2, d4);
  }
  if ("$?" === e3.data) return b2.flags |= 128, b2.child = a4.child, b2 = uj.bind(null, a4), e3._reactRetry = b2, null;
  a4 = f2.treeContext;
  yg = Lf(e3.nextSibling);
  xg = b2;
  I = true;
  zg = null;
  null !== a4 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a4.id, sg = a4.overflow, qg = b2);
  b2 = qj(b2, d4.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a4, b2, c3) {
  a4.lanes |= b2;
  var d4 = a4.alternate;
  null !== d4 && (d4.lanes |= b2);
  bh(a4.return, b2, c3);
}
function wj(a4, b2, c3, d4, e3) {
  var f2 = a4.memoizedState;
  null === f2 ? a4.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d4, tail: c3, tailMode: e3 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d4, f2.tail = c3, f2.tailMode = e3);
}
function xj(a4, b2, c3) {
  var d4 = b2.pendingProps, e3 = d4.revealOrder, f2 = d4.tail;
  Xi(a4, b2, d4.children, c3);
  d4 = L.current;
  if (0 !== (d4 & 2)) d4 = d4 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a4 && 0 !== (a4.flags & 128)) a: for (a4 = b2.child; null !== a4; ) {
      if (13 === a4.tag) null !== a4.memoizedState && vj(a4, c3, b2);
      else if (19 === a4.tag) vj(a4, c3, b2);
      else if (null !== a4.child) {
        a4.child.return = a4;
        a4 = a4.child;
        continue;
      }
      if (a4 === b2) break a;
      for (; null === a4.sibling; ) {
        if (null === a4.return || a4.return === b2) break a;
        a4 = a4.return;
      }
      a4.sibling.return = a4.return;
      a4 = a4.sibling;
    }
    d4 &= 1;
  }
  G(L, d4);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e3) {
    case "forwards":
      c3 = b2.child;
      for (e3 = null; null !== c3; ) a4 = c3.alternate, null !== a4 && null === Ch(a4) && (e3 = c3), c3 = c3.sibling;
      c3 = e3;
      null === c3 ? (e3 = b2.child, b2.child = null) : (e3 = c3.sibling, c3.sibling = null);
      wj(b2, false, e3, c3, f2);
      break;
    case "backwards":
      c3 = null;
      e3 = b2.child;
      for (b2.child = null; null !== e3; ) {
        a4 = e3.alternate;
        if (null !== a4 && null === Ch(a4)) {
          b2.child = e3;
          break;
        }
        a4 = e3.sibling;
        e3.sibling = c3;
        c3 = e3;
        e3 = a4;
      }
      wj(b2, true, c3, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a4, b2) {
  0 === (b2.mode & 1) && null !== a4 && (a4.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a4, b2, c3) {
  null !== a4 && (b2.dependencies = a4.dependencies);
  rh |= b2.lanes;
  if (0 === (c3 & b2.childLanes)) return null;
  if (null !== a4 && b2.child !== a4.child) throw Error(p$1(153));
  if (null !== b2.child) {
    a4 = b2.child;
    c3 = Pg(a4, a4.pendingProps);
    b2.child = c3;
    for (c3.return = b2; null !== a4.sibling; ) a4 = a4.sibling, c3 = c3.sibling = Pg(a4, a4.pendingProps), c3.return = b2;
    c3.sibling = null;
  }
  return b2.child;
}
function yj(a4, b2, c3) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d4 = b2.type._context, e3 = b2.memoizedProps.value;
      G(Wg, d4._currentValue);
      d4._currentValue = e3;
      break;
    case 13:
      d4 = b2.memoizedState;
      if (null !== d4) {
        if (null !== d4.dehydrated) return G(L, L.current & 1), b2.flags |= 128, null;
        if (0 !== (c3 & b2.child.childLanes)) return oj(a4, b2, c3);
        G(L, L.current & 1);
        a4 = Zi(a4, b2, c3);
        return null !== a4 ? a4.sibling : null;
      }
      G(L, L.current & 1);
      break;
    case 19:
      d4 = 0 !== (c3 & b2.childLanes);
      if (0 !== (a4.flags & 128)) {
        if (d4) return xj(a4, b2, c3);
        b2.flags |= 128;
      }
      e3 = b2.memoizedState;
      null !== e3 && (e3.rendering = null, e3.tail = null, e3.lastEffect = null);
      G(L, L.current);
      if (d4) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a4, b2, c3);
  }
  return Zi(a4, b2, c3);
}
var zj, Aj, Bj, Cj;
zj = function(a4, b2) {
  for (var c3 = b2.child; null !== c3; ) {
    if (5 === c3.tag || 6 === c3.tag) a4.appendChild(c3.stateNode);
    else if (4 !== c3.tag && null !== c3.child) {
      c3.child.return = c3;
      c3 = c3.child;
      continue;
    }
    if (c3 === b2) break;
    for (; null === c3.sibling; ) {
      if (null === c3.return || c3.return === b2) return;
      c3 = c3.return;
    }
    c3.sibling.return = c3.return;
    c3 = c3.sibling;
  }
};
Aj = function() {
};
Bj = function(a4, b2, c3, d4) {
  var e3 = a4.memoizedProps;
  if (e3 !== d4) {
    a4 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c3) {
      case "input":
        e3 = Ya(a4, e3);
        d4 = Ya(a4, d4);
        f2 = [];
        break;
      case "select":
        e3 = A$1({}, e3, { value: void 0 });
        d4 = A$1({}, d4, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e3 = gb(a4, e3);
        d4 = gb(a4, d4);
        f2 = [];
        break;
      default:
        "function" !== typeof e3.onClick && "function" === typeof d4.onClick && (a4.onclick = Bf);
    }
    ub(c3, d4);
    var g2;
    c3 = null;
    for (l2 in e3) if (!d4.hasOwnProperty(l2) && e3.hasOwnProperty(l2) && null != e3[l2]) if ("style" === l2) {
      var h4 = e3[l2];
      for (g2 in h4) h4.hasOwnProperty(g2) && (c3 || (c3 = {}), c3[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d4) {
      var k3 = d4[l2];
      h4 = null != e3 ? e3[l2] : void 0;
      if (d4.hasOwnProperty(l2) && k3 !== h4 && (null != k3 || null != h4)) if ("style" === l2) if (h4) {
        for (g2 in h4) !h4.hasOwnProperty(g2) || k3 && k3.hasOwnProperty(g2) || (c3 || (c3 = {}), c3[g2] = "");
        for (g2 in k3) k3.hasOwnProperty(g2) && h4[g2] !== k3[g2] && (c3 || (c3 = {}), c3[g2] = k3[g2]);
      } else c3 || (f2 || (f2 = []), f2.push(
        l2,
        c3
      )), c3 = k3;
      else "dangerouslySetInnerHTML" === l2 ? (k3 = k3 ? k3.__html : void 0, h4 = h4 ? h4.__html : void 0, null != k3 && h4 !== k3 && (f2 = f2 || []).push(l2, k3)) : "children" === l2 ? "string" !== typeof k3 && "number" !== typeof k3 || (f2 = f2 || []).push(l2, "" + k3) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k3 && "onScroll" === l2 && D("scroll", a4), f2 || h4 === k3 || (f2 = [])) : (f2 = f2 || []).push(l2, k3));
    }
    c3 && (f2 = f2 || []).push("style", c3);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a4, b2, c3, d4) {
  c3 !== d4 && (b2.flags |= 4);
};
function Dj(a4, b2) {
  if (!I) switch (a4.tailMode) {
    case "hidden":
      b2 = a4.tail;
      for (var c3 = null; null !== b2; ) null !== b2.alternate && (c3 = b2), b2 = b2.sibling;
      null === c3 ? a4.tail = null : c3.sibling = null;
      break;
    case "collapsed":
      c3 = a4.tail;
      for (var d4 = null; null !== c3; ) null !== c3.alternate && (d4 = c3), c3 = c3.sibling;
      null === d4 ? b2 || null === a4.tail ? a4.tail = null : a4.tail.sibling = null : d4.sibling = null;
  }
}
function S(a4) {
  var b2 = null !== a4.alternate && a4.alternate.child === a4.child, c3 = 0, d4 = 0;
  if (b2) for (var e3 = a4.child; null !== e3; ) c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags & 14680064, d4 |= e3.flags & 14680064, e3.return = a4, e3 = e3.sibling;
  else for (e3 = a4.child; null !== e3; ) c3 |= e3.lanes | e3.childLanes, d4 |= e3.subtreeFlags, d4 |= e3.flags, e3.return = a4, e3 = e3.sibling;
  a4.subtreeFlags |= d4;
  a4.childLanes = c3;
  return b2;
}
function Ej(a4, b2, c3) {
  var d4 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S(b2), null;
    case 3:
      d4 = b2.stateNode;
      zh();
      E(Wf);
      E(H);
      Eh();
      d4.pendingContext && (d4.context = d4.pendingContext, d4.pendingContext = null);
      if (null === a4 || null === a4.child) Gg(b2) ? b2.flags |= 4 : null === a4 || a4.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a4, b2);
      S(b2);
      return null;
    case 5:
      Bh(b2);
      var e3 = xh(wh.current);
      c3 = b2.type;
      if (null !== a4 && null != b2.stateNode) Bj(a4, b2, c3, d4, e3), a4.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d4) {
          if (null === b2.stateNode) throw Error(p$1(166));
          S(b2);
          return null;
        }
        a4 = xh(uh.current);
        if (Gg(b2)) {
          d4 = b2.stateNode;
          c3 = b2.type;
          var f2 = b2.memoizedProps;
          d4[Of] = b2;
          d4[Pf] = f2;
          a4 = 0 !== (b2.mode & 1);
          switch (c3) {
            case "dialog":
              D("cancel", d4);
              D("close", d4);
              break;
            case "iframe":
            case "object":
            case "embed":
              D("load", d4);
              break;
            case "video":
            case "audio":
              for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], d4);
              break;
            case "source":
              D("error", d4);
              break;
            case "img":
            case "image":
            case "link":
              D(
                "error",
                d4
              );
              D("load", d4);
              break;
            case "details":
              D("toggle", d4);
              break;
            case "input":
              Za(d4, f2);
              D("invalid", d4);
              break;
            case "select":
              d4._wrapperState = { wasMultiple: !!f2.multiple };
              D("invalid", d4);
              break;
            case "textarea":
              hb(d4, f2), D("invalid", d4);
          }
          ub(c3, f2);
          e3 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h4 = f2[g2];
            "children" === g2 ? "string" === typeof h4 ? d4.textContent !== h4 && (true !== f2.suppressHydrationWarning && Af(d4.textContent, h4, a4), e3 = ["children", h4]) : "number" === typeof h4 && d4.textContent !== "" + h4 && (true !== f2.suppressHydrationWarning && Af(
              d4.textContent,
              h4,
              a4
            ), e3 = ["children", "" + h4]) : ea.hasOwnProperty(g2) && null != h4 && "onScroll" === g2 && D("scroll", d4);
          }
          switch (c3) {
            case "input":
              Va(d4);
              db(d4, f2, true);
              break;
            case "textarea":
              Va(d4);
              jb(d4);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d4.onclick = Bf);
          }
          d4 = e3;
          b2.updateQueue = d4;
          null !== d4 && (b2.flags |= 4);
        } else {
          g2 = 9 === e3.nodeType ? e3 : e3.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a4 && (a4 = kb(c3));
          "http://www.w3.org/1999/xhtml" === a4 ? "script" === c3 ? (a4 = g2.createElement("div"), a4.innerHTML = "<script><\/script>", a4 = a4.removeChild(a4.firstChild)) : "string" === typeof d4.is ? a4 = g2.createElement(c3, { is: d4.is }) : (a4 = g2.createElement(c3), "select" === c3 && (g2 = a4, d4.multiple ? g2.multiple = true : d4.size && (g2.size = d4.size))) : a4 = g2.createElementNS(a4, c3);
          a4[Of] = b2;
          a4[Pf] = d4;
          zj(a4, b2, false, false);
          b2.stateNode = a4;
          a: {
            g2 = vb(c3, d4);
            switch (c3) {
              case "dialog":
                D("cancel", a4);
                D("close", a4);
                e3 = d4;
                break;
              case "iframe":
              case "object":
              case "embed":
                D("load", a4);
                e3 = d4;
                break;
              case "video":
              case "audio":
                for (e3 = 0; e3 < lf.length; e3++) D(lf[e3], a4);
                e3 = d4;
                break;
              case "source":
                D("error", a4);
                e3 = d4;
                break;
              case "img":
              case "image":
              case "link":
                D(
                  "error",
                  a4
                );
                D("load", a4);
                e3 = d4;
                break;
              case "details":
                D("toggle", a4);
                e3 = d4;
                break;
              case "input":
                Za(a4, d4);
                e3 = Ya(a4, d4);
                D("invalid", a4);
                break;
              case "option":
                e3 = d4;
                break;
              case "select":
                a4._wrapperState = { wasMultiple: !!d4.multiple };
                e3 = A$1({}, d4, { value: void 0 });
                D("invalid", a4);
                break;
              case "textarea":
                hb(a4, d4);
                e3 = gb(a4, d4);
                D("invalid", a4);
                break;
              default:
                e3 = d4;
            }
            ub(c3, e3);
            h4 = e3;
            for (f2 in h4) if (h4.hasOwnProperty(f2)) {
              var k3 = h4[f2];
              "style" === f2 ? sb(a4, k3) : "dangerouslySetInnerHTML" === f2 ? (k3 = k3 ? k3.__html : void 0, null != k3 && nb(a4, k3)) : "children" === f2 ? "string" === typeof k3 ? ("textarea" !== c3 || "" !== k3) && ob(a4, k3) : "number" === typeof k3 && ob(a4, "" + k3) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k3 && "onScroll" === f2 && D("scroll", a4) : null != k3 && ta(a4, f2, k3, g2));
            }
            switch (c3) {
              case "input":
                Va(a4);
                db(a4, d4, false);
                break;
              case "textarea":
                Va(a4);
                jb(a4);
                break;
              case "option":
                null != d4.value && a4.setAttribute("value", "" + Sa(d4.value));
                break;
              case "select":
                a4.multiple = !!d4.multiple;
                f2 = d4.value;
                null != f2 ? fb(a4, !!d4.multiple, f2, false) : null != d4.defaultValue && fb(
                  a4,
                  !!d4.multiple,
                  d4.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e3.onClick && (a4.onclick = Bf);
            }
            switch (c3) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d4 = !!d4.autoFocus;
                break a;
              case "img":
                d4 = true;
                break a;
              default:
                d4 = false;
            }
          }
          d4 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S(b2);
      return null;
    case 6:
      if (a4 && null != b2.stateNode) Cj(a4, b2, a4.memoizedProps, d4);
      else {
        if ("string" !== typeof d4 && null === b2.stateNode) throw Error(p$1(166));
        c3 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d4 = b2.stateNode;
          c3 = b2.memoizedProps;
          d4[Of] = b2;
          if (f2 = d4.nodeValue !== c3) {
            if (a4 = xg, null !== a4) switch (a4.tag) {
              case 3:
                Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
                break;
              case 5:
                true !== a4.memoizedProps.suppressHydrationWarning && Af(d4.nodeValue, c3, 0 !== (a4.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d4 = (9 === c3.nodeType ? c3 : c3.ownerDocument).createTextNode(d4), d4[Of] = b2, b2.stateNode = d4;
      }
      S(b2);
      return null;
    case 13:
      E(L);
      d4 = b2.memoizedState;
      if (null === a4 || null !== a4.memoizedState && null !== a4.memoizedState.dehydrated) {
        if (I && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d4 && null !== d4.dehydrated) {
          if (null === a4) {
            if (!f2) throw Error(p$1(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$1(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c3, b2;
      d4 = null !== d4;
      d4 !== (null !== a4 && null !== a4.memoizedState) && d4 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a4 || 0 !== (L.current & 1) ? 0 === T && (T = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S(b2);
      return null;
    case 4:
      return zh(), Aj(a4, b2), null === a4 && sf(b2.stateNode.containerInfo), S(b2), null;
    case 10:
      return ah(b2.type._context), S(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S(b2), null;
    case 19:
      E(L);
      f2 = b2.memoizedState;
      if (null === f2) return S(b2), null;
      d4 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d4) Dj(f2, false);
      else {
        if (0 !== T || null !== a4 && 0 !== (a4.flags & 128)) for (a4 = b2.child; null !== a4; ) {
          g2 = Ch(a4);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d4 = g2.updateQueue;
            null !== d4 && (b2.updateQueue = d4, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d4 = c3;
            for (c3 = b2.child; null !== c3; ) f2 = c3, a4 = d4, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a4, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a4 = g2.dependencies, f2.dependencies = null === a4 ? null : { lanes: a4.lanes, firstContext: a4.firstContext }), c3 = c3.sibling;
            G(L, L.current & 1 | 2);
            return b2.child;
          }
          a4 = a4.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d4 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d4) if (a4 = Ch(g2), null !== a4) {
          if (b2.flags |= 128, d4 = true, c3 = a4.updateQueue, null !== c3 && (b2.updateQueue = c3, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I) return S(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c3 && (b2.flags |= 128, d4 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c3 = f2.last, null !== c3 ? c3.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c3 = L.current, G(L, d4 ? c3 & 1 | 2 : c3 & 1), b2;
      S(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d4 = null !== b2.memoizedState, null !== a4 && null !== a4.memoizedState !== d4 && (b2.flags |= 8192), d4 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$1(156, b2.tag));
}
function Ij(a4, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a4 = b2.flags, a4 & 65536 ? (b2.flags = a4 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E(Wf), E(H), Eh(), a4 = b2.flags, 0 !== (a4 & 65536) && 0 === (a4 & 128) ? (b2.flags = a4 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E(L);
      a4 = b2.memoizedState;
      if (null !== a4 && null !== a4.dehydrated) {
        if (null === b2.alternate) throw Error(p$1(340));
        Ig();
      }
      a4 = b2.flags;
      return a4 & 65536 ? (b2.flags = a4 & -65537 | 128, b2) : null;
    case 19:
      return E(L), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$1 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Lj(a4, b2) {
  var c3 = a4.ref;
  if (null !== c3) if ("function" === typeof c3) try {
    c3(null);
  } catch (d4) {
    W$1(a4, b2, d4);
  }
  else c3.current = null;
}
function Mj(a4, b2, c3) {
  try {
    c3();
  } catch (d4) {
    W$1(a4, b2, d4);
  }
}
var Nj = false;
function Oj(a4, b2) {
  Cf = dd;
  a4 = Me();
  if (Ne(a4)) {
    if ("selectionStart" in a4) var c3 = { start: a4.selectionStart, end: a4.selectionEnd };
    else a: {
      c3 = (c3 = a4.ownerDocument) && c3.defaultView || window;
      var d4 = c3.getSelection && c3.getSelection();
      if (d4 && 0 !== d4.rangeCount) {
        c3 = d4.anchorNode;
        var e3 = d4.anchorOffset, f2 = d4.focusNode;
        d4 = d4.focusOffset;
        try {
          c3.nodeType, f2.nodeType;
        } catch (F2) {
          c3 = null;
          break a;
        }
        var g2 = 0, h4 = -1, k3 = -1, l2 = 0, m4 = 0, q3 = a4, r2 = null;
        b: for (; ; ) {
          for (var y4; ; ) {
            q3 !== c3 || 0 !== e3 && 3 !== q3.nodeType || (h4 = g2 + e3);
            q3 !== f2 || 0 !== d4 && 3 !== q3.nodeType || (k3 = g2 + d4);
            3 === q3.nodeType && (g2 += q3.nodeValue.length);
            if (null === (y4 = q3.firstChild)) break;
            r2 = q3;
            q3 = y4;
          }
          for (; ; ) {
            if (q3 === a4) break b;
            r2 === c3 && ++l2 === e3 && (h4 = g2);
            r2 === f2 && ++m4 === d4 && (k3 = g2);
            if (null !== (y4 = q3.nextSibling)) break;
            q3 = r2;
            r2 = q3.parentNode;
          }
          q3 = y4;
        }
        c3 = -1 === h4 || -1 === k3 ? null : { start: h4, end: k3 };
      } else c3 = null;
    }
    c3 = c3 || { start: 0, end: 0 };
  } else c3 = null;
  Df = { focusedElem: a4, selectionRange: c3 };
  dd = false;
  for (V$1 = b2; null !== V$1; ) if (b2 = V$1, a4 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a4) a4.return = b2, V$1 = a4;
  else for (; null !== V$1; ) {
    b2 = V$1;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t3 = n2.memoizedProps, J2 = n2.memoizedState, x3 = b2.stateNode, w3 = x3.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t3 : Ci(b2.type, t3), J2);
            x3.__reactInternalSnapshotBeforeUpdate = w3;
          }
          break;
        case 3:
          var u3 = b2.stateNode.containerInfo;
          1 === u3.nodeType ? u3.textContent = "" : 9 === u3.nodeType && u3.documentElement && u3.removeChild(u3.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$1(163));
      }
    } catch (F2) {
      W$1(b2, b2.return, F2);
    }
    a4 = b2.sibling;
    if (null !== a4) {
      a4.return = b2.return;
      V$1 = a4;
      break;
    }
    V$1 = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a4, b2, c3) {
  var d4 = b2.updateQueue;
  d4 = null !== d4 ? d4.lastEffect : null;
  if (null !== d4) {
    var e3 = d4 = d4.next;
    do {
      if ((e3.tag & a4) === a4) {
        var f2 = e3.destroy;
        e3.destroy = void 0;
        void 0 !== f2 && Mj(b2, c3, f2);
      }
      e3 = e3.next;
    } while (e3 !== d4);
  }
}
function Qj(a4, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c3 = b2 = b2.next;
    do {
      if ((c3.tag & a4) === a4) {
        var d4 = c3.create;
        c3.destroy = d4();
      }
      c3 = c3.next;
    } while (c3 !== b2);
  }
}
function Rj(a4) {
  var b2 = a4.ref;
  if (null !== b2) {
    var c3 = a4.stateNode;
    switch (a4.tag) {
      case 5:
        a4 = c3;
        break;
      default:
        a4 = c3;
    }
    "function" === typeof b2 ? b2(a4) : b2.current = a4;
  }
}
function Sj(a4) {
  var b2 = a4.alternate;
  null !== b2 && (a4.alternate = null, Sj(b2));
  a4.child = null;
  a4.deletions = null;
  a4.sibling = null;
  5 === a4.tag && (b2 = a4.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a4.stateNode = null;
  a4.return = null;
  a4.dependencies = null;
  a4.memoizedProps = null;
  a4.memoizedState = null;
  a4.pendingProps = null;
  a4.stateNode = null;
  a4.updateQueue = null;
}
function Tj(a4) {
  return 5 === a4.tag || 3 === a4.tag || 4 === a4.tag;
}
function Uj(a4) {
  a: for (; ; ) {
    for (; null === a4.sibling; ) {
      if (null === a4.return || Tj(a4.return)) return null;
      a4 = a4.return;
    }
    a4.sibling.return = a4.return;
    for (a4 = a4.sibling; 5 !== a4.tag && 6 !== a4.tag && 18 !== a4.tag; ) {
      if (a4.flags & 2) continue a;
      if (null === a4.child || 4 === a4.tag) continue a;
      else a4.child.return = a4, a4 = a4.child;
    }
    if (!(a4.flags & 2)) return a4.stateNode;
  }
}
function Vj(a4, b2, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4) a4 = a4.stateNode, b2 ? 8 === c3.nodeType ? c3.parentNode.insertBefore(a4, b2) : c3.insertBefore(a4, b2) : (8 === c3.nodeType ? (b2 = c3.parentNode, b2.insertBefore(a4, c3)) : (b2 = c3, b2.appendChild(a4)), c3 = c3._reactRootContainer, null !== c3 && void 0 !== c3 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d4 && (a4 = a4.child, null !== a4)) for (Vj(a4, b2, c3), a4 = a4.sibling; null !== a4; ) Vj(a4, b2, c3), a4 = a4.sibling;
}
function Wj(a4, b2, c3) {
  var d4 = a4.tag;
  if (5 === d4 || 6 === d4) a4 = a4.stateNode, b2 ? c3.insertBefore(a4, b2) : c3.appendChild(a4);
  else if (4 !== d4 && (a4 = a4.child, null !== a4)) for (Wj(a4, b2, c3), a4 = a4.sibling; null !== a4; ) Wj(a4, b2, c3), a4 = a4.sibling;
}
var X$1 = null, Xj = false;
function Yj(a4, b2, c3) {
  for (c3 = c3.child; null !== c3; ) Zj(a4, b2, c3), c3 = c3.sibling;
}
function Zj(a4, b2, c3) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c3);
  } catch (h4) {
  }
  switch (c3.tag) {
    case 5:
      U$1 || Lj(c3, b2);
    case 6:
      var d4 = X$1, e3 = Xj;
      X$1 = null;
      Yj(a4, b2, c3);
      X$1 = d4;
      Xj = e3;
      null !== X$1 && (Xj ? (a4 = X$1, c3 = c3.stateNode, 8 === a4.nodeType ? a4.parentNode.removeChild(c3) : a4.removeChild(c3)) : X$1.removeChild(c3.stateNode));
      break;
    case 18:
      null !== X$1 && (Xj ? (a4 = X$1, c3 = c3.stateNode, 8 === a4.nodeType ? Kf(a4.parentNode, c3) : 1 === a4.nodeType && Kf(a4, c3), bd(a4)) : Kf(X$1, c3.stateNode));
      break;
    case 4:
      d4 = X$1;
      e3 = Xj;
      X$1 = c3.stateNode.containerInfo;
      Xj = true;
      Yj(a4, b2, c3);
      X$1 = d4;
      Xj = e3;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d4 = c3.updateQueue, null !== d4 && (d4 = d4.lastEffect, null !== d4))) {
        e3 = d4 = d4.next;
        do {
          var f2 = e3, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c3, b2, g2) : 0 !== (f2 & 4) && Mj(c3, b2, g2));
          e3 = e3.next;
        } while (e3 !== d4);
      }
      Yj(a4, b2, c3);
      break;
    case 1:
      if (!U$1 && (Lj(c3, b2), d4 = c3.stateNode, "function" === typeof d4.componentWillUnmount)) try {
        d4.props = c3.memoizedProps, d4.state = c3.memoizedState, d4.componentWillUnmount();
      } catch (h4) {
        W$1(c3, b2, h4);
      }
      Yj(a4, b2, c3);
      break;
    case 21:
      Yj(a4, b2, c3);
      break;
    case 22:
      c3.mode & 1 ? (U$1 = (d4 = U$1) || null !== c3.memoizedState, Yj(a4, b2, c3), U$1 = d4) : Yj(a4, b2, c3);
      break;
    default:
      Yj(a4, b2, c3);
  }
}
function ak(a4) {
  var b2 = a4.updateQueue;
  if (null !== b2) {
    a4.updateQueue = null;
    var c3 = a4.stateNode;
    null === c3 && (c3 = a4.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d4 = bk.bind(null, a4, b3);
      c3.has(b3) || (c3.add(b3), b3.then(d4, d4));
    });
  }
}
function ck(a4, b2) {
  var c3 = b2.deletions;
  if (null !== c3) for (var d4 = 0; d4 < c3.length; d4++) {
    var e3 = c3[d4];
    try {
      var f2 = a4, g2 = b2, h4 = g2;
      a: for (; null !== h4; ) {
        switch (h4.tag) {
          case 5:
            X$1 = h4.stateNode;
            Xj = false;
            break a;
          case 3:
            X$1 = h4.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$1 = h4.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h4 = h4.return;
      }
      if (null === X$1) throw Error(p$1(160));
      Zj(f2, g2, e3);
      X$1 = null;
      Xj = false;
      var k3 = e3.alternate;
      null !== k3 && (k3.return = null);
      e3.return = null;
    } catch (l2) {
      W$1(e3, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a4), b2 = b2.sibling;
}
function dk(a4, b2) {
  var c3 = a4.alternate, d4 = a4.flags;
  switch (a4.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a4);
      ek(a4);
      if (d4 & 4) {
        try {
          Pj(3, a4, a4.return), Qj(3, a4);
        } catch (t3) {
          W$1(a4, a4.return, t3);
        }
        try {
          Pj(5, a4, a4.return);
        } catch (t3) {
          W$1(a4, a4.return, t3);
        }
      }
      break;
    case 1:
      ck(b2, a4);
      ek(a4);
      d4 & 512 && null !== c3 && Lj(c3, c3.return);
      break;
    case 5:
      ck(b2, a4);
      ek(a4);
      d4 & 512 && null !== c3 && Lj(c3, c3.return);
      if (a4.flags & 32) {
        var e3 = a4.stateNode;
        try {
          ob(e3, "");
        } catch (t3) {
          W$1(a4, a4.return, t3);
        }
      }
      if (d4 & 4 && (e3 = a4.stateNode, null != e3)) {
        var f2 = a4.memoizedProps, g2 = null !== c3 ? c3.memoizedProps : f2, h4 = a4.type, k3 = a4.updateQueue;
        a4.updateQueue = null;
        if (null !== k3) try {
          "input" === h4 && "radio" === f2.type && null != f2.name && ab(e3, f2);
          vb(h4, g2);
          var l2 = vb(h4, f2);
          for (g2 = 0; g2 < k3.length; g2 += 2) {
            var m4 = k3[g2], q3 = k3[g2 + 1];
            "style" === m4 ? sb(e3, q3) : "dangerouslySetInnerHTML" === m4 ? nb(e3, q3) : "children" === m4 ? ob(e3, q3) : ta(e3, m4, q3, l2);
          }
          switch (h4) {
            case "input":
              bb(e3, f2);
              break;
            case "textarea":
              ib(e3, f2);
              break;
            case "select":
              var r2 = e3._wrapperState.wasMultiple;
              e3._wrapperState.wasMultiple = !!f2.multiple;
              var y4 = f2.value;
              null != y4 ? fb(e3, !!f2.multiple, y4, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e3,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e3, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e3[Pf] = f2;
        } catch (t3) {
          W$1(a4, a4.return, t3);
        }
      }
      break;
    case 6:
      ck(b2, a4);
      ek(a4);
      if (d4 & 4) {
        if (null === a4.stateNode) throw Error(p$1(162));
        e3 = a4.stateNode;
        f2 = a4.memoizedProps;
        try {
          e3.nodeValue = f2;
        } catch (t3) {
          W$1(a4, a4.return, t3);
        }
      }
      break;
    case 3:
      ck(b2, a4);
      ek(a4);
      if (d4 & 4 && null !== c3 && c3.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t3) {
        W$1(a4, a4.return, t3);
      }
      break;
    case 4:
      ck(b2, a4);
      ek(a4);
      break;
    case 13:
      ck(b2, a4);
      ek(a4);
      e3 = a4.child;
      e3.flags & 8192 && (f2 = null !== e3.memoizedState, e3.stateNode.isHidden = f2, !f2 || null !== e3.alternate && null !== e3.alternate.memoizedState || (fk = B()));
      d4 & 4 && ak(a4);
      break;
    case 22:
      m4 = null !== c3 && null !== c3.memoizedState;
      a4.mode & 1 ? (U$1 = (l2 = U$1) || m4, ck(b2, a4), U$1 = l2) : ck(b2, a4);
      ek(a4);
      if (d4 & 8192) {
        l2 = null !== a4.memoizedState;
        if ((a4.stateNode.isHidden = l2) && !m4 && 0 !== (a4.mode & 1)) for (V$1 = a4, m4 = a4.child; null !== m4; ) {
          for (q3 = V$1 = m4; null !== V$1; ) {
            r2 = V$1;
            y4 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d4 = r2;
                  c3 = r2.return;
                  try {
                    b2 = d4, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t3) {
                    W$1(d4, c3, t3);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q3);
                  continue;
                }
            }
            null !== y4 ? (y4.return = r2, V$1 = y4) : gk(q3);
          }
          m4 = m4.sibling;
        }
        a: for (m4 = null, q3 = a4; ; ) {
          if (5 === q3.tag) {
            if (null === m4) {
              m4 = q3;
              try {
                e3 = q3.stateNode, l2 ? (f2 = e3.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h4 = q3.stateNode, k3 = q3.memoizedProps.style, g2 = void 0 !== k3 && null !== k3 && k3.hasOwnProperty("display") ? k3.display : null, h4.style.display = rb("display", g2));
              } catch (t3) {
                W$1(a4, a4.return, t3);
              }
            }
          } else if (6 === q3.tag) {
            if (null === m4) try {
              q3.stateNode.nodeValue = l2 ? "" : q3.memoizedProps;
            } catch (t3) {
              W$1(a4, a4.return, t3);
            }
          } else if ((22 !== q3.tag && 23 !== q3.tag || null === q3.memoizedState || q3 === a4) && null !== q3.child) {
            q3.child.return = q3;
            q3 = q3.child;
            continue;
          }
          if (q3 === a4) break a;
          for (; null === q3.sibling; ) {
            if (null === q3.return || q3.return === a4) break a;
            m4 === q3 && (m4 = null);
            q3 = q3.return;
          }
          m4 === q3 && (m4 = null);
          q3.sibling.return = q3.return;
          q3 = q3.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a4);
      ek(a4);
      d4 & 4 && ak(a4);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a4
      ), ek(a4);
  }
}
function ek(a4) {
  var b2 = a4.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c3 = a4.return; null !== c3; ) {
          if (Tj(c3)) {
            var d4 = c3;
            break a;
          }
          c3 = c3.return;
        }
        throw Error(p$1(160));
      }
      switch (d4.tag) {
        case 5:
          var e3 = d4.stateNode;
          d4.flags & 32 && (ob(e3, ""), d4.flags &= -33);
          var f2 = Uj(a4);
          Wj(a4, f2, e3);
          break;
        case 3:
        case 4:
          var g2 = d4.stateNode.containerInfo, h4 = Uj(a4);
          Vj(a4, h4, g2);
          break;
        default:
          throw Error(p$1(161));
      }
    } catch (k3) {
      W$1(a4, a4.return, k3);
    }
    a4.flags &= -3;
  }
  b2 & 4096 && (a4.flags &= -4097);
}
function hk(a4, b2, c3) {
  V$1 = a4;
  ik(a4);
}
function ik(a4, b2, c3) {
  for (var d4 = 0 !== (a4.mode & 1); null !== V$1; ) {
    var e3 = V$1, f2 = e3.child;
    if (22 === e3.tag && d4) {
      var g2 = null !== e3.memoizedState || Jj;
      if (!g2) {
        var h4 = e3.alternate, k3 = null !== h4 && null !== h4.memoizedState || U$1;
        h4 = Jj;
        var l2 = U$1;
        Jj = g2;
        if ((U$1 = k3) && !l2) for (V$1 = e3; null !== V$1; ) g2 = V$1, k3 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e3) : null !== k3 ? (k3.return = g2, V$1 = k3) : jk(e3);
        for (; null !== f2; ) V$1 = f2, ik(f2), f2 = f2.sibling;
        V$1 = e3;
        Jj = h4;
        U$1 = l2;
      }
      kk(a4);
    } else 0 !== (e3.subtreeFlags & 8772) && null !== f2 ? (f2.return = e3, V$1 = f2) : kk(a4);
  }
}
function kk(a4) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c3 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U$1 || Qj(5, b2);
            break;
          case 1:
            var d4 = b2.stateNode;
            if (b2.flags & 4 && !U$1) if (null === c3) d4.componentDidMount();
            else {
              var e3 = b2.elementType === b2.type ? c3.memoizedProps : Ci(b2.type, c3.memoizedProps);
              d4.componentDidUpdate(e3, c3.memoizedState, d4.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d4);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c3 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c3 = b2.child.stateNode;
                  break;
                case 1:
                  c3 = b2.child.stateNode;
              }
              sh(b2, g2, c3);
            }
            break;
          case 5:
            var h4 = b2.stateNode;
            if (null === c3 && b2.flags & 4) {
              c3 = h4;
              var k3 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k3.autoFocus && c3.focus();
                  break;
                case "img":
                  k3.src && (c3.src = k3.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m4 = l2.memoizedState;
                if (null !== m4) {
                  var q3 = m4.dehydrated;
                  null !== q3 && bd(q3);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$1(163));
        }
        U$1 || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W$1(b2, b2.return, r2);
      }
    }
    if (b2 === a4) {
      V$1 = null;
      break;
    }
    c3 = b2.sibling;
    if (null !== c3) {
      c3.return = b2.return;
      V$1 = c3;
      break;
    }
    V$1 = b2.return;
  }
}
function gk(a4) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a4) {
      V$1 = null;
      break;
    }
    var c3 = b2.sibling;
    if (null !== c3) {
      c3.return = b2.return;
      V$1 = c3;
      break;
    }
    V$1 = b2.return;
  }
}
function jk(a4) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c3 = b2.return;
          try {
            Qj(4, b2);
          } catch (k3) {
            W$1(b2, c3, k3);
          }
          break;
        case 1:
          var d4 = b2.stateNode;
          if ("function" === typeof d4.componentDidMount) {
            var e3 = b2.return;
            try {
              d4.componentDidMount();
            } catch (k3) {
              W$1(b2, e3, k3);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k3) {
            W$1(b2, f2, k3);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k3) {
            W$1(b2, g2, k3);
          }
      }
    } catch (k3) {
      W$1(b2, b2.return, k3);
    }
    if (b2 === a4) {
      V$1 = null;
      break;
    }
    var h4 = b2.sibling;
    if (null !== h4) {
      h4.return = b2.return;
      V$1 = h4;
      break;
    }
    V$1 = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y$1 = null, Z = 0, fj = 0, ej = Uf(0), T = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a4) {
  if (0 === (a4.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a4 = C;
  if (0 !== a4) return a4;
  a4 = window.event;
  a4 = void 0 === a4 ? 16 : jd(a4.type);
  return a4;
}
function gi(a4, b2, c3, d4) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$1(185));
  Ac(a4, c3, d4);
  if (0 === (K & 2) || a4 !== Q) a4 === Q && (0 === (K & 2) && (qk |= c3), 4 === T && Ck(a4, Z)), Dk(a4, d4), 1 === c3 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a4, b2) {
  var c3 = a4.callbackNode;
  wc(a4, b2);
  var d4 = uc(a4, a4 === Q ? Z : 0);
  if (0 === d4) null !== c3 && bc(c3), a4.callbackNode = null, a4.callbackPriority = 0;
  else if (b2 = d4 & -d4, a4.callbackPriority !== b2) {
    null != c3 && bc(c3);
    if (1 === b2) 0 === a4.tag ? ig(Ek.bind(null, a4)) : hg(Ek.bind(null, a4)), Jf(function() {
      0 === (K & 6) && jg();
    }), c3 = null;
    else {
      switch (Dc(d4)) {
        case 1:
          c3 = fc;
          break;
        case 4:
          c3 = gc;
          break;
        case 16:
          c3 = hc;
          break;
        case 536870912:
          c3 = jc;
          break;
        default:
          c3 = hc;
      }
      c3 = Fk(c3, Gk.bind(null, a4));
    }
    a4.callbackPriority = b2;
    a4.callbackNode = c3;
  }
}
function Gk(a4, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$1(327));
  var c3 = a4.callbackNode;
  if (Hk() && a4.callbackNode !== c3) return null;
  var d4 = uc(a4, a4 === Q ? Z : 0);
  if (0 === d4) return null;
  if (0 !== (d4 & 30) || 0 !== (d4 & a4.expiredLanes) || b2) b2 = Ik(a4, d4);
  else {
    b2 = d4;
    var e3 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a4 || Z !== b2) uk = null, Gj = B() + 500, Kk(a4, b2);
    do
      try {
        Lk();
        break;
      } catch (h4) {
        Mk(a4, h4);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e3;
    null !== Y$1 ? b2 = 0 : (Q = null, Z = 0, b2 = T);
  }
  if (0 !== b2) {
    2 === b2 && (e3 = xc(a4), 0 !== e3 && (d4 = e3, b2 = Nk(a4, e3)));
    if (1 === b2) throw c3 = pk, Kk(a4, 0), Ck(a4, d4), Dk(a4, B()), c3;
    if (6 === b2) Ck(a4, d4);
    else {
      e3 = a4.current.alternate;
      if (0 === (d4 & 30) && !Ok(e3) && (b2 = Ik(a4, d4), 2 === b2 && (f2 = xc(a4), 0 !== f2 && (d4 = f2, b2 = Nk(a4, f2))), 1 === b2)) throw c3 = pk, Kk(a4, 0), Ck(a4, d4), Dk(a4, B()), c3;
      a4.finishedWork = e3;
      a4.finishedLanes = d4;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$1(345));
        case 2:
          Pk(a4, tk, uk);
          break;
        case 3:
          Ck(a4, d4);
          if ((d4 & 130023424) === d4 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a4, 0)) break;
            e3 = a4.suspendedLanes;
            if ((e3 & d4) !== d4) {
              R();
              a4.pingedLanes |= a4.suspendedLanes & e3;
              break;
            }
            a4.timeoutHandle = Ff(Pk.bind(null, a4, tk, uk), b2);
            break;
          }
          Pk(a4, tk, uk);
          break;
        case 4:
          Ck(a4, d4);
          if ((d4 & 4194240) === d4) break;
          b2 = a4.eventTimes;
          for (e3 = -1; 0 < d4; ) {
            var g2 = 31 - oc(d4);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e3 && (e3 = g2);
            d4 &= ~f2;
          }
          d4 = e3;
          d4 = B() - d4;
          d4 = (120 > d4 ? 120 : 480 > d4 ? 480 : 1080 > d4 ? 1080 : 1920 > d4 ? 1920 : 3e3 > d4 ? 3e3 : 4320 > d4 ? 4320 : 1960 * lk(d4 / 1960)) - d4;
          if (10 < d4) {
            a4.timeoutHandle = Ff(Pk.bind(null, a4, tk, uk), d4);
            break;
          }
          Pk(a4, tk, uk);
          break;
        case 5:
          Pk(a4, tk, uk);
          break;
        default:
          throw Error(p$1(329));
      }
    }
  }
  Dk(a4, B());
  return a4.callbackNode === c3 ? Gk.bind(null, a4) : null;
}
function Nk(a4, b2) {
  var c3 = sk;
  a4.current.memoizedState.isDehydrated && (Kk(a4, b2).flags |= 256);
  a4 = Ik(a4, b2);
  2 !== a4 && (b2 = tk, tk = c3, null !== b2 && Fj(b2));
  return a4;
}
function Fj(a4) {
  null === tk ? tk = a4 : tk.push.apply(tk, a4);
}
function Ok(a4) {
  for (var b2 = a4; ; ) {
    if (b2.flags & 16384) {
      var c3 = b2.updateQueue;
      if (null !== c3 && (c3 = c3.stores, null !== c3)) for (var d4 = 0; d4 < c3.length; d4++) {
        var e3 = c3[d4], f2 = e3.getSnapshot;
        e3 = e3.value;
        try {
          if (!He(f2(), e3)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c3 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c3) c3.return = b2, b2 = c3;
    else {
      if (b2 === a4) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a4) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a4, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a4.suspendedLanes |= b2;
  a4.pingedLanes &= ~b2;
  for (a4 = a4.expirationTimes; 0 < b2; ) {
    var c3 = 31 - oc(b2), d4 = 1 << c3;
    a4[c3] = -1;
    b2 &= ~d4;
  }
}
function Ek(a4) {
  if (0 !== (K & 6)) throw Error(p$1(327));
  Hk();
  var b2 = uc(a4, 0);
  if (0 === (b2 & 1)) return Dk(a4, B()), null;
  var c3 = Ik(a4, b2);
  if (0 !== a4.tag && 2 === c3) {
    var d4 = xc(a4);
    0 !== d4 && (b2 = d4, c3 = Nk(a4, d4));
  }
  if (1 === c3) throw c3 = pk, Kk(a4, 0), Ck(a4, b2), Dk(a4, B()), c3;
  if (6 === c3) throw Error(p$1(345));
  a4.finishedWork = a4.current.alternate;
  a4.finishedLanes = b2;
  Pk(a4, tk, uk);
  Dk(a4, B());
  return null;
}
function Qk(a4, b2) {
  var c3 = K;
  K |= 1;
  try {
    return a4(b2);
  } finally {
    K = c3, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a4) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c3 = ok.transition, d4 = C;
  try {
    if (ok.transition = null, C = 1, a4) return a4();
  } finally {
    C = d4, ok.transition = c3, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E(ej);
}
function Kk(a4, b2) {
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  var c3 = a4.timeoutHandle;
  -1 !== c3 && (a4.timeoutHandle = -1, Gf(c3));
  if (null !== Y$1) for (c3 = Y$1.return; null !== c3; ) {
    var d4 = c3;
    wg(d4);
    switch (d4.tag) {
      case 1:
        d4 = d4.type.childContextTypes;
        null !== d4 && void 0 !== d4 && $f();
        break;
      case 3:
        zh();
        E(Wf);
        E(H);
        Eh();
        break;
      case 5:
        Bh(d4);
        break;
      case 4:
        zh();
        break;
      case 13:
        E(L);
        break;
      case 19:
        E(L);
        break;
      case 10:
        ah(d4.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c3 = c3.return;
  }
  Q = a4;
  Y$1 = a4 = Pg(a4.current, null);
  Z = fj = b2;
  T = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c3 = fh[b2], d4 = c3.interleaved, null !== d4) {
      c3.interleaved = null;
      var e3 = d4.next, f2 = c3.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e3;
        d4.next = g2;
      }
      c3.pending = d4;
    }
    fh = null;
  }
  return a4;
}
function Mk(a4, b2) {
  do {
    var c3 = Y$1;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d4 = M$2.memoizedState; null !== d4; ) {
          var e3 = d4.queue;
          null !== e3 && (e3.pending = null);
          d4 = d4.next;
        }
        Ih = false;
      }
      Hh = 0;
      O = N = M$2 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c3 || null === c3.return) {
        T = 1;
        pk = b2;
        Y$1 = null;
        break;
      }
      a: {
        var f2 = a4, g2 = c3.return, h4 = c3, k3 = b2;
        b2 = Z;
        h4.flags |= 32768;
        if (null !== k3 && "object" === typeof k3 && "function" === typeof k3.then) {
          var l2 = k3, m4 = h4, q3 = m4.tag;
          if (0 === (m4.mode & 1) && (0 === q3 || 11 === q3 || 15 === q3)) {
            var r2 = m4.alternate;
            r2 ? (m4.updateQueue = r2.updateQueue, m4.memoizedState = r2.memoizedState, m4.lanes = r2.lanes) : (m4.updateQueue = null, m4.memoizedState = null);
          }
          var y4 = Ui(g2);
          if (null !== y4) {
            y4.flags &= -257;
            Vi(y4, g2, h4, f2, b2);
            y4.mode & 1 && Si(f2, l2, b2);
            b2 = y4;
            k3 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t3 = /* @__PURE__ */ new Set();
              t3.add(k3);
              b2.updateQueue = t3;
            } else n2.add(k3);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k3 = Error(p$1(426));
          }
        } else if (I && h4.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h4, f2, b2);
            Jg(Ji(k3, h4));
            break a;
          }
        }
        f2 = k3 = Ji(k3, h4);
        4 !== T && (T = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x3 = Ni(f2, k3, b2);
              ph(f2, x3);
              break a;
            case 1:
              h4 = k3;
              var w3 = f2.type, u3 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w3.getDerivedStateFromError || null !== u3 && "function" === typeof u3.componentDidCatch && (null === Ri || !Ri.has(u3)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h4, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c3);
    } catch (na) {
      b2 = na;
      Y$1 === c3 && null !== c3 && (Y$1 = c3 = c3.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a4 = mk.current;
  mk.current = Rh;
  return null === a4 ? Rh : a4;
}
function tj() {
  if (0 === T || 3 === T || 2 === T) T = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a4, b2) {
  var c3 = K;
  K |= 2;
  var d4 = Jk();
  if (Q !== a4 || Z !== b2) uk = null, Kk(a4, b2);
  do
    try {
      Tk();
      break;
    } catch (e3) {
      Mk(a4, e3);
    }
  while (1);
  $g();
  K = c3;
  mk.current = d4;
  if (null !== Y$1) throw Error(p$1(261));
  Q = null;
  Z = 0;
  return T;
}
function Tk() {
  for (; null !== Y$1; ) Uk(Y$1);
}
function Lk() {
  for (; null !== Y$1 && !cc(); ) Uk(Y$1);
}
function Uk(a4) {
  var b2 = Vk(a4.alternate, a4, fj);
  a4.memoizedProps = a4.pendingProps;
  null === b2 ? Sk(a4) : Y$1 = b2;
  nk.current = null;
}
function Sk(a4) {
  var b2 = a4;
  do {
    var c3 = b2.alternate;
    a4 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c3 = Ej(c3, b2, fj), null !== c3) {
        Y$1 = c3;
        return;
      }
    } else {
      c3 = Ij(c3, b2);
      if (null !== c3) {
        c3.flags &= 32767;
        Y$1 = c3;
        return;
      }
      if (null !== a4) a4.flags |= 32768, a4.subtreeFlags = 0, a4.deletions = null;
      else {
        T = 6;
        Y$1 = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y$1 = b2;
      return;
    }
    Y$1 = b2 = a4;
  } while (null !== b2);
  0 === T && (T = 5);
}
function Pk(a4, b2, c3) {
  var d4 = C, e3 = ok.transition;
  try {
    ok.transition = null, C = 1, Wk(a4, b2, c3, d4);
  } finally {
    ok.transition = e3, C = d4;
  }
  return null;
}
function Wk(a4, b2, c3, d4) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$1(327));
  c3 = a4.finishedWork;
  var e3 = a4.finishedLanes;
  if (null === c3) return null;
  a4.finishedWork = null;
  a4.finishedLanes = 0;
  if (c3 === a4.current) throw Error(p$1(177));
  a4.callbackNode = null;
  a4.callbackPriority = 0;
  var f2 = c3.lanes | c3.childLanes;
  Bc(a4, f2);
  a4 === Q && (Y$1 = Q = null, Z = 0);
  0 === (c3.subtreeFlags & 2064) && 0 === (c3.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c3.flags & 15990);
  if (0 !== (c3.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C;
    C = 1;
    var h4 = K;
    K |= 4;
    nk.current = null;
    Oj(a4, c3);
    dk(c3, a4);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a4.current = c3;
    hk(c3);
    dc();
    K = h4;
    C = g2;
    ok.transition = f2;
  } else a4.current = c3;
  vk && (vk = false, wk = a4, xk = e3);
  f2 = a4.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c3.stateNode);
  Dk(a4, B());
  if (null !== b2) for (d4 = a4.onRecoverableError, c3 = 0; c3 < b2.length; c3++) e3 = b2[c3], d4(e3.value, { componentStack: e3.stack, digest: e3.digest });
  if (Oi) throw Oi = false, a4 = Pi, Pi = null, a4;
  0 !== (xk & 1) && 0 !== a4.tag && Hk();
  f2 = a4.pendingLanes;
  0 !== (f2 & 1) ? a4 === zk ? yk++ : (yk = 0, zk = a4) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a4 = Dc(xk), b2 = ok.transition, c3 = C;
    try {
      ok.transition = null;
      C = 16 > a4 ? 16 : a4;
      if (null === wk) var d4 = false;
      else {
        a4 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$1(331));
        var e3 = K;
        K |= 4;
        for (V$1 = a4.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h4 = f2.deletions;
            if (null !== h4) {
              for (var k3 = 0; k3 < h4.length; k3++) {
                var l2 = h4[k3];
                for (V$1 = l2; null !== V$1; ) {
                  var m4 = V$1;
                  switch (m4.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m4, f2);
                  }
                  var q3 = m4.child;
                  if (null !== q3) q3.return = m4, V$1 = q3;
                  else for (; null !== V$1; ) {
                    m4 = V$1;
                    var r2 = m4.sibling, y4 = m4.return;
                    Sj(m4);
                    if (m4 === l2) {
                      V$1 = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y4;
                      V$1 = r2;
                      break;
                    }
                    V$1 = y4;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t3 = n2.child;
                if (null !== t3) {
                  n2.child = null;
                  do {
                    var J2 = t3.sibling;
                    t3.sibling = null;
                    t3 = J2;
                  } while (null !== t3);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V$1 = g2;
          else b: for (; null !== V$1; ) {
            f2 = V$1;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x3 = f2.sibling;
            if (null !== x3) {
              x3.return = f2.return;
              V$1 = x3;
              break b;
            }
            V$1 = f2.return;
          }
        }
        var w3 = a4.current;
        for (V$1 = w3; null !== V$1; ) {
          g2 = V$1;
          var u3 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u3) u3.return = g2, V$1 = u3;
          else b: for (g2 = w3; null !== V$1; ) {
            h4 = V$1;
            if (0 !== (h4.flags & 2048)) try {
              switch (h4.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h4);
              }
            } catch (na) {
              W$1(h4, h4.return, na);
            }
            if (h4 === g2) {
              V$1 = null;
              break b;
            }
            var F2 = h4.sibling;
            if (null !== F2) {
              F2.return = h4.return;
              V$1 = F2;
              break b;
            }
            V$1 = h4.return;
          }
        }
        K = e3;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a4);
        } catch (na) {
        }
        d4 = true;
      }
      return d4;
    } finally {
      C = c3, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a4, b2, c3) {
  b2 = Ji(c3, b2);
  b2 = Ni(a4, b2, 1);
  a4 = nh(a4, b2, 1);
  b2 = R();
  null !== a4 && (Ac(a4, 1, b2), Dk(a4, b2));
}
function W$1(a4, b2, c3) {
  if (3 === a4.tag) Xk(a4, a4, c3);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a4, c3);
      break;
    } else if (1 === b2.tag) {
      var d4 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d4.componentDidCatch && (null === Ri || !Ri.has(d4))) {
        a4 = Ji(c3, a4);
        a4 = Qi(b2, a4, 1);
        b2 = nh(b2, a4, 1);
        a4 = R();
        null !== b2 && (Ac(b2, 1, a4), Dk(b2, a4));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a4, b2, c3) {
  var d4 = a4.pingCache;
  null !== d4 && d4.delete(b2);
  b2 = R();
  a4.pingedLanes |= a4.suspendedLanes & c3;
  Q === a4 && (Z & c3) === c3 && (4 === T || 3 === T && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a4, 0) : rk |= c3);
  Dk(a4, b2);
}
function Yk(a4, b2) {
  0 === b2 && (0 === (a4.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c3 = R();
  a4 = ih(a4, b2);
  null !== a4 && (Ac(a4, b2, c3), Dk(a4, c3));
}
function uj(a4) {
  var b2 = a4.memoizedState, c3 = 0;
  null !== b2 && (c3 = b2.retryLane);
  Yk(a4, c3);
}
function bk(a4, b2) {
  var c3 = 0;
  switch (a4.tag) {
    case 13:
      var d4 = a4.stateNode;
      var e3 = a4.memoizedState;
      null !== e3 && (c3 = e3.retryLane);
      break;
    case 19:
      d4 = a4.stateNode;
      break;
    default:
      throw Error(p$1(314));
  }
  null !== d4 && d4.delete(b2);
  Yk(a4, c3);
}
var Vk;
Vk = function(a4, b2, c3) {
  if (null !== a4) if (a4.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a4.lanes & c3) && 0 === (b2.flags & 128)) return dh = false, yj(a4, b2, c3);
    dh = 0 !== (a4.flags & 131072) ? true : false;
  }
  else dh = false, I && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d4 = b2.type;
      ij(a4, b2);
      a4 = b2.pendingProps;
      var e3 = Yf(b2, H.current);
      ch(b2, c3);
      e3 = Nh(null, b2, d4, a4, e3, c3);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e3 && null !== e3 && "function" === typeof e3.render && void 0 === e3.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d4) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e3.state && void 0 !== e3.state ? e3.state : null, kh(b2), e3.updater = Ei, b2.stateNode = e3, e3._reactInternals = b2, Ii(b2, d4, a4, c3), b2 = jj(null, b2, d4, true, f2, c3)) : (b2.tag = 0, I && f2 && vg(b2), Xi(null, b2, e3, c3), b2 = b2.child);
      return b2;
    case 16:
      d4 = b2.elementType;
      a: {
        ij(a4, b2);
        a4 = b2.pendingProps;
        e3 = d4._init;
        d4 = e3(d4._payload);
        b2.type = d4;
        e3 = b2.tag = Zk(d4);
        a4 = Ci(d4, a4);
        switch (e3) {
          case 0:
            b2 = cj(null, b2, d4, a4, c3);
            break a;
          case 1:
            b2 = hj(null, b2, d4, a4, c3);
            break a;
          case 11:
            b2 = Yi(null, b2, d4, a4, c3);
            break a;
          case 14:
            b2 = $i(null, b2, d4, Ci(d4.type, a4), c3);
            break a;
        }
        throw Error(p$1(
          306,
          d4,
          ""
        ));
      }
      return b2;
    case 0:
      return d4 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d4 ? e3 : Ci(d4, e3), cj(a4, b2, d4, e3, c3);
    case 1:
      return d4 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d4 ? e3 : Ci(d4, e3), hj(a4, b2, d4, e3, c3);
    case 3:
      a: {
        kj(b2);
        if (null === a4) throw Error(p$1(387));
        d4 = b2.pendingProps;
        f2 = b2.memoizedState;
        e3 = f2.element;
        lh(a4, b2);
        qh(b2, d4, null, c3);
        var g2 = b2.memoizedState;
        d4 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d4, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e3 = Ji(Error(p$1(423)), b2);
          b2 = lj(a4, b2, d4, c3, e3);
          break a;
        } else if (d4 !== e3) {
          e3 = Ji(Error(p$1(424)), b2);
          b2 = lj(a4, b2, d4, c3, e3);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I = true, zg = null, c3 = Vg(b2, null, d4, c3), b2.child = c3; c3; ) c3.flags = c3.flags & -3 | 4096, c3 = c3.sibling;
        else {
          Ig();
          if (d4 === e3) {
            b2 = Zi(a4, b2, c3);
            break a;
          }
          Xi(a4, b2, d4, c3);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a4 && Eg(b2), d4 = b2.type, e3 = b2.pendingProps, f2 = null !== a4 ? a4.memoizedProps : null, g2 = e3.children, Ef(d4, e3) ? g2 = null : null !== f2 && Ef(d4, f2) && (b2.flags |= 32), gj(a4, b2), Xi(a4, b2, g2, c3), b2.child;
    case 6:
      return null === a4 && Eg(b2), null;
    case 13:
      return oj(a4, b2, c3);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d4 = b2.pendingProps, null === a4 ? b2.child = Ug(b2, null, d4, c3) : Xi(a4, b2, d4, c3), b2.child;
    case 11:
      return d4 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d4 ? e3 : Ci(d4, e3), Yi(a4, b2, d4, e3, c3);
    case 7:
      return Xi(a4, b2, b2.pendingProps, c3), b2.child;
    case 8:
      return Xi(a4, b2, b2.pendingProps.children, c3), b2.child;
    case 12:
      return Xi(a4, b2, b2.pendingProps.children, c3), b2.child;
    case 10:
      a: {
        d4 = b2.type._context;
        e3 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e3.value;
        G(Wg, d4._currentValue);
        d4._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e3.children && !Wf.current) {
            b2 = Zi(a4, b2, c3);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h4 = f2.dependencies;
          if (null !== h4) {
            g2 = f2.child;
            for (var k3 = h4.firstContext; null !== k3; ) {
              if (k3.context === d4) {
                if (1 === f2.tag) {
                  k3 = mh(-1, c3 & -c3);
                  k3.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m4 = l2.pending;
                    null === m4 ? k3.next = k3 : (k3.next = m4.next, m4.next = k3);
                    l2.pending = k3;
                  }
                }
                f2.lanes |= c3;
                k3 = f2.alternate;
                null !== k3 && (k3.lanes |= c3);
                bh(
                  f2.return,
                  c3,
                  b2
                );
                h4.lanes |= c3;
                break;
              }
              k3 = k3.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$1(341));
            g2.lanes |= c3;
            h4 = g2.alternate;
            null !== h4 && (h4.lanes |= c3);
            bh(g2, c3, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a4, b2, e3.children, c3);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e3 = b2.type, d4 = b2.pendingProps.children, ch(b2, c3), e3 = eh(e3), d4 = d4(e3), b2.flags |= 1, Xi(a4, b2, d4, c3), b2.child;
    case 14:
      return d4 = b2.type, e3 = Ci(d4, b2.pendingProps), e3 = Ci(d4.type, e3), $i(a4, b2, d4, e3, c3);
    case 15:
      return bj(a4, b2, b2.type, b2.pendingProps, c3);
    case 17:
      return d4 = b2.type, e3 = b2.pendingProps, e3 = b2.elementType === d4 ? e3 : Ci(d4, e3), ij(a4, b2), b2.tag = 1, Zf(d4) ? (a4 = true, cg(b2)) : a4 = false, ch(b2, c3), Gi(b2, d4, e3), Ii(b2, d4, e3, c3), jj(null, b2, d4, true, a4, c3);
    case 19:
      return xj(a4, b2, c3);
    case 22:
      return dj(a4, b2, c3);
  }
  throw Error(p$1(156, b2.tag));
};
function Fk(a4, b2) {
  return ac(a4, b2);
}
function $k(a4, b2, c3, d4) {
  this.tag = a4;
  this.key = c3;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d4;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a4, b2, c3, d4) {
  return new $k(a4, b2, c3, d4);
}
function aj(a4) {
  a4 = a4.prototype;
  return !(!a4 || !a4.isReactComponent);
}
function Zk(a4) {
  if ("function" === typeof a4) return aj(a4) ? 1 : 0;
  if (void 0 !== a4 && null !== a4) {
    a4 = a4.$$typeof;
    if (a4 === Da) return 11;
    if (a4 === Ga) return 14;
  }
  return 2;
}
function Pg(a4, b2) {
  var c3 = a4.alternate;
  null === c3 ? (c3 = Bg(a4.tag, b2, a4.key, a4.mode), c3.elementType = a4.elementType, c3.type = a4.type, c3.stateNode = a4.stateNode, c3.alternate = a4, a4.alternate = c3) : (c3.pendingProps = b2, c3.type = a4.type, c3.flags = 0, c3.subtreeFlags = 0, c3.deletions = null);
  c3.flags = a4.flags & 14680064;
  c3.childLanes = a4.childLanes;
  c3.lanes = a4.lanes;
  c3.child = a4.child;
  c3.memoizedProps = a4.memoizedProps;
  c3.memoizedState = a4.memoizedState;
  c3.updateQueue = a4.updateQueue;
  b2 = a4.dependencies;
  c3.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c3.sibling = a4.sibling;
  c3.index = a4.index;
  c3.ref = a4.ref;
  return c3;
}
function Rg(a4, b2, c3, d4, e3, f2) {
  var g2 = 2;
  d4 = a4;
  if ("function" === typeof a4) aj(a4) && (g2 = 1);
  else if ("string" === typeof a4) g2 = 5;
  else a: switch (a4) {
    case ya:
      return Tg(c3.children, e3, f2, b2);
    case za:
      g2 = 8;
      e3 |= 8;
      break;
    case Aa:
      return a4 = Bg(12, c3, b2, e3 | 2), a4.elementType = Aa, a4.lanes = f2, a4;
    case Ea:
      return a4 = Bg(13, c3, b2, e3), a4.elementType = Ea, a4.lanes = f2, a4;
    case Fa:
      return a4 = Bg(19, c3, b2, e3), a4.elementType = Fa, a4.lanes = f2, a4;
    case Ia:
      return pj(c3, e3, f2, b2);
    default:
      if ("object" === typeof a4 && null !== a4) switch (a4.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d4 = null;
          break a;
      }
      throw Error(p$1(130, null == a4 ? a4 : typeof a4, ""));
  }
  b2 = Bg(g2, c3, b2, e3);
  b2.elementType = a4;
  b2.type = d4;
  b2.lanes = f2;
  return b2;
}
function Tg(a4, b2, c3, d4) {
  a4 = Bg(7, a4, d4, b2);
  a4.lanes = c3;
  return a4;
}
function pj(a4, b2, c3, d4) {
  a4 = Bg(22, a4, d4, b2);
  a4.elementType = Ia;
  a4.lanes = c3;
  a4.stateNode = { isHidden: false };
  return a4;
}
function Qg(a4, b2, c3) {
  a4 = Bg(6, a4, null, b2);
  a4.lanes = c3;
  return a4;
}
function Sg(a4, b2, c3) {
  b2 = Bg(4, null !== a4.children ? a4.children : [], a4.key, b2);
  b2.lanes = c3;
  b2.stateNode = { containerInfo: a4.containerInfo, pendingChildren: null, implementation: a4.implementation };
  return b2;
}
function al(a4, b2, c3, d4, e3) {
  this.tag = b2;
  this.containerInfo = a4;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d4;
  this.onRecoverableError = e3;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a4, b2, c3, d4, e3, f2, g2, h4, k3) {
  a4 = new al(a4, b2, c3, h4, k3);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a4.current = f2;
  f2.stateNode = a4;
  f2.memoizedState = { element: d4, isDehydrated: c3, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a4;
}
function cl(a4, b2, c3) {
  var d4 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d4 ? null : "" + d4, children: a4, containerInfo: b2, implementation: c3 };
}
function dl(a4) {
  if (!a4) return Vf;
  a4 = a4._reactInternals;
  a: {
    if (Vb(a4) !== a4 || 1 !== a4.tag) throw Error(p$1(170));
    var b2 = a4;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$1(171));
  }
  if (1 === a4.tag) {
    var c3 = a4.type;
    if (Zf(c3)) return bg(a4, c3, b2);
  }
  return b2;
}
function el(a4, b2, c3, d4, e3, f2, g2, h4, k3) {
  a4 = bl(c3, d4, true, a4, e3, f2, g2, h4, k3);
  a4.context = dl(null);
  c3 = a4.current;
  d4 = R();
  e3 = yi(c3);
  f2 = mh(d4, e3);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c3, f2, e3);
  a4.current.lanes = e3;
  Ac(a4, e3, d4);
  Dk(a4, d4);
  return a4;
}
function fl(a4, b2, c3, d4) {
  var e3 = b2.current, f2 = R(), g2 = yi(e3);
  c3 = dl(c3);
  null === b2.context ? b2.context = c3 : b2.pendingContext = c3;
  b2 = mh(f2, g2);
  b2.payload = { element: a4 };
  d4 = void 0 === d4 ? null : d4;
  null !== d4 && (b2.callback = d4);
  a4 = nh(e3, b2, g2);
  null !== a4 && (gi(a4, e3, g2, f2), oh(a4, e3, g2));
  return g2;
}
function gl(a4) {
  a4 = a4.current;
  if (!a4.child) return null;
  switch (a4.child.tag) {
    case 5:
      return a4.child.stateNode;
    default:
      return a4.child.stateNode;
  }
}
function hl(a4, b2) {
  a4 = a4.memoizedState;
  if (null !== a4 && null !== a4.dehydrated) {
    var c3 = a4.retryLane;
    a4.retryLane = 0 !== c3 && c3 < b2 ? c3 : b2;
  }
}
function il(a4, b2) {
  hl(a4, b2);
  (a4 = a4.alternate) && hl(a4, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a4) {
  console.error(a4);
};
function ll(a4) {
  this._internalRoot = a4;
}
ml.prototype.render = ll.prototype.render = function(a4) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$1(409));
  fl(a4, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a4 = this._internalRoot;
  if (null !== a4) {
    this._internalRoot = null;
    var b2 = a4.containerInfo;
    Rk(function() {
      fl(null, a4, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a4) {
  this._internalRoot = a4;
}
ml.prototype.unstable_scheduleHydration = function(a4) {
  if (a4) {
    var b2 = Hc();
    a4 = { blockedOn: null, target: a4, priority: b2 };
    for (var c3 = 0; c3 < Qc.length && 0 !== b2 && b2 < Qc[c3].priority; c3++) ;
    Qc.splice(c3, 0, a4);
    0 === c3 && Vc(a4);
  }
};
function nl(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType);
}
function ol(a4) {
  return !(!a4 || 1 !== a4.nodeType && 9 !== a4.nodeType && 11 !== a4.nodeType && (8 !== a4.nodeType || " react-mount-point-unstable " !== a4.nodeValue));
}
function pl() {
}
function ql(a4, b2, c3, d4, e3) {
  if (e3) {
    if ("function" === typeof d4) {
      var f2 = d4;
      d4 = function() {
        var a5 = gl(g2);
        f2.call(a5);
      };
    }
    var g2 = el(b2, d4, a4, 0, null, false, false, "", pl);
    a4._reactRootContainer = g2;
    a4[uf] = g2.current;
    sf(8 === a4.nodeType ? a4.parentNode : a4);
    Rk();
    return g2;
  }
  for (; e3 = a4.lastChild; ) a4.removeChild(e3);
  if ("function" === typeof d4) {
    var h4 = d4;
    d4 = function() {
      var a5 = gl(k3);
      h4.call(a5);
    };
  }
  var k3 = bl(a4, 0, false, null, null, false, false, "", pl);
  a4._reactRootContainer = k3;
  a4[uf] = k3.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  Rk(function() {
    fl(b2, k3, c3, d4);
  });
  return k3;
}
function rl(a4, b2, c3, d4, e3) {
  var f2 = c3._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e3) {
      var h4 = e3;
      e3 = function() {
        var a5 = gl(g2);
        h4.call(a5);
      };
    }
    fl(b2, g2, a4, e3);
  } else g2 = ql(c3, b2, a4, e3, d4);
  return gl(g2);
}
Ec = function(a4) {
  switch (a4.tag) {
    case 3:
      var b2 = a4.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c3 = tc(b2.pendingLanes);
        0 !== c3 && (Cc(b2, c3 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a4, 1);
        if (null !== b3) {
          var c4 = R();
          gi(b3, a4, 1, c4);
        }
      }), il(a4, 1);
  }
};
Fc = function(a4) {
  if (13 === a4.tag) {
    var b2 = ih(a4, 134217728);
    if (null !== b2) {
      var c3 = R();
      gi(b2, a4, 134217728, c3);
    }
    il(a4, 134217728);
  }
};
Gc = function(a4) {
  if (13 === a4.tag) {
    var b2 = yi(a4), c3 = ih(a4, b2);
    if (null !== c3) {
      var d4 = R();
      gi(c3, a4, b2, d4);
    }
    il(a4, b2);
  }
};
Hc = function() {
  return C;
};
Ic = function(a4, b2) {
  var c3 = C;
  try {
    return C = a4, b2();
  } finally {
    C = c3;
  }
};
yb = function(a4, b2, c3) {
  switch (b2) {
    case "input":
      bb(a4, c3);
      b2 = c3.name;
      if ("radio" === c3.type && null != b2) {
        for (c3 = a4; c3.parentNode; ) c3 = c3.parentNode;
        c3 = c3.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c3.length; b2++) {
          var d4 = c3[b2];
          if (d4 !== a4 && d4.form === a4.form) {
            var e3 = Db(d4);
            if (!e3) throw Error(p$1(90));
            Wa(d4);
            bb(d4, e3);
          }
        }
      }
      break;
    case "textarea":
      ib(a4, c3);
      break;
    case "select":
      b2 = c3.value, null != b2 && fb(a4, !!c3.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue$2, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a4) {
  a4 = Zb(a4);
  return null === a4 ? null : a4.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a4) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a4, b2) {
  var c3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$1(200));
  return cl(a4, b2, null, c3);
};
reactDom_production_min.createRoot = function(a4, b2) {
  if (!nl(a4)) throw Error(p$1(299));
  var c3 = false, d4 = "", e3 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c3 = true), void 0 !== b2.identifierPrefix && (d4 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e3 = b2.onRecoverableError));
  b2 = bl(a4, 1, false, null, null, c3, false, d4, e3);
  a4[uf] = b2.current;
  sf(8 === a4.nodeType ? a4.parentNode : a4);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a4) {
  if (null == a4) return null;
  if (1 === a4.nodeType) return a4;
  var b2 = a4._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a4.render) throw Error(p$1(188));
    a4 = Object.keys(a4).join(",");
    throw Error(p$1(268, a4));
  }
  a4 = Zb(b2);
  a4 = null === a4 ? null : a4.stateNode;
  return a4;
};
reactDom_production_min.flushSync = function(a4) {
  return Rk(a4);
};
reactDom_production_min.hydrate = function(a4, b2, c3) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a4, b2, true, c3);
};
reactDom_production_min.hydrateRoot = function(a4, b2, c3) {
  if (!nl(a4)) throw Error(p$1(405));
  var d4 = null != c3 && c3.hydratedSources || null, e3 = false, f2 = "", g2 = kl;
  null !== c3 && void 0 !== c3 && (true === c3.unstable_strictMode && (e3 = true), void 0 !== c3.identifierPrefix && (f2 = c3.identifierPrefix), void 0 !== c3.onRecoverableError && (g2 = c3.onRecoverableError));
  b2 = el(b2, null, a4, 1, null != c3 ? c3 : null, e3, false, f2, g2);
  a4[uf] = b2.current;
  sf(a4);
  if (d4) for (a4 = 0; a4 < d4.length; a4++) c3 = d4[a4], e3 = c3._getVersion, e3 = e3(c3._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c3, e3] : b2.mutableSourceEagerHydrationData.push(
    c3,
    e3
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a4, b2, c3) {
  if (!ol(b2)) throw Error(p$1(200));
  return rl(null, a4, b2, false, c3);
};
reactDom_production_min.unmountComponentAtNode = function(a4) {
  if (!ol(a4)) throw Error(p$1(40));
  return a4._reactRootContainer ? (Rk(function() {
    rl(null, null, a4, false, function() {
      a4._reactRootContainer = null;
      a4[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a4, b2, c3, d4) {
  if (!ol(c3)) throw Error(p$1(200));
  if (null == a4 || void 0 === a4._reactInternals) throw Error(p$1(38));
  return rl(a4, b2, c3, false, d4);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
const ReactDOM$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: ReactDOM
}, [reactDomExports]);
var createRoot;
var m$1 = reactDomExports;
{
  createRoot = m$1.createRoot;
  m$1.hydrateRoot;
}
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
var Action$3;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action$3 || (Action$3 = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createBrowserLocation(window2, globalHistory) {
    let {
      pathname,
      search,
      hash
    } = window2.location;
    return createLocation(
      "",
      {
        pathname,
        search,
        hash
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createBrowserHref(window2, to) {
    return typeof to === "string" ? to : createPath(to);
  }
  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);
}
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e3) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location2, index2) {
  return {
    usr: location2.state,
    key: location2.key,
    idx: index2
  };
}
function createLocation(current, to, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location2 = _extends$2({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to === "string" ? parsePath(to) : to, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to && to.key || key || createKey()
  });
  return location2;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash = ""
  } = _ref;
  if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action$3.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends$2({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action$3.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push(to, state) {
    action = Action$3.Push;
    let location2 = createLocation(history.location, to, state);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location2, index2);
    let url2 = history.createHref(location2);
    try {
      globalHistory.pushState(historyState, "", url2);
    } catch (error) {
      if (error instanceof DOMException && error.name === "DataCloneError") {
        throw error;
      }
      window2.location.assign(url2);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to, state) {
    action = Action$3.Replace;
    let location2 = createLocation(history.location, to, state);
    index2 = getIndex();
    let historyState = getHistoryState(location2, index2);
    let url2 = history.createHref(location2);
    globalHistory.replaceState(historyState, "", url2);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to === "string" ? to : createPath(to);
    href = href.replace(/ $/, "%20");
    invariant(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to) {
      return createHref(window2, to);
    },
    createURL,
    encodeLocation(to) {
      let url2 = createURL(to);
      return {
        pathname: url2.pathname,
        search: url2.search,
        hash: url2.hash
      };
    },
    push,
    replace,
    go(n2) {
      return globalHistory.go(n2);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
const immutableRouteKeys = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(route) {
  return route.index === true;
}
function convertRoutesToDataRoutes(routes, mapRouteProperties2, parentPath, manifest) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  if (manifest === void 0) {
    manifest = {};
  }
  return routes.map((route, index2) => {
    let treePath = [...parentPath, String(index2)];
    let id2 = typeof route.id === "string" ? route.id : treePath.join("-");
    invariant(route.index !== true || !route.children, "Cannot specify children on an index route");
    invariant(!manifest[id2], 'Found a route id collision on id "' + id2 + `".  Route id's must be globally unique within Data Router usages`);
    if (isIndexRoute(route)) {
      let indexRoute = _extends$2({}, route, mapRouteProperties2(route), {
        id: id2
      });
      manifest[id2] = indexRoute;
      return indexRoute;
    } else {
      let pathOrLayoutRoute = _extends$2({}, route, mapRouteProperties2(route), {
        id: id2,
        children: void 0
      });
      manifest[id2] = pathOrLayoutRoute;
      if (route.children) {
        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties2, treePath, manifest);
      }
      return pathOrLayoutRoute;
    }
  });
}
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location2 = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location2.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i3 = 0; matches == null && i3 < branches.length; ++i3) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(branches[i3], decoded, allowPartial);
  }
  return matches;
}
function convertRouteMatchToUiMatch(match2, loaderData) {
  let {
    route,
    pathname,
    params
  } = match2;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required : [required, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a4, b2) => a4.score !== b2.score ? b2.score - a4.score : compareIndexes(a4.routesMeta.map((meta) => meta.childrenIndex), b2.routesMeta.map((meta) => meta.childrenIndex)));
}
const paramRe = /^:[\w-]+$/;
const dynamicSegmentValue = 3;
const indexRouteValue = 2;
const emptySegmentValue = 1;
const staticSegmentValue = 10;
const splatPenalty = -2;
const isSplat = (s4) => s4 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s4) => !isSplat(s4)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a4, b2) {
  let siblings = a4.length === b2.length && a4.slice(0, -1).every((n2, i3) => n2 === b2[i3]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a4[a4.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial) {
  if (allowPartial === void 0) {
    allowPartial = false;
  }
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i3 = 0; i3 < routesMeta.length; ++i3) {
    let meta = routesMeta[i3];
    let end = i3 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match2 = matchPath({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end
    }, remainingPathname);
    let route = meta.route;
    if (!match2 && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match2 = matchPath({
        path: meta.relativePath,
        caseSensitive: meta.caseSensitive,
        end: false
      }, remainingPathname);
    }
    if (!match2) {
      return null;
    }
    Object.assign(matchedParams, match2.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match2.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match2.pathnameBase])),
      route
    });
    if (match2.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match2.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match2 = pathname.match(matcher);
  if (!match2) return null;
  let matchedPathname = match2[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match2.slice(1);
  let params = compiledParams.reduce((memo, _ref, index2) => {
    let {
      paramName,
      isOptional
    } = _ref;
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    const value = captureGroups[index2];
    if (isOptional && !value) {
      memo[paramName] = void 0;
    } else {
      memo[paramName] = (value || "").replace(/%2F/g, "/");
    }
    return memo;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end === void 0) {
    end = true;
  }
  warning(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (_2, paramName, isOptional) => {
    params.push({
      paramName,
      isOptional: isOptional != null
    });
    return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    params.push({
      paramName: "*"
    });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error) {
    warning(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to === "string" ? parsePath(to) : to;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match2, index2) => index2 === 0 || match2.route.path && match2.route.path.length > 0);
}
function getResolveToMatches(matches, v7_relativeSplatPath) {
  let pathMatches = getPathContributingMatches(matches);
  if (v7_relativeSplatPath) {
    return pathMatches.map((match2, idx) => idx === pathMatches.length - 1 ? match2.pathname : match2.pathnameBase);
  }
  return pathMatches.map((match2) => match2.pathnameBase);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to;
  if (typeof toArg === "string") {
    to = parsePath(toArg);
  } else {
    to = _extends$2({}, toArg);
    invariant(!to.pathname || !to.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to));
    invariant(!to.pathname || !to.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to));
    invariant(!to.search || !to.search.includes("#"), getInvalidPathError("#", "search", "hash", to));
  }
  let isEmptyPath = toArg === "" || to.pathname === "";
  let toPathname = isEmptyPath ? "/" : to.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
const joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
const normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
const normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
const normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
class ErrorResponseImpl {
  constructor(status, statusText, data, internal) {
    if (internal === void 0) {
      internal = false;
    }
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data instanceof Error) {
      this.data = data.toString();
      this.error = data;
    } else {
      this.data = data;
    }
  }
}
function isRouteErrorResponse(error) {
  return error != null && typeof error.status === "number" && typeof error.statusText === "string" && typeof error.internal === "boolean" && "data" in error;
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
const validMutationMethods = new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
const validRequestMethods = new Set(validRequestMethodsArr);
const redirectStatusCodes = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]);
const redirectPreserveMethodStatusCodes = /* @__PURE__ */ new Set([307, 308]);
const IDLE_NAVIGATION = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_FETCHER = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
};
const IDLE_BLOCKER = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
};
const ABSOLUTE_URL_REGEX$1 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const defaultMapRouteProperties = (route) => ({
  hasErrorBoundary: Boolean(route.hasErrorBoundary)
});
const TRANSITIONS_STORAGE_KEY = "remix-router-transitions";
function createRouter(init) {
  const routerWindow = init.window ? init.window : typeof window !== "undefined" ? window : void 0;
  const isBrowser2 = typeof routerWindow !== "undefined" && typeof routerWindow.document !== "undefined" && typeof routerWindow.document.createElement !== "undefined";
  const isServer = !isBrowser2;
  invariant(init.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let mapRouteProperties2;
  if (init.mapRouteProperties) {
    mapRouteProperties2 = init.mapRouteProperties;
  } else if (init.detectErrorBoundary) {
    let detectErrorBoundary = init.detectErrorBoundary;
    mapRouteProperties2 = (route) => ({
      hasErrorBoundary: detectErrorBoundary(route)
    });
  } else {
    mapRouteProperties2 = defaultMapRouteProperties;
  }
  let manifest = {};
  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties2, void 0, manifest);
  let inFlightDataRoutes;
  let basename = init.basename || "/";
  let dataStrategyImpl = init.dataStrategy || defaultDataStrategy;
  let patchRoutesOnNavigationImpl = init.patchRoutesOnNavigation;
  let future = _extends$2({
    v7_fetcherPersist: false,
    v7_normalizeFormMethod: false,
    v7_partialHydration: false,
    v7_prependBasename: false,
    v7_relativeSplatPath: false,
    v7_skipActionErrorRevalidation: false
  }, init.future);
  let unlistenHistory = null;
  let subscribers = /* @__PURE__ */ new Set();
  let savedScrollPositions = null;
  let getScrollRestorationKey = null;
  let getScrollPosition2 = null;
  let initialScrollRestored = init.hydrationData != null;
  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);
  let initialMatchesIsFOW = false;
  let initialErrors = null;
  if (initialMatches == null && !patchRoutesOnNavigationImpl) {
    let error = getInternalRouterError(404, {
      pathname: init.history.location.pathname
    });
    let {
      matches,
      route
    } = getShortCircuitMatches(dataRoutes);
    initialMatches = matches;
    initialErrors = {
      [route.id]: error
    };
  }
  if (initialMatches && !init.hydrationData) {
    let fogOfWar = checkFogOfWar(initialMatches, dataRoutes, init.history.location.pathname);
    if (fogOfWar.active) {
      initialMatches = null;
    }
  }
  let initialized;
  if (!initialMatches) {
    initialized = false;
    initialMatches = [];
    if (future.v7_partialHydration) {
      let fogOfWar = checkFogOfWar(null, dataRoutes, init.history.location.pathname);
      if (fogOfWar.active && fogOfWar.matches) {
        initialMatchesIsFOW = true;
        initialMatches = fogOfWar.matches;
      }
    }
  } else if (initialMatches.some((m4) => m4.route.lazy)) {
    initialized = false;
  } else if (!initialMatches.some((m4) => m4.route.loader)) {
    initialized = true;
  } else if (future.v7_partialHydration) {
    let loaderData = init.hydrationData ? init.hydrationData.loaderData : null;
    let errors = init.hydrationData ? init.hydrationData.errors : null;
    if (errors) {
      let idx = initialMatches.findIndex((m4) => errors[m4.route.id] !== void 0);
      initialized = initialMatches.slice(0, idx + 1).every((m4) => !shouldLoadRouteOnHydration(m4.route, loaderData, errors));
    } else {
      initialized = initialMatches.every((m4) => !shouldLoadRouteOnHydration(m4.route, loaderData, errors));
    }
  } else {
    initialized = init.hydrationData != null;
  }
  let router2;
  let state = {
    historyAction: init.history.action,
    location: init.history.location,
    matches: initialMatches,
    initialized,
    navigation: IDLE_NAVIGATION,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: init.hydrationData != null ? false : null,
    preventScrollReset: false,
    revalidation: "idle",
    loaderData: init.hydrationData && init.hydrationData.loaderData || {},
    actionData: init.hydrationData && init.hydrationData.actionData || null,
    errors: init.hydrationData && init.hydrationData.errors || initialErrors,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  };
  let pendingAction = Action$3.Pop;
  let pendingPreventScrollReset = false;
  let pendingNavigationController;
  let pendingViewTransitionEnabled = false;
  let appliedViewTransitions = /* @__PURE__ */ new Map();
  let removePageHideEventListener = null;
  let isUninterruptedRevalidation = false;
  let isRevalidationRequired = false;
  let cancelledDeferredRoutes = [];
  let cancelledFetcherLoads = /* @__PURE__ */ new Set();
  let fetchControllers = /* @__PURE__ */ new Map();
  let incrementingLoadId = 0;
  let pendingNavigationLoadId = -1;
  let fetchReloadIds = /* @__PURE__ */ new Map();
  let fetchRedirectIds = /* @__PURE__ */ new Set();
  let fetchLoadMatches = /* @__PURE__ */ new Map();
  let activeFetchers = /* @__PURE__ */ new Map();
  let deletedFetchers = /* @__PURE__ */ new Set();
  let activeDeferreds = /* @__PURE__ */ new Map();
  let blockerFunctions = /* @__PURE__ */ new Map();
  let unblockBlockerHistoryUpdate = void 0;
  function initialize() {
    unlistenHistory = init.history.listen((_ref) => {
      let {
        action: historyAction,
        location: location2,
        delta
      } = _ref;
      if (unblockBlockerHistoryUpdate) {
        unblockBlockerHistoryUpdate();
        unblockBlockerHistoryUpdate = void 0;
        return;
      }
      warning(blockerFunctions.size === 0 || delta != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let blockerKey = shouldBlockNavigation({
        currentLocation: state.location,
        nextLocation: location2,
        historyAction
      });
      if (blockerKey && delta != null) {
        let nextHistoryUpdatePromise = new Promise((resolve) => {
          unblockBlockerHistoryUpdate = resolve;
        });
        init.history.go(delta * -1);
        updateBlocker(blockerKey, {
          state: "blocked",
          location: location2,
          proceed() {
            updateBlocker(blockerKey, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: location2
            });
            nextHistoryUpdatePromise.then(() => init.history.go(delta));
          },
          reset() {
            let blockers = new Map(state.blockers);
            blockers.set(blockerKey, IDLE_BLOCKER);
            updateState({
              blockers
            });
          }
        });
        return;
      }
      return startNavigation(historyAction, location2);
    });
    if (isBrowser2) {
      restoreAppliedTransitions(routerWindow, appliedViewTransitions);
      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);
      routerWindow.addEventListener("pagehide", _saveAppliedTransitions);
      removePageHideEventListener = () => routerWindow.removeEventListener("pagehide", _saveAppliedTransitions);
    }
    if (!state.initialized) {
      startNavigation(Action$3.Pop, state.location, {
        initialHydration: true
      });
    }
    return router2;
  }
  function dispose() {
    if (unlistenHistory) {
      unlistenHistory();
    }
    if (removePageHideEventListener) {
      removePageHideEventListener();
    }
    subscribers.clear();
    pendingNavigationController && pendingNavigationController.abort();
    state.fetchers.forEach((_2, key) => deleteFetcher(key));
    state.blockers.forEach((_2, key) => deleteBlocker(key));
  }
  function subscribe2(fn) {
    subscribers.add(fn);
    return () => subscribers.delete(fn);
  }
  function updateState(newState, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state = _extends$2({}, state, newState);
    let completedFetchers = [];
    let deletedFetchersKeys = [];
    if (future.v7_fetcherPersist) {
      state.fetchers.forEach((fetcher, key) => {
        if (fetcher.state === "idle") {
          if (deletedFetchers.has(key)) {
            deletedFetchersKeys.push(key);
          } else {
            completedFetchers.push(key);
          }
        }
      });
    }
    deletedFetchers.forEach((key) => {
      if (!state.fetchers.has(key) && !fetchControllers.has(key)) {
        deletedFetchersKeys.push(key);
      }
    });
    [...subscribers].forEach((subscriber) => subscriber(state, {
      deletedFetchers: deletedFetchersKeys,
      viewTransitionOpts: opts.viewTransitionOpts,
      flushSync: opts.flushSync === true
    }));
    if (future.v7_fetcherPersist) {
      completedFetchers.forEach((key) => state.fetchers.delete(key));
      deletedFetchersKeys.forEach((key) => deleteFetcher(key));
    } else {
      deletedFetchersKeys.forEach((key) => deletedFetchers.delete(key));
    }
  }
  function completeNavigation(location2, newState, _temp) {
    var _location$state, _location$state2;
    let {
      flushSync
    } = _temp === void 0 ? {} : _temp;
    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === "loading" && ((_location$state = location2.state) == null ? void 0 : _location$state._isRedirect) !== true;
    let actionData;
    if (newState.actionData) {
      if (Object.keys(newState.actionData).length > 0) {
        actionData = newState.actionData;
      } else {
        actionData = null;
      }
    } else if (isActionReload) {
      actionData = state.actionData;
    } else {
      actionData = null;
    }
    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;
    let blockers = state.blockers;
    if (blockers.size > 0) {
      blockers = new Map(blockers);
      blockers.forEach((_2, k3) => blockers.set(k3, IDLE_BLOCKER));
    }
    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location2.state) == null ? void 0 : _location$state2._isRedirect) !== true;
    if (inFlightDataRoutes) {
      dataRoutes = inFlightDataRoutes;
      inFlightDataRoutes = void 0;
    }
    if (isUninterruptedRevalidation) ;
    else if (pendingAction === Action$3.Pop) ;
    else if (pendingAction === Action$3.Push) {
      init.history.push(location2, location2.state);
    } else if (pendingAction === Action$3.Replace) {
      init.history.replace(location2, location2.state);
    }
    let viewTransitionOpts;
    if (pendingAction === Action$3.Pop) {
      let priorPaths = appliedViewTransitions.get(state.location.pathname);
      if (priorPaths && priorPaths.has(location2.pathname)) {
        viewTransitionOpts = {
          currentLocation: state.location,
          nextLocation: location2
        };
      } else if (appliedViewTransitions.has(location2.pathname)) {
        viewTransitionOpts = {
          currentLocation: location2,
          nextLocation: state.location
        };
      }
    } else if (pendingViewTransitionEnabled) {
      let toPaths = appliedViewTransitions.get(state.location.pathname);
      if (toPaths) {
        toPaths.add(location2.pathname);
      } else {
        toPaths = /* @__PURE__ */ new Set([location2.pathname]);
        appliedViewTransitions.set(state.location.pathname, toPaths);
      }
      viewTransitionOpts = {
        currentLocation: state.location,
        nextLocation: location2
      };
    }
    updateState(_extends$2({}, newState, {
      actionData,
      loaderData,
      historyAction: pendingAction,
      location: location2,
      initialized: true,
      navigation: IDLE_NAVIGATION,
      revalidation: "idle",
      restoreScrollPosition: getSavedScrollPosition(location2, newState.matches || state.matches),
      preventScrollReset,
      blockers
    }), {
      viewTransitionOpts,
      flushSync: flushSync === true
    });
    pendingAction = Action$3.Pop;
    pendingPreventScrollReset = false;
    pendingViewTransitionEnabled = false;
    isUninterruptedRevalidation = false;
    isRevalidationRequired = false;
    cancelledDeferredRoutes = [];
  }
  async function navigate(to, opts) {
    if (typeof to === "number") {
      init.history.go(to);
      return;
    }
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, future.v7_relativeSplatPath, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);
    let currentLocation = state.location;
    let nextLocation = createLocation(state.location, path, opts && opts.state);
    nextLocation = _extends$2({}, nextLocation, init.history.encodeLocation(nextLocation));
    let userReplace = opts && opts.replace != null ? opts.replace : void 0;
    let historyAction = Action$3.Push;
    if (userReplace === true) {
      historyAction = Action$3.Replace;
    } else if (userReplace === false) ;
    else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {
      historyAction = Action$3.Replace;
    }
    let preventScrollReset = opts && "preventScrollReset" in opts ? opts.preventScrollReset === true : void 0;
    let flushSync = (opts && opts.flushSync) === true;
    let blockerKey = shouldBlockNavigation({
      currentLocation,
      nextLocation,
      historyAction
    });
    if (blockerKey) {
      updateBlocker(blockerKey, {
        state: "blocked",
        location: nextLocation,
        proceed() {
          updateBlocker(blockerKey, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: nextLocation
          });
          navigate(to, opts);
        },
        reset() {
          let blockers = new Map(state.blockers);
          blockers.set(blockerKey, IDLE_BLOCKER);
          updateState({
            blockers
          });
        }
      });
      return;
    }
    return await startNavigation(historyAction, nextLocation, {
      submission,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: error,
      preventScrollReset,
      replace: opts && opts.replace,
      enableViewTransition: opts && opts.viewTransition,
      flushSync
    });
  }
  function revalidate() {
    interruptActiveLoads();
    updateState({
      revalidation: "loading"
    });
    if (state.navigation.state === "submitting") {
      return;
    }
    if (state.navigation.state === "idle") {
      startNavigation(state.historyAction, state.location, {
        startUninterruptedRevalidation: true
      });
      return;
    }
    startNavigation(pendingAction || state.historyAction, state.navigation.location, {
      overrideNavigation: state.navigation,
      // Proxy through any rending view transition
      enableViewTransition: pendingViewTransitionEnabled === true
    });
  }
  async function startNavigation(historyAction, location2, opts) {
    pendingNavigationController && pendingNavigationController.abort();
    pendingNavigationController = null;
    pendingAction = historyAction;
    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;
    saveScrollPosition(state.location, state.matches);
    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;
    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let loadingNavigation = opts && opts.overrideNavigation;
    let matches = opts != null && opts.initialHydration && state.matches && state.matches.length > 0 && !initialMatchesIsFOW ? (
      // `matchRoutes()` has already been called if we're in here via `router.initialize()`
      state.matches
    ) : matchRoutes(routesToUse, location2, basename);
    let flushSync = (opts && opts.flushSync) === true;
    if (matches && state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location2) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {
      completeNavigation(location2, {
        matches
      }, {
        flushSync
      });
      return;
    }
    let fogOfWar = checkFogOfWar(matches, routesToUse, location2.pathname);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      let {
        error,
        notFoundMatches,
        route
      } = handleNavigational404(location2.pathname);
      completeNavigation(location2, {
        matches: notFoundMatches,
        loaderData: {},
        errors: {
          [route.id]: error
        }
      }, {
        flushSync
      });
      return;
    }
    pendingNavigationController = new AbortController();
    let request = createClientSideRequest(init.history, location2, pendingNavigationController.signal, opts && opts.submission);
    let pendingActionResult;
    if (opts && opts.pendingError) {
      pendingActionResult = [findNearestBoundary(matches).route.id, {
        type: ResultType.error,
        error: opts.pendingError
      }];
    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {
      let actionResult = await handleAction(request, location2, opts.submission, matches, fogOfWar.active, {
        replace: opts.replace,
        flushSync
      });
      if (actionResult.shortCircuited) {
        return;
      }
      if (actionResult.pendingActionResult) {
        let [routeId, result] = actionResult.pendingActionResult;
        if (isErrorResult(result) && isRouteErrorResponse(result.error) && result.error.status === 404) {
          pendingNavigationController = null;
          completeNavigation(location2, {
            matches: actionResult.matches,
            loaderData: {},
            errors: {
              [routeId]: result.error
            }
          });
          return;
        }
      }
      matches = actionResult.matches || matches;
      pendingActionResult = actionResult.pendingActionResult;
      loadingNavigation = getLoadingNavigation(location2, opts.submission);
      flushSync = false;
      fogOfWar.active = false;
      request = createClientSideRequest(init.history, request.url, request.signal);
    }
    let {
      shortCircuited,
      matches: updatedMatches,
      loaderData,
      errors
    } = await handleLoaders(request, location2, matches, fogOfWar.active, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, opts && opts.initialHydration === true, flushSync, pendingActionResult);
    if (shortCircuited) {
      return;
    }
    pendingNavigationController = null;
    completeNavigation(location2, _extends$2({
      matches: updatedMatches || matches
    }, getActionDataForCommit(pendingActionResult), {
      loaderData,
      errors
    }));
  }
  async function handleAction(request, location2, submission, matches, isFogOfWar, opts) {
    if (opts === void 0) {
      opts = {};
    }
    interruptActiveLoads();
    let navigation = getSubmittingNavigation(location2, submission);
    updateState({
      navigation
    }, {
      flushSync: opts.flushSync === true
    });
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, location2.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          pendingActionResult: [boundaryId, {
            type: ResultType.error,
            error: discoverResult.error
          }]
        };
      } else if (!discoverResult.matches) {
        let {
          notFoundMatches,
          error,
          route
        } = handleNavigational404(location2.pathname);
        return {
          matches: notFoundMatches,
          pendingActionResult: [route.id, {
            type: ResultType.error,
            error
          }]
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let result;
    let actionMatch = getTargetMatch(matches, location2);
    if (!actionMatch.route.action && !actionMatch.route.lazy) {
      result = {
        type: ResultType.error,
        error: getInternalRouterError(405, {
          method: request.method,
          pathname: location2.pathname,
          routeId: actionMatch.route.id
        })
      };
    } else {
      let results = await callDataStrategy("action", state, request, [actionMatch], matches, null);
      result = results[actionMatch.route.id];
      if (request.signal.aborted) {
        return {
          shortCircuited: true
        };
      }
    }
    if (isRedirectResult(result)) {
      let replace;
      if (opts && opts.replace != null) {
        replace = opts.replace;
      } else {
        let location3 = normalizeRedirectLocation(result.response.headers.get("Location"), new URL(request.url), basename);
        replace = location3 === state.location.pathname + state.location.search;
      }
      await startRedirectNavigation(request, result, true, {
        submission,
        replace
      });
      return {
        shortCircuited: true
      };
    }
    if (isDeferredResult(result)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);
      if ((opts && opts.replace) !== true) {
        pendingAction = Action$3.Push;
      }
      return {
        matches,
        pendingActionResult: [boundaryMatch.route.id, result]
      };
    }
    return {
      matches,
      pendingActionResult: [actionMatch.route.id, result]
    };
  }
  async function handleLoaders(request, location2, matches, isFogOfWar, overrideNavigation, submission, fetcherSubmission, replace, initialHydration, flushSync, pendingActionResult) {
    let loadingNavigation = overrideNavigation || getLoadingNavigation(location2, submission);
    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);
    let shouldUpdateNavigationState = !isUninterruptedRevalidation && (!future.v7_partialHydration || !initialHydration);
    if (isFogOfWar) {
      if (shouldUpdateNavigationState) {
        let actionData = getUpdatedActionData(pendingActionResult);
        updateState(_extends$2({
          navigation: loadingNavigation
        }, actionData !== void 0 ? {
          actionData
        } : {}), {
          flushSync
        });
      }
      let discoverResult = await discoverRoutes(matches, location2.pathname, request.signal);
      if (discoverResult.type === "aborted") {
        return {
          shortCircuited: true
        };
      } else if (discoverResult.type === "error") {
        let boundaryId = findNearestBoundary(discoverResult.partialMatches).route.id;
        return {
          matches: discoverResult.partialMatches,
          loaderData: {},
          errors: {
            [boundaryId]: discoverResult.error
          }
        };
      } else if (!discoverResult.matches) {
        let {
          error,
          notFoundMatches,
          route
        } = handleNavigational404(location2.pathname);
        return {
          matches: notFoundMatches,
          loaderData: {},
          errors: {
            [route.id]: error
          }
        };
      } else {
        matches = discoverResult.matches;
      }
    }
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location2, future.v7_partialHydration && initialHydration === true, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult);
    cancelActiveDeferreds((routeId) => !(matches && matches.some((m4) => m4.route.id === routeId)) || matchesToLoad && matchesToLoad.some((m4) => m4.route.id === routeId));
    pendingNavigationLoadId = ++incrementingLoadId;
    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {
      let updatedFetchers2 = markFetchRedirectsDone();
      completeNavigation(location2, _extends$2({
        matches,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: pendingActionResult && isErrorResult(pendingActionResult[1]) ? {
          [pendingActionResult[0]]: pendingActionResult[1].error
        } : null
      }, getActionDataForCommit(pendingActionResult), updatedFetchers2 ? {
        fetchers: new Map(state.fetchers)
      } : {}), {
        flushSync
      });
      return {
        shortCircuited: true
      };
    }
    if (shouldUpdateNavigationState) {
      let updates = {};
      if (!isFogOfWar) {
        updates.navigation = loadingNavigation;
        let actionData = getUpdatedActionData(pendingActionResult);
        if (actionData !== void 0) {
          updates.actionData = actionData;
        }
      }
      if (revalidatingFetchers.length > 0) {
        updates.fetchers = getUpdatedRevalidatingFetchers(revalidatingFetchers);
      }
      updateState(updates, {
        flushSync
      });
    }
    revalidatingFetchers.forEach((rf2) => {
      abortFetcher(rf2.key);
      if (rf2.controller) {
        fetchControllers.set(rf2.key, rf2.controller);
      }
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((f2) => abortFetcher(f2.key));
    if (pendingNavigationController) {
      pendingNavigationController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    }
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, request);
    if (request.signal.aborted) {
      return {
        shortCircuited: true
      };
    }
    if (pendingNavigationController) {
      pendingNavigationController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    }
    revalidatingFetchers.forEach((rf2) => fetchControllers.delete(rf2.key));
    let redirect = findRedirect(loaderResults);
    if (redirect) {
      await startRedirectNavigation(request, redirect.result, true, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    redirect = findRedirect(fetcherResults);
    if (redirect) {
      fetchRedirectIds.add(redirect.key);
      await startRedirectNavigation(request, redirect.result, true, {
        replace
      });
      return {
        shortCircuited: true
      };
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, loaderResults, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds);
    activeDeferreds.forEach((deferredData, routeId) => {
      deferredData.subscribe((aborted) => {
        if (aborted || deferredData.done) {
          activeDeferreds.delete(routeId);
        }
      });
    });
    if (future.v7_partialHydration && initialHydration && state.errors) {
      errors = _extends$2({}, state.errors, errors);
    }
    let updatedFetchers = markFetchRedirectsDone();
    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);
    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;
    return _extends$2({
      matches,
      loaderData,
      errors
    }, shouldUpdateFetchers ? {
      fetchers: new Map(state.fetchers)
    } : {});
  }
  function getUpdatedActionData(pendingActionResult) {
    if (pendingActionResult && !isErrorResult(pendingActionResult[1])) {
      return {
        [pendingActionResult[0]]: pendingActionResult[1].data
      };
    } else if (state.actionData) {
      if (Object.keys(state.actionData).length === 0) {
        return null;
      } else {
        return state.actionData;
      }
    }
  }
  function getUpdatedRevalidatingFetchers(revalidatingFetchers) {
    revalidatingFetchers.forEach((rf2) => {
      let fetcher = state.fetchers.get(rf2.key);
      let revalidatingFetcher = getLoadingFetcher(void 0, fetcher ? fetcher.data : void 0);
      state.fetchers.set(rf2.key, revalidatingFetcher);
    });
    return new Map(state.fetchers);
  }
  function fetch(key, routeId, href, opts) {
    if (isServer) {
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    }
    abortFetcher(key);
    let flushSync = (opts && opts.flushSync) === true;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, future.v7_relativeSplatPath, routeId, opts == null ? void 0 : opts.relative);
    let matches = matchRoutes(routesToUse, normalizedPath, basename);
    let fogOfWar = checkFogOfWar(matches, routesToUse, normalizedPath);
    if (fogOfWar.active && fogOfWar.matches) {
      matches = fogOfWar.matches;
    }
    if (!matches) {
      setFetcherError(key, routeId, getInternalRouterError(404, {
        pathname: normalizedPath
      }), {
        flushSync
      });
      return;
    }
    let {
      path,
      submission,
      error
    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);
    if (error) {
      setFetcherError(key, routeId, error, {
        flushSync
      });
      return;
    }
    let match2 = getTargetMatch(matches, path);
    let preventScrollReset = (opts && opts.preventScrollReset) === true;
    if (submission && isMutationMethod(submission.formMethod)) {
      handleFetcherAction(key, routeId, path, match2, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
      return;
    }
    fetchLoadMatches.set(key, {
      routeId,
      path
    });
    handleFetcherLoader(key, routeId, path, match2, matches, fogOfWar.active, flushSync, preventScrollReset, submission);
  }
  async function handleFetcherAction(key, routeId, path, match2, requestMatches, isFogOfWar, flushSync, preventScrollReset, submission) {
    interruptActiveLoads();
    fetchLoadMatches.delete(key);
    function detectAndHandle405Error(m4) {
      if (!m4.route.action && !m4.route.lazy) {
        let error = getInternalRouterError(405, {
          method: submission.formMethod,
          pathname: path,
          routeId
        });
        setFetcherError(key, routeId, error, {
          flushSync
        });
        return true;
      }
      return false;
    }
    if (!isFogOfWar && detectAndHandle405Error(match2)) {
      return;
    }
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(requestMatches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        requestMatches = discoverResult.matches;
        match2 = getTargetMatch(requestMatches, path);
        if (detectAndHandle405Error(match2)) {
          return;
        }
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let actionResults = await callDataStrategy("action", state, fetchRequest, [match2], requestMatches, key);
    let actionResult = actionResults[match2.route.id];
    if (fetchRequest.signal.aborted) {
      if (fetchControllers.get(key) === abortController) {
        fetchControllers.delete(key);
      }
      return;
    }
    if (future.v7_fetcherPersist && deletedFetchers.has(key)) {
      if (isRedirectResult(actionResult) || isErrorResult(actionResult)) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      }
    } else {
      if (isRedirectResult(actionResult)) {
        fetchControllers.delete(key);
        if (pendingNavigationLoadId > originatingLoadId) {
          updateFetcherState(key, getDoneFetcher(void 0));
          return;
        } else {
          fetchRedirectIds.add(key);
          updateFetcherState(key, getLoadingFetcher(submission));
          return startRedirectNavigation(fetchRequest, actionResult, false, {
            fetcherSubmission: submission,
            preventScrollReset
          });
        }
      }
      if (isErrorResult(actionResult)) {
        setFetcherError(key, routeId, actionResult.error);
        return;
      }
    }
    if (isDeferredResult(actionResult)) {
      throw getInternalRouterError(400, {
        type: "defer-action"
      });
    }
    let nextLocation = state.navigation.location || state.location;
    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let matches = state.navigation.state !== "idle" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;
    invariant(matches, "Didn't find any matches after fetcher action");
    let loadId = ++incrementingLoadId;
    fetchReloadIds.set(key, loadId);
    let loadFetcher = getLoadingFetcher(submission, actionResult.data);
    state.fetchers.set(key, loadFetcher);
    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, false, future.v7_skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, [match2.route.id, actionResult]);
    revalidatingFetchers.filter((rf2) => rf2.key !== key).forEach((rf2) => {
      let staleKey = rf2.key;
      let existingFetcher2 = state.fetchers.get(staleKey);
      let revalidatingFetcher = getLoadingFetcher(void 0, existingFetcher2 ? existingFetcher2.data : void 0);
      state.fetchers.set(staleKey, revalidatingFetcher);
      abortFetcher(staleKey);
      if (rf2.controller) {
        fetchControllers.set(staleKey, rf2.controller);
      }
    });
    updateState({
      fetchers: new Map(state.fetchers)
    });
    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach((rf2) => abortFetcher(rf2.key));
    abortController.signal.addEventListener("abort", abortPendingFetchRevalidations);
    let {
      loaderResults,
      fetcherResults
    } = await callLoadersAndMaybeResolveData(state, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);
    if (abortController.signal.aborted) {
      return;
    }
    abortController.signal.removeEventListener("abort", abortPendingFetchRevalidations);
    fetchReloadIds.delete(key);
    fetchControllers.delete(key);
    revalidatingFetchers.forEach((r2) => fetchControllers.delete(r2.key));
    let redirect = findRedirect(loaderResults);
    if (redirect) {
      return startRedirectNavigation(revalidationRequest, redirect.result, false, {
        preventScrollReset
      });
    }
    redirect = findRedirect(fetcherResults);
    if (redirect) {
      fetchRedirectIds.add(redirect.key);
      return startRedirectNavigation(revalidationRequest, redirect.result, false, {
        preventScrollReset
      });
    }
    let {
      loaderData,
      errors
    } = processLoaderData(state, matches, loaderResults, void 0, revalidatingFetchers, fetcherResults, activeDeferreds);
    if (state.fetchers.has(key)) {
      let doneFetcher = getDoneFetcher(actionResult.data);
      state.fetchers.set(key, doneFetcher);
    }
    abortStaleFetchLoads(loadId);
    if (state.navigation.state === "loading" && loadId > pendingNavigationLoadId) {
      invariant(pendingAction, "Expected pending action");
      pendingNavigationController && pendingNavigationController.abort();
      completeNavigation(state.navigation.location, {
        matches,
        loaderData,
        errors,
        fetchers: new Map(state.fetchers)
      });
    } else {
      updateState({
        errors,
        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),
        fetchers: new Map(state.fetchers)
      });
      isRevalidationRequired = false;
    }
  }
  async function handleFetcherLoader(key, routeId, path, match2, matches, isFogOfWar, flushSync, preventScrollReset, submission) {
    let existingFetcher = state.fetchers.get(key);
    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : void 0), {
      flushSync
    });
    let abortController = new AbortController();
    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);
    if (isFogOfWar) {
      let discoverResult = await discoverRoutes(matches, new URL(fetchRequest.url).pathname, fetchRequest.signal, key);
      if (discoverResult.type === "aborted") {
        return;
      } else if (discoverResult.type === "error") {
        setFetcherError(key, routeId, discoverResult.error, {
          flushSync
        });
        return;
      } else if (!discoverResult.matches) {
        setFetcherError(key, routeId, getInternalRouterError(404, {
          pathname: path
        }), {
          flushSync
        });
        return;
      } else {
        matches = discoverResult.matches;
        match2 = getTargetMatch(matches, path);
      }
    }
    fetchControllers.set(key, abortController);
    let originatingLoadId = incrementingLoadId;
    let results = await callDataStrategy("loader", state, fetchRequest, [match2], matches, key);
    let result = results[match2.route.id];
    if (isDeferredResult(result)) {
      result = await resolveDeferredData(result, fetchRequest.signal, true) || result;
    }
    if (fetchControllers.get(key) === abortController) {
      fetchControllers.delete(key);
    }
    if (fetchRequest.signal.aborted) {
      return;
    }
    if (deletedFetchers.has(key)) {
      updateFetcherState(key, getDoneFetcher(void 0));
      return;
    }
    if (isRedirectResult(result)) {
      if (pendingNavigationLoadId > originatingLoadId) {
        updateFetcherState(key, getDoneFetcher(void 0));
        return;
      } else {
        fetchRedirectIds.add(key);
        await startRedirectNavigation(fetchRequest, result, false, {
          preventScrollReset
        });
        return;
      }
    }
    if (isErrorResult(result)) {
      setFetcherError(key, routeId, result.error);
      return;
    }
    invariant(!isDeferredResult(result), "Unhandled fetcher deferred data");
    updateFetcherState(key, getDoneFetcher(result.data));
  }
  async function startRedirectNavigation(request, redirect, isNavigation, _temp2) {
    let {
      submission,
      fetcherSubmission,
      preventScrollReset,
      replace
    } = _temp2 === void 0 ? {} : _temp2;
    if (redirect.response.headers.has("X-Remix-Revalidate")) {
      isRevalidationRequired = true;
    }
    let location2 = redirect.response.headers.get("Location");
    invariant(location2, "Expected a Location header on the redirect Response");
    location2 = normalizeRedirectLocation(location2, new URL(request.url), basename);
    let redirectLocation = createLocation(state.location, location2, {
      _isRedirect: true
    });
    if (isBrowser2) {
      let isDocumentReload = false;
      if (redirect.response.headers.has("X-Remix-Reload-Document")) {
        isDocumentReload = true;
      } else if (ABSOLUTE_URL_REGEX$1.test(location2)) {
        const url2 = init.history.createURL(location2);
        isDocumentReload = // Hard reload if it's an absolute URL to a new origin
        url2.origin !== routerWindow.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        stripBasename(url2.pathname, basename) == null;
      }
      if (isDocumentReload) {
        if (replace) {
          routerWindow.location.replace(location2);
        } else {
          routerWindow.location.assign(location2);
        }
        return;
      }
    }
    pendingNavigationController = null;
    let redirectHistoryAction = replace === true || redirect.response.headers.has("X-Remix-Replace") ? Action$3.Replace : Action$3.Push;
    let {
      formMethod,
      formAction,
      formEncType
    } = state.navigation;
    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {
      submission = getSubmissionFromNavigation(state.navigation);
    }
    let activeSubmission = submission || fetcherSubmission;
    if (redirectPreserveMethodStatusCodes.has(redirect.response.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {
      await startNavigation(redirectHistoryAction, redirectLocation, {
        submission: _extends$2({}, activeSubmission, {
          formAction: location2
        }),
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    } else {
      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);
      await startNavigation(redirectHistoryAction, redirectLocation, {
        overrideNavigation,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission,
        // Preserve these flags across redirects
        preventScrollReset: preventScrollReset || pendingPreventScrollReset,
        enableViewTransition: isNavigation ? pendingViewTransitionEnabled : void 0
      });
    }
  }
  async function callDataStrategy(type, state2, request, matchesToLoad, matches, fetcherKey) {
    let results;
    let dataResults = {};
    try {
      results = await callDataStrategyImpl(dataStrategyImpl, type, state2, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2);
    } catch (e3) {
      matchesToLoad.forEach((m4) => {
        dataResults[m4.route.id] = {
          type: ResultType.error,
          error: e3
        };
      });
      return dataResults;
    }
    for (let [routeId, result] of Object.entries(results)) {
      if (isRedirectDataStrategyResultResult(result)) {
        let response = result.result;
        dataResults[routeId] = {
          type: ResultType.redirect,
          response: normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, future.v7_relativeSplatPath)
        };
      } else {
        dataResults[routeId] = await convertDataStrategyResultToDataResult(result);
      }
    }
    return dataResults;
  }
  async function callLoadersAndMaybeResolveData(state2, matches, matchesToLoad, fetchersToLoad, request) {
    let currentMatches = state2.matches;
    let loaderResultsPromise = callDataStrategy("loader", state2, request, matchesToLoad, matches, null);
    let fetcherResultsPromise = Promise.all(fetchersToLoad.map(async (f2) => {
      if (f2.matches && f2.match && f2.controller) {
        let results = await callDataStrategy("loader", state2, createClientSideRequest(init.history, f2.path, f2.controller.signal), [f2.match], f2.matches, f2.key);
        let result = results[f2.match.route.id];
        return {
          [f2.key]: result
        };
      } else {
        return Promise.resolve({
          [f2.key]: {
            type: ResultType.error,
            error: getInternalRouterError(404, {
              pathname: f2.path
            })
          }
        });
      }
    }));
    let loaderResults = await loaderResultsPromise;
    let fetcherResults = (await fetcherResultsPromise).reduce((acc, r2) => Object.assign(acc, r2), {});
    await Promise.all([resolveNavigationDeferredResults(matches, loaderResults, request.signal, currentMatches, state2.loaderData), resolveFetcherDeferredResults(matches, fetcherResults, fetchersToLoad)]);
    return {
      loaderResults,
      fetcherResults
    };
  }
  function interruptActiveLoads() {
    isRevalidationRequired = true;
    cancelledDeferredRoutes.push(...cancelActiveDeferreds());
    fetchLoadMatches.forEach((_2, key) => {
      if (fetchControllers.has(key)) {
        cancelledFetcherLoads.add(key);
      }
      abortFetcher(key);
    });
  }
  function updateFetcherState(key, fetcher, opts) {
    if (opts === void 0) {
      opts = {};
    }
    state.fetchers.set(key, fetcher);
    updateState({
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function setFetcherError(key, routeId, error, opts) {
    if (opts === void 0) {
      opts = {};
    }
    let boundaryMatch = findNearestBoundary(state.matches, routeId);
    deleteFetcher(key);
    updateState({
      errors: {
        [boundaryMatch.route.id]: error
      },
      fetchers: new Map(state.fetchers)
    }, {
      flushSync: (opts && opts.flushSync) === true
    });
  }
  function getFetcher(key) {
    activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);
    if (deletedFetchers.has(key)) {
      deletedFetchers.delete(key);
    }
    return state.fetchers.get(key) || IDLE_FETCHER;
  }
  function deleteFetcher(key) {
    let fetcher = state.fetchers.get(key);
    if (fetchControllers.has(key) && !(fetcher && fetcher.state === "loading" && fetchReloadIds.has(key))) {
      abortFetcher(key);
    }
    fetchLoadMatches.delete(key);
    fetchReloadIds.delete(key);
    fetchRedirectIds.delete(key);
    if (future.v7_fetcherPersist) {
      deletedFetchers.delete(key);
    }
    cancelledFetcherLoads.delete(key);
    state.fetchers.delete(key);
  }
  function deleteFetcherAndUpdateState(key) {
    let count2 = (activeFetchers.get(key) || 0) - 1;
    if (count2 <= 0) {
      activeFetchers.delete(key);
      deletedFetchers.add(key);
      if (!future.v7_fetcherPersist) {
        deleteFetcher(key);
      }
    } else {
      activeFetchers.set(key, count2);
    }
    updateState({
      fetchers: new Map(state.fetchers)
    });
  }
  function abortFetcher(key) {
    let controller = fetchControllers.get(key);
    if (controller) {
      controller.abort();
      fetchControllers.delete(key);
    }
  }
  function markFetchersDone(keys2) {
    for (let key of keys2) {
      let fetcher = getFetcher(key);
      let doneFetcher = getDoneFetcher(fetcher.data);
      state.fetchers.set(key, doneFetcher);
    }
  }
  function markFetchRedirectsDone() {
    let doneKeys = [];
    let updatedFetchers = false;
    for (let key of fetchRedirectIds) {
      let fetcher = state.fetchers.get(key);
      invariant(fetcher, "Expected fetcher: " + key);
      if (fetcher.state === "loading") {
        fetchRedirectIds.delete(key);
        doneKeys.push(key);
        updatedFetchers = true;
      }
    }
    markFetchersDone(doneKeys);
    return updatedFetchers;
  }
  function abortStaleFetchLoads(landedId) {
    let yeetedKeys = [];
    for (let [key, id2] of fetchReloadIds) {
      if (id2 < landedId) {
        let fetcher = state.fetchers.get(key);
        invariant(fetcher, "Expected fetcher: " + key);
        if (fetcher.state === "loading") {
          abortFetcher(key);
          fetchReloadIds.delete(key);
          yeetedKeys.push(key);
        }
      }
    }
    markFetchersDone(yeetedKeys);
    return yeetedKeys.length > 0;
  }
  function getBlocker(key, fn) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    if (blockerFunctions.get(key) !== fn) {
      blockerFunctions.set(key, fn);
    }
    return blocker;
  }
  function deleteBlocker(key) {
    state.blockers.delete(key);
    blockerFunctions.delete(key);
  }
  function updateBlocker(key, newBlocker) {
    let blocker = state.blockers.get(key) || IDLE_BLOCKER;
    invariant(blocker.state === "unblocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "blocked" || blocker.state === "blocked" && newBlocker.state === "proceeding" || blocker.state === "blocked" && newBlocker.state === "unblocked" || blocker.state === "proceeding" && newBlocker.state === "unblocked", "Invalid blocker state transition: " + blocker.state + " -> " + newBlocker.state);
    let blockers = new Map(state.blockers);
    blockers.set(key, newBlocker);
    updateState({
      blockers
    });
  }
  function shouldBlockNavigation(_ref2) {
    let {
      currentLocation,
      nextLocation,
      historyAction
    } = _ref2;
    if (blockerFunctions.size === 0) {
      return;
    }
    if (blockerFunctions.size > 1) {
      warning(false, "A router only supports one blocker at a time");
    }
    let entries = Array.from(blockerFunctions.entries());
    let [blockerKey, blockerFunction] = entries[entries.length - 1];
    let blocker = state.blockers.get(blockerKey);
    if (blocker && blocker.state === "proceeding") {
      return;
    }
    if (blockerFunction({
      currentLocation,
      nextLocation,
      historyAction
    })) {
      return blockerKey;
    }
  }
  function handleNavigational404(pathname) {
    let error = getInternalRouterError(404, {
      pathname
    });
    let routesToUse = inFlightDataRoutes || dataRoutes;
    let {
      matches,
      route
    } = getShortCircuitMatches(routesToUse);
    cancelActiveDeferreds();
    return {
      notFoundMatches: matches,
      route,
      error
    };
  }
  function cancelActiveDeferreds(predicate) {
    let cancelledRouteIds = [];
    activeDeferreds.forEach((dfd, routeId) => {
      if (!predicate || predicate(routeId)) {
        dfd.cancel();
        cancelledRouteIds.push(routeId);
        activeDeferreds.delete(routeId);
      }
    });
    return cancelledRouteIds;
  }
  function enableScrollRestoration(positions, getPosition, getKey) {
    savedScrollPositions = positions;
    getScrollPosition2 = getPosition;
    getScrollRestorationKey = getKey || null;
    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {
      initialScrollRestored = true;
      let y4 = getSavedScrollPosition(state.location, state.matches);
      if (y4 != null) {
        updateState({
          restoreScrollPosition: y4
        });
      }
    }
    return () => {
      savedScrollPositions = null;
      getScrollPosition2 = null;
      getScrollRestorationKey = null;
    };
  }
  function getScrollKey(location2, matches) {
    if (getScrollRestorationKey) {
      let key = getScrollRestorationKey(location2, matches.map((m4) => convertRouteMatchToUiMatch(m4, state.loaderData)));
      return key || location2.key;
    }
    return location2.key;
  }
  function saveScrollPosition(location2, matches) {
    if (savedScrollPositions && getScrollPosition2) {
      let key = getScrollKey(location2, matches);
      savedScrollPositions[key] = getScrollPosition2();
    }
  }
  function getSavedScrollPosition(location2, matches) {
    if (savedScrollPositions) {
      let key = getScrollKey(location2, matches);
      let y4 = savedScrollPositions[key];
      if (typeof y4 === "number") {
        return y4;
      }
    }
    return null;
  }
  function checkFogOfWar(matches, routesToUse, pathname) {
    if (patchRoutesOnNavigationImpl) {
      if (!matches) {
        let fogMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
        return {
          active: true,
          matches: fogMatches || []
        };
      } else {
        if (Object.keys(matches[0].params).length > 0) {
          let partialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
          return {
            active: true,
            matches: partialMatches
          };
        }
      }
    }
    return {
      active: false,
      matches: null
    };
  }
  async function discoverRoutes(matches, pathname, signal, fetcherKey) {
    if (!patchRoutesOnNavigationImpl) {
      return {
        type: "success",
        matches
      };
    }
    let partialMatches = matches;
    while (true) {
      let isNonHMR = inFlightDataRoutes == null;
      let routesToUse = inFlightDataRoutes || dataRoutes;
      let localManifest = manifest;
      try {
        await patchRoutesOnNavigationImpl({
          signal,
          path: pathname,
          matches: partialMatches,
          fetcherKey,
          patch: (routeId, children) => {
            if (signal.aborted) return;
            patchRoutesImpl(routeId, children, routesToUse, localManifest, mapRouteProperties2);
          }
        });
      } catch (e3) {
        return {
          type: "error",
          error: e3,
          partialMatches
        };
      } finally {
        if (isNonHMR && !signal.aborted) {
          dataRoutes = [...dataRoutes];
        }
      }
      if (signal.aborted) {
        return {
          type: "aborted"
        };
      }
      let newMatches = matchRoutes(routesToUse, pathname, basename);
      if (newMatches) {
        return {
          type: "success",
          matches: newMatches
        };
      }
      let newPartialMatches = matchRoutesImpl(routesToUse, pathname, basename, true);
      if (!newPartialMatches || partialMatches.length === newPartialMatches.length && partialMatches.every((m4, i3) => m4.route.id === newPartialMatches[i3].route.id)) {
        return {
          type: "success",
          matches: null
        };
      }
      partialMatches = newPartialMatches;
    }
  }
  function _internalSetRoutes(newRoutes) {
    manifest = {};
    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties2, void 0, manifest);
  }
  function patchRoutes(routeId, children) {
    let isNonHMR = inFlightDataRoutes == null;
    let routesToUse = inFlightDataRoutes || dataRoutes;
    patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2);
    if (isNonHMR) {
      dataRoutes = [...dataRoutes];
      updateState({});
    }
  }
  router2 = {
    get basename() {
      return basename;
    },
    get future() {
      return future;
    },
    get state() {
      return state;
    },
    get routes() {
      return dataRoutes;
    },
    get window() {
      return routerWindow;
    },
    initialize,
    subscribe: subscribe2,
    enableScrollRestoration,
    navigate,
    fetch,
    revalidate,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (to) => init.history.createHref(to),
    encodeLocation: (to) => init.history.encodeLocation(to),
    getFetcher,
    deleteFetcher: deleteFetcherAndUpdateState,
    dispose,
    getBlocker,
    deleteBlocker,
    patchRoutes,
    _internalFetchControllers: fetchControllers,
    _internalActiveDeferreds: activeDeferreds,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes
  };
  return router2;
}
function isSubmissionNavigation(opts) {
  return opts != null && ("formData" in opts && opts.formData != null || "body" in opts && opts.body !== void 0);
}
function normalizeTo(location2, matches, basename, prependBasename, to, v7_relativeSplatPath, fromRouteId, relative) {
  let contextualMatches;
  let activeRouteMatch;
  if (fromRouteId) {
    contextualMatches = [];
    for (let match2 of matches) {
      contextualMatches.push(match2);
      if (match2.route.id === fromRouteId) {
        activeRouteMatch = match2;
        break;
      }
    }
  } else {
    contextualMatches = matches;
    activeRouteMatch = matches[matches.length - 1];
  }
  let path = resolveTo(to ? to : ".", getResolveToMatches(contextualMatches, v7_relativeSplatPath), stripBasename(location2.pathname, basename) || location2.pathname, relative === "path");
  if (to == null) {
    path.search = location2.search;
    path.hash = location2.hash;
  }
  if ((to == null || to === "" || to === ".") && activeRouteMatch) {
    let nakedIndex = hasNakedIndexQuery(path.search);
    if (activeRouteMatch.route.index && !nakedIndex) {
      path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
    } else if (!activeRouteMatch.route.index && nakedIndex) {
      let params = new URLSearchParams(path.search);
      let indexValues = params.getAll("index");
      params.delete("index");
      indexValues.filter((v2) => v2).forEach((v2) => params.append("index", v2));
      let qs = params.toString();
      path.search = qs ? "?" + qs : "";
    }
  }
  if (prependBasename && basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
function normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {
  if (!opts || !isSubmissionNavigation(opts)) {
    return {
      path
    };
  }
  if (opts.formMethod && !isValidMethod(opts.formMethod)) {
    return {
      path,
      error: getInternalRouterError(405, {
        method: opts.formMethod
      })
    };
  }
  let getInvalidBodyError = () => ({
    path,
    error: getInternalRouterError(400, {
      type: "invalid-body"
    })
  });
  let rawFormMethod = opts.formMethod || "get";
  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();
  let formAction = stripHashFromPath(path);
  if (opts.body !== void 0) {
    if (opts.formEncType === "text/plain") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      let text = typeof opts.body === "string" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(opts.body.entries()).reduce((acc, _ref3) => {
          let [name, value] = _ref3;
          return "" + acc + name + "=" + value + "\n";
        }, "")
      ) : String(opts.body);
      return {
        path,
        submission: {
          formMethod,
          formAction,
          formEncType: opts.formEncType,
          formData: void 0,
          json: void 0,
          text
        }
      };
    } else if (opts.formEncType === "application/json") {
      if (!isMutationMethod(formMethod)) {
        return getInvalidBodyError();
      }
      try {
        let json = typeof opts.body === "string" ? JSON.parse(opts.body) : opts.body;
        return {
          path,
          submission: {
            formMethod,
            formAction,
            formEncType: opts.formEncType,
            formData: void 0,
            json,
            text: void 0
          }
        };
      } catch (e3) {
        return getInvalidBodyError();
      }
    }
  }
  invariant(typeof FormData === "function", "FormData is not available in this environment");
  let searchParams;
  let formData;
  if (opts.formData) {
    searchParams = convertFormDataToSearchParams(opts.formData);
    formData = opts.formData;
  } else if (opts.body instanceof FormData) {
    searchParams = convertFormDataToSearchParams(opts.body);
    formData = opts.body;
  } else if (opts.body instanceof URLSearchParams) {
    searchParams = opts.body;
    formData = convertSearchParamsToFormData(searchParams);
  } else if (opts.body == null) {
    searchParams = new URLSearchParams();
    formData = new FormData();
  } else {
    try {
      searchParams = new URLSearchParams(opts.body);
      formData = convertSearchParamsToFormData(searchParams);
    } catch (e3) {
      return getInvalidBodyError();
    }
  }
  let submission = {
    formMethod,
    formAction,
    formEncType: opts && opts.formEncType || "application/x-www-form-urlencoded",
    formData,
    json: void 0,
    text: void 0
  };
  if (isMutationMethod(submission.formMethod)) {
    return {
      path,
      submission
    };
  }
  let parsedPath = parsePath(path);
  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {
    searchParams.append("index", "");
  }
  parsedPath.search = "?" + searchParams;
  return {
    path: createPath(parsedPath),
    submission
  };
}
function getLoaderMatchesUntilBoundary(matches, boundaryId, includeBoundary) {
  if (includeBoundary === void 0) {
    includeBoundary = false;
  }
  let index2 = matches.findIndex((m4) => m4.route.id === boundaryId);
  if (index2 >= 0) {
    return matches.slice(0, includeBoundary ? index2 + 1 : index2);
  }
  return matches;
}
function getMatchesToLoad(history, state, matches, submission, location2, initialHydration, skipActionErrorRevalidation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionResult) {
  let actionResult = pendingActionResult ? isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : pendingActionResult[1].data : void 0;
  let currentUrl = history.createURL(state.location);
  let nextUrl = history.createURL(location2);
  let boundaryMatches = matches;
  if (initialHydration && state.errors) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches, Object.keys(state.errors)[0], true);
  } else if (pendingActionResult && isErrorResult(pendingActionResult[1])) {
    boundaryMatches = getLoaderMatchesUntilBoundary(matches, pendingActionResult[0]);
  }
  let actionStatus = pendingActionResult ? pendingActionResult[1].statusCode : void 0;
  let shouldSkipRevalidation = skipActionErrorRevalidation && actionStatus && actionStatus >= 400;
  let navigationMatches = boundaryMatches.filter((match2, index2) => {
    let {
      route
    } = match2;
    if (route.lazy) {
      return true;
    }
    if (route.loader == null) {
      return false;
    }
    if (initialHydration) {
      return shouldLoadRouteOnHydration(route, state.loaderData, state.errors);
    }
    if (isNewLoader(state.loaderData, state.matches[index2], match2) || cancelledDeferredRoutes.some((id2) => id2 === match2.route.id)) {
      return true;
    }
    let currentRouteMatch = state.matches[index2];
    let nextRouteMatch = match2;
    return shouldRevalidateLoader(match2, _extends$2({
      currentUrl,
      currentParams: currentRouteMatch.params,
      nextUrl,
      nextParams: nextRouteMatch.params
    }, submission, {
      actionResult,
      actionStatus,
      defaultShouldRevalidate: shouldSkipRevalidation ? false : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        isRevalidationRequired || currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search || // Search params affect all loaders
        currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)
      )
    }));
  });
  let revalidatingFetchers = [];
  fetchLoadMatches.forEach((f2, key) => {
    if (initialHydration || !matches.some((m4) => m4.route.id === f2.routeId) || deletedFetchers.has(key)) {
      return;
    }
    let fetcherMatches = matchRoutes(routesToUse, f2.path, basename);
    if (!fetcherMatches) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let fetcher = state.fetchers.get(key);
    let fetcherMatch = getTargetMatch(fetcherMatches, f2.path);
    let shouldRevalidate = false;
    if (fetchRedirectIds.has(key)) {
      shouldRevalidate = false;
    } else if (cancelledFetcherLoads.has(key)) {
      cancelledFetcherLoads.delete(key);
      shouldRevalidate = true;
    } else if (fetcher && fetcher.state !== "idle" && fetcher.data === void 0) {
      shouldRevalidate = isRevalidationRequired;
    } else {
      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends$2({
        currentUrl,
        currentParams: state.matches[state.matches.length - 1].params,
        nextUrl,
        nextParams: matches[matches.length - 1].params
      }, submission, {
        actionResult,
        actionStatus,
        defaultShouldRevalidate: shouldSkipRevalidation ? false : isRevalidationRequired
      }));
    }
    if (shouldRevalidate) {
      revalidatingFetchers.push({
        key,
        routeId: f2.routeId,
        path: f2.path,
        matches: fetcherMatches,
        match: fetcherMatch,
        controller: new AbortController()
      });
    }
  });
  return [navigationMatches, revalidatingFetchers];
}
function shouldLoadRouteOnHydration(route, loaderData, errors) {
  if (route.lazy) {
    return true;
  }
  if (!route.loader) {
    return false;
  }
  let hasData = loaderData != null && loaderData[route.id] !== void 0;
  let hasError = errors != null && errors[route.id] !== void 0;
  if (!hasData && hasError) {
    return false;
  }
  if (typeof route.loader === "function" && route.loader.hydrate === true) {
    return true;
  }
  return !hasData && !hasError;
}
function isNewLoader(currentLoaderData, currentMatch, match2) {
  let isNew = (
    // [a] -> [a, b]
    !currentMatch || // [a, b] -> [a, c]
    match2.route.id !== currentMatch.route.id
  );
  let isMissingData = currentLoaderData[match2.route.id] === void 0;
  return isNew || isMissingData;
}
function isNewRouteInstance(currentMatch, match2) {
  let currentPath = currentMatch.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    currentMatch.pathname !== match2.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    currentPath != null && currentPath.endsWith("*") && currentMatch.params["*"] !== match2.params["*"]
  );
}
function shouldRevalidateLoader(loaderMatch, arg) {
  if (loaderMatch.route.shouldRevalidate) {
    let routeChoice = loaderMatch.route.shouldRevalidate(arg);
    if (typeof routeChoice === "boolean") {
      return routeChoice;
    }
  }
  return arg.defaultShouldRevalidate;
}
function patchRoutesImpl(routeId, children, routesToUse, manifest, mapRouteProperties2) {
  var _childrenToPatch;
  let childrenToPatch;
  if (routeId) {
    let route = manifest[routeId];
    invariant(route, "No route found to patch children into: routeId = " + routeId);
    if (!route.children) {
      route.children = [];
    }
    childrenToPatch = route.children;
  } else {
    childrenToPatch = routesToUse;
  }
  let uniqueChildren = children.filter((newRoute) => !childrenToPatch.some((existingRoute) => isSameRoute(newRoute, existingRoute)));
  let newRoutes = convertRoutesToDataRoutes(uniqueChildren, mapRouteProperties2, [routeId || "_", "patch", String(((_childrenToPatch = childrenToPatch) == null ? void 0 : _childrenToPatch.length) || "0")], manifest);
  childrenToPatch.push(...newRoutes);
}
function isSameRoute(newRoute, existingRoute) {
  if ("id" in newRoute && "id" in existingRoute && newRoute.id === existingRoute.id) {
    return true;
  }
  if (!(newRoute.index === existingRoute.index && newRoute.path === existingRoute.path && newRoute.caseSensitive === existingRoute.caseSensitive)) {
    return false;
  }
  if ((!newRoute.children || newRoute.children.length === 0) && (!existingRoute.children || existingRoute.children.length === 0)) {
    return true;
  }
  return newRoute.children.every((aChild, i3) => {
    var _existingRoute$childr;
    return (_existingRoute$childr = existingRoute.children) == null ? void 0 : _existingRoute$childr.some((bChild) => isSameRoute(aChild, bChild));
  });
}
async function loadLazyRouteModule(route, mapRouteProperties2, manifest) {
  if (!route.lazy) {
    return;
  }
  let lazyRoute = await route.lazy();
  if (!route.lazy) {
    return;
  }
  let routeToUpdate = manifest[route.id];
  invariant(routeToUpdate, "No route found in manifest");
  let routeUpdates = {};
  for (let lazyRouteProperty in lazyRoute) {
    let staticRouteValue = routeToUpdate[lazyRouteProperty];
    let isPropertyStaticallyDefined = staticRouteValue !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    lazyRouteProperty !== "hasErrorBoundary";
    warning(!isPropertyStaticallyDefined, 'Route "' + routeToUpdate.id + '" has a static property "' + lazyRouteProperty + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + lazyRouteProperty + '" will be ignored.'));
    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {
      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];
    }
  }
  Object.assign(routeToUpdate, routeUpdates);
  Object.assign(routeToUpdate, _extends$2({}, mapRouteProperties2(routeToUpdate), {
    lazy: void 0
  }));
}
async function defaultDataStrategy(_ref4) {
  let {
    matches
  } = _ref4;
  let matchesToLoad = matches.filter((m4) => m4.shouldLoad);
  let results = await Promise.all(matchesToLoad.map((m4) => m4.resolve()));
  return results.reduce((acc, result, i3) => Object.assign(acc, {
    [matchesToLoad[i3].route.id]: result
  }), {});
}
async function callDataStrategyImpl(dataStrategyImpl, type, state, request, matchesToLoad, matches, fetcherKey, manifest, mapRouteProperties2, requestContext) {
  let loadRouteDefinitionsPromises = matches.map((m4) => m4.route.lazy ? loadLazyRouteModule(m4.route, mapRouteProperties2, manifest) : void 0);
  let dsMatches = matches.map((match2, i3) => {
    let loadRoutePromise = loadRouteDefinitionsPromises[i3];
    let shouldLoad = matchesToLoad.some((m4) => m4.route.id === match2.route.id);
    let resolve = async (handlerOverride) => {
      if (handlerOverride && request.method === "GET" && (match2.route.lazy || match2.route.loader)) {
        shouldLoad = true;
      }
      return shouldLoad ? callLoaderOrAction(type, request, match2, loadRoutePromise, handlerOverride, requestContext) : Promise.resolve({
        type: ResultType.data,
        result: void 0
      });
    };
    return _extends$2({}, match2, {
      shouldLoad,
      resolve
    });
  });
  let results = await dataStrategyImpl({
    matches: dsMatches,
    request,
    params: matches[0].params,
    fetcherKey,
    context: requestContext
  });
  try {
    await Promise.all(loadRouteDefinitionsPromises);
  } catch (e3) {
  }
  return results;
}
async function callLoaderOrAction(type, request, match2, loadRoutePromise, handlerOverride, staticContext) {
  let result;
  let onReject;
  let runHandler = (handler) => {
    let reject;
    let abortPromise = new Promise((_2, r2) => reject = r2);
    onReject = () => reject();
    request.signal.addEventListener("abort", onReject);
    let actualHandler = (ctx) => {
      if (typeof handler !== "function") {
        return Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + type + '" [routeId: ' + match2.route.id + "]")));
      }
      return handler({
        request,
        params: match2.params,
        context: staticContext
      }, ...ctx !== void 0 ? [ctx] : []);
    };
    let handlerPromise = (async () => {
      try {
        let val = await (handlerOverride ? handlerOverride((ctx) => actualHandler(ctx)) : actualHandler());
        return {
          type: "data",
          result: val
        };
      } catch (e3) {
        return {
          type: "error",
          result: e3
        };
      }
    })();
    return Promise.race([handlerPromise, abortPromise]);
  };
  try {
    let handler = match2.route[type];
    if (loadRoutePromise) {
      if (handler) {
        let handlerError;
        let [value] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          runHandler(handler).catch((e3) => {
            handlerError = e3;
          }),
          loadRoutePromise
        ]);
        if (handlerError !== void 0) {
          throw handlerError;
        }
        result = value;
      } else {
        await loadRoutePromise;
        handler = match2.route[type];
        if (handler) {
          result = await runHandler(handler);
        } else if (type === "action") {
          let url2 = new URL(request.url);
          let pathname = url2.pathname + url2.search;
          throw getInternalRouterError(405, {
            method: request.method,
            pathname,
            routeId: match2.route.id
          });
        } else {
          return {
            type: ResultType.data,
            result: void 0
          };
        }
      }
    } else if (!handler) {
      let url2 = new URL(request.url);
      let pathname = url2.pathname + url2.search;
      throw getInternalRouterError(404, {
        pathname
      });
    } else {
      result = await runHandler(handler);
    }
    invariant(result.result !== void 0, "You defined " + (type === "action" ? "an action" : "a loader") + " for route " + ('"' + match2.route.id + "\" but didn't return anything from your `" + type + "` ") + "function. Please return a value or `null`.");
  } catch (e3) {
    return {
      type: ResultType.error,
      result: e3
    };
  } finally {
    if (onReject) {
      request.signal.removeEventListener("abort", onReject);
    }
  }
  return result;
}
async function convertDataStrategyResultToDataResult(dataStrategyResult) {
  let {
    result,
    type
  } = dataStrategyResult;
  if (isResponse(result)) {
    let data;
    try {
      let contentType = result.headers.get("Content-Type");
      if (contentType && /\bapplication\/json\b/.test(contentType)) {
        if (result.body == null) {
          data = null;
        } else {
          data = await result.json();
        }
      } else {
        data = await result.text();
      }
    } catch (e3) {
      return {
        type: ResultType.error,
        error: e3
      };
    }
    if (type === ResultType.error) {
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(result.status, result.statusText, data),
        statusCode: result.status,
        headers: result.headers
      };
    }
    return {
      type: ResultType.data,
      data,
      statusCode: result.status,
      headers: result.headers
    };
  }
  if (type === ResultType.error) {
    if (isDataWithResponseInit(result)) {
      var _result$init3, _result$init4;
      if (result.data instanceof Error) {
        var _result$init, _result$init2;
        return {
          type: ResultType.error,
          error: result.data,
          statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,
          headers: (_result$init2 = result.init) != null && _result$init2.headers ? new Headers(result.init.headers) : void 0
        };
      }
      return {
        type: ResultType.error,
        error: new ErrorResponseImpl(((_result$init3 = result.init) == null ? void 0 : _result$init3.status) || 500, void 0, result.data),
        statusCode: isRouteErrorResponse(result) ? result.status : void 0,
        headers: (_result$init4 = result.init) != null && _result$init4.headers ? new Headers(result.init.headers) : void 0
      };
    }
    return {
      type: ResultType.error,
      error: result,
      statusCode: isRouteErrorResponse(result) ? result.status : void 0
    };
  }
  if (isDeferredData(result)) {
    var _result$init5, _result$init6;
    return {
      type: ResultType.deferred,
      deferredData: result,
      statusCode: (_result$init5 = result.init) == null ? void 0 : _result$init5.status,
      headers: ((_result$init6 = result.init) == null ? void 0 : _result$init6.headers) && new Headers(result.init.headers)
    };
  }
  if (isDataWithResponseInit(result)) {
    var _result$init7, _result$init8;
    return {
      type: ResultType.data,
      data: result.data,
      statusCode: (_result$init7 = result.init) == null ? void 0 : _result$init7.status,
      headers: (_result$init8 = result.init) != null && _result$init8.headers ? new Headers(result.init.headers) : void 0
    };
  }
  return {
    type: ResultType.data,
    data: result
  };
}
function normalizeRelativeRoutingRedirectResponse(response, request, routeId, matches, basename, v7_relativeSplatPath) {
  let location2 = response.headers.get("Location");
  invariant(location2, "Redirects returned/thrown from loaders/actions must have a Location header");
  if (!ABSOLUTE_URL_REGEX$1.test(location2)) {
    let trimmedMatches = matches.slice(0, matches.findIndex((m4) => m4.route.id === routeId) + 1);
    location2 = normalizeTo(new URL(request.url), trimmedMatches, basename, true, location2, v7_relativeSplatPath);
    response.headers.set("Location", location2);
  }
  return response;
}
function normalizeRedirectLocation(location2, currentUrl, basename) {
  if (ABSOLUTE_URL_REGEX$1.test(location2)) {
    let normalizedLocation = location2;
    let url2 = normalizedLocation.startsWith("//") ? new URL(currentUrl.protocol + normalizedLocation) : new URL(normalizedLocation);
    let isSameBasename = stripBasename(url2.pathname, basename) != null;
    if (url2.origin === currentUrl.origin && isSameBasename) {
      return url2.pathname + url2.search + url2.hash;
    }
  }
  return location2;
}
function createClientSideRequest(history, location2, signal, submission) {
  let url2 = history.createURL(stripHashFromPath(location2)).toString();
  let init = {
    signal
  };
  if (submission && isMutationMethod(submission.formMethod)) {
    let {
      formMethod,
      formEncType
    } = submission;
    init.method = formMethod.toUpperCase();
    if (formEncType === "application/json") {
      init.headers = new Headers({
        "Content-Type": formEncType
      });
      init.body = JSON.stringify(submission.json);
    } else if (formEncType === "text/plain") {
      init.body = submission.text;
    } else if (formEncType === "application/x-www-form-urlencoded" && submission.formData) {
      init.body = convertFormDataToSearchParams(submission.formData);
    } else {
      init.body = submission.formData;
    }
  }
  return new Request(url2, init);
}
function convertFormDataToSearchParams(formData) {
  let searchParams = new URLSearchParams();
  for (let [key, value] of formData.entries()) {
    searchParams.append(key, typeof value === "string" ? value : value.name);
  }
  return searchParams;
}
function convertSearchParamsToFormData(searchParams) {
  let formData = new FormData();
  for (let [key, value] of searchParams.entries()) {
    formData.append(key, value);
  }
  return formData;
}
function processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds, skipLoaderErrorBubbling) {
  let loaderData = {};
  let errors = null;
  let statusCode;
  let foundError = false;
  let loaderHeaders = {};
  let pendingError = pendingActionResult && isErrorResult(pendingActionResult[1]) ? pendingActionResult[1].error : void 0;
  matches.forEach((match2) => {
    if (!(match2.route.id in results)) {
      return;
    }
    let id2 = match2.route.id;
    let result = results[id2];
    invariant(!isRedirectResult(result), "Cannot handle redirect results in processLoaderData");
    if (isErrorResult(result)) {
      let error = result.error;
      if (pendingError !== void 0) {
        error = pendingError;
        pendingError = void 0;
      }
      errors = errors || {};
      {
        let boundaryMatch = findNearestBoundary(matches, id2);
        if (errors[boundaryMatch.route.id] == null) {
          errors[boundaryMatch.route.id] = error;
        }
      }
      loaderData[id2] = void 0;
      if (!foundError) {
        foundError = true;
        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;
      }
      if (result.headers) {
        loaderHeaders[id2] = result.headers;
      }
    } else {
      if (isDeferredResult(result)) {
        activeDeferreds.set(id2, result.deferredData);
        loaderData[id2] = result.deferredData.data;
        if (result.statusCode != null && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      } else {
        loaderData[id2] = result.data;
        if (result.statusCode && result.statusCode !== 200 && !foundError) {
          statusCode = result.statusCode;
        }
        if (result.headers) {
          loaderHeaders[id2] = result.headers;
        }
      }
    }
  });
  if (pendingError !== void 0 && pendingActionResult) {
    errors = {
      [pendingActionResult[0]]: pendingError
    };
    loaderData[pendingActionResult[0]] = void 0;
  }
  return {
    loaderData,
    errors,
    statusCode: statusCode || 200,
    loaderHeaders
  };
}
function processLoaderData(state, matches, results, pendingActionResult, revalidatingFetchers, fetcherResults, activeDeferreds) {
  let {
    loaderData,
    errors
  } = processRouteLoaderData(matches, results, pendingActionResult, activeDeferreds);
  revalidatingFetchers.forEach((rf2) => {
    let {
      key,
      match: match2,
      controller
    } = rf2;
    let result = fetcherResults[key];
    invariant(result, "Did not find corresponding fetcher result");
    if (controller && controller.signal.aborted) {
      return;
    } else if (isErrorResult(result)) {
      let boundaryMatch = findNearestBoundary(state.matches, match2 == null ? void 0 : match2.route.id);
      if (!(errors && errors[boundaryMatch.route.id])) {
        errors = _extends$2({}, errors, {
          [boundaryMatch.route.id]: result.error
        });
      }
      state.fetchers.delete(key);
    } else if (isRedirectResult(result)) {
      invariant(false, "Unhandled fetcher revalidation redirect");
    } else if (isDeferredResult(result)) {
      invariant(false, "Unhandled fetcher deferred data");
    } else {
      let doneFetcher = getDoneFetcher(result.data);
      state.fetchers.set(key, doneFetcher);
    }
  });
  return {
    loaderData,
    errors
  };
}
function mergeLoaderData(loaderData, newLoaderData, matches, errors) {
  let mergedLoaderData = _extends$2({}, newLoaderData);
  for (let match2 of matches) {
    let id2 = match2.route.id;
    if (newLoaderData.hasOwnProperty(id2)) {
      if (newLoaderData[id2] !== void 0) {
        mergedLoaderData[id2] = newLoaderData[id2];
      }
    } else if (loaderData[id2] !== void 0 && match2.route.loader) {
      mergedLoaderData[id2] = loaderData[id2];
    }
    if (errors && errors.hasOwnProperty(id2)) {
      break;
    }
  }
  return mergedLoaderData;
}
function getActionDataForCommit(pendingActionResult) {
  if (!pendingActionResult) {
    return {};
  }
  return isErrorResult(pendingActionResult[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [pendingActionResult[0]]: pendingActionResult[1].data
    }
  };
}
function findNearestBoundary(matches, routeId) {
  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex((m4) => m4.route.id === routeId) + 1) : [...matches];
  return eligibleMatches.reverse().find((m4) => m4.route.hasErrorBoundary === true) || matches[0];
}
function getShortCircuitMatches(routes) {
  let route = routes.length === 1 ? routes[0] : routes.find((r2) => r2.index || !r2.path || r2.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route
    }],
    route
  };
}
function getInternalRouterError(status, _temp5) {
  let {
    pathname,
    routeId,
    method,
    type,
    message
  } = _temp5 === void 0 ? {} : _temp5;
  let statusText = "Unknown Server Error";
  let errorMessage = "Unknown @remix-run/router error";
  if (status === 400) {
    statusText = "Bad Request";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method + ' request to "' + pathname + '" but ' + ('did not provide a `loader` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (type === "defer-action") {
      errorMessage = "defer() is not supported in actions";
    } else if (type === "invalid-body") {
      errorMessage = "Unable to encode submission body";
    }
  } else if (status === 403) {
    statusText = "Forbidden";
    errorMessage = 'Route "' + routeId + '" does not match URL "' + pathname + '"';
  } else if (status === 404) {
    statusText = "Not Found";
    errorMessage = 'No route matches URL "' + pathname + '"';
  } else if (status === 405) {
    statusText = "Method Not Allowed";
    if (method && pathname && routeId) {
      errorMessage = "You made a " + method.toUpperCase() + ' request to "' + pathname + '" but ' + ('did not provide an `action` for route "' + routeId + '", ') + "so there is no way to handle the request.";
    } else if (method) {
      errorMessage = 'Invalid request method "' + method.toUpperCase() + '"';
    }
  }
  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);
}
function findRedirect(results) {
  let entries = Object.entries(results);
  for (let i3 = entries.length - 1; i3 >= 0; i3--) {
    let [key, result] = entries[i3];
    if (isRedirectResult(result)) {
      return {
        key,
        result
      };
    }
  }
}
function stripHashFromPath(path) {
  let parsedPath = typeof path === "string" ? parsePath(path) : path;
  return createPath(_extends$2({}, parsedPath, {
    hash: ""
  }));
}
function isHashChangeOnly(a4, b2) {
  if (a4.pathname !== b2.pathname || a4.search !== b2.search) {
    return false;
  }
  if (a4.hash === "") {
    return b2.hash !== "";
  } else if (a4.hash === b2.hash) {
    return true;
  } else if (b2.hash !== "") {
    return true;
  }
  return false;
}
function isRedirectDataStrategyResultResult(result) {
  return isResponse(result.result) && redirectStatusCodes.has(result.result.status);
}
function isDeferredResult(result) {
  return result.type === ResultType.deferred;
}
function isErrorResult(result) {
  return result.type === ResultType.error;
}
function isRedirectResult(result) {
  return (result && result.type) === ResultType.redirect;
}
function isDataWithResponseInit(value) {
  return typeof value === "object" && value != null && "type" in value && "data" in value && "init" in value && value.type === "DataWithResponseInit";
}
function isDeferredData(value) {
  let deferred = value;
  return deferred && typeof deferred === "object" && typeof deferred.data === "object" && typeof deferred.subscribe === "function" && typeof deferred.cancel === "function" && typeof deferred.resolveData === "function";
}
function isResponse(value) {
  return value != null && typeof value.status === "number" && typeof value.statusText === "string" && typeof value.headers === "object" && typeof value.body !== "undefined";
}
function isValidMethod(method) {
  return validRequestMethods.has(method.toLowerCase());
}
function isMutationMethod(method) {
  return validMutationMethods.has(method.toLowerCase());
}
async function resolveNavigationDeferredResults(matches, results, signal, currentMatches, currentLoaderData) {
  let entries = Object.entries(results);
  for (let index2 = 0; index2 < entries.length; index2++) {
    let [routeId, result] = entries[index2];
    let match2 = matches.find((m4) => (m4 == null ? void 0 : m4.route.id) === routeId);
    if (!match2) {
      continue;
    }
    let currentMatch = currentMatches.find((m4) => m4.route.id === match2.route.id);
    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match2) && (currentLoaderData && currentLoaderData[match2.route.id]) !== void 0;
    if (isDeferredResult(result) && isRevalidatingLoader) {
      await resolveDeferredData(result, signal, false).then((result2) => {
        if (result2) {
          results[routeId] = result2;
        }
      });
    }
  }
}
async function resolveFetcherDeferredResults(matches, results, revalidatingFetchers) {
  for (let index2 = 0; index2 < revalidatingFetchers.length; index2++) {
    let {
      key,
      routeId,
      controller
    } = revalidatingFetchers[index2];
    let result = results[key];
    let match2 = matches.find((m4) => (m4 == null ? void 0 : m4.route.id) === routeId);
    if (!match2) {
      continue;
    }
    if (isDeferredResult(result)) {
      invariant(controller, "Expected an AbortController for revalidating fetcher deferred result");
      await resolveDeferredData(result, controller.signal, true).then((result2) => {
        if (result2) {
          results[key] = result2;
        }
      });
    }
  }
}
async function resolveDeferredData(result, signal, unwrap) {
  if (unwrap === void 0) {
    unwrap = false;
  }
  let aborted = await result.deferredData.resolveData(signal);
  if (aborted) {
    return;
  }
  if (unwrap) {
    try {
      return {
        type: ResultType.data,
        data: result.deferredData.unwrappedData
      };
    } catch (e3) {
      return {
        type: ResultType.error,
        error: e3
      };
    }
  }
  return {
    type: ResultType.data,
    data: result.deferredData.data
  };
}
function hasNakedIndexQuery(search) {
  return new URLSearchParams(search).getAll("index").some((v2) => v2 === "");
}
function getTargetMatch(matches, location2) {
  let search = typeof location2 === "string" ? parsePath(location2).search : location2.search;
  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || "")) {
    return matches[matches.length - 1];
  }
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches[pathMatches.length - 1];
}
function getSubmissionFromNavigation(navigation) {
  let {
    formMethod,
    formAction,
    formEncType,
    text,
    formData,
    json
  } = navigation;
  if (!formMethod || !formAction || !formEncType) {
    return;
  }
  if (text != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json: void 0,
      text
    };
  } else if (formData != null) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData,
      json: void 0,
      text: void 0
    };
  } else if (json !== void 0) {
    return {
      formMethod,
      formAction,
      formEncType,
      formData: void 0,
      json,
      text: void 0
    };
  }
}
function getLoadingNavigation(location2, submission) {
  if (submission) {
    let navigation = {
      state: "loading",
      location: location2,
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text
    };
    return navigation;
  } else {
    let navigation = {
      state: "loading",
      location: location2,
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0
    };
    return navigation;
  }
}
function getSubmittingNavigation(location2, submission) {
  let navigation = {
    state: "submitting",
    location: location2,
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text
  };
  return navigation;
}
function getLoadingFetcher(submission, data) {
  if (submission) {
    let fetcher = {
      state: "loading",
      formMethod: submission.formMethod,
      formAction: submission.formAction,
      formEncType: submission.formEncType,
      formData: submission.formData,
      json: submission.json,
      text: submission.text,
      data
    };
    return fetcher;
  } else {
    let fetcher = {
      state: "loading",
      formMethod: void 0,
      formAction: void 0,
      formEncType: void 0,
      formData: void 0,
      json: void 0,
      text: void 0,
      data
    };
    return fetcher;
  }
}
function getSubmittingFetcher(submission, existingFetcher) {
  let fetcher = {
    state: "submitting",
    formMethod: submission.formMethod,
    formAction: submission.formAction,
    formEncType: submission.formEncType,
    formData: submission.formData,
    json: submission.json,
    text: submission.text,
    data: existingFetcher ? existingFetcher.data : void 0
  };
  return fetcher;
}
function getDoneFetcher(data) {
  let fetcher = {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data
  };
  return fetcher;
}
function restoreAppliedTransitions(_window, transitions) {
  try {
    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);
    if (sessionPositions) {
      let json = JSON.parse(sessionPositions);
      for (let [k3, v2] of Object.entries(json || {})) {
        if (v2 && Array.isArray(v2)) {
          transitions.set(k3, new Set(v2 || []));
        }
      }
    }
  } catch (e3) {
  }
}
function persistAppliedTransitions(_window, transitions) {
  if (transitions.size > 0) {
    let json = {};
    for (let [k3, v2] of transitions) {
      json[k3] = [...v2];
    }
    try {
      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));
    } catch (error) {
      warning(false, "Failed to save applied view transitions in sessionStorage (" + error + ").");
    }
  }
}
/**
 * React Router v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
const DataRouterContext = /* @__PURE__ */ reactExports.createContext(null);
const DataRouterStateContext = /* @__PURE__ */ reactExports.createContext(null);
const NavigationContext = /* @__PURE__ */ reactExports.createContext(null);
const LocationContext = /* @__PURE__ */ reactExports.createContext(null);
const RouteContext = /* @__PURE__ */ reactExports.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
const RouteErrorContext = /* @__PURE__ */ reactExports.createContext(null);
function useHref(to, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    hash,
    pathname,
    search
  } = useResolvedPath(to, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash
  });
}
function useInRouterContext() {
  return reactExports.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? invariant(false) : void 0;
  return reactExports.useContext(LocationContext).location;
}
function useIsomorphicLayoutEffect$3(cb2) {
  let isStatic = reactExports.useContext(NavigationContext).static;
  if (!isStatic) {
    reactExports.useLayoutEffect(cb2);
  }
}
function useNavigate() {
  let {
    isDataRoute
  } = reactExports.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  !useInRouterContext() ? invariant(false) : void 0;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  let {
    basename,
    future,
    navigator: navigator2
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      navigator2.go(to);
      return;
    }
    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (dataRouterContext == null && basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname, dataRouterContext]);
  return navigate;
}
function useResolvedPath(to, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    future
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches, future.v7_relativeSplatPath));
  return reactExports.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  return useRoutesImpl(routes, locationArg);
}
function useRoutesImpl(routes, locationArg, dataRouterState, future) {
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    navigator: navigator2,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches: parentMatches
  } = reactExports.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  routeMatch && routeMatch.route;
  let locationFromContext = useLocation();
  let location2;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? invariant(false) : void 0;
    location2 = parsedLocationArg;
  } else {
    location2 = locationFromContext;
  }
  let pathname = location2.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = !isStatic && dataRouterState && dataRouterState.matches && dataRouterState.matches.length > 0 ? dataRouterState.matches : matchRoutes(routes, {
    pathname: remainingPathname
  });
  let renderedMatches = _renderMatches(matches && matches.map((match2) => Object.assign({}, match2, {
    params: Object.assign({}, parentParams, match2.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathname).pathname : match2.pathname
    ]),
    pathnameBase: match2.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match2.pathnameBase).pathname : match2.pathnameBase
    ])
  })), parentMatches, dataRouterState, future);
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
      value: {
        location: _extends$1({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location2),
        navigationType: Action$3.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error = useRouteError();
  let message = isRouteErrorResponse(error) ? error.status + " " + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);
  let stack = error instanceof Error ? error.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ reactExports.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? /* @__PURE__ */ reactExports.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
const defaultErrorElement = /* @__PURE__ */ reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error, errorInfo) {
    console.error("React Router caught the following error during render", error, errorInfo);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ reactExports.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match2,
    children
  } = _ref;
  let dataRouterContext = reactExports.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match2.route.errorElement || match2.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match2.route.id;
  }
  return /* @__PURE__ */ reactExports.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState, future) {
  var _dataRouterState;
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (dataRouterState === void 0) {
    dataRouterState = null;
  }
  if (future === void 0) {
    future = null;
  }
  if (matches == null) {
    var _future;
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if ((_future = future) != null && _future.v7_partialHydration && parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = (_dataRouterState = dataRouterState) == null ? void 0 : _dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m4) => m4.route.id && (errors == null ? void 0 : errors[m4.route.id]) !== void 0);
    !(errorIndex >= 0) ? invariant(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState && future && future.v7_partialHydration) {
    for (let i3 = 0; i3 < renderedMatches.length; i3++) {
      let match2 = renderedMatches[i3];
      if (match2.route.HydrateFallback || match2.route.hydrateFallbackElement) {
        fallbackIndex = i3;
      }
      if (match2.route.id) {
        let {
          loaderData,
          errors: errors2
        } = dataRouterState;
        let needsToRunLoader = match2.route.loader && loaderData[match2.route.id] === void 0 && (!errors2 || errors2[match2.route.id] === void 0);
        if (match2.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  return renderedMatches.reduceRight((outlet, match2, index2) => {
    let error;
    let shouldRenderHydrateFallback = false;
    let errorElement = null;
    let hydrateFallbackElement = null;
    if (dataRouterState) {
      error = errors && match2.route.id ? errors[match2.route.id] : void 0;
      errorElement = match2.route.errorElement || defaultErrorElement;
      if (renderFallback) {
        if (fallbackIndex < 0 && index2 === 0) {
          warningOnce("route-fallback");
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = null;
        } else if (fallbackIndex === index2) {
          shouldRenderHydrateFallback = true;
          hydrateFallbackElement = match2.route.hydrateFallbackElement || null;
        }
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren = () => {
      let children;
      if (error) {
        children = errorElement;
      } else if (shouldRenderHydrateFallback) {
        children = hydrateFallbackElement;
      } else if (match2.route.Component) {
        children = /* @__PURE__ */ reactExports.createElement(match2.route.Component, null);
      } else if (match2.route.element) {
        children = match2.route.element;
      } else {
        children = outlet;
      }
      return /* @__PURE__ */ reactExports.createElement(RenderedRoute, {
        match: match2,
        routeContext: {
          outlet,
          matches: matches2,
          isDataRoute: dataRouterState != null
        },
        children
      });
    };
    return dataRouterState && (match2.route.ErrorBoundary || match2.route.errorElement || index2 === 0) ? /* @__PURE__ */ reactExports.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      revalidation: dataRouterState.revalidation,
      component: errorElement,
      error,
      children: getChildren(),
      routeContext: {
        outlet: null,
        matches: matches2,
        isDataRoute: true
      }
    }) : getChildren();
  }, null);
}
var DataRouterHook$1 = /* @__PURE__ */ function(DataRouterHook2) {
  DataRouterHook2["UseBlocker"] = "useBlocker";
  DataRouterHook2["UseRevalidator"] = "useRevalidator";
  DataRouterHook2["UseNavigateStable"] = "useNavigate";
  return DataRouterHook2;
}(DataRouterHook$1 || {});
var DataRouterStateHook$1 = /* @__PURE__ */ function(DataRouterStateHook2) {
  DataRouterStateHook2["UseBlocker"] = "useBlocker";
  DataRouterStateHook2["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook2["UseActionData"] = "useActionData";
  DataRouterStateHook2["UseRouteError"] = "useRouteError";
  DataRouterStateHook2["UseNavigation"] = "useNavigation";
  DataRouterStateHook2["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook2["UseMatches"] = "useMatches";
  DataRouterStateHook2["UseRevalidator"] = "useRevalidator";
  DataRouterStateHook2["UseNavigateStable"] = "useNavigate";
  DataRouterStateHook2["UseRouteId"] = "useRouteId";
  return DataRouterStateHook2;
}(DataRouterStateHook$1 || {});
function useDataRouterContext(hookName) {
  let ctx = reactExports.useContext(DataRouterContext);
  !ctx ? invariant(false) : void 0;
  return ctx;
}
function useDataRouterState(hookName) {
  let state = reactExports.useContext(DataRouterStateContext);
  !state ? invariant(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = reactExports.useContext(RouteContext);
  !route ? invariant(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext();
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? invariant(false) : void 0;
  return thisRoute.route.id;
}
function useRouteError() {
  var _state$errors;
  let error = reactExports.useContext(RouteErrorContext);
  let state = useDataRouterState();
  let routeId = useCurrentRouteId();
  if (error !== void 0) {
    return error;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
function useNavigateStable() {
  let {
    router: router2
  } = useDataRouterContext(DataRouterHook$1.UseNavigateStable);
  let id2 = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable);
  let activeRef = reactExports.useRef(false);
  useIsomorphicLayoutEffect$3(() => {
    activeRef.current = true;
  });
  let navigate = reactExports.useCallback(function(to, options) {
    if (options === void 0) {
      options = {};
    }
    if (!activeRef.current) return;
    if (typeof to === "number") {
      router2.navigate(to);
    } else {
      router2.navigate(to, _extends$1({
        fromRouteId: id2
      }, options));
    }
  }, [router2, id2]);
  return navigate;
}
const alreadyWarned$1 = {};
function warningOnce(key, cond, message) {
  if (!alreadyWarned$1[key]) {
    alreadyWarned$1[key] = true;
  }
}
function logV6DeprecationWarnings(renderFuture, routerFuture) {
  if ((renderFuture == null ? void 0 : renderFuture.v7_startTransition) === void 0) ;
  if ((renderFuture == null ? void 0 : renderFuture.v7_relativeSplatPath) === void 0 && (!routerFuture || !routerFuture.v7_relativeSplatPath)) ;
  if (routerFuture) {
    if (routerFuture.v7_fetcherPersist === void 0) ;
    if (routerFuture.v7_normalizeFormMethod === void 0) ;
    if (routerFuture.v7_partialHydration === void 0) ;
    if (routerFuture.v7_skipActionErrorRevalidation === void 0) ;
  }
}
function Navigate(_ref4) {
  let {
    to,
    replace: replace2,
    state,
    relative
  } = _ref4;
  !useInRouterContext() ? invariant(false) : void 0;
  let {
    future,
    static: isStatic
  } = reactExports.useContext(NavigationContext);
  let {
    matches
  } = reactExports.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let navigate = useNavigate();
  let path = resolveTo(to, getResolveToMatches(matches, future.v7_relativeSplatPath), locationPathname, relative === "path");
  let jsonPath = JSON.stringify(path);
  reactExports.useEffect(() => navigate(JSON.parse(jsonPath), {
    replace: replace2,
    state,
    relative
  }), [navigate, jsonPath, relative, replace2, state]);
  return null;
}
function Route(_props) {
  invariant(false);
}
function Router(_ref5) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action$3.Pop,
    navigator: navigator2,
    static: staticProp = false,
    future
  } = _ref5;
  !!useInRouterContext() ? invariant(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = reactExports.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp,
    future: _extends$1({
      v7_relativeSplatPath: false
    }, future)
  }), [basename, future, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = reactExports.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ reactExports.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, /* @__PURE__ */ reactExports.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref6) {
  let {
    children,
    location: location2
  } = _ref6;
  return useRoutes(createRoutesFromChildren(children), location2);
}
new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  reactExports.Children.forEach(children, (element, index2) => {
    if (!/* @__PURE__ */ reactExports.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === reactExports.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? invariant(false) : void 0;
    !(!element.props.index || !element.props.children) ? invariant(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}
function mapRouteProperties(route) {
  let updates = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null
  };
  if (route.Component) {
    Object.assign(updates, {
      element: /* @__PURE__ */ reactExports.createElement(route.Component),
      Component: void 0
    });
  }
  if (route.HydrateFallback) {
    Object.assign(updates, {
      hydrateFallbackElement: /* @__PURE__ */ reactExports.createElement(route.HydrateFallback),
      HydrateFallback: void 0
    });
  }
  if (route.ErrorBoundary) {
    Object.assign(updates, {
      errorElement: /* @__PURE__ */ reactExports.createElement(route.ErrorBoundary),
      ErrorBoundary: void 0
    });
  }
  return updates;
}
/**
 * React Router DOM v6.30.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i3 = 1; i3 < arguments.length; i3++) {
      var source = arguments[i3];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i3;
  for (i3 = 0; i3 < sourceKeys.length; i3++) {
    key = sourceKeys[i3];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {
    let value = init[key];
    return memo.concat(Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_2, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
const REACT_ROUTER_VERSION = "6";
try {
  window.__reactRouterVersion = REACT_ROUTER_VERSION;
} catch (e3) {
}
function createBrowserRouter(routes, opts) {
  return createRouter({
    basename: void 0,
    future: _extends({}, void 0, {
      v7_prependBasename: true
    }),
    history: createBrowserHistory({
      window: void 0
    }),
    hydrationData: parseHydrationData(),
    routes,
    mapRouteProperties,
    dataStrategy: void 0,
    patchRoutesOnNavigation: void 0,
    window: void 0
  }).initialize();
}
function parseHydrationData() {
  var _window;
  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;
  if (state && state.errors) {
    state = _extends({}, state, {
      errors: deserializeErrors(state.errors)
    });
  }
  return state;
}
function deserializeErrors(errors) {
  if (!errors) return null;
  let entries = Object.entries(errors);
  let serialized = {};
  for (let [key, val] of entries) {
    if (val && val.__type === "RouteErrorResponse") {
      serialized[key] = new ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);
    } else if (val && val.__type === "Error") {
      if (val.__subType) {
        let ErrorConstructor = window[val.__subType];
        if (typeof ErrorConstructor === "function") {
          try {
            let error = new ErrorConstructor(val.message);
            error.stack = "";
            serialized[key] = error;
          } catch (e3) {
          }
        }
      }
      if (serialized[key] == null) {
        let error = new Error(val.message);
        error.stack = "";
        serialized[key] = error;
      }
    } else {
      serialized[key] = val;
    }
  }
  return serialized;
}
const ViewTransitionContext = /* @__PURE__ */ reactExports.createContext({
  isTransitioning: false
});
const FetchersContext = /* @__PURE__ */ reactExports.createContext(/* @__PURE__ */ new Map());
const START_TRANSITION = "startTransition";
const startTransitionImpl = React$2[START_TRANSITION];
const FLUSH_SYNC = "flushSync";
const flushSyncImpl = ReactDOM$1[FLUSH_SYNC];
function startTransitionSafe(cb2) {
  if (startTransitionImpl) {
    startTransitionImpl(cb2);
  } else {
    cb2();
  }
}
function flushSyncSafe(cb2) {
  if (flushSyncImpl) {
    flushSyncImpl(cb2);
  } else {
    cb2();
  }
}
class Deferred {
  constructor() {
    this.status = "pending";
    this.promise = new Promise((resolve, reject) => {
      this.resolve = (value) => {
        if (this.status === "pending") {
          this.status = "resolved";
          resolve(value);
        }
      };
      this.reject = (reason) => {
        if (this.status === "pending") {
          this.status = "rejected";
          reject(reason);
        }
      };
    });
  }
}
function RouterProvider(_ref) {
  let {
    fallbackElement,
    router: router2,
    future
  } = _ref;
  let [state, setStateImpl] = reactExports.useState(router2.state);
  let [pendingState, setPendingState] = reactExports.useState();
  let [vtContext, setVtContext] = reactExports.useState({
    isTransitioning: false
  });
  let [renderDfd, setRenderDfd] = reactExports.useState();
  let [transition, setTransition] = reactExports.useState();
  let [interruption, setInterruption] = reactExports.useState();
  let fetcherData = reactExports.useRef(/* @__PURE__ */ new Map());
  let {
    v7_startTransition
  } = future || {};
  let optInStartTransition = reactExports.useCallback((cb2) => {
    if (v7_startTransition) {
      startTransitionSafe(cb2);
    } else {
      cb2();
    }
  }, [v7_startTransition]);
  let setState = reactExports.useCallback((newState, _ref2) => {
    let {
      deletedFetchers,
      flushSync,
      viewTransitionOpts
    } = _ref2;
    newState.fetchers.forEach((fetcher, key) => {
      if (fetcher.data !== void 0) {
        fetcherData.current.set(key, fetcher.data);
      }
    });
    deletedFetchers.forEach((key) => fetcherData.current.delete(key));
    let isViewTransitionUnavailable = router2.window == null || router2.window.document == null || typeof router2.window.document.startViewTransition !== "function";
    if (!viewTransitionOpts || isViewTransitionUnavailable) {
      if (flushSync) {
        flushSyncSafe(() => setStateImpl(newState));
      } else {
        optInStartTransition(() => setStateImpl(newState));
      }
      return;
    }
    if (flushSync) {
      flushSyncSafe(() => {
        if (transition) {
          renderDfd && renderDfd.resolve();
          transition.skipTransition();
        }
        setVtContext({
          isTransitioning: true,
          flushSync: true,
          currentLocation: viewTransitionOpts.currentLocation,
          nextLocation: viewTransitionOpts.nextLocation
        });
      });
      let t3 = router2.window.document.startViewTransition(() => {
        flushSyncSafe(() => setStateImpl(newState));
      });
      t3.finished.finally(() => {
        flushSyncSafe(() => {
          setRenderDfd(void 0);
          setTransition(void 0);
          setPendingState(void 0);
          setVtContext({
            isTransitioning: false
          });
        });
      });
      flushSyncSafe(() => setTransition(t3));
      return;
    }
    if (transition) {
      renderDfd && renderDfd.resolve();
      transition.skipTransition();
      setInterruption({
        state: newState,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    } else {
      setPendingState(newState);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: viewTransitionOpts.currentLocation,
        nextLocation: viewTransitionOpts.nextLocation
      });
    }
  }, [router2.window, transition, renderDfd, fetcherData, optInStartTransition]);
  reactExports.useLayoutEffect(() => router2.subscribe(setState), [router2, setState]);
  reactExports.useEffect(() => {
    if (vtContext.isTransitioning && !vtContext.flushSync) {
      setRenderDfd(new Deferred());
    }
  }, [vtContext]);
  reactExports.useEffect(() => {
    if (renderDfd && pendingState && router2.window) {
      let newState = pendingState;
      let renderPromise = renderDfd.promise;
      let transition2 = router2.window.document.startViewTransition(async () => {
        optInStartTransition(() => setStateImpl(newState));
        await renderPromise;
      });
      transition2.finished.finally(() => {
        setRenderDfd(void 0);
        setTransition(void 0);
        setPendingState(void 0);
        setVtContext({
          isTransitioning: false
        });
      });
      setTransition(transition2);
    }
  }, [optInStartTransition, pendingState, renderDfd, router2.window]);
  reactExports.useEffect(() => {
    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {
      renderDfd.resolve();
    }
  }, [renderDfd, transition, state.location, pendingState]);
  reactExports.useEffect(() => {
    if (!vtContext.isTransitioning && interruption) {
      setPendingState(interruption.state);
      setVtContext({
        isTransitioning: true,
        flushSync: false,
        currentLocation: interruption.currentLocation,
        nextLocation: interruption.nextLocation
      });
      setInterruption(void 0);
    }
  }, [vtContext.isTransitioning, interruption]);
  reactExports.useEffect(() => {
  }, []);
  let navigator2 = reactExports.useMemo(() => {
    return {
      createHref: router2.createHref,
      encodeLocation: router2.encodeLocation,
      go: (n2) => router2.navigate(n2),
      push: (to, state2, opts) => router2.navigate(to, {
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      }),
      replace: (to, state2, opts) => router2.navigate(to, {
        replace: true,
        state: state2,
        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset
      })
    };
  }, [router2]);
  let basename = router2.basename || "/";
  let dataRouterContext = reactExports.useMemo(() => ({
    router: router2,
    navigator: navigator2,
    static: false,
    basename
  }), [router2, navigator2, basename]);
  let routerFuture = reactExports.useMemo(() => ({
    v7_relativeSplatPath: router2.future.v7_relativeSplatPath
  }), [router2.future.v7_relativeSplatPath]);
  reactExports.useEffect(() => logV6DeprecationWarnings(future, router2.future), [future, router2.future]);
  return /* @__PURE__ */ reactExports.createElement(reactExports.Fragment, null, /* @__PURE__ */ reactExports.createElement(DataRouterContext.Provider, {
    value: dataRouterContext
  }, /* @__PURE__ */ reactExports.createElement(DataRouterStateContext.Provider, {
    value: state
  }, /* @__PURE__ */ reactExports.createElement(FetchersContext.Provider, {
    value: fetcherData.current
  }, /* @__PURE__ */ reactExports.createElement(ViewTransitionContext.Provider, {
    value: vtContext
  }, /* @__PURE__ */ reactExports.createElement(Router, {
    basename,
    location: state.location,
    navigationType: state.historyAction,
    navigator: navigator2,
    future: routerFuture
  }, state.initialized || router2.future.v7_partialHydration ? /* @__PURE__ */ reactExports.createElement(MemoizedDataRoutes, {
    routes: router2.routes,
    future: router2.future,
    state
  }) : fallbackElement))))), null);
}
const MemoizedDataRoutes = /* @__PURE__ */ reactExports.memo(DataRoutes);
function DataRoutes(_ref3) {
  let {
    routes,
    future,
    state
  } = _ref3;
  return useRoutesImpl(routes, void 0, state, future);
}
const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
const ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
const Link = /* @__PURE__ */ reactExports.forwardRef(function LinkWithRef(_ref7, ref) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to,
    preventScrollReset,
    viewTransition
  } = _ref7, rest = _objectWithoutPropertiesLoose(_ref7, _excluded);
  let {
    basename
  } = reactExports.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to === "string" && ABSOLUTE_URL_REGEX.test(to)) {
    absoluteHref = to;
    if (isBrowser) {
      try {
        let currentUrl = new URL(window.location.href);
        let targetUrl = to.startsWith("//") ? new URL(currentUrl.protocol + to) : new URL(to);
        let path = stripBasename(targetUrl.pathname, basename);
        if (targetUrl.origin === currentUrl.origin && path != null) {
          to = path + targetUrl.search + targetUrl.hash;
        } else {
          isExternal = true;
        }
      } catch (e3) {
      }
    }
  }
  let href = useHref(to, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to, {
    replace: replace2,
    state,
    target,
    preventScrollReset,
    relative,
    viewTransition
  });
  function handleClick(event) {
    if (onClick) onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ reactExports.createElement("a", _extends({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref,
      target
    }))
  );
});
var DataRouterHook;
(function(DataRouterHook2) {
  DataRouterHook2["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook2["UseSubmit"] = "useSubmit";
  DataRouterHook2["UseSubmitFetcher"] = "useSubmitFetcher";
  DataRouterHook2["UseFetcher"] = "useFetcher";
  DataRouterHook2["useViewTransitionState"] = "useViewTransitionState";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook2) {
  DataRouterStateHook2["UseFetcher"] = "useFetcher";
  DataRouterStateHook2["UseFetchers"] = "useFetchers";
  DataRouterStateHook2["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function useLinkClickHandler(to, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative,
    viewTransition
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location2 = useLocation();
  let path = useResolvedPath(to, {
    relative
  });
  return reactExports.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location2) === createPath(path);
      navigate(to, {
        replace: replace2,
        state,
        preventScrollReset,
        relative,
        viewTransition
      });
    }
  }, [location2, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, viewTransition]);
}
function useSearchParams(defaultInit) {
  let defaultSearchParamsRef = reactExports.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = reactExports.useRef(false);
  let location2 = useLocation();
  let searchParams = reactExports.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location2.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location2.search]);
  let navigate = useNavigate();
  let setSearchParams = reactExports.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes$1 = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase().trim();
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ color = "currentColor", size: size2 = 24, strokeWidth = 2, absoluteStrokeWidth, className = "", children, ...rest }, ref) => reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes$1,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: ["lucide", `lucide-${toKebabCase(iconName)}`, className].join(" "),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    )
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const AlertCircle = createLucideIcon("AlertCircle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }],
  ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ArrowUpDown = createLucideIcon("ArrowUpDown", [
  ["path", { d: "m21 16-4 4-4-4", key: "f6ql7i" }],
  ["path", { d: "M17 20V4", key: "1ejh1v" }],
  ["path", { d: "m3 8 4-4 4 4", key: "11wl7u" }],
  ["path", { d: "M7 4v16", key: "1glfcx" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const BarChart2 = createLucideIcon("BarChart2", [
  ["line", { x1: "18", x2: "18", y1: "20", y2: "10", key: "1xfpm4" }],
  ["line", { x1: "12", x2: "12", y1: "20", y2: "4", key: "be30l9" }],
  ["line", { x1: "6", x2: "6", y1: "20", y2: "14", key: "1r4le6" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Bug = createLucideIcon("Bug", [
  ["path", { d: "m8 2 1.88 1.88", key: "fmnt4t" }],
  ["path", { d: "M14.12 3.88 16 2", key: "qol33r" }],
  ["path", { d: "M9 7.13v-1a3.003 3.003 0 1 1 6 0v1", key: "d7y7pr" }],
  [
    "path",
    {
      d: "M12 20c-3.3 0-6-2.7-6-6v-3a4 4 0 0 1 4-4h4a4 4 0 0 1 4 4v3c0 3.3-2.7 6-6 6",
      key: "xs1cw7"
    }
  ],
  ["path", { d: "M12 20v-9", key: "1qisl0" }],
  ["path", { d: "M6.53 9C4.6 8.8 3 7.1 3 5", key: "32zzws" }],
  ["path", { d: "M6 13H2", key: "82j7cp" }],
  ["path", { d: "M3 21c0-2.1 1.7-3.9 3.8-4", key: "4p0ekp" }],
  ["path", { d: "M20.97 5c0 2.1-1.6 3.8-3.5 4", key: "18gb23" }],
  ["path", { d: "M22 13h-4", key: "1jl80f" }],
  ["path", { d: "M17.2 17c2.1.1 3.8 1.9 3.8 4", key: "k3fwyw" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Camera = createLucideIcon("Camera", [
  [
    "path",
    {
      d: "M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z",
      key: "1tc9qg"
    }
  ],
  ["circle", { cx: "12", cy: "13", r: "3", key: "1vg3eu" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronDown = createLucideIcon("ChevronDown", [
  ["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronUp = createLucideIcon("ChevronUp", [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Circle = createLucideIcon("Circle", [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Copy = createLucideIcon("Copy", [
  ["rect", { width: "14", height: "14", x: "8", y: "8", rx: "2", ry: "2", key: "17jyea" }],
  ["path", { d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2", key: "zix9uf" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Database = createLucideIcon("Database", [
  ["ellipse", { cx: "12", cy: "5", rx: "9", ry: "3", key: "msslwz" }],
  ["path", { d: "M3 5V19A9 3 0 0 0 21 19V5", key: "1wlel7" }],
  ["path", { d: "M3 12A9 3 0 0 0 21 12", key: "mv7ke4" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Download = createLucideIcon("Download", [
  ["path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4", key: "ih7n3h" }],
  ["polyline", { points: "7 10 12 15 17 10", key: "2ggqvy" }],
  ["line", { x1: "12", x2: "12", y1: "15", y2: "3", key: "1vk2je" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileJson = createLucideIcon("FileJson", [
  [
    "path",
    { d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z", key: "1nnpy2" }
  ],
  ["polyline", { points: "14 2 14 8 20 8", key: "1ew0cm" }],
  [
    "path",
    { d: "M10 12a1 1 0 0 0-1 1v1a1 1 0 0 1-1 1 1 1 0 0 1 1 1v1a1 1 0 0 0 1 1", key: "1oajmo" }
  ],
  [
    "path",
    { d: "M14 18a1 1 0 0 0 1-1v-1a1 1 0 0 1 1-1 1 1 0 0 1-1-1v-1a1 1 0 0 0-1-1", key: "mpwhp6" }
  ]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const FileText = createLucideIcon("FileText", [
  [
    "path",
    { d: "M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z", key: "1nnpy2" }
  ],
  ["polyline", { points: "14 2 14 8 20 8", key: "1ew0cm" }],
  ["line", { x1: "16", x2: "8", y1: "13", y2: "13", key: "14keom" }],
  ["line", { x1: "16", x2: "8", y1: "17", y2: "17", key: "17nazh" }],
  ["line", { x1: "10", x2: "8", y1: "9", y2: "9", key: "1a5vjj" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Filter = createLucideIcon("Filter", [
  ["polygon", { points: "22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3", key: "1yg77f" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GripVertical = createLucideIcon("GripVertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Key = createLucideIcon("Key", [
  ["circle", { cx: "7.5", cy: "15.5", r: "5.5", key: "yqb3hr" }],
  ["path", { d: "m21 2-9.6 9.6", key: "1j0ho8" }],
  ["path", { d: "m15.5 7.5 3 3L22 7l-3-3", key: "1rn1fs" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LayoutDashboard = createLucideIcon("LayoutDashboard", [
  ["rect", { width: "7", height: "9", x: "3", y: "3", rx: "1", key: "10lvy0" }],
  ["rect", { width: "7", height: "5", x: "14", y: "3", rx: "1", key: "16une8" }],
  ["rect", { width: "7", height: "9", x: "14", y: "12", rx: "1", key: "1hutg5" }],
  ["rect", { width: "7", height: "5", x: "3", y: "16", rx: "1", key: "ldoo1y" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const List$1 = createLucideIcon("List", [
  ["line", { x1: "8", x2: "21", y1: "6", y2: "6", key: "7ey8pc" }],
  ["line", { x1: "8", x2: "21", y1: "12", y2: "12", key: "rjfblc" }],
  ["line", { x1: "8", x2: "21", y1: "18", y2: "18", key: "c3b1m8" }],
  ["line", { x1: "3", x2: "3.01", y1: "6", y2: "6", key: "1g7gq3" }],
  ["line", { x1: "3", x2: "3.01", y1: "12", y2: "12", key: "1pjlvk" }],
  ["line", { x1: "3", x2: "3.01", y1: "18", y2: "18", key: "28t2mc" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Loader2 = createLucideIcon("Loader2", [
  ["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LogIn = createLucideIcon("LogIn", [
  ["path", { d: "M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4", key: "u53s6r" }],
  ["polyline", { points: "10 17 15 12 10 7", key: "1ail0h" }],
  ["line", { x1: "15", x2: "3", y1: "12", y2: "12", key: "v6grx8" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const LogOut = createLucideIcon("LogOut", [
  ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }],
  ["polyline", { points: "16 17 21 12 16 7", key: "1gabdz" }],
  ["line", { x1: "21", x2: "9", y1: "12", y2: "12", key: "1uyos4" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const PenSquare = createLucideIcon("PenSquare", [
  ["path", { d: "M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7", key: "1qinfi" }],
  ["path", { d: "M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4Z", key: "w2jsv5" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pen = createLucideIcon("Pen", [
  ["path", { d: "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z", key: "5qss01" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pencil = createLucideIcon("Pencil", [
  ["path", { d: "M17 3a2.85 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5Z", key: "5qss01" }],
  ["path", { d: "m15 5 4 4", key: "1mk7zo" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Printer = createLucideIcon("Printer", [
  ["polyline", { points: "6 9 6 2 18 2 18 9", key: "1306q4" }],
  [
    "path",
    {
      d: "M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2",
      key: "143wyd"
    }
  ],
  ["rect", { width: "12", height: "8", x: "6", y: "14", key: "5ipwut" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QrCode = createLucideIcon("QrCode", [
  ["rect", { width: "5", height: "5", x: "3", y: "3", rx: "1", key: "1tu5fj" }],
  ["rect", { width: "5", height: "5", x: "16", y: "3", rx: "1", key: "1v8r4q" }],
  ["rect", { width: "5", height: "5", x: "3", y: "16", rx: "1", key: "1x03jg" }],
  ["path", { d: "M21 16h-3a2 2 0 0 0-2 2v3", key: "177gqh" }],
  ["path", { d: "M21 21v.01", key: "ents32" }],
  ["path", { d: "M12 7v3a2 2 0 0 1-2 2H7", key: "8crl2c" }],
  ["path", { d: "M3 12h.01", key: "nlz23k" }],
  ["path", { d: "M12 3h.01", key: "n36tog" }],
  ["path", { d: "M12 16v.01", key: "133mhm" }],
  ["path", { d: "M16 12h1", key: "1slzba" }],
  ["path", { d: "M21 12v.01", key: "1lwtk9" }],
  ["path", { d: "M12 21v-1", key: "1880an" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Save = createLucideIcon("Save", [
  ["path", { d: "M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z", key: "1owoqh" }],
  ["polyline", { points: "17 21 17 13 7 13 7 21", key: "1md35c" }],
  ["polyline", { points: "7 3 7 8 15 8", key: "8nz8an" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ScanLine = createLucideIcon("ScanLine", [
  ["path", { d: "M3 7V5a2 2 0 0 1 2-2h2", key: "aa7l1z" }],
  ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2", key: "4qcy5o" }],
  ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2", key: "6vwrx8" }],
  ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2", key: "ioqczr" }],
  ["path", { d: "M7 12h10", key: "b7w52i" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Search = createLucideIcon("Search", [
  ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }],
  ["path", { d: "m21 21-4.3-4.3", key: "1qie3q" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings2 = createLucideIcon("Settings2", [
  ["path", { d: "M20 7h-9", key: "3s1dr2" }],
  ["path", { d: "M14 17H5", key: "gfn3mx" }],
  ["circle", { cx: "17", cy: "17", r: "3", key: "18b49y" }],
  ["circle", { cx: "7", cy: "7", r: "3", key: "dfmy0x" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Settings = createLucideIcon("Settings", [
  [
    "path",
    {
      d: "M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z",
      key: "1qme2f"
    }
  ],
  ["circle", { cx: "12", cy: "12", r: "3", key: "1v7zrd" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ShoppingCart = createLucideIcon("ShoppingCart", [
  ["circle", { cx: "8", cy: "21", r: "1", key: "jimo8o" }],
  ["circle", { cx: "19", cy: "21", r: "1", key: "13723u" }],
  [
    "path",
    {
      d: "M2.05 2.05h2l2.66 12.42a2 2 0 0 0 2 1.58h9.78a2 2 0 0 0 1.95-1.57l1.65-7.43H5.12",
      key: "9zh506"
    }
  ]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const StickyNote = createLucideIcon("StickyNote", [
  [
    "path",
    { d: "M15.5 3H5a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h14a2 2 0 0 0 2-2V8.5L15.5 3Z", key: "1wis1t" }
  ],
  ["path", { d: "M15 3v6h6", key: "edgan2" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash2 = createLucideIcon("Trash2", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }],
  ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }],
  ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Trash = createLucideIcon("Trash", [
  ["path", { d: "M3 6h18", key: "d0wm0j" }],
  ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }],
  ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const UserPlus = createLucideIcon("UserPlus", [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }],
  ["line", { x1: "19", x2: "19", y1: "8", y2: "14", key: "1bvyxn" }],
  ["line", { x1: "22", x2: "16", y1: "11", y2: "11", key: "1shjgl" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const User = createLucideIcon("User", [
  ["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }],
  ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]
]);
/**
 * @license lucide-react v0.294.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
function r$1(e3) {
  var t3, f2, n2 = "";
  if ("string" == typeof e3 || "number" == typeof e3) n2 += e3;
  else if ("object" == typeof e3) if (Array.isArray(e3)) {
    var o2 = e3.length;
    for (t3 = 0; t3 < o2; t3++) e3[t3] && (f2 = r$1(e3[t3])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e3) e3[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e3, t3, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e3 = arguments[f2]) && (t3 = r$1(e3)) && (n2 && (n2 += " "), n2 += t3);
  return n2;
}
function twJoin() {
  var index2 = 0;
  var argument;
  var resolvedValue;
  var string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
function toValue(mix) {
  if (typeof mix === "string") {
    return mix;
  }
  var resolvedValue;
  var string = "";
  for (var k3 = 0; k3 < mix.length; k3++) {
    if (mix[k3]) {
      if (resolvedValue = toValue(mix[k3])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
var CLASS_PART_SEPARATOR = "-";
function createClassUtils(config) {
  var classMap = createClassMap(config);
  var conflictingClassGroups = config.conflictingClassGroups, _config$conflictingCl = config.conflictingClassGroupModifiers, conflictingClassGroupModifiers = _config$conflictingCl === void 0 ? {} : _config$conflictingCl;
  function getClassGroupId(className) {
    var classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  }
  function getConflictingClassGroupIds(classGroupId, hasPostfixModifier) {
    var conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [].concat(conflicts, conflictingClassGroupModifiers[classGroupId]);
    }
    return conflicts;
  }
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
}
function getGroupRecursive(classParts, classPartObject) {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  var currentClassPart = classParts[0];
  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  var classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(function(_ref) {
    var validator = _ref.validator;
    return validator(classRest);
  })?.classGroupId;
}
var arbitraryPropertyRegex = /^\[(.+)\]$/;
function getGroupIdForArbitraryProperty(className) {
  if (arbitraryPropertyRegex.test(className)) {
    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    var property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
}
function createClassMap(config) {
  var theme = config.theme, prefix = config.prefix;
  var classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);
  prefixedClassGroupEntries.forEach(function(_ref2) {
    var classGroupId = _ref2[0], classGroup = _ref2[1];
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
}
function processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {
  classGroup.forEach(function(classDefinition) {
    if (typeof classDefinition === "string") {
      var classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(function(_ref3) {
      var key = _ref3[0], classGroup2 = _ref3[1];
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
}
function getPart(classPartObject, path) {
  var currentClassPartObject = classPartObject;
  path.split(CLASS_PART_SEPARATOR).forEach(function(pathPart) {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
}
function isThemeGetter(func) {
  return func.isThemeGetter;
}
function getPrefixedClassGroupEntries(classGroupEntries, prefix) {
  if (!prefix) {
    return classGroupEntries;
  }
  return classGroupEntries.map(function(_ref4) {
    var classGroupId = _ref4[0], classGroup = _ref4[1];
    var prefixedClassGroup = classGroup.map(function(classDefinition) {
      if (typeof classDefinition === "string") {
        return prefix + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(function(_ref5) {
          var key = _ref5[0], value = _ref5[1];
          return [prefix + key, value];
        }));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
}
function createLruCache(maxCacheSize) {
  if (maxCacheSize < 1) {
    return {
      get: function get2() {
        return void 0;
      },
      set: function set2() {
      }
    };
  }
  var cacheSize = 0;
  var cache = /* @__PURE__ */ new Map();
  var previousCache = /* @__PURE__ */ new Map();
  function update(key, value) {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  }
  return {
    get: function get2(key) {
      var value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set: function set2(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
}
var IMPORTANT_MODIFIER = "!";
function createSplitModifiers(config) {
  var separator = config.separator || ":";
  var isSeparatorSingleCharacter = separator.length === 1;
  var firstSeparatorCharacter = separator[0];
  var separatorLength = separator.length;
  return function splitModifiers(className) {
    var modifiers = [];
    var bracketDepth = 0;
    var modifierStart = 0;
    var postfixModifierPosition;
    for (var index2 = 0; index2 < className.length; index2++) {
      var currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    var maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
}
function sortModifiers(modifiers) {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  var sortedModifiers = [];
  var unsortedModifiers = [];
  modifiers.forEach(function(modifier) {
    var isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());
  return sortedModifiers;
}
function createConfigUtils(config) {
  return {
    cache: createLruCache(config.cacheSize),
    splitModifiers: createSplitModifiers(config),
    ...createClassUtils(config)
  };
}
var SPLIT_CLASSES_REGEX = /\s+/;
function mergeClassList(classList, configUtils) {
  var splitModifiers = configUtils.splitModifiers, getClassGroupId = configUtils.getClassGroupId, getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;
  var classGroupsInConflict = /* @__PURE__ */ new Set();
  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function(originalClassName) {
    var _splitModifiers = splitModifiers(originalClassName), modifiers = _splitModifiers.modifiers, hasImportantModifier = _splitModifiers.hasImportantModifier, baseClassName = _splitModifiers.baseClassName, maybePostfixModifierPosition = _splitModifiers.maybePostfixModifierPosition;
    var classGroupId = getClassGroupId(maybePostfixModifierPosition ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    var hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    if (!classGroupId) {
      if (!maybePostfixModifierPosition) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        return {
          isTailwindClass: false,
          originalClassName
        };
      }
      hasPostfixModifier = false;
    }
    var variantModifier = sortModifiers(modifiers).join(":");
    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    return {
      isTailwindClass: true,
      modifierId,
      classGroupId,
      originalClassName,
      hasPostfixModifier
    };
  }).reverse().filter(function(parsed) {
    if (!parsed.isTailwindClass) {
      return true;
    }
    var modifierId = parsed.modifierId, classGroupId = parsed.classGroupId, hasPostfixModifier = parsed.hasPostfixModifier;
    var classId = modifierId + classGroupId;
    if (classGroupsInConflict.has(classId)) {
      return false;
    }
    classGroupsInConflict.add(classId);
    getConflictingClassGroupIds(classGroupId, hasPostfixModifier).forEach(function(group) {
      return classGroupsInConflict.add(modifierId + group);
    });
    return true;
  }).reverse().map(function(parsed) {
    return parsed.originalClassName;
  }).join(" ");
}
function createTailwindMerge() {
  for (var _len = arguments.length, createConfig = new Array(_len), _key = 0; _key < _len; _key++) {
    createConfig[_key] = arguments[_key];
  }
  var configUtils;
  var cacheGet;
  var cacheSet;
  var functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    var firstCreateConfig = createConfig[0], restCreateConfig = createConfig.slice(1);
    var config = restCreateConfig.reduce(function(previousConfig, createConfigCurrent) {
      return createConfigCurrent(previousConfig);
    }, firstCreateConfig());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    var cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    var result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
function fromTheme(key) {
  var themeGetter = function themeGetter2(theme) {
    return theme[key] || [];
  };
  themeGetter.isThemeGetter = true;
  return themeGetter;
}
var arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var fractionRegex = /^\d+\/\d+$/;
var stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var shadowRegex = /^-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
function isLength(value) {
  return isNumber(value) || stringLengths.has(value) || fractionRegex.test(value) || isArbitraryLength(value);
}
function isArbitraryLength(value) {
  return getIsArbitraryValue(value, "length", isLengthOnly);
}
function isArbitrarySize(value) {
  return getIsArbitraryValue(value, "size", isNever);
}
function isArbitraryPosition(value) {
  return getIsArbitraryValue(value, "position", isNever);
}
function isArbitraryUrl(value) {
  return getIsArbitraryValue(value, "url", isUrl);
}
function isArbitraryNumber(value) {
  return getIsArbitraryValue(value, "number", isNumber);
}
function isNumber(value) {
  return !Number.isNaN(Number(value));
}
function isPercent(value) {
  return value.endsWith("%") && isNumber(value.slice(0, -1));
}
function isInteger(value) {
  return isIntegerOnly(value) || getIsArbitraryValue(value, "number", isIntegerOnly);
}
function isArbitraryValue(value) {
  return arbitraryValueRegex.test(value);
}
function isAny() {
  return true;
}
function isTshirtSize(value) {
  return tshirtUnitRegex.test(value);
}
function isArbitraryShadow(value) {
  return getIsArbitraryValue(value, "", isShadow);
}
function getIsArbitraryValue(value, label, testValue) {
  var result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return result[1] === label;
    }
    return testValue(result[2]);
  }
  return false;
}
function isLengthOnly(value) {
  return lengthUnitRegex.test(value);
}
function isNever() {
  return false;
}
function isUrl(value) {
  return value.startsWith("url(");
}
function isIntegerOnly(value) {
  return Number.isInteger(Number(value));
}
function isShadow(value) {
  return shadowRegex.test(value);
}
function getDefaultConfig() {
  var colors = fromTheme("colors");
  var spacing = fromTheme("spacing");
  var blur = fromTheme("blur");
  var brightness = fromTheme("brightness");
  var borderColor = fromTheme("borderColor");
  var borderRadius = fromTheme("borderRadius");
  var borderSpacing = fromTheme("borderSpacing");
  var borderWidth = fromTheme("borderWidth");
  var contrast = fromTheme("contrast");
  var grayscale = fromTheme("grayscale");
  var hueRotate = fromTheme("hueRotate");
  var invert = fromTheme("invert");
  var gap = fromTheme("gap");
  var gradientColorStops = fromTheme("gradientColorStops");
  var gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  var inset = fromTheme("inset");
  var margin = fromTheme("margin");
  var opacity = fromTheme("opacity");
  var padding = fromTheme("padding");
  var saturate = fromTheme("saturate");
  var scale = fromTheme("scale");
  var sepia = fromTheme("sepia");
  var skew = fromTheme("skew");
  var space = fromTheme("space");
  var translate = fromTheme("translate");
  var getOverscroll = function getOverscroll2() {
    return ["auto", "contain", "none"];
  };
  var getOverflow = function getOverflow2() {
    return ["auto", "hidden", "clip", "visible", "scroll"];
  };
  var getSpacingWithAutoAndArbitrary = function getSpacingWithAutoAndArbitrary2() {
    return ["auto", isArbitraryValue, spacing];
  };
  var getSpacingWithArbitrary = function getSpacingWithArbitrary2() {
    return [isArbitraryValue, spacing];
  };
  var getLengthWithEmpty = function getLengthWithEmpty2() {
    return ["", isLength];
  };
  var getNumberWithAutoAndArbitrary = function getNumberWithAutoAndArbitrary2() {
    return ["auto", isNumber, isArbitraryValue];
  };
  var getPositions = function getPositions2() {
    return ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  };
  var getLineStyles = function getLineStyles2() {
    return ["solid", "dashed", "dotted", "double", "none"];
  };
  var getBlendModes = function getBlendModes2() {
    return ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity", "plus-lighter"];
  };
  var getAlign = function getAlign2() {
    return ["start", "end", "center", "between", "around", "evenly", "stretch"];
  };
  var getZeroAndEmpty = function getZeroAndEmpty2() {
    return ["", "0", isArbitraryValue];
  };
  var getBreaks = function getBreaks2() {
    return ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  };
  var getNumber = function getNumber2() {
    return [isNumber, isArbitraryNumber];
  };
  var getNumberAndArbitrary = function getNumberAndArbitrary2() {
    return [isNumber, isArbitraryValue];
  };
  return {
    cacheSize: 500,
    theme: {
      colors: [isAny],
      spacing: [isLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumber(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmpty(),
      contrast: getNumber(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumber(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumber(),
      scale: getNumber(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      "float": [{
        "float": ["right", "left", "none"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [].concat(getPositions(), [isArbitraryValue])
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal"].concat(getAlign())
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal"].concat(getAlign(), ["baseline"])
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [].concat(getAlign(), ["baseline"])
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": ["0", "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize, isArbitraryValue]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": ["min", "max", "fit", isArbitraryValue, isLength]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isArbitraryValue, isLength]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [].concat(getLineStyles(), ["wavy"])
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isArbitraryValue, isLength]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      "break": [{
        "break": ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [].concat(getPositions(), [isArbitraryPosition])
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryUrl]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [].concat(getLineStyles(), ["hidden"])
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: [""].concat(getLineStyles())
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isArbitraryValue, isLength]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmpty()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": getBlendModes()
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: ["appearance-none"],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "pinch-zoom", "manipulation", {
          pan: ["x", "left", "right", "y", "up", "down"]
        }]
      }],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}
var twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn(...inputs) {
  return twMerge(clsx(inputs));
}
function formatCurrency(value, currency = "USD") {
  if (value === void 0 || value === null) return "-";
  return new Intl.NumberFormat("en-US", { style: "currency", currency }).format(value);
}
function comparePasswords(inputPassword, storedPassword) {
  console.log("PasswordUtils: Comparing passwords");
  console.log("PasswordUtils: Input password length:", inputPassword?.length);
  console.log("PasswordUtils: Stored password length:", storedPassword?.length);
  const result = inputPassword === storedPassword;
  console.log("PasswordUtils: Password match result:", result);
  return result;
}
let e = { data: "" }, t$1 = (t3) => "object" == typeof window ? ((t3 ? t3.querySelector("#_goober") : window._goober) || Object.assign((t3 || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t3 || e, l = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, a = /\/\*[^]*?\*\/|  +/g, n$1 = /\n+/g, o$1 = (e3, t3) => {
  let r2 = "", l2 = "", a4 = "";
  for (let n2 in e3) {
    let c3 = e3[n2];
    "@" == n2[0] ? "i" == n2[1] ? r2 = n2 + " " + c3 + ";" : l2 += "f" == n2[1] ? o$1(c3, n2) : n2 + "{" + o$1(c3, "k" == n2[1] ? "" : t3) + "}" : "object" == typeof c3 ? l2 += o$1(c3, t3 ? t3.replace(/([^,])+/g, (e4) => n2.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, (t4) => /&/.test(t4) ? t4.replace(/&/g, e4) : e4 ? e4 + " " + t4 : t4)) : n2) : null != c3 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, "-$&").toLowerCase(), a4 += o$1.p ? o$1.p(n2, c3) : n2 + ":" + c3 + ";");
  }
  return r2 + (t3 && a4 ? t3 + "{" + a4 + "}" : a4) + l2;
}, c$1 = {}, s$1 = (e3) => {
  if ("object" == typeof e3) {
    let t3 = "";
    for (let r2 in e3) t3 += r2 + s$1(e3[r2]);
    return t3;
  }
  return e3;
}, i$1 = (e3, t3, r2, i3, p2) => {
  let u3 = s$1(e3), d4 = c$1[u3] || (c$1[u3] = ((e4) => {
    let t4 = 0, r3 = 11;
    for (; t4 < e4.length; ) r3 = 101 * r3 + e4.charCodeAt(t4++) >>> 0;
    return "go" + r3;
  })(u3));
  if (!c$1[d4]) {
    let t4 = u3 !== e3 ? e3 : ((e4) => {
      let t5, r3, o2 = [{}];
      for (; t5 = l.exec(e4.replace(a, "")); ) t5[4] ? o2.shift() : t5[3] ? (r3 = t5[3].replace(n$1, " ").trim(), o2.unshift(o2[0][r3] = o2[0][r3] || {})) : o2[0][t5[1]] = t5[2].replace(n$1, " ").trim();
      return o2[0];
    })(e3);
    c$1[d4] = o$1(p2 ? { ["@keyframes " + d4]: t4 } : t4, r2 ? "" : "." + d4);
  }
  let f2 = r2 && c$1.g ? c$1.g : null;
  return r2 && (c$1.g = c$1[d4]), ((e4, t4, r3, l2) => {
    l2 ? t4.data = t4.data.replace(l2, e4) : -1 === t4.data.indexOf(e4) && (t4.data = r3 ? e4 + t4.data : t4.data + e4);
  })(c$1[d4], t3, i3, f2), d4;
}, p = (e3, t3, r2) => e3.reduce((e4, l2, a4) => {
  let n2 = t3[a4];
  if (n2 && n2.call) {
    let e5 = n2(r2), t4 = e5 && e5.props && e5.props.className || /^go/.test(e5) && e5;
    n2 = t4 ? "." + t4 : e5 && "object" == typeof e5 ? e5.props ? "" : o$1(e5, "") : false === e5 ? "" : e5;
  }
  return e4 + l2 + (null == n2 ? "" : n2);
}, "");
function u$1(e3) {
  let r2 = this || {}, l2 = e3.call ? e3(r2.p) : e3;
  return i$1(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r2.p) : l2.reduce((e4, t3) => Object.assign(e4, t3 && t3.call ? t3(r2.p) : t3), {}) : l2, t$1(r2.target), r2.g, r2.o, r2.k);
}
let d, f$1, g;
u$1.bind({ g: 1 });
let h = u$1.bind({ k: 1 });
function m(e3, t3, r2, l2) {
  o$1.p = t3, d = e3, f$1 = r2, g = l2;
}
function j(e3, t3) {
  let r2 = this || {};
  return function() {
    let l2 = arguments;
    function a4(n2, o2) {
      let c3 = Object.assign({}, n2), s4 = c3.className || a4.className;
      r2.p = Object.assign({ theme: f$1 && f$1() }, c3), r2.o = / *go\d+/.test(s4), c3.className = u$1.apply(r2, l2) + (s4 ? " " + s4 : "");
      let i3 = e3;
      return e3[0] && (i3 = c3.as || e3, delete c3.as), g && i3[0] && g(c3), d(i3, c3);
    }
    return a4;
  };
}
var W = (e3) => typeof e3 == "function", f = (e3, t3) => W(e3) ? e3(t3) : e3;
var F = /* @__PURE__ */ (() => {
  let e3 = 0;
  return () => (++e3).toString();
})(), A = /* @__PURE__ */ (() => {
  let e3;
  return () => {
    if (e3 === void 0 && typeof window < "u") {
      let t3 = matchMedia("(prefers-reduced-motion: reduce)");
      e3 = !t3 || t3.matches;
    }
    return e3;
  };
})();
var Y = 20;
var U = (e3, t3) => {
  switch (t3.type) {
    case 0:
      return { ...e3, toasts: [t3.toast, ...e3.toasts].slice(0, Y) };
    case 1:
      return { ...e3, toasts: e3.toasts.map((o2) => o2.id === t3.toast.id ? { ...o2, ...t3.toast } : o2) };
    case 2:
      let { toast: r2 } = t3;
      return U(e3, { type: e3.toasts.find((o2) => o2.id === r2.id) ? 1 : 0, toast: r2 });
    case 3:
      let { toastId: s4 } = t3;
      return { ...e3, toasts: e3.toasts.map((o2) => o2.id === s4 || s4 === void 0 ? { ...o2, dismissed: true, visible: false } : o2) };
    case 4:
      return t3.toastId === void 0 ? { ...e3, toasts: [] } : { ...e3, toasts: e3.toasts.filter((o2) => o2.id !== t3.toastId) };
    case 5:
      return { ...e3, pausedAt: t3.time };
    case 6:
      let a4 = t3.time - (e3.pausedAt || 0);
      return { ...e3, pausedAt: void 0, toasts: e3.toasts.map((o2) => ({ ...o2, pauseDuration: o2.pauseDuration + a4 })) };
  }
}, P = [], y = { toasts: [], pausedAt: void 0 }, u = (e3) => {
  y = U(y, e3), P.forEach((t3) => {
    t3(y);
  });
};
var J = (e3, t3 = "blank", r2) => ({ createdAt: Date.now(), visible: true, dismissed: false, type: t3, ariaProps: { role: "status", "aria-live": "polite" }, message: e3, pauseDuration: 0, ...r2, id: (r2 == null ? void 0 : r2.id) || F() }), x = (e3) => (t3, r2) => {
  let s4 = J(t3, e3, r2);
  return u({ type: 2, toast: s4 }), s4.id;
}, c = (e3, t3) => x("blank")(e3, t3);
c.error = x("error");
c.success = x("success");
c.loading = x("loading");
c.custom = x("custom");
c.dismiss = (e3) => {
  u({ type: 3, toastId: e3 });
};
c.remove = (e3) => u({ type: 4, toastId: e3 });
c.promise = (e3, t3, r2) => {
  let s4 = c.loading(t3.loading, { ...r2, ...r2 == null ? void 0 : r2.loading });
  return typeof e3 == "function" && (e3 = e3()), e3.then((a4) => {
    let o2 = t3.success ? f(t3.success, a4) : void 0;
    return o2 ? c.success(o2, { id: s4, ...r2, ...r2 == null ? void 0 : r2.success }) : c.dismiss(s4), a4;
  }).catch((a4) => {
    let o2 = t3.error ? f(t3.error, a4) : void 0;
    o2 ? c.error(o2, { id: s4, ...r2, ...r2 == null ? void 0 : r2.error }) : c.dismiss(s4);
  }), e3;
};
var oe$1 = h`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, re = h`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, se$1 = h`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, k = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e3) => e3.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e3) => e3.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se$1} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`;
var ne$1 = h`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, V = j("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e3) => e3.secondary || "#e0e0e0"};
  border-right-color: ${(e3) => e3.primary || "#616161"};
  animation: ${ne$1} 1s linear infinite;
`;
var pe$1 = h`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, de$1 = h`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, _ = j("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e3) => e3.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe$1} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de$1} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e3) => e3.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`;
var ue$1 = j("div")`
  position: absolute;
`, le$1 = j("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, fe = h`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Te$1 = j("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${fe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, M$1 = ({ toast: e3 }) => {
  let { icon: t3, type: r2, iconTheme: s4 } = e3;
  return t3 !== void 0 ? typeof t3 == "string" ? reactExports.createElement(Te$1, null, t3) : t3 : r2 === "blank" ? null : reactExports.createElement(le$1, null, reactExports.createElement(V, { ...s4 }), r2 !== "loading" && reactExports.createElement(ue$1, null, r2 === "error" ? reactExports.createElement(k, { ...s4 }) : reactExports.createElement(_, { ...s4 })));
};
var ye$1 = (e3) => `
0% {transform: translate3d(0,${e3 * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, ge$1 = (e3) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e3 * -150}%,-1px) scale(.6); opacity:0;}
`, he$1 = "0%{opacity:0;} 100%{opacity:1;}", xe$1 = "0%{opacity:1;} 100%{opacity:0;}", be$1 = j("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Se = j("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Ae = (e3, t3) => {
  let s4 = e3.includes("top") ? 1 : -1, [a4, o2] = A() ? [he$1, xe$1] : [ye$1(s4), ge$1(s4)];
  return { animation: t3 ? `${h(a4)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h(o2)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
reactExports.memo(({ toast: e3, position: t3, style: r2, children: s4 }) => {
  let a4 = e3.height ? Ae(e3.position || t3 || "top-center", e3.visible) : { opacity: 0 }, o2 = reactExports.createElement(M$1, { toast: e3 }), n2 = reactExports.createElement(Se, { ...e3.ariaProps }, f(e3.message, e3));
  return reactExports.createElement(be$1, { className: e3.className, style: { ...a4, ...r2, ...e3.style } }, typeof s4 == "function" ? s4({ icon: o2, message: n2 }) : reactExports.createElement(reactExports.Fragment, null, o2, n2));
});
m(reactExports.createElement);
u$1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
var jt = (n2) => {
  switch (n2) {
    case "success":
      return ee;
    case "info":
      return ae;
    case "warning":
      return oe;
    case "error":
      return se;
    default:
      return null;
  }
}, te = Array(12).fill(0), Yt = ({ visible: n2, className: e3 }) => React$1.createElement("div", { className: ["sonner-loading-wrapper", e3].filter(Boolean).join(" "), "data-visible": n2 }, React$1.createElement("div", { className: "sonner-spinner" }, te.map((t3, a4) => React$1.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${a4}` })))), ee = React$1.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React$1.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), oe = React$1.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React$1.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), ae = React$1.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React$1.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), se = React$1.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React$1.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), Ot = React$1.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React$1.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React$1.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" }));
var Ft = () => {
  let [n2, e3] = React$1.useState(document.hidden);
  return React$1.useEffect(() => {
    let t3 = () => {
      e3(document.hidden);
    };
    return document.addEventListener("visibilitychange", t3), () => window.removeEventListener("visibilitychange", t3);
  }, []), n2;
};
var bt = 1, yt = class {
  constructor() {
    this.subscribe = (e3) => (this.subscribers.push(e3), () => {
      let t3 = this.subscribers.indexOf(e3);
      this.subscribers.splice(t3, 1);
    });
    this.publish = (e3) => {
      this.subscribers.forEach((t3) => t3(e3));
    };
    this.addToast = (e3) => {
      this.publish(e3), this.toasts = [...this.toasts, e3];
    };
    this.create = (e3) => {
      var S4;
      let { message: t3, ...a4 } = e3, u3 = typeof (e3 == null ? void 0 : e3.id) == "number" || ((S4 = e3.id) == null ? void 0 : S4.length) > 0 ? e3.id : bt++, f2 = this.toasts.find((g2) => g2.id === u3), w3 = e3.dismissible === void 0 ? true : e3.dismissible;
      return this.dismissedToasts.has(u3) && this.dismissedToasts.delete(u3), f2 ? this.toasts = this.toasts.map((g2) => g2.id === u3 ? (this.publish({ ...g2, ...e3, id: u3, title: t3 }), { ...g2, ...e3, id: u3, dismissible: w3, title: t3 }) : g2) : this.addToast({ title: t3, ...a4, dismissible: w3, id: u3 }), u3;
    };
    this.dismiss = (e3) => (this.dismissedToasts.add(e3), e3 || this.toasts.forEach((t3) => {
      this.subscribers.forEach((a4) => a4({ id: t3.id, dismiss: true }));
    }), this.subscribers.forEach((t3) => t3({ id: e3, dismiss: true })), e3);
    this.message = (e3, t3) => this.create({ ...t3, message: e3 });
    this.error = (e3, t3) => this.create({ ...t3, message: e3, type: "error" });
    this.success = (e3, t3) => this.create({ ...t3, type: "success", message: e3 });
    this.info = (e3, t3) => this.create({ ...t3, type: "info", message: e3 });
    this.warning = (e3, t3) => this.create({ ...t3, type: "warning", message: e3 });
    this.loading = (e3, t3) => this.create({ ...t3, type: "loading", message: e3 });
    this.promise = (e3, t3) => {
      if (!t3) return;
      let a4;
      t3.loading !== void 0 && (a4 = this.create({ ...t3, promise: e3, type: "loading", message: t3.loading, description: typeof t3.description != "function" ? t3.description : void 0 }));
      let u3 = e3 instanceof Promise ? e3 : e3(), f2 = a4 !== void 0, w3, S4 = u3.then(async (i3) => {
        if (w3 = ["resolve", i3], React$1.isValidElement(i3)) f2 = false, this.create({ id: a4, type: "default", message: i3 });
        else if (ie(i3) && !i3.ok) {
          f2 = false;
          let T3 = typeof t3.error == "function" ? await t3.error(`HTTP error! status: ${i3.status}`) : t3.error, F2 = typeof t3.description == "function" ? await t3.description(`HTTP error! status: ${i3.status}`) : t3.description;
          this.create({ id: a4, type: "error", message: T3, description: F2 });
        } else if (t3.success !== void 0) {
          f2 = false;
          let T3 = typeof t3.success == "function" ? await t3.success(i3) : t3.success, F2 = typeof t3.description == "function" ? await t3.description(i3) : t3.description;
          this.create({ id: a4, type: "success", message: T3, description: F2 });
        }
      }).catch(async (i3) => {
        if (w3 = ["reject", i3], t3.error !== void 0) {
          f2 = false;
          let D3 = typeof t3.error == "function" ? await t3.error(i3) : t3.error, T3 = typeof t3.description == "function" ? await t3.description(i3) : t3.description;
          this.create({ id: a4, type: "error", message: D3, description: T3 });
        }
      }).finally(() => {
        var i3;
        f2 && (this.dismiss(a4), a4 = void 0), (i3 = t3.finally) == null || i3.call(t3);
      }), g2 = () => new Promise((i3, D3) => S4.then(() => w3[0] === "reject" ? D3(w3[1]) : i3(w3[1])).catch(D3));
      return typeof a4 != "string" && typeof a4 != "number" ? { unwrap: g2 } : Object.assign(a4, { unwrap: g2 });
    };
    this.custom = (e3, t3) => {
      let a4 = (t3 == null ? void 0 : t3.id) || bt++;
      return this.create({ jsx: e3(a4), id: a4, ...t3 }), a4;
    };
    this.getActiveToasts = () => this.toasts.filter((e3) => !this.dismissedToasts.has(e3.id));
    this.subscribers = [], this.toasts = [], this.dismissedToasts = /* @__PURE__ */ new Set();
  }
}, v = new yt(), ne = (n2, e3) => {
  let t3 = (e3 == null ? void 0 : e3.id) || bt++;
  return v.addToast({ title: n2, ...e3, id: t3 }), t3;
}, ie = (n2) => n2 && typeof n2 == "object" && "ok" in n2 && typeof n2.ok == "boolean" && "status" in n2 && typeof n2.status == "number", le = ne, ce = () => v.toasts, de = () => v.getActiveToasts(), ue = Object.assign(le, { success: v.success, info: v.info, warning: v.warning, error: v.error, custom: v.custom, message: v.message, promise: v.promise, dismiss: v.dismiss, loading: v.loading }, { getHistory: ce, getToasts: de });
function wt(n2, { insertAt: e3 } = {}) {
  if (typeof document == "undefined") return;
  let t3 = document.head || document.getElementsByTagName("head")[0], a4 = document.createElement("style");
  a4.type = "text/css", e3 === "top" && t3.firstChild ? t3.insertBefore(a4, t3.firstChild) : t3.appendChild(a4), a4.styleSheet ? a4.styleSheet.cssText = n2 : a4.appendChild(document.createTextNode(n2));
}
wt(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function tt(n2) {
  return n2.label !== void 0;
}
var pe = 3, me = "32px", ge = "16px", Wt = 4e3, he = 356, be = 14, ye = 20, we = 200;
function M(...n2) {
  return n2.filter(Boolean).join(" ");
}
function xe(n2) {
  let [e3, t3] = n2.split("-"), a4 = [];
  return e3 && a4.push(e3), t3 && a4.push(t3), a4;
}
var ve = (n2) => {
  var Dt, Pt, Nt, Bt, Ct, kt, It, Mt, Ht, At, Lt;
  let { invert: e3, toast: t3, unstyled: a4, interacting: u3, setHeights: f2, visibleToasts: w3, heights: S4, index: g2, toasts: i3, expanded: D3, removeToast: T3, defaultRichColors: F2, closeButton: et, style: ut, cancelButtonStyle: ft, actionButtonStyle: l2, className: ot = "", descriptionClassName: at = "", duration: X3, position: st, gap: pt, loadingIcon: rt, expandByDefault: B3, classNames: s4, icons: P2, closeButtonAriaLabel: nt = "Close toast", pauseWhenPageIsHidden: it } = n2, [Y3, C2] = React$1.useState(null), [lt, J2] = React$1.useState(null), [W2, H4] = React$1.useState(false), [A2, mt] = React$1.useState(false), [L3, z3] = React$1.useState(false), [ct, d4] = React$1.useState(false), [h4, y4] = React$1.useState(false), [R3, j2] = React$1.useState(0), [p2, _2] = React$1.useState(0), O3 = React$1.useRef(t3.duration || X3 || Wt), G3 = React$1.useRef(null), k3 = React$1.useRef(null), Vt = g2 === 0, Ut = g2 + 1 <= w3, N2 = t3.type, V2 = t3.dismissible !== false, Kt = t3.className || "", Xt = t3.descriptionClassName || "", dt = React$1.useMemo(() => S4.findIndex((r2) => r2.toastId === t3.id) || 0, [S4, t3.id]), Jt = React$1.useMemo(() => {
    var r2;
    return (r2 = t3.closeButton) != null ? r2 : et;
  }, [t3.closeButton, et]), Tt = React$1.useMemo(() => t3.duration || X3 || Wt, [t3.duration, X3]), gt = React$1.useRef(0), U2 = React$1.useRef(0), St = React$1.useRef(0), K3 = React$1.useRef(null), [Gt, Qt] = st.split("-"), Rt = React$1.useMemo(() => S4.reduce((r2, m4, c3) => c3 >= dt ? r2 : r2 + m4.height, 0), [S4, dt]), Et = Ft(), qt = t3.invert || e3, ht = N2 === "loading";
  U2.current = React$1.useMemo(() => dt * pt + Rt, [dt, Rt]), React$1.useEffect(() => {
    O3.current = Tt;
  }, [Tt]), React$1.useEffect(() => {
    H4(true);
  }, []), React$1.useEffect(() => {
    let r2 = k3.current;
    if (r2) {
      let m4 = r2.getBoundingClientRect().height;
      return _2(m4), f2((c3) => [{ toastId: t3.id, height: m4, position: t3.position }, ...c3]), () => f2((c3) => c3.filter((b2) => b2.toastId !== t3.id));
    }
  }, [f2, t3.id]), React$1.useLayoutEffect(() => {
    if (!W2) return;
    let r2 = k3.current, m4 = r2.style.height;
    r2.style.height = "auto";
    let c3 = r2.getBoundingClientRect().height;
    r2.style.height = m4, _2(c3), f2((b2) => b2.find((x3) => x3.toastId === t3.id) ? b2.map((x3) => x3.toastId === t3.id ? { ...x3, height: c3 } : x3) : [{ toastId: t3.id, height: c3, position: t3.position }, ...b2]);
  }, [W2, t3.title, t3.description, f2, t3.id]);
  let $2 = React$1.useCallback(() => {
    mt(true), j2(U2.current), f2((r2) => r2.filter((m4) => m4.toastId !== t3.id)), setTimeout(() => {
      T3(t3);
    }, we);
  }, [t3, T3, f2, U2]);
  React$1.useEffect(() => {
    if (t3.promise && N2 === "loading" || t3.duration === 1 / 0 || t3.type === "loading") return;
    let r2;
    return D3 || u3 || it && Et ? (() => {
      if (St.current < gt.current) {
        let b2 = (/* @__PURE__ */ new Date()).getTime() - gt.current;
        O3.current = O3.current - b2;
      }
      St.current = (/* @__PURE__ */ new Date()).getTime();
    })() : (() => {
      O3.current !== 1 / 0 && (gt.current = (/* @__PURE__ */ new Date()).getTime(), r2 = setTimeout(() => {
        var b2;
        (b2 = t3.onAutoClose) == null || b2.call(t3, t3), $2();
      }, O3.current));
    })(), () => clearTimeout(r2);
  }, [D3, u3, t3, N2, it, Et, $2]), React$1.useEffect(() => {
    t3.delete && $2();
  }, [$2, t3.delete]);
  function Zt() {
    var r2, m4, c3;
    return P2 != null && P2.loading ? React$1.createElement("div", { className: M(s4 == null ? void 0 : s4.loader, (r2 = t3 == null ? void 0 : t3.classNames) == null ? void 0 : r2.loader, "sonner-loader"), "data-visible": N2 === "loading" }, P2.loading) : rt ? React$1.createElement("div", { className: M(s4 == null ? void 0 : s4.loader, (m4 = t3 == null ? void 0 : t3.classNames) == null ? void 0 : m4.loader, "sonner-loader"), "data-visible": N2 === "loading" }, rt) : React$1.createElement(Yt, { className: M(s4 == null ? void 0 : s4.loader, (c3 = t3 == null ? void 0 : t3.classNames) == null ? void 0 : c3.loader), visible: N2 === "loading" });
  }
  return React$1.createElement("li", { tabIndex: 0, ref: k3, className: M(ot, Kt, s4 == null ? void 0 : s4.toast, (Dt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Dt.toast, s4 == null ? void 0 : s4.default, s4 == null ? void 0 : s4[N2], (Pt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Pt[N2]), "data-sonner-toast": "", "data-rich-colors": (Nt = t3.richColors) != null ? Nt : F2, "data-styled": !(t3.jsx || t3.unstyled || a4), "data-mounted": W2, "data-promise": !!t3.promise, "data-swiped": h4, "data-removed": A2, "data-visible": Ut, "data-y-position": Gt, "data-x-position": Qt, "data-index": g2, "data-front": Vt, "data-swiping": L3, "data-dismissible": V2, "data-type": N2, "data-invert": qt, "data-swipe-out": ct, "data-swipe-direction": lt, "data-expanded": !!(D3 || B3 && W2), style: { "--index": g2, "--toasts-before": g2, "--z-index": i3.length - g2, "--offset": `${A2 ? R3 : U2.current}px`, "--initial-height": B3 ? "auto" : `${p2}px`, ...ut, ...t3.style }, onDragEnd: () => {
    z3(false), C2(null), K3.current = null;
  }, onPointerDown: (r2) => {
    ht || !V2 || (G3.current = /* @__PURE__ */ new Date(), j2(U2.current), r2.target.setPointerCapture(r2.pointerId), r2.target.tagName !== "BUTTON" && (z3(true), K3.current = { x: r2.clientX, y: r2.clientY }));
  }, onPointerUp: () => {
    var x3, Q3, q3, Z2;
    if (ct || !V2) return;
    K3.current = null;
    let r2 = Number(((x3 = k3.current) == null ? void 0 : x3.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), m4 = Number(((Q3 = k3.current) == null ? void 0 : Q3.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), c3 = (/* @__PURE__ */ new Date()).getTime() - ((q3 = G3.current) == null ? void 0 : q3.getTime()), b2 = Y3 === "x" ? r2 : m4, I3 = Math.abs(b2) / c3;
    if (Math.abs(b2) >= ye || I3 > 0.11) {
      j2(U2.current), (Z2 = t3.onDismiss) == null || Z2.call(t3, t3), J2(Y3 === "x" ? r2 > 0 ? "right" : "left" : m4 > 0 ? "down" : "up"), $2(), d4(true), y4(false);
      return;
    }
    z3(false), C2(null);
  }, onPointerMove: (r2) => {
    var Q3, q3, Z2, zt;
    if (!K3.current || !V2 || ((Q3 = window.getSelection()) == null ? void 0 : Q3.toString().length) > 0) return;
    let c3 = r2.clientY - K3.current.y, b2 = r2.clientX - K3.current.x, I3 = (q3 = n2.swipeDirections) != null ? q3 : xe(st);
    !Y3 && (Math.abs(b2) > 1 || Math.abs(c3) > 1) && C2(Math.abs(b2) > Math.abs(c3) ? "x" : "y");
    let x3 = { x: 0, y: 0 };
    Y3 === "y" ? (I3.includes("top") || I3.includes("bottom")) && (I3.includes("top") && c3 < 0 || I3.includes("bottom") && c3 > 0) && (x3.y = c3) : Y3 === "x" && (I3.includes("left") || I3.includes("right")) && (I3.includes("left") && b2 < 0 || I3.includes("right") && b2 > 0) && (x3.x = b2), (Math.abs(x3.x) > 0 || Math.abs(x3.y) > 0) && y4(true), (Z2 = k3.current) == null || Z2.style.setProperty("--swipe-amount-x", `${x3.x}px`), (zt = k3.current) == null || zt.style.setProperty("--swipe-amount-y", `${x3.y}px`);
  } }, Jt && !t3.jsx ? React$1.createElement("button", { "aria-label": nt, "data-disabled": ht, "data-close-button": true, onClick: ht || !V2 ? () => {
  } : () => {
    var r2;
    $2(), (r2 = t3.onDismiss) == null || r2.call(t3, t3);
  }, className: M(s4 == null ? void 0 : s4.closeButton, (Bt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Bt.closeButton) }, (Ct = P2 == null ? void 0 : P2.close) != null ? Ct : Ot) : null, t3.jsx || reactExports.isValidElement(t3.title) ? t3.jsx ? t3.jsx : typeof t3.title == "function" ? t3.title() : t3.title : React$1.createElement(React$1.Fragment, null, N2 || t3.icon || t3.promise ? React$1.createElement("div", { "data-icon": "", className: M(s4 == null ? void 0 : s4.icon, (kt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : kt.icon) }, t3.promise || t3.type === "loading" && !t3.icon ? t3.icon || Zt() : null, t3.type !== "loading" ? t3.icon || (P2 == null ? void 0 : P2[N2]) || jt(N2) : null) : null, React$1.createElement("div", { "data-content": "", className: M(s4 == null ? void 0 : s4.content, (It = t3 == null ? void 0 : t3.classNames) == null ? void 0 : It.content) }, React$1.createElement("div", { "data-title": "", className: M(s4 == null ? void 0 : s4.title, (Mt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Mt.title) }, typeof t3.title == "function" ? t3.title() : t3.title), t3.description ? React$1.createElement("div", { "data-description": "", className: M(at, Xt, s4 == null ? void 0 : s4.description, (Ht = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Ht.description) }, typeof t3.description == "function" ? t3.description() : t3.description) : null), reactExports.isValidElement(t3.cancel) ? t3.cancel : t3.cancel && tt(t3.cancel) ? React$1.createElement("button", { "data-button": true, "data-cancel": true, style: t3.cancelButtonStyle || ft, onClick: (r2) => {
    var m4, c3;
    tt(t3.cancel) && V2 && ((c3 = (m4 = t3.cancel).onClick) == null || c3.call(m4, r2), $2());
  }, className: M(s4 == null ? void 0 : s4.cancelButton, (At = t3 == null ? void 0 : t3.classNames) == null ? void 0 : At.cancelButton) }, t3.cancel.label) : null, reactExports.isValidElement(t3.action) ? t3.action : t3.action && tt(t3.action) ? React$1.createElement("button", { "data-button": true, "data-action": true, style: t3.actionButtonStyle || l2, onClick: (r2) => {
    var m4, c3;
    tt(t3.action) && ((c3 = (m4 = t3.action).onClick) == null || c3.call(m4, r2), !r2.defaultPrevented && $2());
  }, className: M(s4 == null ? void 0 : s4.actionButton, (Lt = t3 == null ? void 0 : t3.classNames) == null ? void 0 : Lt.actionButton) }, t3.action.label) : null));
};
function _t() {
  if (typeof window == "undefined" || typeof document == "undefined") return "ltr";
  let n2 = document.documentElement.getAttribute("dir");
  return n2 === "auto" || !n2 ? window.getComputedStyle(document.documentElement).direction : n2;
}
function Te(n2, e3) {
  let t3 = {};
  return [n2, e3].forEach((a4, u3) => {
    let f2 = u3 === 1, w3 = f2 ? "--mobile-offset" : "--offset", S4 = f2 ? ge : me;
    function g2(i3) {
      ["top", "right", "bottom", "left"].forEach((D3) => {
        t3[`${w3}-${D3}`] = typeof i3 == "number" ? `${i3}px` : i3;
      });
    }
    typeof a4 == "number" || typeof a4 == "string" ? g2(a4) : typeof a4 == "object" ? ["top", "right", "bottom", "left"].forEach((i3) => {
      a4[i3] === void 0 ? t3[`${w3}-${i3}`] = S4 : t3[`${w3}-${i3}`] = typeof a4[i3] == "number" ? `${a4[i3]}px` : a4[i3];
    }) : g2(S4);
  }), t3;
}
var $e = reactExports.forwardRef(function(e3, t3) {
  let { invert: a4, position: u3 = "bottom-right", hotkey: f2 = ["altKey", "KeyT"], expand: w3, closeButton: S4, className: g2, offset: i3, mobileOffset: D3, theme: T3 = "light", richColors: F2, duration: et, style: ut, visibleToasts: ft = pe, toastOptions: l2, dir: ot = _t(), gap: at = be, loadingIcon: X3, icons: st, containerAriaLabel: pt = "Notifications", pauseWhenPageIsHidden: rt } = e3, [B3, s4] = React$1.useState([]), P2 = React$1.useMemo(() => Array.from(new Set([u3].concat(B3.filter((d4) => d4.position).map((d4) => d4.position)))), [B3, u3]), [nt, it] = React$1.useState([]), [Y3, C2] = React$1.useState(false), [lt, J2] = React$1.useState(false), [W2, H4] = React$1.useState(T3 !== "system" ? T3 : typeof window != "undefined" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), A2 = React$1.useRef(null), mt = f2.join("+").replace(/Key/g, "").replace(/Digit/g, ""), L3 = React$1.useRef(null), z3 = React$1.useRef(false), ct = React$1.useCallback((d4) => {
    s4((h4) => {
      var y4;
      return (y4 = h4.find((R3) => R3.id === d4.id)) != null && y4.delete || v.dismiss(d4.id), h4.filter(({ id: R3 }) => R3 !== d4.id);
    });
  }, []);
  return React$1.useEffect(() => v.subscribe((d4) => {
    if (d4.dismiss) {
      s4((h4) => h4.map((y4) => y4.id === d4.id ? { ...y4, delete: true } : y4));
      return;
    }
    setTimeout(() => {
      ReactDOM.flushSync(() => {
        s4((h4) => {
          let y4 = h4.findIndex((R3) => R3.id === d4.id);
          return y4 !== -1 ? [...h4.slice(0, y4), { ...h4[y4], ...d4 }, ...h4.slice(y4 + 1)] : [d4, ...h4];
        });
      });
    });
  }), []), React$1.useEffect(() => {
    if (T3 !== "system") {
      H4(T3);
      return;
    }
    if (T3 === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? H4("dark") : H4("light")), typeof window == "undefined") return;
    let d4 = window.matchMedia("(prefers-color-scheme: dark)");
    try {
      d4.addEventListener("change", ({ matches: h4 }) => {
        H4(h4 ? "dark" : "light");
      });
    } catch (h4) {
      d4.addListener(({ matches: y4 }) => {
        try {
          H4(y4 ? "dark" : "light");
        } catch (R3) {
          console.error(R3);
        }
      });
    }
  }, [T3]), React$1.useEffect(() => {
    B3.length <= 1 && C2(false);
  }, [B3]), React$1.useEffect(() => {
    let d4 = (h4) => {
      var R3, j2;
      f2.every((p2) => h4[p2] || h4.code === p2) && (C2(true), (R3 = A2.current) == null || R3.focus()), h4.code === "Escape" && (document.activeElement === A2.current || (j2 = A2.current) != null && j2.contains(document.activeElement)) && C2(false);
    };
    return document.addEventListener("keydown", d4), () => document.removeEventListener("keydown", d4);
  }, [f2]), React$1.useEffect(() => {
    if (A2.current) return () => {
      L3.current && (L3.current.focus({ preventScroll: true }), L3.current = null, z3.current = false);
    };
  }, [A2.current]), React$1.createElement("section", { ref: t3, "aria-label": `${pt} ${mt}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: true }, P2.map((d4, h4) => {
    var j2;
    let [y4, R3] = d4.split("-");
    return B3.length ? React$1.createElement("ol", { key: d4, dir: ot === "auto" ? _t() : ot, tabIndex: -1, ref: A2, className: g2, "data-sonner-toaster": true, "data-theme": W2, "data-y-position": y4, "data-lifted": Y3 && B3.length > 1 && !w3, "data-x-position": R3, style: { "--front-toast-height": `${((j2 = nt[0]) == null ? void 0 : j2.height) || 0}px`, "--width": `${he}px`, "--gap": `${at}px`, ...ut, ...Te(i3, D3) }, onBlur: (p2) => {
      z3.current && !p2.currentTarget.contains(p2.relatedTarget) && (z3.current = false, L3.current && (L3.current.focus({ preventScroll: true }), L3.current = null));
    }, onFocus: (p2) => {
      p2.target instanceof HTMLElement && p2.target.dataset.dismissible === "false" || z3.current || (z3.current = true, L3.current = p2.relatedTarget);
    }, onMouseEnter: () => C2(true), onMouseMove: () => C2(true), onMouseLeave: () => {
      lt || C2(false);
    }, onDragEnd: () => C2(false), onPointerDown: (p2) => {
      p2.target instanceof HTMLElement && p2.target.dataset.dismissible === "false" || J2(true);
    }, onPointerUp: () => J2(false) }, B3.filter((p2) => !p2.position && h4 === 0 || p2.position === d4).map((p2, _2) => {
      var O3, G3;
      return React$1.createElement(ve, { key: p2.id, icons: st, index: _2, toast: p2, defaultRichColors: F2, duration: (O3 = l2 == null ? void 0 : l2.duration) != null ? O3 : et, className: l2 == null ? void 0 : l2.className, descriptionClassName: l2 == null ? void 0 : l2.descriptionClassName, invert: a4, visibleToasts: ft, closeButton: (G3 = l2 == null ? void 0 : l2.closeButton) != null ? G3 : S4, interacting: lt, position: d4, style: l2 == null ? void 0 : l2.style, unstyled: l2 == null ? void 0 : l2.unstyled, classNames: l2 == null ? void 0 : l2.classNames, cancelButtonStyle: l2 == null ? void 0 : l2.cancelButtonStyle, actionButtonStyle: l2 == null ? void 0 : l2.actionButtonStyle, removeToast: ct, toasts: B3.filter((k3) => k3.position == p2.position), heights: nt.filter((k3) => k3.position == p2.position), setHeights: it, expandByDefault: w3, gap: at, loadingIcon: X3, expanded: Y3, pauseWhenPageIsHidden: rt, swipeDirections: e3.swipeDirections });
    })) : null;
  }));
});
class FileLogger {
  logs = [];
  context = "";
  constructor() {
    console.debug("Logger initialized");
    if (typeof window !== "undefined") {
      console.debug("Window is defined");
      console.debug("electronAPI available:", !!window.electronAPI);
      console.debug("saveLogs available:", !!window.electronAPI?.saveLogs);
    }
  }
  setContext(context) {
    this.context = context;
    this.log(`Context set to: ${context}`);
  }
  log(message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const logEntry = `[${timestamp}] ${this.context ? `[${this.context}] ` : ""}${message}`;
    this.logs.push(logEntry);
    console.log(message);
  }
  error(message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    const errorMessage = message;
    this.logs.push(`[${timestamp}] ERROR: ${errorMessage}`);
    console.error(errorMessage);
  }
  info(message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    this.logs.push(`[${timestamp}] INFO: ${message}`);
    console.info(message);
  }
  warn(message) {
    const timestamp = (/* @__PURE__ */ new Date()).toISOString();
    this.logs.push(`[${timestamp}] WARN: ${message}`);
    console.warn(message);
  }
  async downloadLogs(filenameOverride) {
    try {
      console.debug("Starting downloadLogs");
      console.debug("Current logs count:", this.logs.length);
      console.debug("electronAPI status:", !!window.electronAPI);
      if (!window.electronAPI?.saveLogs) {
        ue.error("Electron API not available. Logs will be printed to the console.");
        console.log("Logs:", this.logs.join("\n"));
        return;
      }
      let filename;
      if (filenameOverride) {
        filename = filenameOverride;
      } else {
        const date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
        const time = (/* @__PURE__ */ new Date()).toTimeString().split(" ")[0].replace(/:/g, "-");
        filename = `${date}_${time}_${this.context || "app"}.log`;
      }
      const content = this.logs.join("\n");
      console.debug("Attempting to save logs...", { filename });
      const result = await window.electronAPI.saveLogs(filename, content);
      if (result.success) {
        console.debug("Logs saved successfully at:", result.path);
        ue.success(`Logs saved to logs/${filename}`);
      } else {
        console.error("Failed to save logs:", result.error);
        ue.error(`Failed to save logs: ${result.error}`);
      }
    } catch (error) {
      console.error("Error in downloadLogs:", error);
      ue.error(`Error saving logs: ${error.message}`);
      console.debug("Error details:", {
        errorType: error.constructor.name,
        message: error.message,
        stack: error.stack,
        electronAPI: !!window.electronAPI,
        saveLogs: !!window.electronAPI?.saveLogs
      });
    }
  }
}
const logger$1 = new FileLogger();
const AuthContext = reactExports.createContext(void 0);
function useAuth() {
  const context = reactExports.useContext(AuthContext);
  if (!context) {
    throw new Error("useAuth must be used within an AuthProvider");
  }
  return context;
}
function getStore() {
  if (window.electron && window.electron.store) return window.electron.store;
  if (window.electronStore) return {
    get: async (key) => window.electronStore.getData(key),
    set: async (key, value) => window.electronStore.setData(key, value),
    delete: async (key) => window.electronStore.deleteData(key)
  };
  throw new Error("No Electron store found");
}
function AuthProvider({ children }) {
  const [currentUser, setCurrentUser] = reactExports.useState(null);
  const [loading, setLoading] = reactExports.useState(true);
  reactExports.useEffect(() => {
    const initializeAuth = async () => {
      try {
        const store = getStore();
        let storedUsers = await store.get("users");
        if (!storedUsers) {
          const defaultAdmin = {
            id: crypto.randomUUID(),
            username: "admin",
            displayName: "Administrator",
            password: "admin",
            role: "admin",
            securityQuestion: "What is the default password?",
            securityAnswer: "admin"
          };
          await store.set("users", [defaultAdmin]);
          storedUsers = [defaultAdmin];
          c.success("Default admin account created. Username: admin, Password: admin");
          logger$1.info("Created default admin account");
        }
        const rememberedUser = await store.get("rememberedUser");
        if (rememberedUser) {
          setCurrentUser(rememberedUser);
          logger$1.info("Restored remembered user session");
        }
      } catch (error) {
        logger$1.error("Error initializing auth: " + String(error));
        c.error("Error initializing authentication");
      } finally {
        setLoading(false);
      }
    };
    initializeAuth();
  }, []);
  const login = async (username, password, rememberMe) => {
    logger$1.info(`Login attempt for user: ${username}`);
    setLoading(true);
    try {
      const store = getStore();
      const users = await store.get("users");
      console.log("Retrieved users:", users);
      const userRecord = users.find((u3) => u3.username === username);
      if (!userRecord) {
        logger$1.warn("Login failed: User not found");
        c.error("Invalid username or password");
        return false;
      }
      const passwordMatch = await comparePasswords(password, userRecord.password);
      console.log("Password match result:", passwordMatch);
      if (passwordMatch) {
        setCurrentUser(userRecord);
        if (rememberMe) {
          await store.set("rememberedUser", userRecord);
          logger$1.info("User session remembered");
        }
        logger$1.info("Login successful");
        c.success("Login successful");
        return true;
      } else {
        logger$1.warn("Login failed: Invalid password");
        c.error("Invalid username or password");
        return false;
      }
    } catch (error) {
      logger$1.error("Login error: " + String(error));
      c.error("An error occurred during login");
      return false;
    } finally {
      setLoading(false);
    }
  };
  const logout = async () => {
    const store = getStore();
    setCurrentUser(null);
    await store.delete("rememberedUser");
    logger$1.info("User logged out");
    c.success("Logged out successfully");
  };
  const resetPassword = async (username, securityAnswer, newPassword) => {
    try {
      const store = getStore();
      const users = await store.get("users");
      const userIndex = users.findIndex((u3) => u3.username === username);
      if (userIndex === -1) {
        logger$1.warn("Password reset failed: User not found");
        c.error("User not found");
        return false;
      }
      if (users[userIndex].securityAnswer !== securityAnswer) {
        logger$1.warn("Password reset failed: Incorrect security answer");
        c.error("Incorrect security answer");
        return false;
      }
      users[userIndex].password = newPassword;
      await store.set("users", users);
      logger$1.info("Password reset successful");
      c.success("Password reset successful");
      return true;
    } catch (error) {
      logger$1.error("Password reset error: " + String(error));
      c.error("An error occurred during password reset");
      return false;
    }
  };
  const value = {
    currentUser,
    loading,
    login,
    logout,
    resetPassword
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AuthContext.Provider, { value, children });
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    return ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    let hasCleanup = false;
    const cleanups = refs.map((ref) => {
      const cleanup = setRef(ref, node);
      if (!hasCleanup && typeof cleanup == "function") {
        hasCleanup = true;
      }
      return cleanup;
    });
    if (hasCleanup) {
      return () => {
        for (let i3 = 0; i3 < cleanups.length; i3++) {
          const cleanup = cleanups[i3];
          if (typeof cleanup == "function") {
            cleanup();
          } else {
            setRef(refs[i3], null);
          }
        }
      };
    }
  };
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
function createContext2(rootComponentName, defaultContext) {
  const Context2 = reactExports.createContext(defaultContext);
  const Provider2 = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
  };
  Provider2.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context2);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider2, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider2 = (props) => {
      const { scope, children, ...context } = props;
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context2.Provider, { value, children });
    };
    Provider2.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope) {
      const Context2 = scope?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context2);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider2, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope) {
      const contexts = scope?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),
        [scope, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var useLayoutEffect2 = globalThis?.document ? reactExports.useLayoutEffect : () => {
};
var useInsertionEffect = React$2[" useInsertionEffect ".trim().toString()] || useLayoutEffect2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  },
  caller
}) {
  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({
    defaultProp,
    onChange
  });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  {
    const isControlledRef = reactExports.useRef(prop !== void 0);
    reactExports.useEffect(() => {
      const wasControlled = isControlledRef.current;
      if (wasControlled !== isControlled) {
        const from = wasControlled ? "controlled" : "uncontrolled";
        const to = isControlled ? "controlled" : "uncontrolled";
        console.warn(
          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`
        );
      }
      isControlledRef.current = isControlled;
    }, [isControlled, caller]);
  }
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const value2 = isFunction$1(nextValue) ? nextValue(prop) : nextValue;
        if (value2 !== prop) {
          onChangeRef.current?.(value2);
        }
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, onChangeRef]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const [value, setValue] = reactExports.useState(defaultProp);
  const prevValueRef = reactExports.useRef(value);
  const onChangeRef = reactExports.useRef(onChange);
  useInsertionEffect(() => {
    onChangeRef.current = onChange;
  }, [onChange]);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      onChangeRef.current?.(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef]);
  return [value, setValue, onChangeRef];
}
function isFunction$1(value) {
  return typeof value === "function";
}
// @__NO_SIDE_EFFECTS__
function createSlot(ownerName) {
  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);
  const Slot2 = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    const childrenArray = reactExports.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
          return reactExports.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot$3 = /* @__PURE__ */ createSlot("Slot");
// @__NO_SIDE_EFFECTS__
function createSlotClone(ownerName) {
  const SlotClone = reactExports.forwardRef((props, forwardedRef) => {
    const { children, ...slotProps } = props;
    if (reactExports.isValidElement(children)) {
      const childrenRef = getElementRef$1(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== reactExports.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return reactExports.cloneElement(children, props2);
    }
    return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
// @__NO_SIDE_EFFECTS__
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
function isSlottable(child) {
  return reactExports.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = /* @__PURE__ */ createSlot(`Primitive.${node}`);
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function createCollection(name) {
  const PROVIDER_NAME2 = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope(PROVIDER_NAME2);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME2,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope, children } = props;
    const ref = React$1.useRef(null);
    const itemMap = React$1.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME2;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlotImpl = /* @__PURE__ */ createSlot(COLLECTION_SLOT_NAME);
  const CollectionSlot = React$1.forwardRef(
    (props, forwardedRef) => {
      const { scope, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionSlotImpl, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlotImpl = /* @__PURE__ */ createSlot(ITEM_SLOT_NAME);
  const CollectionItemSlot = React$1.forwardRef(
    (props, forwardedRef) => {
      const { scope, children, ...itemData } = props;
      const ref = React$1.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope);
      React$1.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionItemSlotImpl, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope) {
    const context = useCollectionContext(name + "CollectionConsumer", scope);
    const getItems2 = React$1.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a4, b2) => orderedNodes.indexOf(a4.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems2;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent$1(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent$1(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent$1(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var Root$9 = DismissableLayer;
var Branch = DismissableLayerBranch;
var count$2 = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$2++;
    return () => {
      if (count$2 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$2--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS$1 = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS$1);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst$3(removeLinks(getTabbableCandidates$1(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS$1);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst$3(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates$1(container);
  const first = findVisible(candidates, container);
  const last = findVisible(candidates.reverse(), container);
  return [first, last];
}
function getTabbableCandidates$1(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useReactId = React$2[" useId ".trim().toString()] || (() => void 0);
var count$1 = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count$1++));
  }, [deterministicId]);
  return id2 ? `radix-${id2}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$1(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt2 = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt2;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x3,
    y: y4,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y4,
    left: x3,
    right: x3 + width,
    bottom: y4 + height,
    x: x3,
    y: y4
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x3,
    y: y4
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i3 = 0; i3 < validMiddleware.length; i3++) {
    const {
      name,
      fn
    } = validMiddleware[i3];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x3,
      y: y4,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x3 = nextX != null ? nextX : x3;
    y4 = nextY != null ? nextY : y4;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x3,
          y: y4
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i3 = -1;
    }
  }
  return {
    x: x3,
    y: y4,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x3,
    y: y4,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x3,
    y: y4,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x3,
      y: y4,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x3,
      y: y4
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp$1(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d4) => d4.overflows[0] <= 0).sort((a4, b2) => a4.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d4) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d4.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d4) => [d4.placement, d4.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a4, b2) => a4[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x3,
        y: y4,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x3 + diffCoords.x,
        y: y4 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x3,
        y: y4,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x4,
              y: y5
            } = _ref;
            return {
              x: x4,
              y: y5
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y4
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$1(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$1(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x3,
          y: limitedCoords.y - y4,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x3,
        y: y4,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x3,
        y: y4
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode$1(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow$1(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode$1(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow$1(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow$1(value).Element;
}
function isHTMLElement$3(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow$1(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow$1(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e3) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css[value] ? css[value] !== "none" : false) || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow$1(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$3(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow$1(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x3 = ($2 ? round(rect.width) : rect.width) / width;
  let y4 = ($2 ? round(rect.height) : rect.height) / height;
  if (!x3 || !Number.isFinite(x3)) {
    x3 = 1;
  }
  if (!y4 || !Number.isFinite(y4)) {
    y4 = 1;
  }
  return {
    x: x3,
    y: y4
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow$1(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed2, floatingOffsetParent) {
  if (isFixed2 === void 0) {
    isFixed2 = false;
  }
  if (!floatingOffsetParent || isFixed2 && floatingOffsetParent !== getWindow$1(element)) {
    return false;
  }
  return isFixed2;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x3 = (clientRect.left + visualOffsets.x) / scale.x;
  let y4 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow$1(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow$1(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x3 *= iframeScale.x;
      y4 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x3 += left;
      y4 += top;
      currentWin = getWindow$1(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x3,
    y: y4
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x3 = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y4 = htmlRect.top + scroll.scrollTop;
  return {
    x: x3,
    y: y4
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed2 = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed2) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$3(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed2 ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x3 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y4 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x3 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow$1(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x3 = 0;
  let y4 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x3 = visualViewport.offsetLeft;
      y4 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$3(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x3 = left * scale.x;
  const y4 = top * scale.y;
  return {
    width,
    height,
    x: x3,
    y: y4
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$3(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed2 = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed2, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed2) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed2, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed2 ? getHTMLOffset(documentElement, scroll) : createCoords(0);
  const x3 = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;
  const y4 = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x3,
    y: y4,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$3(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow$1(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$3(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function rectsAreEqual(a4, b2) {
  return a4.x === b2.x && a4.y === b2.y && a4.width === b2.width && a4.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e3) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$1(a4, b2) {
  if (a4 === b2) {
    return true;
  }
  if (typeof a4 !== typeof b2) {
    return false;
  }
  if (typeof a4 === "function" && a4.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i3;
  let keys2;
  if (a4 && b2 && typeof a4 === "object") {
    if (Array.isArray(a4)) {
      length = a4.length;
      if (length !== b2.length) return false;
      for (i3 = length; i3-- !== 0; ) {
        if (!deepEqual$1(a4[i3], b2[i3])) {
          return false;
        }
      }
      return true;
    }
    keys2 = Object.keys(a4);
    length = keys2.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i3 = length; i3-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys2[i3])) {
        return false;
      }
    }
    for (i3 = length; i3-- !== 0; ) {
      const key = keys2[i3];
      if (key === "_owner" && a4.$$typeof) {
        continue;
      }
      if (!deepEqual$1(a4[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a4 !== a4 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$1(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual$1(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x3 = roundByDPR(elements.floating, data.x);
    const y4 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x3 + "px, " + y4 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x3,
      top: y4
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$2 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$2;
var Root$8 = Arrow$1;
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME$1 = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME$1, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME$1;
var CONTENT_NAME$7 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$7);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$7, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$7;
var ARROW_NAME$4 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$4, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$8,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$4;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x3 = "";
    let y4 = "";
    if (placedSide === "bottom") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y4 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x3 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y4 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x3 = `${-arrowHeight}px`;
      y4 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x3 = `${rects.floating.width + arrowHeight}px`;
      y4 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x3, y: y4 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$5 = Popper;
var Anchor = PopperAnchor;
var Content$2 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$6 = "Portal";
var Portal$3 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$3.displayName = PORTAL_NAME$6;
function useStateMachine$1(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef(null);
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine$1(initialState, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      stylesRef.current = node2 ? getComputedStyle(node2) : null;
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var ENTRY_FOCUS = "rovingFocusGroup.onEntryFocus";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var GROUP_NAME$3 = "RovingFocusGroup";
var [Collection$3, useCollection$3, createCollectionScope$3] = createCollection(GROUP_NAME$3);
var [createRovingFocusGroupContext, createRovingFocusGroupScope] = createContextScope(
  GROUP_NAME$3,
  [createCollectionScope$3]
);
var [RovingFocusProvider, useRovingFocusContext] = createRovingFocusGroupContext(GROUP_NAME$3);
var RovingFocusGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Provider, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$3.Slot, { scope: props.__scopeRovingFocusGroup, children: /* @__PURE__ */ jsxRuntimeExports.jsx(RovingFocusGroupImpl, { ...props, ref: forwardedRef }) }) });
  }
);
RovingFocusGroup.displayName = GROUP_NAME$3;
var RovingFocusGroupImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeRovingFocusGroup,
    orientation,
    loop = false,
    dir,
    currentTabStopId: currentTabStopIdProp,
    defaultCurrentTabStopId,
    onCurrentTabStopIdChange,
    onEntryFocus,
    preventScrollOnEntryFocus = false,
    ...groupProps
  } = props;
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const direction = useDirection(dir);
  const [currentTabStopId, setCurrentTabStopId] = useControllableState({
    prop: currentTabStopIdProp,
    defaultProp: defaultCurrentTabStopId ?? null,
    onChange: onCurrentTabStopIdChange,
    caller: GROUP_NAME$3
  });
  const [isTabbingBackOut, setIsTabbingBackOut] = reactExports.useState(false);
  const handleEntryFocus = useCallbackRef$1(onEntryFocus);
  const getItems2 = useCollection$3(__scopeRovingFocusGroup);
  const isClickFocusRef = reactExports.useRef(false);
  const [focusableItemsCount, setFocusableItemsCount] = reactExports.useState(0);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      node.addEventListener(ENTRY_FOCUS, handleEntryFocus);
      return () => node.removeEventListener(ENTRY_FOCUS, handleEntryFocus);
    }
  }, [handleEntryFocus]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    RovingFocusProvider,
    {
      scope: __scopeRovingFocusGroup,
      orientation,
      dir: direction,
      loop,
      currentTabStopId,
      onItemFocus: reactExports.useCallback(
        (tabStopId) => setCurrentTabStopId(tabStopId),
        [setCurrentTabStopId]
      ),
      onItemShiftTab: reactExports.useCallback(() => setIsTabbingBackOut(true), []),
      onFocusableItemAdd: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount + 1),
        []
      ),
      onFocusableItemRemove: reactExports.useCallback(
        () => setFocusableItemsCount((prevCount) => prevCount - 1),
        []
      ),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          tabIndex: isTabbingBackOut || focusableItemsCount === 0 ? -1 : 0,
          "data-orientation": orientation,
          ...groupProps,
          ref: composedRefs,
          style: { outline: "none", ...props.style },
          onMouseDown: composeEventHandlers(props.onMouseDown, () => {
            isClickFocusRef.current = true;
          }),
          onFocus: composeEventHandlers(props.onFocus, (event) => {
            const isKeyboardFocus = !isClickFocusRef.current;
            if (event.target === event.currentTarget && isKeyboardFocus && !isTabbingBackOut) {
              const entryFocusEvent = new CustomEvent(ENTRY_FOCUS, EVENT_OPTIONS);
              event.currentTarget.dispatchEvent(entryFocusEvent);
              if (!entryFocusEvent.defaultPrevented) {
                const items = getItems2().filter((item) => item.focusable);
                const activeItem = items.find((item) => item.active);
                const currentItem = items.find((item) => item.id === currentTabStopId);
                const candidateItems = [activeItem, currentItem, ...items].filter(
                  Boolean
                );
                const candidateNodes = candidateItems.map((item) => item.ref.current);
                focusFirst$2(candidateNodes, preventScrollOnEntryFocus);
              }
            }
            isClickFocusRef.current = false;
          }),
          onBlur: composeEventHandlers(props.onBlur, () => setIsTabbingBackOut(false))
        }
      )
    }
  );
});
var ITEM_NAME$3 = "RovingFocusGroupItem";
var RovingFocusGroupItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeRovingFocusGroup,
      focusable = true,
      active = false,
      tabStopId,
      children,
      ...itemProps
    } = props;
    const autoId = useId();
    const id2 = tabStopId || autoId;
    const context = useRovingFocusContext(ITEM_NAME$3, __scopeRovingFocusGroup);
    const isCurrentTabStop = context.currentTabStopId === id2;
    const getItems2 = useCollection$3(__scopeRovingFocusGroup);
    const { onFocusableItemAdd, onFocusableItemRemove, currentTabStopId } = context;
    reactExports.useEffect(() => {
      if (focusable) {
        onFocusableItemAdd();
        return () => onFocusableItemRemove();
      }
    }, [focusable, onFocusableItemAdd, onFocusableItemRemove]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$3.ItemSlot,
      {
        scope: __scopeRovingFocusGroup,
        id: id2,
        focusable,
        active,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            tabIndex: isCurrentTabStop ? 0 : -1,
            "data-orientation": context.orientation,
            ...itemProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!focusable) event.preventDefault();
              else context.onItemFocus(id2);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => context.onItemFocus(id2)),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if (event.key === "Tab" && event.shiftKey) {
                context.onItemShiftTab();
                return;
              }
              if (event.target !== event.currentTarget) return;
              const focusIntent = getFocusIntent(event, context.orientation, context.dir);
              if (focusIntent !== void 0) {
                if (event.metaKey || event.ctrlKey || event.altKey || event.shiftKey) return;
                event.preventDefault();
                const items = getItems2().filter((item) => item.focusable);
                let candidateNodes = items.map((item) => item.ref.current);
                if (focusIntent === "last") candidateNodes.reverse();
                else if (focusIntent === "prev" || focusIntent === "next") {
                  if (focusIntent === "prev") candidateNodes.reverse();
                  const currentIndex = candidateNodes.indexOf(event.currentTarget);
                  candidateNodes = context.loop ? wrapArray$2(candidateNodes, currentIndex + 1) : candidateNodes.slice(currentIndex + 1);
                }
                setTimeout(() => focusFirst$2(candidateNodes));
              }
            }),
            children: typeof children === "function" ? children({ isCurrentTabStop, hasTabStop: currentTabStopId != null }) : children
          }
        )
      }
    );
  }
);
RovingFocusGroupItem.displayName = ITEM_NAME$3;
var MAP_KEY_TO_FOCUS_INTENT = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function getDirectionAwareKey(key, dir) {
  if (dir !== "rtl") return key;
  return key === "ArrowLeft" ? "ArrowRight" : key === "ArrowRight" ? "ArrowLeft" : key;
}
function getFocusIntent(event, orientation, dir) {
  const key = getDirectionAwareKey(event.key, dir);
  if (orientation === "vertical" && ["ArrowLeft", "ArrowRight"].includes(key)) return void 0;
  if (orientation === "horizontal" && ["ArrowUp", "ArrowDown"].includes(key)) return void 0;
  return MAP_KEY_TO_FOCUS_INTENT[key];
}
function focusFirst$2(candidates, preventScroll = false) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus({ preventScroll });
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$2(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root$7 = RovingFocusGroup;
var Item$1 = RovingFocusGroupItem;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x3) {
    return Boolean(x3);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e3) {
          console.error("aria-hidden: cannot operate on ", node, e3);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s4, i3 = 1, n2 = arguments.length; i3 < n2; i3++) {
      s4 = arguments[i3];
      for (var p2 in s4) if (Object.prototype.hasOwnProperty.call(s4, p2)) t3[p2] = s4[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __rest(s4, e3) {
  var t3 = {};
  for (var p2 in s4) if (Object.prototype.hasOwnProperty.call(s4, p2) && e3.indexOf(p2) < 0)
    t3[p2] = s4[p2];
  if (s4 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i3 = 0, p2 = Object.getOwnPropertySymbols(s4); i3 < p2.length; i3++) {
      if (e3.indexOf(p2[i3]) < 0 && Object.prototype.propertyIsEnumerable.call(s4, p2[i3]))
        t3[p2[i3]] = s4[p2[i3]];
    }
  return t3;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i3 = 0, l2 = from.length, ar; i3 < l2; i3++) {
    if (ar || !(i3 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i3);
      ar[i3] = from[i3];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last = ref.value;
          if (last !== value) {
            ref.value = value;
            ref.callback(value, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect$2 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue2) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect$2(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a4) {
  return a4;
}
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x3) {
          return x3 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x3) {
          return cb2(x3);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x3) {
          pendingQueue.push(x3);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse = function(x3) {
  return parseInt(x3 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse(left), parse(top), parse(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable2 = elementCouldBeScrolled(axis, current);
    if (isScrollable2) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || false)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || false)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x3, y4) {
  return x3[0] === y4[0] && x3[1] === y4[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e3) {
      return e3.name === event.type && (e3.target === event.target || event.target === e3.shadowParent) && deltaCompare(e3.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e3) {
        return e3 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var SELECTION_KEYS$1 = ["Enter", " "];
var FIRST_KEYS = ["ArrowDown", "PageUp", "Home"];
var LAST_KEYS = ["ArrowUp", "PageDown", "End"];
var FIRST_LAST_KEYS = [...FIRST_KEYS, ...LAST_KEYS];
var SUB_OPEN_KEYS = {
  ltr: [...SELECTION_KEYS$1, "ArrowRight"],
  rtl: [...SELECTION_KEYS$1, "ArrowLeft"]
};
var SUB_CLOSE_KEYS = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
};
var MENU_NAME = "Menu";
var [Collection$2, useCollection$2, createCollectionScope$2] = createCollection(MENU_NAME);
var [createMenuContext, createMenuScope] = createContextScope(MENU_NAME, [
  createCollectionScope$2,
  createPopperScope,
  createRovingFocusGroupScope
]);
var usePopperScope$2 = createPopperScope();
var useRovingFocusGroupScope$1 = createRovingFocusGroupScope();
var [MenuProvider, useMenuContext] = createMenuContext(MENU_NAME);
var [MenuRootProvider, useMenuRootContext] = createMenuContext(MENU_NAME);
var Menu = (props) => {
  const { __scopeMenu, open = false, children, dir, onOpenChange, modal = true } = props;
  const popperScope = usePopperScope$2(__scopeMenu);
  const [content, setContent] = reactExports.useState(null);
  const isUsingKeyboardRef = reactExports.useRef(false);
  const handleOpenChange = useCallbackRef$1(onOpenChange);
  const direction = useDirection(dir);
  reactExports.useEffect(() => {
    const handleKeyDown = () => {
      isUsingKeyboardRef.current = true;
      document.addEventListener("pointerdown", handlePointer, { capture: true, once: true });
      document.addEventListener("pointermove", handlePointer, { capture: true, once: true });
    };
    const handlePointer = () => isUsingKeyboardRef.current = false;
    document.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => {
      document.removeEventListener("keydown", handleKeyDown, { capture: true });
      document.removeEventListener("pointerdown", handlePointer, { capture: true });
      document.removeEventListener("pointermove", handlePointer, { capture: true });
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuProvider,
    {
      scope: __scopeMenu,
      open,
      onOpenChange: handleOpenChange,
      content,
      onContentChange: setContent,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuRootProvider,
        {
          scope: __scopeMenu,
          onClose: reactExports.useCallback(() => handleOpenChange(false), [handleOpenChange]),
          isUsingKeyboardRef,
          dir: direction,
          modal,
          children
        }
      )
    }
  ) });
};
Menu.displayName = MENU_NAME;
var ANCHOR_NAME = "MenuAnchor";
var MenuAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...anchorProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { ...popperScope, ...anchorProps, ref: forwardedRef });
  }
);
MenuAnchor.displayName = ANCHOR_NAME;
var PORTAL_NAME$5 = "MenuPortal";
var [PortalProvider$2, usePortalContext$2] = createMenuContext(PORTAL_NAME$5, {
  forceMount: void 0
});
var MenuPortal = (props) => {
  const { __scopeMenu, forceMount, children, container } = props;
  const context = useMenuContext(PORTAL_NAME$5, __scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider$2, { scope: __scopeMenu, forceMount, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children }) }) });
};
MenuPortal.displayName = PORTAL_NAME$5;
var CONTENT_NAME$6 = "MenuContent";
var [MenuContentProvider, useMenuContentContext] = createMenuContext(CONTENT_NAME$6);
var MenuContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: rootContext.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(MenuRootContentNonModal, { ...contentProps, ref: forwardedRef }) }) }) });
  }
);
var MenuRootContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      const content = ref.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: context.open,
        disableOutsideScroll: true,
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault(),
          { checkForDefaultPrevented: false }
        ),
        onDismiss: () => context.onOpenChange(false)
      }
    );
  }
);
var MenuRootContentNonModal = reactExports.forwardRef((props, forwardedRef) => {
  const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    MenuContentImpl,
    {
      ...props,
      ref: forwardedRef,
      trapFocus: false,
      disableOutsidePointerEvents: false,
      disableOutsideScroll: false,
      onDismiss: () => context.onOpenChange(false)
    }
  );
});
var Slot$2 = /* @__PURE__ */ createSlot("MenuContent.ScrollLock");
var MenuContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeMenu,
      loop = false,
      trapFocus,
      onOpenAutoFocus,
      onCloseAutoFocus,
      disableOutsidePointerEvents,
      onEntryFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      disableOutsideScroll,
      ...contentProps
    } = props;
    const context = useMenuContext(CONTENT_NAME$6, __scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, __scopeMenu);
    const popperScope = usePopperScope$2(__scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
    const getItems2 = useCollection$2(__scopeMenu);
    const [currentItemId, setCurrentItemId] = reactExports.useState(null);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef, context.onContentChange);
    const timerRef = reactExports.useRef(0);
    const searchRef = reactExports.useRef("");
    const pointerGraceTimerRef = reactExports.useRef(0);
    const pointerGraceIntentRef = reactExports.useRef(null);
    const pointerDirRef = reactExports.useRef("right");
    const lastPointerXRef = reactExports.useRef(0);
    const ScrollLockWrapper = disableOutsideScroll ? ReactRemoveScroll : reactExports.Fragment;
    const scrollLockWrapperProps = disableOutsideScroll ? { as: Slot$2, allowPinchZoom: true } : void 0;
    const handleTypeaheadSearch = (key) => {
      const search = searchRef.current + key;
      const items = getItems2().filter((item) => !item.disabled);
      const currentItem = document.activeElement;
      const currentMatch = items.find((item) => item.ref.current === currentItem)?.textValue;
      const values = items.map((item) => item.textValue);
      const nextMatch = getNextMatch(values, search, currentMatch);
      const newItem = items.find((item) => item.textValue === nextMatch)?.ref.current;
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
      if (newItem) {
        setTimeout(() => newItem.focus());
      }
    };
    reactExports.useEffect(() => {
      return () => window.clearTimeout(timerRef.current);
    }, []);
    useFocusGuards();
    const isPointerMovingToSubmenu = reactExports.useCallback((event) => {
      const isMovingTowards = pointerDirRef.current === pointerGraceIntentRef.current?.side;
      return isMovingTowards && isPointerInGraceArea(event, pointerGraceIntentRef.current?.area);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentProvider,
      {
        scope: __scopeMenu,
        searchRef,
        onItemEnter: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        onItemLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) return;
            contentRef.current?.focus();
            setCurrentItemId(null);
          },
          [isPointerMovingToSubmenu]
        ),
        onTriggerLeave: reactExports.useCallback(
          (event) => {
            if (isPointerMovingToSubmenu(event)) event.preventDefault();
          },
          [isPointerMovingToSubmenu]
        ),
        pointerGraceTimerRef,
        onPointerGraceIntentChange: reactExports.useCallback((intent) => {
          pointerGraceIntentRef.current = intent;
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollLockWrapper, { ...scrollLockWrapperProps, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: trapFocus,
            onMountAutoFocus: composeEventHandlers(onOpenAutoFocus, (event) => {
              event.preventDefault();
              contentRef.current?.focus({ preventScroll: true });
            }),
            onUnmountAutoFocus: onCloseAutoFocus,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside,
                onInteractOutside,
                onDismiss,
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Root$7,
                  {
                    asChild: true,
                    ...rovingFocusGroupScope,
                    dir: rootContext.dir,
                    orientation: "vertical",
                    loop,
                    currentTabStopId: currentItemId,
                    onCurrentTabStopIdChange: setCurrentItemId,
                    onEntryFocus: composeEventHandlers(onEntryFocus, (event) => {
                      if (!rootContext.isUsingKeyboardRef.current) event.preventDefault();
                    }),
                    preventScrollOnEntryFocus: true,
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      Content$2,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": getOpenState(context.open),
                        "data-radix-menu-content": "",
                        dir: rootContext.dir,
                        ...popperScope,
                        ...contentProps,
                        ref: composedRefs,
                        style: { outline: "none", ...contentProps.style },
                        onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                          const target = event.target;
                          const isKeyDownInside = target.closest("[data-radix-menu-content]") === event.currentTarget;
                          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                          const isCharacterKey = event.key.length === 1;
                          if (isKeyDownInside) {
                            if (event.key === "Tab") event.preventDefault();
                            if (!isModifierKey && isCharacterKey) handleTypeaheadSearch(event.key);
                          }
                          const content = contentRef.current;
                          if (event.target !== content) return;
                          if (!FIRST_LAST_KEYS.includes(event.key)) return;
                          event.preventDefault();
                          const items = getItems2().filter((item) => !item.disabled);
                          const candidateNodes = items.map((item) => item.ref.current);
                          if (LAST_KEYS.includes(event.key)) candidateNodes.reverse();
                          focusFirst$1(candidateNodes);
                        }),
                        onBlur: composeEventHandlers(props.onBlur, (event) => {
                          if (!event.currentTarget.contains(event.target)) {
                            window.clearTimeout(timerRef.current);
                            searchRef.current = "";
                          }
                        }),
                        onPointerMove: composeEventHandlers(
                          props.onPointerMove,
                          whenMouse((event) => {
                            const target = event.target;
                            const pointerXHasChanged = lastPointerXRef.current !== event.clientX;
                            if (event.currentTarget.contains(target) && pointerXHasChanged) {
                              const newDir = event.clientX > lastPointerXRef.current ? "right" : "left";
                              pointerDirRef.current = newDir;
                              lastPointerXRef.current = event.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
MenuContent.displayName = CONTENT_NAME$6;
var GROUP_NAME$2 = "MenuGroup";
var MenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...groupProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", ...groupProps, ref: forwardedRef });
  }
);
MenuGroup.displayName = GROUP_NAME$2;
var LABEL_NAME$2 = "MenuLabel";
var MenuLabel = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...labelProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...labelProps, ref: forwardedRef });
  }
);
MenuLabel.displayName = LABEL_NAME$2;
var ITEM_NAME$2 = "MenuItem";
var ITEM_SELECT = "menu.itemSelect";
var MenuItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { disabled = false, onSelect, ...itemProps } = props;
    const ref = reactExports.useRef(null);
    const rootContext = useMenuRootContext(ITEM_NAME$2, props.__scopeMenu);
    const contentContext = useMenuContentContext(ITEM_NAME$2, props.__scopeMenu);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const isPointerDownRef = reactExports.useRef(false);
    const handleSelect = () => {
      const menuItem = ref.current;
      if (!disabled && menuItem) {
        const itemSelectEvent = new CustomEvent(ITEM_SELECT, { bubbles: true, cancelable: true });
        menuItem.addEventListener(ITEM_SELECT, (event) => onSelect?.(event), { once: true });
        dispatchDiscreteCustomEvent(menuItem, itemSelectEvent);
        if (itemSelectEvent.defaultPrevented) {
          isPointerDownRef.current = false;
        } else {
          rootContext.onClose();
        }
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        ...itemProps,
        ref: composedRefs,
        disabled,
        onClick: composeEventHandlers(props.onClick, handleSelect),
        onPointerDown: (event) => {
          props.onPointerDown?.(event);
          isPointerDownRef.current = true;
        },
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          if (!isPointerDownRef.current) event.currentTarget?.click();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (disabled || isTypingAhead && event.key === " ") return;
          if (SELECTION_KEYS$1.includes(event.key)) {
            event.currentTarget.click();
            event.preventDefault();
          }
        })
      }
    );
  }
);
MenuItem.displayName = ITEM_NAME$2;
var MenuItemImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, disabled = false, textValue, ...itemProps } = props;
    const contentContext = useMenuContentContext(ITEM_NAME$2, __scopeMenu);
    const rovingFocusGroupScope = useRovingFocusGroupScope$1(__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const [textContent, setTextContent] = reactExports.useState("");
    reactExports.useEffect(() => {
      const menuItem = ref.current;
      if (menuItem) {
        setTextContent((menuItem.textContent ?? "").trim());
      }
    }, [itemProps.children]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Collection$2.ItemSlot,
      {
        scope: __scopeMenu,
        disabled,
        textValue: textValue ?? textContent,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Item$1, { asChild: true, ...rovingFocusGroupScope, focusable: !disabled, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "menuitem",
            "data-highlighted": isFocused ? "" : void 0,
            "aria-disabled": disabled || void 0,
            "data-disabled": disabled ? "" : void 0,
            ...itemProps,
            ref: composedRefs,
            onPointerMove: composeEventHandlers(
              props.onPointerMove,
              whenMouse((event) => {
                if (disabled) {
                  contentContext.onItemLeave(event);
                } else {
                  contentContext.onItemEnter(event);
                  if (!event.defaultPrevented) {
                    const item = event.currentTarget;
                    item.focus({ preventScroll: true });
                  }
                }
              })
            ),
            onPointerLeave: composeEventHandlers(
              props.onPointerLeave,
              whenMouse((event) => contentContext.onItemLeave(event))
            ),
            onFocus: composeEventHandlers(props.onFocus, () => setIsFocused(true)),
            onBlur: composeEventHandlers(props.onBlur, () => setIsFocused(false))
          }
        ) })
      }
    );
  }
);
var CHECKBOX_ITEM_NAME$1 = "MenuCheckboxItem";
var MenuCheckboxItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { checked = false, onCheckedChange, ...checkboxItemProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemcheckbox",
        "aria-checked": isIndeterminate$1(checked) ? "mixed" : checked,
        ...checkboxItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          checkboxItemProps.onSelect,
          () => onCheckedChange?.(isIndeterminate$1(checked) ? true : !checked),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuCheckboxItem.displayName = CHECKBOX_ITEM_NAME$1;
var RADIO_GROUP_NAME$1 = "MenuRadioGroup";
var [RadioGroupProvider, useRadioGroupContext] = createMenuContext(
  RADIO_GROUP_NAME$1,
  { value: void 0, onValueChange: () => {
  } }
);
var MenuRadioGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, onValueChange, ...groupProps } = props;
    const handleValueChange = useCallbackRef$1(onValueChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroupProvider, { scope: props.__scopeMenu, value, onValueChange: handleValueChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MenuGroup, { ...groupProps, ref: forwardedRef }) });
  }
);
MenuRadioGroup.displayName = RADIO_GROUP_NAME$1;
var RADIO_ITEM_NAME$1 = "MenuRadioItem";
var MenuRadioItem = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...radioItemProps } = props;
    const context = useRadioGroupContext(RADIO_ITEM_NAME$1, props.__scopeMenu);
    const checked = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicatorProvider, { scope: props.__scopeMenu, checked, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItem,
      {
        role: "menuitemradio",
        "aria-checked": checked,
        ...radioItemProps,
        ref: forwardedRef,
        "data-state": getCheckedState(checked),
        onSelect: composeEventHandlers(
          radioItemProps.onSelect,
          () => context.onValueChange?.(value),
          { checkForDefaultPrevented: false }
        )
      }
    ) });
  }
);
MenuRadioItem.displayName = RADIO_ITEM_NAME$1;
var ITEM_INDICATOR_NAME$1 = "MenuItemIndicator";
var [ItemIndicatorProvider, useItemIndicatorContext] = createMenuContext(
  ITEM_INDICATOR_NAME$1,
  { checked: false }
);
var MenuItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, forceMount, ...itemIndicatorProps } = props;
    const indicatorContext = useItemIndicatorContext(ITEM_INDICATOR_NAME$1, __scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Presence,
      {
        present: forceMount || isIndeterminate$1(indicatorContext.checked) || indicatorContext.checked === true,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.span,
          {
            ...itemIndicatorProps,
            ref: forwardedRef,
            "data-state": getCheckedState(indicatorContext.checked)
          }
        )
      }
    );
  }
);
MenuItemIndicator.displayName = ITEM_INDICATOR_NAME$1;
var SEPARATOR_NAME$2 = "MenuSeparator";
var MenuSeparator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...separatorProps,
        ref: forwardedRef
      }
    );
  }
);
MenuSeparator.displayName = SEPARATOR_NAME$2;
var ARROW_NAME$3 = "MenuArrow";
var MenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeMenu, ...arrowProps } = props;
    const popperScope = usePopperScope$2(__scopeMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
MenuArrow.displayName = ARROW_NAME$3;
var SUB_NAME = "MenuSub";
var [MenuSubProvider, useMenuSubContext] = createMenuContext(SUB_NAME);
var SUB_TRIGGER_NAME$1 = "MenuSubTrigger";
var MenuSubTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useMenuContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const rootContext = useMenuRootContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const contentContext = useMenuContentContext(SUB_TRIGGER_NAME$1, props.__scopeMenu);
    const openTimerRef = reactExports.useRef(null);
    const { pointerGraceTimerRef, onPointerGraceIntentChange } = contentContext;
    const scope = { __scopeMenu: props.__scopeMenu };
    const clearOpenTimer = reactExports.useCallback(() => {
      if (openTimerRef.current) window.clearTimeout(openTimerRef.current);
      openTimerRef.current = null;
    }, []);
    reactExports.useEffect(() => clearOpenTimer, [clearOpenTimer]);
    reactExports.useEffect(() => {
      const pointerGraceTimer = pointerGraceTimerRef.current;
      return () => {
        window.clearTimeout(pointerGraceTimer);
        onPointerGraceIntentChange(null);
      };
    }, [pointerGraceTimerRef, onPointerGraceIntentChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(MenuAnchor, { asChild: true, ...scope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuItemImpl,
      {
        id: subContext.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": subContext.contentId,
        "data-state": getOpenState(context.open),
        ...props,
        ref: composeRefs(forwardedRef, subContext.onTriggerChange),
        onClick: (event) => {
          props.onClick?.(event);
          if (props.disabled || event.defaultPrevented) return;
          event.currentTarget.focus();
          if (!context.open) context.onOpenChange(true);
        },
        onPointerMove: composeEventHandlers(
          props.onPointerMove,
          whenMouse((event) => {
            contentContext.onItemEnter(event);
            if (event.defaultPrevented) return;
            if (!props.disabled && !context.open && !openTimerRef.current) {
              contentContext.onPointerGraceIntentChange(null);
              openTimerRef.current = window.setTimeout(() => {
                context.onOpenChange(true);
                clearOpenTimer();
              }, 100);
            }
          })
        ),
        onPointerLeave: composeEventHandlers(
          props.onPointerLeave,
          whenMouse((event) => {
            clearOpenTimer();
            const contentRect = context.content?.getBoundingClientRect();
            if (contentRect) {
              const side = context.content?.dataset.side;
              const rightSide = side === "right";
              const bleed = rightSide ? -5 : 5;
              const contentNearEdge = contentRect[rightSide ? "left" : "right"];
              const contentFarEdge = contentRect[rightSide ? "right" : "left"];
              contentContext.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: event.clientX + bleed, y: event.clientY },
                  { x: contentNearEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.top },
                  { x: contentFarEdge, y: contentRect.bottom },
                  { x: contentNearEdge, y: contentRect.bottom }
                ],
                side
              });
              window.clearTimeout(pointerGraceTimerRef.current);
              pointerGraceTimerRef.current = window.setTimeout(
                () => contentContext.onPointerGraceIntentChange(null),
                300
              );
            } else {
              contentContext.onTriggerLeave(event);
              if (event.defaultPrevented) return;
              contentContext.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isTypingAhead = contentContext.searchRef.current !== "";
          if (props.disabled || isTypingAhead && event.key === " ") return;
          if (SUB_OPEN_KEYS[rootContext.dir].includes(event.key)) {
            context.onOpenChange(true);
            context.content?.focus();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
MenuSubTrigger.displayName = SUB_TRIGGER_NAME$1;
var SUB_CONTENT_NAME$1 = "MenuSubContent";
var MenuSubContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$2(CONTENT_NAME$6, props.__scopeMenu);
    const { forceMount = portalContext.forceMount, ...subContentProps } = props;
    const context = useMenuContext(CONTENT_NAME$6, props.__scopeMenu);
    const rootContext = useMenuRootContext(CONTENT_NAME$6, props.__scopeMenu);
    const subContext = useMenuSubContext(SUB_CONTENT_NAME$1, props.__scopeMenu);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Provider, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$2.Slot, { scope: props.__scopeMenu, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      MenuContentImpl,
      {
        id: subContext.contentId,
        "aria-labelledby": subContext.triggerId,
        ...subContentProps,
        ref: composedRefs,
        align: "start",
        side: rootContext.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: false,
        disableOutsideScroll: false,
        trapFocus: false,
        onOpenAutoFocus: (event) => {
          if (rootContext.isUsingKeyboardRef.current) ref.current?.focus();
          event.preventDefault();
        },
        onCloseAutoFocus: (event) => event.preventDefault(),
        onFocusOutside: composeEventHandlers(props.onFocusOutside, (event) => {
          if (event.target !== subContext.trigger) context.onOpenChange(false);
        }),
        onEscapeKeyDown: composeEventHandlers(props.onEscapeKeyDown, (event) => {
          rootContext.onClose();
          event.preventDefault();
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          const isKeyDownInside = event.currentTarget.contains(event.target);
          const isCloseKey = SUB_CLOSE_KEYS[rootContext.dir].includes(event.key);
          if (isKeyDownInside && isCloseKey) {
            context.onOpenChange(false);
            subContext.trigger?.focus();
            event.preventDefault();
          }
        })
      }
    ) }) }) });
  }
);
MenuSubContent.displayName = SUB_CONTENT_NAME$1;
function getOpenState(open) {
  return open ? "open" : "closed";
}
function isIndeterminate$1(checked) {
  return checked === "indeterminate";
}
function getCheckedState(checked) {
  return isIndeterminate$1(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
function focusFirst$1(candidates) {
  const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
  for (const candidate of candidates) {
    if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
    candidate.focus();
    if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
  }
}
function wrapArray$1(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
function getNextMatch(values, search, currentMatch) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentMatchIndex = currentMatch ? values.indexOf(currentMatch) : -1;
  let wrappedValues = wrapArray$1(values, Math.max(currentMatchIndex, 0));
  const excludeCurrentMatch = normalizedSearch.length === 1;
  if (excludeCurrentMatch) wrappedValues = wrappedValues.filter((v2) => v2 !== currentMatch);
  const nextMatch = wrappedValues.find(
    (value) => value.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextMatch !== currentMatch ? nextMatch : void 0;
}
function isPointInPolygon$1(point, polygon) {
  const { x: x3, y: y4 } = point;
  let inside = false;
  for (let i3 = 0, j2 = polygon.length - 1; i3 < polygon.length; j2 = i3++) {
    const ii2 = polygon[i3];
    const jj2 = polygon[j2];
    const xi2 = ii2.x;
    const yi2 = ii2.y;
    const xj2 = jj2.x;
    const yj2 = jj2.y;
    const intersect = yi2 > y4 !== yj2 > y4 && x3 < (xj2 - xi2) * (y4 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function isPointerInGraceArea(event, area) {
  if (!area) return false;
  const cursorPos = { x: event.clientX, y: event.clientY };
  return isPointInPolygon$1(cursorPos, area);
}
function whenMouse(handler) {
  return (event) => event.pointerType === "mouse" ? handler(event) : void 0;
}
var Root3$1 = Menu;
var Anchor2 = MenuAnchor;
var Portal$2 = MenuPortal;
var Content2$4 = MenuContent;
var Group = MenuGroup;
var Label$3 = MenuLabel;
var Item2$1 = MenuItem;
var CheckboxItem = MenuCheckboxItem;
var RadioGroup = MenuRadioGroup;
var RadioItem = MenuRadioItem;
var ItemIndicator$1 = MenuItemIndicator;
var Separator$1 = MenuSeparator;
var Arrow2 = MenuArrow;
var SubTrigger = MenuSubTrigger;
var SubContent = MenuSubContent;
var DROPDOWN_MENU_NAME = "DropdownMenu";
var [createDropdownMenuContext, createDropdownMenuScope] = createContextScope(
  DROPDOWN_MENU_NAME,
  [createMenuScope]
);
var useMenuScope = createMenuScope();
var [DropdownMenuProvider, useDropdownMenuContext] = createDropdownMenuContext(DROPDOWN_MENU_NAME);
var DropdownMenu$1 = (props) => {
  const {
    __scopeDropdownMenu,
    children,
    dir,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  const triggerRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DROPDOWN_MENU_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DropdownMenuProvider,
    {
      scope: __scopeDropdownMenu,
      triggerId: useId(),
      triggerRef,
      contentId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root3$1, { ...menuScope, open, onOpenChange: setOpen, dir, modal, children })
    }
  );
};
DropdownMenu$1.displayName = DROPDOWN_MENU_NAME;
var TRIGGER_NAME$5 = "DropdownMenuTrigger";
var DropdownMenuTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, disabled = false, ...triggerProps } = props;
    const context = useDropdownMenuContext(TRIGGER_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor2, { asChild: true, ...menuScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        id: context.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": context.open,
        "aria-controls": context.open ? context.contentId : void 0,
        "data-state": context.open ? "open" : "closed",
        "data-disabled": disabled ? "" : void 0,
        disabled,
        ...triggerProps,
        ref: composeRefs(forwardedRef, context.triggerRef),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          if (!disabled && event.button === 0 && event.ctrlKey === false) {
            context.onOpenToggle();
            if (!context.open) event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (disabled) return;
          if (["Enter", " "].includes(event.key)) context.onOpenToggle();
          if (event.key === "ArrowDown") context.onOpenChange(true);
          if (["Enter", " ", "ArrowDown"].includes(event.key)) event.preventDefault();
        })
      }
    ) });
  }
);
DropdownMenuTrigger$1.displayName = TRIGGER_NAME$5;
var PORTAL_NAME$4 = "DropdownMenuPortal";
var DropdownMenuPortal = (props) => {
  const { __scopeDropdownMenu, ...portalProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { ...menuScope, ...portalProps });
};
DropdownMenuPortal.displayName = PORTAL_NAME$4;
var CONTENT_NAME$5 = "DropdownMenuContent";
var DropdownMenuContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...contentProps } = props;
    const context = useDropdownMenuContext(CONTENT_NAME$5, __scopeDropdownMenu);
    const menuScope = useMenuScope(__scopeDropdownMenu);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Content2$4,
      {
        id: context.contentId,
        "aria-labelledby": context.triggerId,
        ...menuScope,
        ...contentProps,
        ref: forwardedRef,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
          hasInteractedOutsideRef.current = false;
          event.preventDefault();
        }),
        onInteractOutside: composeEventHandlers(props.onInteractOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (!context.modal || isRightClick) hasInteractedOutsideRef.current = true;
        }),
        style: {
          ...props.style,
          // re-namespace exposed content custom properties
          ...{
            "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
            "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
            "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
          }
        }
      }
    );
  }
);
DropdownMenuContent$1.displayName = CONTENT_NAME$5;
var GROUP_NAME$1 = "DropdownMenuGroup";
var DropdownMenuGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...groupProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Group, { ...menuScope, ...groupProps, ref: forwardedRef });
  }
);
DropdownMenuGroup.displayName = GROUP_NAME$1;
var LABEL_NAME$1 = "DropdownMenuLabel";
var DropdownMenuLabel$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...labelProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Label$3, { ...menuScope, ...labelProps, ref: forwardedRef });
  }
);
DropdownMenuLabel$1.displayName = LABEL_NAME$1;
var ITEM_NAME$1 = "DropdownMenuItem";
var DropdownMenuItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...itemProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Item2$1, { ...menuScope, ...itemProps, ref: forwardedRef });
  }
);
DropdownMenuItem$1.displayName = ITEM_NAME$1;
var CHECKBOX_ITEM_NAME = "DropdownMenuCheckboxItem";
var DropdownMenuCheckboxItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...checkboxItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(CheckboxItem, { ...menuScope, ...checkboxItemProps, ref: forwardedRef });
});
DropdownMenuCheckboxItem$1.displayName = CHECKBOX_ITEM_NAME;
var RADIO_GROUP_NAME = "DropdownMenuRadioGroup";
var DropdownMenuRadioGroup = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioGroupProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioGroup, { ...menuScope, ...radioGroupProps, ref: forwardedRef });
});
DropdownMenuRadioGroup.displayName = RADIO_GROUP_NAME;
var RADIO_ITEM_NAME = "DropdownMenuRadioItem";
var DropdownMenuRadioItem$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...radioItemProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RadioItem, { ...menuScope, ...radioItemProps, ref: forwardedRef });
});
DropdownMenuRadioItem$1.displayName = RADIO_ITEM_NAME;
var INDICATOR_NAME$1 = "DropdownMenuItemIndicator";
var DropdownMenuItemIndicator = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...itemIndicatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator$1, { ...menuScope, ...itemIndicatorProps, ref: forwardedRef });
});
DropdownMenuItemIndicator.displayName = INDICATOR_NAME$1;
var SEPARATOR_NAME$1 = "DropdownMenuSeparator";
var DropdownMenuSeparator$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...separatorProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Separator$1, { ...menuScope, ...separatorProps, ref: forwardedRef });
});
DropdownMenuSeparator$1.displayName = SEPARATOR_NAME$1;
var ARROW_NAME$2 = "DropdownMenuArrow";
var DropdownMenuArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDropdownMenu, ...arrowProps } = props;
    const menuScope = useMenuScope(__scopeDropdownMenu);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow2, { ...menuScope, ...arrowProps, ref: forwardedRef });
  }
);
DropdownMenuArrow.displayName = ARROW_NAME$2;
var SUB_TRIGGER_NAME = "DropdownMenuSubTrigger";
var DropdownMenuSubTrigger$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subTriggerProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SubTrigger, { ...menuScope, ...subTriggerProps, ref: forwardedRef });
});
DropdownMenuSubTrigger$1.displayName = SUB_TRIGGER_NAME;
var SUB_CONTENT_NAME = "DropdownMenuSubContent";
var DropdownMenuSubContent$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeDropdownMenu, ...subContentProps } = props;
  const menuScope = useMenuScope(__scopeDropdownMenu);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SubContent,
    {
      ...menuScope,
      ...subContentProps,
      ref: forwardedRef,
      style: {
        ...props.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
DropdownMenuSubContent$1.displayName = SUB_CONTENT_NAME;
var Root2$4 = DropdownMenu$1;
var Trigger$4 = DropdownMenuTrigger$1;
var Portal2$1 = DropdownMenuPortal;
var Content2$3 = DropdownMenuContent$1;
var Label2 = DropdownMenuLabel$1;
var Item2 = DropdownMenuItem$1;
var CheckboxItem2 = DropdownMenuCheckboxItem$1;
var RadioItem2 = DropdownMenuRadioItem$1;
var ItemIndicator2 = DropdownMenuItemIndicator;
var Separator2 = DropdownMenuSeparator$1;
var SubTrigger2 = DropdownMenuSubTrigger$1;
var SubContent2 = DropdownMenuSubContent$1;
const DropdownMenu = Root2$4;
const DropdownMenuTrigger = Trigger$4;
const DropdownMenuSubTrigger = reactExports.forwardRef(({ className, inset, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  SubTrigger2,
  {
    ref,
    className: cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent",
      inset && "pl-8",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, { className: "ml-auto h-4 w-4" })
    ]
  }
));
DropdownMenuSubTrigger.displayName = SubTrigger2.displayName;
const DropdownMenuSubContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  SubContent2,
  {
    ref,
    className: cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    ),
    ...props
  }
));
DropdownMenuSubContent.displayName = SubContent2.displayName;
const DropdownMenuContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal2$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2$3,
  {
    ref,
    sideOffset,
    className: cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    ),
    ...props
  }
) }));
DropdownMenuContent.displayName = Content2$3.displayName;
const DropdownMenuItem = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Item2,
  {
    ref,
    className: cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    ),
    ...props
  }
));
DropdownMenuItem.displayName = Item2.displayName;
const DropdownMenuCheckboxItem = reactExports.forwardRef(({ className, children, checked, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  CheckboxItem2,
  {
    ref,
    className: cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    checked,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
      children
    ]
  }
));
DropdownMenuCheckboxItem.displayName = CheckboxItem2.displayName;
const DropdownMenuRadioItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  RadioItem2,
  {
    ref,
    className: cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator2, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Circle, { className: "h-2 w-2 fill-current" }) }) }),
      children
    ]
  }
));
DropdownMenuRadioItem.displayName = RadioItem2.displayName;
const DropdownMenuLabel = reactExports.forwardRef(({ className, inset, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label2,
  {
    ref,
    className: cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    ),
    ...props
  }
));
DropdownMenuLabel.displayName = Label2.displayName;
const DropdownMenuSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator2,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
DropdownMenuSeparator.displayName = Separator2.displayName;
const falsyToString = (value) => typeof value === "boolean" ? `${value}` : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config) => (props) => {
  var _config_compoundVariants;
  if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  const { variants, defaultVariants } = config;
  const getVariantClassNames = Object.keys(variants).map((variant) => {
    const variantProp = props === null || props === void 0 ? void 0 : props[variant];
    const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
    if (variantProp === null) return null;
    const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
    return variants[variant][variantKey];
  });
  const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
    let [key, value] = param;
    if (value === void 0) {
      return acc;
    }
    acc[key] = value;
    return acc;
  }, {});
  const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (_config_compoundVariants = config.compoundVariants) === null || _config_compoundVariants === void 0 ? void 0 : _config_compoundVariants.reduce((acc, param) => {
    let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param;
    return Object.entries(compoundVariantOptions).every((param2) => {
      let [key, value] = param2;
      return Array.isArray(value) ? value.includes({
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key]) : {
        ...defaultVariants,
        ...propsWithoutUndefined
      }[key] === value;
    }) ? [
      ...acc,
      cvClass,
      cvClassName
    ] : acc;
  }, []);
  return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
};
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button = reactExports.forwardRef(
  ({ className, variant, size: size2, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot$3 : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn(buttonVariants({ variant, size: size2, className })),
        ref,
        ...props
      }
    );
  }
);
Button.displayName = "Button";
var shim$1 = { exports: {} };
var useSyncExternalStoreShim_production = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var React = reactExports;
function is(x3, y4) {
  return x3 === y4 && (0 !== x3 || 1 / x3 === 1 / y4) || x3 !== x3 && y4 !== y4;
}
var objectIs = "function" === typeof Object.is ? Object.is : is, useState = React.useState, useEffect = React.useEffect, useLayoutEffect = React.useLayoutEffect, useDebugValue = React.useDebugValue;
function useSyncExternalStore$2(subscribe2, getSnapshot) {
  var value = getSnapshot(), _useState = useState({ inst: { value, getSnapshot } }), inst = _useState[0].inst, forceUpdate = _useState[1];
  useLayoutEffect(
    function() {
      inst.value = value;
      inst.getSnapshot = getSnapshot;
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
    },
    [subscribe2, value, getSnapshot]
  );
  useEffect(
    function() {
      checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      return subscribe2(function() {
        checkIfSnapshotChanged(inst) && forceUpdate({ inst });
      });
    },
    [subscribe2]
  );
  useDebugValue(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  var latestGetSnapshot = inst.getSnapshot;
  inst = inst.value;
  try {
    var nextValue = latestGetSnapshot();
    return !objectIs(inst, nextValue);
  } catch (error) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe2, getSnapshot) {
  return getSnapshot();
}
var shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
useSyncExternalStoreShim_production.useSyncExternalStore = void 0 !== React.useSyncExternalStore ? React.useSyncExternalStore : shim;
{
  shim$1.exports = useSyncExternalStoreShim_production;
}
var shimExports = shim$1.exports;
function useIsHydrated() {
  return shimExports.useSyncExternalStore(
    subscribe,
    () => true,
    () => false
  );
}
function subscribe() {
  return () => {
  };
}
var AVATAR_NAME = "Avatar";
var [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME);
var [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME);
var Avatar$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, ...avatarProps } = props;
    const [imageLoadingStatus, setImageLoadingStatus] = reactExports.useState("idle");
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      AvatarProvider,
      {
        scope: __scopeAvatar,
        imageLoadingStatus,
        onImageLoadingStatusChange: setImageLoadingStatus,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { ...avatarProps, ref: forwardedRef })
      }
    );
  }
);
Avatar$1.displayName = AVATAR_NAME;
var IMAGE_NAME = "AvatarImage";
var AvatarImage$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, src, onLoadingStatusChange = () => {
    }, ...imageProps } = props;
    const context = useAvatarContext(IMAGE_NAME, __scopeAvatar);
    const imageLoadingStatus = useImageLoadingStatus(src, imageProps);
    const handleLoadingStatusChange = useCallbackRef$1((status) => {
      onLoadingStatusChange(status);
      context.onImageLoadingStatusChange(status);
    });
    useLayoutEffect2(() => {
      if (imageLoadingStatus !== "idle") {
        handleLoadingStatusChange(imageLoadingStatus);
      }
    }, [imageLoadingStatus, handleLoadingStatusChange]);
    return imageLoadingStatus === "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.img, { ...imageProps, ref: forwardedRef, src }) : null;
  }
);
AvatarImage$1.displayName = IMAGE_NAME;
var FALLBACK_NAME = "AvatarFallback";
var AvatarFallback$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAvatar, delayMs, ...fallbackProps } = props;
    const context = useAvatarContext(FALLBACK_NAME, __scopeAvatar);
    const [canRender, setCanRender] = reactExports.useState(delayMs === void 0);
    reactExports.useEffect(() => {
      if (delayMs !== void 0) {
        const timerId = window.setTimeout(() => setCanRender(true), delayMs);
        return () => window.clearTimeout(timerId);
      }
    }, [delayMs]);
    return canRender && context.imageLoadingStatus !== "loaded" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { ...fallbackProps, ref: forwardedRef }) : null;
  }
);
AvatarFallback$1.displayName = FALLBACK_NAME;
function resolveLoadingStatus(image, src) {
  if (!image) {
    return "idle";
  }
  if (!src) {
    return "error";
  }
  if (image.src !== src) {
    image.src = src;
  }
  return image.complete && image.naturalWidth > 0 ? "loaded" : "loading";
}
function useImageLoadingStatus(src, { referrerPolicy, crossOrigin }) {
  const isHydrated = useIsHydrated();
  const imageRef = reactExports.useRef(null);
  const image = (() => {
    if (!isHydrated) return null;
    if (!imageRef.current) {
      imageRef.current = new window.Image();
    }
    return imageRef.current;
  })();
  const [loadingStatus, setLoadingStatus] = reactExports.useState(
    () => resolveLoadingStatus(image, src)
  );
  useLayoutEffect2(() => {
    setLoadingStatus(resolveLoadingStatus(image, src));
  }, [image, src]);
  useLayoutEffect2(() => {
    const updateStatus = (status) => () => {
      setLoadingStatus(status);
    };
    if (!image) return;
    const handleLoad = updateStatus("loaded");
    const handleError = updateStatus("error");
    image.addEventListener("load", handleLoad);
    image.addEventListener("error", handleError);
    if (referrerPolicy) {
      image.referrerPolicy = referrerPolicy;
    }
    if (typeof crossOrigin === "string") {
      image.crossOrigin = crossOrigin;
    }
    return () => {
      image.removeEventListener("load", handleLoad);
      image.removeEventListener("error", handleError);
    };
  }, [image, crossOrigin, referrerPolicy]);
  return loadingStatus;
}
var Root$6 = Avatar$1;
var Image$1 = AvatarImage$1;
var Fallback = AvatarFallback$1;
const Avatar = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$6,
  {
    ref,
    className: cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    ),
    ...props
  }
));
Avatar.displayName = Root$6.displayName;
const AvatarImage = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Image$1,
  {
    ref,
    className: cn("aspect-square h-full w-full", className),
    ...props
  }
));
AvatarImage.displayName = Image$1.displayName;
const AvatarFallback = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Fallback,
  {
    ref,
    className: cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    ),
    ...props
  }
));
AvatarFallback.displayName = Fallback.displayName;
function UserMenu() {
  const { currentUser, logout } = useAuth();
  const navigate = useNavigate();
  const [isOpen, setIsOpen] = reactExports.useState(false);
  const handleLogout = async () => {
    try {
      await logout();
      navigate("/login");
    } catch (error) {
      console.error("Failed to logout:", error);
    }
  };
  if (!currentUser) return null;
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenu, { open: isOpen, onOpenChange: setIsOpen, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", className: "relative h-8 w-8 rounded-full", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Avatar, { className: "h-8 w-8", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AvatarFallback, { children: currentUser.displayName.charAt(0).toUpperCase() }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuContent, { className: "w-56", align: "end", forceMount: true, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuLabel, { className: "font-normal", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium leading-none", children: currentUser.displayName }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-xs leading-none text-muted-foreground", children: [
          "@",
          currentUser.username
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DropdownMenuSeparator, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuItem, { onClick: () => {
        navigate("/settings?tab=users");
        setIsOpen(false);
      }, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(User, { className: "mr-2 h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Profile" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DropdownMenuItem, { onClick: handleLogout, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(LogOut, { className: "mr-2 h-4 w-4" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: "Log out" })
      ] })
    ] })
  ] });
}
var VISUALLY_HIDDEN_STYLES = Object.freeze({
  // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
  position: "absolute",
  border: 0,
  width: 1,
  height: 1,
  padding: 0,
  margin: -1,
  overflow: "hidden",
  clip: "rect(0, 0, 0, 0)",
  whiteSpace: "nowrap",
  wordWrap: "normal"
});
var NAME$1 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$1;
var Root$5 = VisuallyHidden;
var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [
  createPopperScope
]);
var usePopperScope$1 = createPopperScope();
var PROVIDER_NAME$1 = "TooltipProvider";
var DEFAULT_DELAY_DURATION = 700;
var TOOLTIP_OPEN = "tooltip.open";
var [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME$1);
var TooltipProvider$1 = (props) => {
  const {
    __scopeTooltip,
    delayDuration = DEFAULT_DELAY_DURATION,
    skipDelayDuration = 300,
    disableHoverableContent = false,
    children
  } = props;
  const isOpenDelayedRef = reactExports.useRef(true);
  const isPointerInTransitRef = reactExports.useRef(false);
  const skipDelayTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => {
    const skipDelayTimer = skipDelayTimerRef.current;
    return () => window.clearTimeout(skipDelayTimer);
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipProviderContextProvider,
    {
      scope: __scopeTooltip,
      isOpenDelayedRef,
      delayDuration,
      onOpen: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        isOpenDelayedRef.current = false;
      }, []),
      onClose: reactExports.useCallback(() => {
        window.clearTimeout(skipDelayTimerRef.current);
        skipDelayTimerRef.current = window.setTimeout(
          () => isOpenDelayedRef.current = true,
          skipDelayDuration
        );
      }, [skipDelayDuration]),
      isPointerInTransitRef,
      onPointerInTransitChange: reactExports.useCallback((inTransit) => {
        isPointerInTransitRef.current = inTransit;
      }, []),
      disableHoverableContent,
      children
    }
  );
};
TooltipProvider$1.displayName = PROVIDER_NAME$1;
var TOOLTIP_NAME = "Tooltip";
var [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME);
var Tooltip$1 = (props) => {
  const {
    __scopeTooltip,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    disableHoverableContent: disableHoverableContentProp,
    delayDuration: delayDurationProp
  } = props;
  const providerContext = useTooltipProviderContext(TOOLTIP_NAME, props.__scopeTooltip);
  const popperScope = usePopperScope$1(__scopeTooltip);
  const [trigger, setTrigger] = reactExports.useState(null);
  const contentId = useId();
  const openTimerRef = reactExports.useRef(0);
  const disableHoverableContent = disableHoverableContentProp ?? providerContext.disableHoverableContent;
  const delayDuration = delayDurationProp ?? providerContext.delayDuration;
  const wasOpenDelayedRef = reactExports.useRef(false);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: (open2) => {
      if (open2) {
        providerContext.onOpen();
        document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN));
      } else {
        providerContext.onClose();
      }
      onOpenChange?.(open2);
    },
    caller: TOOLTIP_NAME
  });
  const stateAttribute = reactExports.useMemo(() => {
    return open ? wasOpenDelayedRef.current ? "delayed-open" : "instant-open" : "closed";
  }, [open]);
  const handleOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    wasOpenDelayedRef.current = false;
    setOpen(true);
  }, [setOpen]);
  const handleClose = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = 0;
    setOpen(false);
  }, [setOpen]);
  const handleDelayedOpen = reactExports.useCallback(() => {
    window.clearTimeout(openTimerRef.current);
    openTimerRef.current = window.setTimeout(() => {
      wasOpenDelayedRef.current = true;
      setOpen(true);
      openTimerRef.current = 0;
    }, delayDuration);
  }, [delayDuration, setOpen]);
  reactExports.useEffect(() => {
    return () => {
      if (openTimerRef.current) {
        window.clearTimeout(openTimerRef.current);
        openTimerRef.current = 0;
      }
    };
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    TooltipContextProvider,
    {
      scope: __scopeTooltip,
      contentId,
      open,
      stateAttribute,
      trigger,
      onTriggerChange: setTrigger,
      onTriggerEnter: reactExports.useCallback(() => {
        if (providerContext.isOpenDelayedRef.current) handleDelayedOpen();
        else handleOpen();
      }, [providerContext.isOpenDelayedRef, handleDelayedOpen, handleOpen]),
      onTriggerLeave: reactExports.useCallback(() => {
        if (disableHoverableContent) {
          handleClose();
        } else {
          window.clearTimeout(openTimerRef.current);
          openTimerRef.current = 0;
        }
      }, [handleClose, disableHoverableContent]),
      onOpen: handleOpen,
      onClose: handleClose,
      disableHoverableContent,
      children
    }
  ) });
};
Tooltip$1.displayName = TOOLTIP_NAME;
var TRIGGER_NAME$4 = "TooltipTrigger";
var TooltipTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...triggerProps } = props;
    const context = useTooltipContext(TRIGGER_NAME$4, __scopeTooltip);
    const providerContext = useTooltipProviderContext(TRIGGER_NAME$4, __scopeTooltip);
    const popperScope = usePopperScope$1(__scopeTooltip);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onTriggerChange);
    const isPointerDownRef = reactExports.useRef(false);
    const hasPointerMoveOpenedRef = reactExports.useRef(false);
    const handlePointerUp = reactExports.useCallback(() => isPointerDownRef.current = false, []);
    reactExports.useEffect(() => {
      return () => document.removeEventListener("pointerup", handlePointerUp);
    }, [handlePointerUp]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        "aria-describedby": context.open ? context.contentId : void 0,
        "data-state": context.stateAttribute,
        ...triggerProps,
        ref: composedRefs,
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          if (event.pointerType === "touch") return;
          if (!hasPointerMoveOpenedRef.current && !providerContext.isPointerInTransitRef.current) {
            context.onTriggerEnter();
            hasPointerMoveOpenedRef.current = true;
          }
        }),
        onPointerLeave: composeEventHandlers(props.onPointerLeave, () => {
          context.onTriggerLeave();
          hasPointerMoveOpenedRef.current = false;
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, () => {
          if (context.open) {
            context.onClose();
          }
          isPointerDownRef.current = true;
          document.addEventListener("pointerup", handlePointerUp, { once: true });
        }),
        onFocus: composeEventHandlers(props.onFocus, () => {
          if (!isPointerDownRef.current) context.onOpen();
        }),
        onBlur: composeEventHandlers(props.onBlur, context.onClose),
        onClick: composeEventHandlers(props.onClick, context.onClose)
      }
    ) });
  }
);
TooltipTrigger$1.displayName = TRIGGER_NAME$4;
var PORTAL_NAME$3 = "TooltipPortal";
var [PortalProvider$1, usePortalContext$1] = createTooltipContext(PORTAL_NAME$3, {
  forceMount: void 0
});
var CONTENT_NAME$4 = "TooltipContent";
var TooltipContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext$1(CONTENT_NAME$4, props.__scopeTooltip);
    const { forceMount = portalContext.forceMount, side = "top", ...contentProps } = props;
    const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.disableHoverableContent ? /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { side, ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentHoverable, { side, ...contentProps, ref: forwardedRef }) });
  }
);
var TooltipContentHoverable = reactExports.forwardRef((props, forwardedRef) => {
  const context = useTooltipContext(CONTENT_NAME$4, props.__scopeTooltip);
  const providerContext = useTooltipProviderContext(CONTENT_NAME$4, props.__scopeTooltip);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  const [pointerGraceArea, setPointerGraceArea] = reactExports.useState(null);
  const { trigger, onClose } = context;
  const content = ref.current;
  const { onPointerInTransitChange } = providerContext;
  const handleRemoveGraceArea = reactExports.useCallback(() => {
    setPointerGraceArea(null);
    onPointerInTransitChange(false);
  }, [onPointerInTransitChange]);
  const handleCreateGraceArea = reactExports.useCallback(
    (event, hoverTarget) => {
      const currentTarget = event.currentTarget;
      const exitPoint = { x: event.clientX, y: event.clientY };
      const exitSide = getExitSideFromRect(exitPoint, currentTarget.getBoundingClientRect());
      const paddedExitPoints = getPaddedExitPoints(exitPoint, exitSide);
      const hoverTargetPoints = getPointsFromRect(hoverTarget.getBoundingClientRect());
      const graceArea = getHull([...paddedExitPoints, ...hoverTargetPoints]);
      setPointerGraceArea(graceArea);
      onPointerInTransitChange(true);
    },
    [onPointerInTransitChange]
  );
  reactExports.useEffect(() => {
    return () => handleRemoveGraceArea();
  }, [handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (trigger && content) {
      const handleTriggerLeave = (event) => handleCreateGraceArea(event, content);
      const handleContentLeave = (event) => handleCreateGraceArea(event, trigger);
      trigger.addEventListener("pointerleave", handleTriggerLeave);
      content.addEventListener("pointerleave", handleContentLeave);
      return () => {
        trigger.removeEventListener("pointerleave", handleTriggerLeave);
        content.removeEventListener("pointerleave", handleContentLeave);
      };
    }
  }, [trigger, content, handleCreateGraceArea, handleRemoveGraceArea]);
  reactExports.useEffect(() => {
    if (pointerGraceArea) {
      const handleTrackPointerGrace = (event) => {
        const target = event.target;
        const pointerPosition = { x: event.clientX, y: event.clientY };
        const hasEnteredTarget = trigger?.contains(target) || content?.contains(target);
        const isPointerOutsideGraceArea = !isPointInPolygon(pointerPosition, pointerGraceArea);
        if (hasEnteredTarget) {
          handleRemoveGraceArea();
        } else if (isPointerOutsideGraceArea) {
          handleRemoveGraceArea();
          onClose();
        }
      };
      document.addEventListener("pointermove", handleTrackPointerGrace);
      return () => document.removeEventListener("pointermove", handleTrackPointerGrace);
    }
  }, [trigger, content, pointerGraceArea, onClose, handleRemoveGraceArea]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContentImpl, { ...props, ref: composedRefs });
});
var [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: false });
var Slottable$1 = /* @__PURE__ */ createSlottable("TooltipContent");
var TooltipContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTooltip,
      children,
      "aria-label": ariaLabel,
      onEscapeKeyDown,
      onPointerDownOutside,
      ...contentProps
    } = props;
    const context = useTooltipContext(CONTENT_NAME$4, __scopeTooltip);
    const popperScope = usePopperScope$1(__scopeTooltip);
    const { onClose } = context;
    reactExports.useEffect(() => {
      document.addEventListener(TOOLTIP_OPEN, onClose);
      return () => document.removeEventListener(TOOLTIP_OPEN, onClose);
    }, [onClose]);
    reactExports.useEffect(() => {
      if (context.trigger) {
        const handleScroll2 = (event) => {
          const target = event.target;
          if (target?.contains(context.trigger)) onClose();
        };
        window.addEventListener("scroll", handleScroll2, { capture: true });
        return () => window.removeEventListener("scroll", handleScroll2, { capture: true });
      }
    }, [context.trigger, onClose]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DismissableLayer,
      {
        asChild: true,
        disableOutsidePointerEvents: false,
        onEscapeKeyDown,
        onPointerDownOutside,
        onFocusOutside: (event) => event.preventDefault(),
        onDismiss: onClose,
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$2,
          {
            "data-state": context.stateAttribute,
            ...popperScope,
            ...contentProps,
            ref: forwardedRef,
            style: {
              ...contentProps.style,
              // re-namespace exposed content custom properties
              ...{
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
              }
            },
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable$1, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: __scopeTooltip, isInside: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Root$5, { id: context.contentId, role: "tooltip", children: ariaLabel || children }) })
            ]
          }
        )
      }
    );
  }
);
TooltipContent$1.displayName = CONTENT_NAME$4;
var ARROW_NAME$1 = "TooltipArrow";
var TooltipArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTooltip, ...arrowProps } = props;
    const popperScope = usePopperScope$1(__scopeTooltip);
    const visuallyHiddenContentContext = useVisuallyHiddenContentContext(
      ARROW_NAME$1,
      __scopeTooltip
    );
    return visuallyHiddenContentContext.isInside ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef });
  }
);
TooltipArrow.displayName = ARROW_NAME$1;
function getExitSideFromRect(point, rect) {
  const top = Math.abs(rect.top - point.y);
  const bottom = Math.abs(rect.bottom - point.y);
  const right = Math.abs(rect.right - point.x);
  const left = Math.abs(rect.left - point.x);
  switch (Math.min(top, bottom, right, left)) {
    case left:
      return "left";
    case right:
      return "right";
    case top:
      return "top";
    case bottom:
      return "bottom";
    default:
      throw new Error("unreachable");
  }
}
function getPaddedExitPoints(exitPoint, exitSide, padding = 5) {
  const paddedExitPoints = [];
  switch (exitSide) {
    case "top":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y + padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "bottom":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y - padding }
      );
      break;
    case "left":
      paddedExitPoints.push(
        { x: exitPoint.x + padding, y: exitPoint.y - padding },
        { x: exitPoint.x + padding, y: exitPoint.y + padding }
      );
      break;
    case "right":
      paddedExitPoints.push(
        { x: exitPoint.x - padding, y: exitPoint.y - padding },
        { x: exitPoint.x - padding, y: exitPoint.y + padding }
      );
      break;
  }
  return paddedExitPoints;
}
function getPointsFromRect(rect) {
  const { top, right, bottom, left } = rect;
  return [
    { x: left, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom }
  ];
}
function isPointInPolygon(point, polygon) {
  const { x: x3, y: y4 } = point;
  let inside = false;
  for (let i3 = 0, j2 = polygon.length - 1; i3 < polygon.length; j2 = i3++) {
    const ii2 = polygon[i3];
    const jj2 = polygon[j2];
    const xi2 = ii2.x;
    const yi2 = ii2.y;
    const xj2 = jj2.x;
    const yj2 = jj2.y;
    const intersect = yi2 > y4 !== yj2 > y4 && x3 < (xj2 - xi2) * (y4 - yi2) / (yj2 - yi2) + xi2;
    if (intersect) inside = !inside;
  }
  return inside;
}
function getHull(points) {
  const newPoints = points.slice();
  newPoints.sort((a4, b2) => {
    if (a4.x < b2.x) return -1;
    else if (a4.x > b2.x) return 1;
    else if (a4.y < b2.y) return -1;
    else if (a4.y > b2.y) return 1;
    else return 0;
  });
  return getHullPresorted(newPoints);
}
function getHullPresorted(points) {
  if (points.length <= 1) return points.slice();
  const upperHull = [];
  for (let i3 = 0; i3 < points.length; i3++) {
    const p2 = points[i3];
    while (upperHull.length >= 2) {
      const q3 = upperHull[upperHull.length - 1];
      const r2 = upperHull[upperHull.length - 2];
      if ((q3.x - r2.x) * (p2.y - r2.y) >= (q3.y - r2.y) * (p2.x - r2.x)) upperHull.pop();
      else break;
    }
    upperHull.push(p2);
  }
  upperHull.pop();
  const lowerHull = [];
  for (let i3 = points.length - 1; i3 >= 0; i3--) {
    const p2 = points[i3];
    while (lowerHull.length >= 2) {
      const q3 = lowerHull[lowerHull.length - 1];
      const r2 = lowerHull[lowerHull.length - 2];
      if ((q3.x - r2.x) * (p2.y - r2.y) >= (q3.y - r2.y) * (p2.x - r2.x)) lowerHull.pop();
      else break;
    }
    lowerHull.push(p2);
  }
  lowerHull.pop();
  if (upperHull.length === 1 && lowerHull.length === 1 && upperHull[0].x === lowerHull[0].x && upperHull[0].y === lowerHull[0].y) {
    return upperHull;
  } else {
    return upperHull.concat(lowerHull);
  }
}
var Provider$1 = TooltipProvider$1;
var Root3 = Tooltip$1;
var Trigger$3 = TooltipTrigger$1;
var Content2$2 = TooltipContent$1;
const TooltipProvider = Provider$1;
const Tooltip = Root3;
const TooltipTrigger = Trigger$3;
const TooltipContent = reactExports.forwardRef(({ className, sideOffset = 4, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content2$2,
  {
    ref,
    sideOffset,
    className: cn(
      "z-50 overflow-hidden rounded-lg bg-white/90 px-3 py-2 text-sm text-zinc-800 shadow-lg backdrop-blur-sm animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 border border-zinc-200/50",
      className
    ),
    ...props
  }
));
TooltipContent.displayName = Content2$2.displayName;
function DebugLogsButton({ onDownload, context = "general" }) {
  const handleDownload = async () => {
    try {
      onDownload();
      ue.success(`Logs saved to /logs/${context}_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.log`);
    } catch (error) {
      console.error("Error downloading logs:", error);
      ue.error("Failed to download logs");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        variant: "ghost",
        size: "icon",
        className: "absolute bottom-2 left-2 h-6 w-6 opacity-30 hover:opacity-100",
        onClick: handleDownload,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Bug, { className: "h-4 w-4" })
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Save Debug Logs to /logs" }) })
  ] }) });
}
function Navigation() {
  const location2 = useLocation();
  const [mobileMenuOpen, setMobileMenuOpen] = reactExports.useState(false);
  const navItems = [
    { path: "/", label: "Dashboard", icon: LayoutDashboard },
    { path: "/inventory", label: "Inventory", icon: List$1 },
    { path: "/checkout", label: "Checkout", icon: ShoppingCart },
    { path: "/templates", label: "Templates", icon: Copy },
    { path: "/reports", label: "Reports", icon: FileText },
    { path: "/settings", label: "Settings", icon: Settings }
  ];
  return /* @__PURE__ */ jsxRuntimeExports.jsx("nav", { className: "bg-background border-b sticky top-0 z-50", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-16 items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-lg font-bold", children: "TEd_trackIT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "hidden md:flex items-center space-x-2", children: [
        navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Link,
          {
            to: item.path,
            className: cn(
              "flex items-center px-3 py-2 rounded-md text-sm font-medium transition-colors",
              location2.pathname === item.path ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent hover:text-accent-foreground"
            ),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(item.icon, { className: "h-4 w-4 mr-2" }),
              item.label
            ]
          },
          item.path
        )),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DebugLogsButton, { onDownload: () => logger$1.downloadLogs("trackit-continuous.log"), context: "trackit-continuous" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "ml-4 flex items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserMenu, {}) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: "md:hidden p-2 rounded-md text-muted-foreground hover:bg-accent hover:text-accent-foreground",
          onClick: () => setMobileMenuOpen(!mobileMenuOpen),
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: /* @__PURE__ */ jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M4 6h16M4 12h16M4 18h16" }) })
        }
      )
    ] }),
    mobileMenuOpen && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "md:hidden pb-3 space-y-1", children: [
      navItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
        Link,
        {
          to: item.path,
          className: cn(
            "block px-3 py-2 rounded-md text-base font-medium",
            location2.pathname === item.path ? "bg-accent text-accent-foreground" : "text-muted-foreground hover:bg-accent hover:text-accent-foreground"
          ),
          onClick: () => setMobileMenuOpen(false),
          children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(item.icon, { className: "h-4 w-4 mr-2" }),
            item.label
          ] })
        },
        item.path
      )),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "px-3 py-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(UserMenu, {}) })
    ] })
  ] }) });
}
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = reactExports.useState(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      if (typeof window !== "undefined") {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.error(`Error setting localStorage key "${key}":`, error);
    }
  };
  reactExports.useEffect(() => {
    function handleStorageChange(e3) {
      if (e3.key === key && e3.newValue) {
        try {
          setStoredValue(JSON.parse(e3.newValue));
        } catch (error) {
          console.error(`Error parsing localStorage change for key "${key}":`, error);
        }
      }
    }
    if (typeof window !== "undefined") {
      window.addEventListener("storage", handleStorageChange);
      return () => {
        window.removeEventListener("storage", handleStorageChange);
      };
    }
  }, [key]);
  return [storedValue, setValue];
}
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: DIALOG_NAME
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME$3 = "DialogTrigger";
var DialogTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME$3, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$2(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger$1.displayName = TRIGGER_NAME$3;
var PORTAL_NAME$2 = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME$2, {
  forceMount: void 0
});
var DialogPortal$1 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME$2, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, container, children: child }) })) });
};
DialogPortal$1.displayName = PORTAL_NAME$2;
var OVERLAY_NAME$1 = "DialogOverlay";
var DialogOverlay$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME$1, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME$1, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay$1.displayName = OVERLAY_NAME$1;
var Slot$1 = /* @__PURE__ */ createSlot("DialogOverlay.RemoveScroll");
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME$1, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$1, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$2(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME$3 = "DialogContent";
var DialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME$3, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME$3;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME$3, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME$3, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$2(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning$1, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME$2 = "DialogTitle";
var DialogTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME$2, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME$2;
var DESCRIPTION_NAME$2 = "DialogDescription";
var DialogDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME$2, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription$1.displayName = DESCRIPTION_NAME$2;
var CLOSE_NAME$1 = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME$1, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME$1;
function getState$2(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME$3,
  titleName: TITLE_NAME$2,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning$1 = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$4 = Dialog$1;
var Trigger$2 = DialogTrigger$1;
var Portal$1 = DialogPortal$1;
var Overlay = DialogOverlay$1;
var Content$1 = DialogContent$1;
var Title$1 = DialogTitle$1;
var Description$1 = DialogDescription$1;
var Close$1 = DialogClose;
const Dialog = Root$4;
const DialogTrigger = Trigger$2;
const DialogPortal = Portal$1;
const DialogOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay,
  {
    ref,
    className: cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props
  }
));
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content$1,
    {
      ref,
      className: cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Close$1, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
DialogContent.displayName = Content$1.displayName;
const DialogHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    ),
    ...props
  }
);
DialogHeader.displayName = "DialogHeader";
const DialogFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
DialogFooter.displayName = "DialogFooter";
const DialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title$1,
  {
    ref,
    className: cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle.displayName = Title$1.displayName;
const DialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description$1,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription.displayName = Description$1.displayName;
const Input = reactExports.forwardRef(
  ({ className, type, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type,
        className: cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref,
        autoComplete: props.autoComplete ?? "off",
        ...props
      }
    );
  }
);
Input.displayName = "Input";
var NAME = "Label";
var Label$2 = reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$2.displayName = NAME;
var Root$3 = Label$2;
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
const Label$1 = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$3,
  {
    ref,
    className: cn(labelVariants(), className),
    ...props
  }
));
Label$1.displayName = Root$3.displayName;
function clamp(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function usePrevious$1(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue: defaultValue2,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = reactExports.useState(null);
  const [valueNode, setValueNode] = reactExports.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
  const direction = useDirection(dir);
  const [open, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen ?? false,
    onChange: onOpenChange,
    caller: SELECT_NAME
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue2,
    onChange: onValueChange,
    caller: SELECT_NAME
  });
  const triggerPointerDownPosRef = reactExports.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$5, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          SelectBubbleInput,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$2 = "SelectTrigger";
var SelectTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$2, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems2 = useCollection$1(__scopeSelect);
    const pointerTypeRef = reactExports.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems2().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME$2;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$2 = "SelectContent";
var SelectContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$2, props.__scopeSelect);
    const [fragment, setFragment] = reactExports.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME$2;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$2);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var Slot = /* @__PURE__ */ createSlot("SelectContent.RemoveScroll");
var SelectContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
    const [content, setContent] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = reactExports.useState(null);
    const [selectedItemText, setSelectedItemText] = reactExports.useState(
      null
    );
    const getItems2 = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = reactExports.useState(false);
    const firstValidItemFoundRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = reactExports.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems2().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems2, viewport]
    );
    const focusSelectedItem = reactExports.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    reactExports.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    reactExports.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    reactExports.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems2().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = reactExports.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems2().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$2, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$2, __scopeSelect);
  const [contentWrapper, setContentWrapper] = reactExports.useState(null);
  const [content, setContent] = reactExports.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems2 = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = reactExports.useRef(false);
  const shouldRepositionRef = reactExports.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = reactExports.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems2();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems2,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = reactExports.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$2,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$2, {});
var VIEWPORT_NAME$2 = "SelectViewport";
var SelectViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$2, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$2, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = reactExports.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$2;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = reactExports.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = reactExports.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = reactExports.useRef(null);
  const getItems2 = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = reactExports.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    const activeItem = getItems2().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME;
var BUBBLE_INPUT_NAME$2 = "SelectBubbleInput";
var SelectBubbleInput = reactExports.forwardRef(
  ({ __scopeSelect, value, ...props }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious$1(value);
    reactExports.useEffect(() => {
      const select = ref.current;
      if (!select) return;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.select,
      {
        ...props,
        style: { ...VISUALLY_HIDDEN_STYLES, ...props.style },
        ref: composedRefs,
        defaultValue: value
      }
    );
  }
);
SelectBubbleInput.displayName = BUBBLE_INPUT_NAME$2;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root2$3 = Select$1;
var Trigger$1 = SelectTrigger$1;
var Value = SelectValue$1;
var Icon = SelectIcon;
var Portal = SelectPortal;
var Content2$1 = SelectContent$1;
var Viewport$2 = SelectViewport;
var Label = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
const Select = Root2$3;
const SelectValue = Value;
const SelectTrigger = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger$1,
  {
    ref,
    className: cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger$1.displayName;
const SelectScrollUpButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUp, { className: "h-4 w-4" })
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDown, { className: "h-4 w-4" })
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = reactExports.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2$1,
  {
    ref,
    className: cn(
      "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport$2,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2$1.displayName;
const SelectLabel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label,
  {
    ref,
    className: cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label.displayName;
const SelectItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const byteToHex = [];
for (let i3 = 0; i3 < 256; ++i3) {
  byteToHex.push((i3 + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset2 = 0) {
  return (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();
}
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    if (typeof crypto === "undefined" || !crypto.getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
    getRandomValues = crypto.getRandomValues.bind(crypto);
  }
  return getRandomValues(rnds8);
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = { randomUUID };
function v4(options, buf, offset2) {
  if (native.randomUUID && true && !options) {
    return native.randomUUID();
  }
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  return unsafeStringify(rnds);
}
const STORAGE_KEYS = {
  CATEGORIES: "inventory-categories",
  UNITS: "inventory-units",
  LOCATIONS: "inventory-locations",
  SUPPLIERS: "inventory-suppliers",
  PROJECTS: "inventory-projects",
  ITEMS: "inventoryItems",
  HISTORY: "inventory-history",
  TEMPLATES: "inventory-templates",
  GENERAL_SETTINGS: "inventory-general-settings",
  USERS: "users"
};
const parseItemDates = (item) => ({
  ...item,
  lastUpdated: item.lastUpdated ? new Date(item.lastUpdated) : /* @__PURE__ */ new Date(),
  expectedDeliveryDate: item.expectedDeliveryDate ? new Date(item.expectedDeliveryDate) : void 0
});
const getItems = () => {
  try {
    const items = window.electronStore.getData(STORAGE_KEYS.ITEMS);
    return items ? items.map(parseItemDates) : [];
  } catch (error) {
    console.error("Error getting items from store:", error);
    return [];
  }
};
const saveItems = (items) => {
  try {
    const itemsToSave = items.map((item) => ({
      ...item,
      lastUpdated: item.lastUpdated instanceof Date ? item.lastUpdated.toISOString() : (/* @__PURE__ */ new Date()).toISOString(),
      expectedDeliveryDate: item.expectedDeliveryDate instanceof Date ? item.expectedDeliveryDate.toISOString() : void 0
    }));
    window.electronStore.setData(STORAGE_KEYS.ITEMS, itemsToSave);
  } catch (error) {
    console.error("Error saving items to store:", error);
  }
};
const getSettings = () => {
  try {
    const settings = {
      categories: [],
      units: [],
      locations: [],
      suppliers: [],
      projects: []
    };
    Object.entries(STORAGE_KEYS).forEach(([key, storageKey]) => {
      if (["CATEGORIES", "UNITS", "LOCATIONS", "SUPPLIERS", "PROJECTS"].includes(key)) {
        const values = window.electronStore.getData(storageKey);
        if (values) {
          if (Array.isArray(values)) {
            if (values.length > 0) {
              if (typeof values[0] === "string") {
                const newFormat = values.map((name) => ({
                  id: crypto.randomUUID(),
                  name,
                  subcategories: []
                }));
                settings[key.toLowerCase()] = newFormat;
                window.electronStore.setData(storageKey, newFormat);
              } else {
                settings[key.toLowerCase()] = values;
              }
            }
          }
        }
      }
    });
    return settings;
  } catch (error) {
    console.error("Error getting settings from store:", error);
    return {
      categories: [],
      units: [],
      locations: [],
      suppliers: [],
      projects: []
    };
  }
};
const saveSettings = (settings) => {
  try {
    Object.entries(settings).forEach(([key, values]) => {
      const storageKey = STORAGE_KEYS[key.toUpperCase()];
      if (storageKey) {
        window.electronStore.setData(storageKey, values);
      }
    });
  } catch (error) {
    console.error("Error saving settings to store:", error);
  }
};
const saveTemplates = (templates) => {
  try {
    console.log("Saving templates:", templates);
    if (!Array.isArray(templates)) {
      console.error("Templates must be an array");
      return;
    }
    const validTemplates = templates.filter(
      (template) => template && typeof template === "object" && template.templateId && template.templateName
    );
    window.electronStore.setData(STORAGE_KEYS.TEMPLATES, validTemplates);
    console.log("Templates saved successfully");
  } catch (error) {
    console.error("Error saving templates to store:", error);
    throw error;
  }
};
const getTemplates = () => {
  try {
    const templates = window.electronStore.getData(STORAGE_KEYS.TEMPLATES);
    console.log("Templates loaded from store:", templates);
    if (!templates) {
      console.log("No templates found in storage");
      return [];
    }
    if (!Array.isArray(templates)) {
      console.error("Stored templates is not an array");
      return [];
    }
    const validTemplates = templates.filter(
      (template) => template && typeof template === "object" && template.templateId && template.templateName
    );
    console.log("Valid templates loaded:", validTemplates);
    return validTemplates;
  } catch (error) {
    console.error("Error getting templates from store:", error);
    return [];
  }
};
var OrderStatus = /* @__PURE__ */ ((OrderStatus2) => {
  OrderStatus2["PENDING"] = "PENDING";
  OrderStatus2["IN_PROGRESS"] = "IN_PROGRESS";
  OrderStatus2["COMPLETED"] = "COMPLETED";
  OrderStatus2["CANCELLED"] = "CANCELLED";
  OrderStatus2["BACK_ORDERED"] = "BACK_ORDERED";
  return OrderStatus2;
})(OrderStatus || {});
function _typeof(o2) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
    return typeof o3;
  } : function(o3) {
    return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
  }, _typeof(o2);
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var defaultOptions$2 = {};
function getDefaultOptions() {
  return defaultOptions$2;
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function compareAsc(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var diff = dateLeft.getTime() - dateRight.getTime();
  if (diff < 0) {
    return -1;
  } else if (diff > 0) {
    return 1;
  } else {
    return diff;
  }
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid$1(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function differenceInCalendarMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var yearDiff = dateLeft.getFullYear() - dateRight.getFullYear();
  var monthDiff = dateLeft.getMonth() - dateRight.getMonth();
  return yearDiff * 12 + monthDiff;
}
function differenceInMilliseconds(dateLeft, dateRight) {
  requiredArgs(2, arguments);
  return toDate(dateLeft).getTime() - toDate(dateRight).getTime();
}
var roundingMap = {
  ceil: Math.ceil,
  round: Math.round,
  floor: Math.floor,
  trunc: function trunc(value) {
    return value < 0 ? Math.ceil(value) : Math.floor(value);
  }
  // Math.trunc is not supported by IE
};
var defaultRoundingMethod = "trunc";
function getRoundingMethod(method) {
  return roundingMap[defaultRoundingMethod];
}
function endOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(23, 59, 59, 999);
  return date;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function isLastDayOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  return endOfDay(date).getTime() === endOfMonth(date).getTime();
}
function differenceInMonths(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyDateLeft);
  var dateRight = toDate(dirtyDateRight);
  var sign = compareAsc(dateLeft, dateRight);
  var difference = Math.abs(differenceInCalendarMonths(dateLeft, dateRight));
  var result;
  if (difference < 1) {
    result = 0;
  } else {
    if (dateLeft.getMonth() === 1 && dateLeft.getDate() > 27) {
      dateLeft.setDate(30);
    }
    dateLeft.setMonth(dateLeft.getMonth() - sign * difference);
    var isLastMonthNotFull = compareAsc(dateLeft, dateRight) === -sign;
    if (isLastDayOfMonth(toDate(dirtyDateLeft)) && difference === 1 && compareAsc(dirtyDateLeft, dateRight) === 1) {
      isLastMonthNotFull = false;
    }
    result = sign * (difference - Number(isLastMonthNotFull));
  }
  return result === 0 ? 0 : result;
}
function differenceInSeconds(dateLeft, dateRight, options) {
  requiredArgs(2, arguments);
  var diff = differenceInMilliseconds(dateLeft, dateRight) / 1e3;
  return getRoundingMethod()(diff);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$1 = {
  // Year
  y: function y2(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M2(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d2(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a2(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h2(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H2(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m2(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S2(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G2(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y3(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$1.y(date, token);
  },
  // Local week-numbering year
  Y: function Y2(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R2(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u2(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q2(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q2(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M3(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$1.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w2(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I2(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d3(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$1.d(date, token);
  },
  // Day of year
  D: function D2(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E2(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e2(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c2(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a3(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h3(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$1.h(date, token);
  },
  // Hour [0-23]
  H: function H3(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$1.H(date, token);
  },
  // Hour [0-11]
  K: function K2(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k2(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m3(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$1.m(date, token);
  },
  // Second
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$1.s(date, token);
  },
  // Fraction of second
  S: function S3(date, token) {
    return formatters$1.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset2, dirtyDelimiter) {
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter;
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset2, dirtyDelimiter) {
  if (offset2 % 60 === 0) {
    var sign = offset2 > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset2) / 60, 2);
  }
  return formatTimezone(offset2, dirtyDelimiter);
}
function formatTimezone(offset2, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset2 > 0 ? "-" : "+";
  var absOffset = Math.abs(offset2);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance$1 = function formatDistance(token, count2, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count2 === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count2.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale$1.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale$1.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid$1(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale$1,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString(substring);
    }
    var formatter = formatters[firstCharacter];
    if (formatter) {
      if (isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale$1.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString(input) {
  var matched = input.match(escapedStringRegExp);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp, "'");
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function cloneObject$1(object) {
  return assign({}, object);
}
var MINUTES_IN_DAY = 1440;
var MINUTES_IN_ALMOST_TWO_DAYS = 2520;
var MINUTES_IN_MONTH = 43200;
var MINUTES_IN_TWO_MONTHS = 86400;
function formatDistance2(dirtyDate, dirtyBaseDate, options) {
  var _ref, _options$locale;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  if (!locale$1.formatDistance) {
    throw new RangeError("locale must contain formatDistance property");
  }
  var comparison = compareAsc(dirtyDate, dirtyBaseDate);
  if (isNaN(comparison)) {
    throw new RangeError("Invalid time value");
  }
  var localizeOptions = assign(cloneObject$1(options), {
    addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
    comparison
  });
  var dateLeft;
  var dateRight;
  if (comparison > 0) {
    dateLeft = toDate(dirtyBaseDate);
    dateRight = toDate(dirtyDate);
  } else {
    dateLeft = toDate(dirtyDate);
    dateRight = toDate(dirtyBaseDate);
  }
  var seconds = differenceInSeconds(dateRight, dateLeft);
  var offsetInSeconds = (getTimezoneOffsetInMilliseconds(dateRight) - getTimezoneOffsetInMilliseconds(dateLeft)) / 1e3;
  var minutes = Math.round((seconds - offsetInSeconds) / 60);
  var months2;
  if (minutes < 2) {
    if (options !== null && options !== void 0 && options.includeSeconds) {
      if (seconds < 5) {
        return locale$1.formatDistance("lessThanXSeconds", 5, localizeOptions);
      } else if (seconds < 10) {
        return locale$1.formatDistance("lessThanXSeconds", 10, localizeOptions);
      } else if (seconds < 20) {
        return locale$1.formatDistance("lessThanXSeconds", 20, localizeOptions);
      } else if (seconds < 40) {
        return locale$1.formatDistance("halfAMinute", 0, localizeOptions);
      } else if (seconds < 60) {
        return locale$1.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale$1.formatDistance("xMinutes", 1, localizeOptions);
      }
    } else {
      if (minutes === 0) {
        return locale$1.formatDistance("lessThanXMinutes", 1, localizeOptions);
      } else {
        return locale$1.formatDistance("xMinutes", minutes, localizeOptions);
      }
    }
  } else if (minutes < 45) {
    return locale$1.formatDistance("xMinutes", minutes, localizeOptions);
  } else if (minutes < 90) {
    return locale$1.formatDistance("aboutXHours", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_DAY) {
    var hours = Math.round(minutes / 60);
    return locale$1.formatDistance("aboutXHours", hours, localizeOptions);
  } else if (minutes < MINUTES_IN_ALMOST_TWO_DAYS) {
    return locale$1.formatDistance("xDays", 1, localizeOptions);
  } else if (minutes < MINUTES_IN_MONTH) {
    var days2 = Math.round(minutes / MINUTES_IN_DAY);
    return locale$1.formatDistance("xDays", days2, localizeOptions);
  } else if (minutes < MINUTES_IN_TWO_MONTHS) {
    months2 = Math.round(minutes / MINUTES_IN_MONTH);
    return locale$1.formatDistance("aboutXMonths", months2, localizeOptions);
  }
  months2 = differenceInMonths(dateRight, dateLeft);
  if (months2 < 12) {
    var nearestMonth = Math.round(minutes / MINUTES_IN_MONTH);
    return locale$1.formatDistance("xMonths", nearestMonth, localizeOptions);
  } else {
    var monthsSinceStartOfYear = months2 % 12;
    var years = Math.floor(months2 / 12);
    if (monthsSinceStartOfYear < 3) {
      return locale$1.formatDistance("aboutXYears", years, localizeOptions);
    } else if (monthsSinceStartOfYear < 9) {
      return locale$1.formatDistance("overXYears", years, localizeOptions);
    } else {
      return locale$1.formatDistance("almostXYears", years + 1, localizeOptions);
    }
  }
}
function formatDistanceToNow(dirtyDate, options) {
  requiredArgs(1, arguments);
  return formatDistance2(dirtyDate, Date.now(), options);
}
const categories = ["Cable", "Connector", "Hardware", "Tool", "Software", "Expendable", "Fiber Optic", "Power", "Networking", "Audio", "Video", "Lighting"];
const units = ["ft", "each", "box", "spool", "kit", "license", "pair", "meter"];
const locationNames = ["Rm 105 A", "Engineering Store", "PCR 1 Project Area", "TE Room", "Lighting Rm", "Studio ", "Tech Bench", "Remote Kit"];
const locations = locationNames.map((name) => ({
  id: v4(),
  name,
  subcategories: []
}));
const suppliers = ["Joseph Electronics", "Markertek", "B&H Photo", "Clark Wire & Cable", "Amazon Business", "Sweetwater", "Local Hardware"];
const projects = ["2025:SUTRO", "2024:NAB", "MAINTENANCE", "STUDIO_UPGRADE", "Ultrix", "INFRASTRUCTURE"];
const generateRandomDate = (start, end) => {
  return new Date(start.getTime() + Math.random() * (end.getTime() - start.getTime()));
};
const generateRandomInt = (min2, max2) => {
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
};
const generateRandomFloat = (min2, max2, decimals = 2) => {
  const factor = Math.pow(10, decimals);
  return Math.round((Math.random() * (max2 - min2) + min2) * factor) / factor;
};
const generateBarcode = () => {
  return Math.random().toString(36).substring(2, 15).toUpperCase();
};
function generateRandomOrderStatus() {
  const statuses = [
    OrderStatus.PENDING,
    OrderStatus.IN_PROGRESS,
    OrderStatus.COMPLETED,
    OrderStatus.CANCELLED
  ];
  return statuses[Math.floor(Math.random() * statuses.length)];
}
const dummyItems = [];
for (let i3 = 0; i3 < 200; i3++) {
  const category = categories[generateRandomInt(0, categories.length - 1)];
  const unit = units[generateRandomInt(0, units.length - 1)];
  const location2 = locations[generateRandomInt(0, locations.length - 1)];
  const quantity = generateRandomInt(0, category === "Cable" ? 5e3 : 100);
  const costPerUnit = category === "Cable" ? generateRandomFloat(0.1, 1.5) : generateRandomFloat(5, 500);
  const price = costPerUnit * 1.3;
  const reorderLevel = generateRandomInt(0, quantity > 10 ? Math.floor(quantity * 0.3) : 5);
  const minQuantity = reorderLevel;
  const orderStatus = generateRandomOrderStatus();
  const deliveryPercentage = orderStatus === OrderStatus.COMPLETED ? 100 : orderStatus === OrderStatus.IN_PROGRESS ? generateRandomInt(30, 90) : 0;
  const lastUpdated = generateRandomDate(new Date(2023, 0, 1), /* @__PURE__ */ new Date());
  orderStatus === OrderStatus.COMPLETED ? /* @__PURE__ */ new Date() : void 0;
  const expectedDelivery = orderStatus === OrderStatus.IN_PROGRESS ? new Date(Date.now() + 7 * 24 * 60 * 60 * 1e3) : void 0;
  dummyItems.push({
    id: v4(),
    name: `${category} Item ${i3 + 1}`,
    description: `Generated dummy description for ${category} item #${i3 + 1}`,
    quantity,
    minQuantity,
    unit,
    costPerUnit: Math.random() > 0.1 ? costPerUnit : void 0,
    // Some items without cost
    price: Math.random() > 0.1 ? price : void 0,
    // Some items without price
    category,
    location: location2.id,
    reorderLevel: Math.random() > 0.2 ? reorderLevel : void 0,
    // Some items without reorder level
    barcode: Math.random() > 0.3 ? generateBarcode() : void 0,
    // Some items without barcode
    notes: Math.random() > 0.7 ? `Additional notes for item ${i3 + 1}` : void 0,
    supplier: suppliers[generateRandomInt(0, suppliers.length - 1)],
    supplierWebsite: Math.random() > 0.6 ? `www.${suppliers[generateRandomInt(0, suppliers.length - 1)].toLowerCase().replace(/ /g, "")}.com` : void 0,
    project: Math.random() > 0.15 ? projects[generateRandomInt(0, projects.length - 1)] : void 0,
    // Some unassigned
    lastUpdated,
    orderStatus,
    deliveryPercentage,
    expectedDeliveryDate: expectedDelivery
  });
}
const warehouseLocation = {
  id: v4(),
  name: "Warehouse A",
  subcategories: []
};
locations.push(warehouseLocation);
dummyItems.push({
  id: v4(),
  name: "Belden 1855a Yellow",
  description: "1000ft Spool, SDI Cable",
  quantity: 10,
  // 10 delivered
  minQuantity: 5,
  unit: "spool",
  costPerUnit: 340,
  price: 442,
  // ~30% markup
  category: "Cable",
  location: warehouseLocation.id,
  reorderLevel: 5,
  barcode: generateBarcode(),
  notes: "DUMMY DATA   >  14 ordered total, 4 backordered ETA 2 weeks",
  supplier: "Joseph Electronics",
  supplierWebsite: "www.josephelectronics.com",
  project: "2025:SUTRO",
  lastUpdated: /* @__PURE__ */ new Date(),
  orderStatus: OrderStatus.IN_PROGRESS,
  deliveryPercentage: Math.round(10 / 14 * 100),
  // ~71%
  expectedDeliveryDate: addDays(/* @__PURE__ */ new Date(), 14)
});
const INITIAL_SETTINGS = {
  [STORAGE_KEYS.CATEGORIES]: categories,
  [STORAGE_KEYS.UNITS]: units,
  [STORAGE_KEYS.LOCATIONS]: locations,
  [STORAGE_KEYS.SUPPLIERS]: suppliers,
  [STORAGE_KEYS.PROJECTS]: projects
};
const initializeSettings = () => {
  Object.entries(INITIAL_SETTINGS).forEach(([key, values]) => {
    const existing = localStorage.getItem(key);
    if (!existing) {
      localStorage.setItem(key, JSON.stringify(values));
    }
  });
};
const DUMMY_INVENTORY_DATA = dummyItems;
function useInventory() {
  const [items, setItems] = reactExports.useState([]);
  const [history, setHistory] = reactExports.useState([]);
  const [loading, setLoading] = reactExports.useState(true);
  const [categories2, setCategories] = reactExports.useState([]);
  const [units2, setUnits] = reactExports.useState([]);
  const [locations2, setLocations] = reactExports.useState([]);
  const [suppliers2, setSuppliers] = reactExports.useState([]);
  const [projects2, setProjects] = reactExports.useState([]);
  const [cabinets, setCabinets] = reactExports.useState([]);
  reactExports.useEffect(() => {
    let loadedItems = [];
    try {
      loadedItems = getItems();
      console.log("Loaded items from localStorage:", loadedItems.length);
      if (loadedItems.length === 0) {
        console.log("localStorage empty, loading dummy data...");
        loadedItems = DUMMY_INVENTORY_DATA.map((item) => ({
          ...item,
          lastUpdated: new Date(item.lastUpdated),
          expectedDeliveryDate: item.expectedDeliveryDate ? new Date(item.expectedDeliveryDate) : void 0
        }));
        saveItems(loadedItems);
        ue.info("Loaded dummy inventory data.");
      }
      setItems(loadedItems);
      const settings = getSettings();
      setCategories(settings.categories);
      setUnits(settings.units);
      setLocations(settings.locations);
      setSuppliers(settings.suppliers);
      setProjects(settings.projects);
      const savedCabinets = localStorage.getItem("cabinets");
      if (savedCabinets) {
        setCabinets(JSON.parse(savedCabinets));
      }
      const loadedHistory = localStorage.getItem("inventoryHistory");
      if (loadedHistory) {
        try {
          const parsedHistory = JSON.parse(loadedHistory).map((entry) => ({
            ...entry,
            timestamp: entry.timestamp ? new Date(entry.timestamp) : /* @__PURE__ */ new Date()
          }));
          setHistory(parsedHistory);
        } catch (histError) {
          console.error("Error parsing history:", histError);
          setHistory([]);
        }
      }
    } catch (error) {
      console.error("Failed to load items or settings:", error);
    } finally {
      setLoading(false);
    }
  }, []);
  reactExports.useEffect(() => {
    try {
      const settings = getSettings();
      setCategories(settings.categories);
      setUnits(settings.units);
      setLocations(settings.locations);
      setSuppliers(settings.suppliers);
      setProjects(settings.projects);
    } catch (error) {
      console.error("Failed to load settings:", error);
    }
  }, []);
  reactExports.useEffect(() => {
    if (!loading) saveItems(items);
  }, [items, loading]);
  reactExports.useEffect(() => {
    if (!loading && history.length > 0) {
      try {
        const historyToSave = history.map((entry) => ({
          ...entry,
          timestamp: entry.timestamp instanceof Date ? entry.timestamp.toISOString() : (/* @__PURE__ */ new Date()).toISOString()
        }));
        localStorage.setItem("inventoryHistory", JSON.stringify(historyToSave));
      } catch (error) {
        console.error("Error saving history:", error);
      }
    }
  }, [history, loading]);
  const updateSettingsList = reactExports.useCallback((listKey, newList, reassignInfo) => {
    let listSetter;
    let itemField;
    const itemFieldMap = {
      categories: "category",
      units: "unit",
      locations: "location",
      suppliers: "supplier",
      projects: "project"
    };
    itemField = itemFieldMap[listKey];
    switch (listKey) {
      case "categories":
        listSetter = setCategories;
        break;
      case "units":
        listSetter = setUnits;
        break;
      case "locations":
        listSetter = setLocations;
        break;
      case "suppliers":
        listSetter = setSuppliers;
        break;
      case "projects":
        listSetter = setProjects;
        break;
      default:
        listSetter = setCategories;
        break;
    }
    let reconciledCount = 0;
    if (reassignInfo) {
      const { valueToRemove, reassignTo } = reassignInfo;
      setItems((prevItems) => {
        const updatedItems = prevItems.map((item) => {
          const fieldValue = item[itemField];
          if (typeof fieldValue === "string" && fieldValue === valueToRemove) {
            reconciledCount++;
            return { ...item, [itemField]: reassignTo, lastUpdated: /* @__PURE__ */ new Date() };
          }
          return item;
        });
        return updatedItems;
      });
      if (reconciledCount > 0) {
        ue.info(`Updated ${reconciledCount} items from ${valueToRemove} to ${reassignTo || "unassigned"}`);
      }
    }
    listSetter(newList);
    const settings = getSettings();
    settings[listKey] = newList;
    saveSettings(settings);
    if (!reassignInfo) ue.success(`${listKey} list updated.`);
  }, [items]);
  const getItemById = reactExports.useCallback((id2) => {
    return items.find((item) => item.id === id2);
  }, [items]);
  const addItem = reactExports.useCallback((newItemData) => {
    const newItem = {
      ...newItemData,
      id: v4(),
      lastUpdated: /* @__PURE__ */ new Date()
    };
    setItems((prevItems) => [...prevItems, newItem]);
    const historyEntry = {
      id: v4(),
      itemId: newItem.id,
      itemName: newItem.name,
      previousQuantity: 0,
      newQuantity: newItem.quantity,
      reason: "Initial inventory entry",
      timestamp: /* @__PURE__ */ new Date()
    };
    setHistory((prevHistory) => [...prevHistory, historyEntry]);
    return newItem;
  }, []);
  const updateItem = reactExports.useCallback((updatedItemData) => {
    const existingItem = items.find((item) => item.id === updatedItemData.id);
    if (!existingItem) {
      throw new Error(`Item with ID ${updatedItemData.id} not found`);
    }
    const finalUpdatedItem = {
      ...existingItem,
      // Start with existing item to ensure all required fields
      ...updatedItemData,
      // Override with any provided updates
      lastUpdated: /* @__PURE__ */ new Date(),
      // Ensure required fields are preserved
      name: updatedItemData.name ?? existingItem.name,
      category: updatedItemData.category ?? existingItem.category,
      unit: updatedItemData.unit ?? existingItem.unit,
      location: updatedItemData.location ?? existingItem.location,
      quantity: updatedItemData.quantity ?? existingItem.quantity,
      // Handle optional fields
      orderStatus: updatedItemData.orderStatus ?? existingItem.orderStatus,
      deliveryPercentage: updatedItemData.deliveryPercentage ?? existingItem.deliveryPercentage ?? 100
    };
    setItems((prevItems) => {
      const newItems = prevItems.map(
        (item) => item.id === updatedItemData.id ? finalUpdatedItem : item
      );
      saveItems(newItems);
      return newItems;
    });
    return finalUpdatedItem;
  }, [items]);
  const deleteItem = reactExports.useCallback((itemId) => {
    setItems((prevItems) => {
      const newItems = prevItems.filter((item) => item.id !== itemId);
      saveItems(newItems);
      return newItems;
    });
  }, []);
  const adjustQuantity = reactExports.useCallback((itemId, newQuantity, reason) => {
    let updatedItem = void 0;
    const originalItem = items.find((item) => item.id === itemId);
    setItems((prevItems) => {
      return prevItems.map((item) => {
        if (item.id === itemId) {
          updatedItem = { ...item, quantity: newQuantity, lastUpdated: /* @__PURE__ */ new Date() };
          return updatedItem;
        }
        return item;
      });
    });
    if (updatedItem && originalItem) {
      const historyEntry = {
        id: v4(),
        itemId,
        itemName: updatedItem.name,
        previousQuantity: originalItem.quantity,
        newQuantity,
        reason,
        timestamp: /* @__PURE__ */ new Date()
      };
      setHistory((prevHistory) => [...prevHistory, historyEntry]);
    }
    return updatedItem;
  }, [items]);
  const importItems = reactExports.useCallback(async (itemsToImport) => {
    return new Promise((resolve) => {
      let importedCount = 0;
      let skippedCount = 0;
      const newItems = [];
      const updatedItemsMap = /* @__PURE__ */ new Map();
      itemsToImport.forEach((importRow, index2) => {
        if (!importRow.name || !importRow.unit || importRow.quantity === void 0 || importRow.quantity === null) {
          console.warn(`Skipping row ${index2 + 1} due to missing required fields (name, unit, quantity).`);
          skippedCount++;
          return;
        }
        const existingItemIndex = items.findIndex((item) => item.name.toLowerCase() === String(importRow.name).toLowerCase());
        if (existingItemIndex !== -1) {
          const existingItem = items[existingItemIndex];
          const updatedItem = {
            ...existingItem,
            ...importRow,
            // Override with imported data
            // Ensure numeric types and handle potential undefined values from importRow
            quantity: Number(importRow.quantity),
            costPerUnit: importRow.costPerUnit !== void 0 ? Number(importRow.costPerUnit) : existingItem.costPerUnit,
            reorderLevel: importRow.reorderLevel !== void 0 ? Number(importRow.reorderLevel) : existingItem.reorderLevel,
            deliveryPercentage: importRow.deliveryPercentage !== void 0 ? Number(importRow.deliveryPercentage) : existingItem.deliveryPercentage,
            // Ensure dates are Date objects
            expectedDeliveryDate: importRow.expectedDeliveryDate ? new Date(importRow.expectedDeliveryDate) : existingItem.expectedDeliveryDate,
            lastUpdated: /* @__PURE__ */ new Date()
            // Always update timestamp
          };
          updatedItemsMap.set(updatedItem.id, updatedItem);
          importedCount++;
        } else {
          const newItem = {
            id: v4(),
            name: String(importRow.name),
            description: importRow.description ? String(importRow.description) : void 0,
            quantity: Number(importRow.quantity),
            unit: String(importRow.unit),
            costPerUnit: importRow.costPerUnit !== void 0 ? Number(importRow.costPerUnit) : void 0,
            category: importRow.category ? String(importRow.category) : void 0,
            location: importRow.location ? String(importRow.location) : void 0,
            reorderLevel: importRow.reorderLevel !== void 0 ? Number(importRow.reorderLevel) : void 0,
            barcode: importRow.barcode ? String(importRow.barcode) : void 0,
            notes: importRow.notes ? String(importRow.notes) : void 0,
            supplier: importRow.supplier ? String(importRow.supplier) : void 0,
            supplierWebsite: importRow.supplierWebsite ? String(importRow.supplierWebsite) : void 0,
            project: importRow.project ? String(importRow.project) : void 0,
            orderStatus: importRow.orderStatus || "delivered",
            // Default status
            deliveryPercentage: importRow.deliveryPercentage !== void 0 ? Number(importRow.deliveryPercentage) : 100,
            expectedDeliveryDate: importRow.expectedDeliveryDate ? new Date(importRow.expectedDeliveryDate) : void 0,
            lastUpdated: /* @__PURE__ */ new Date()
            // Set timestamp for new item
          };
          newItems.push(newItem);
          importedCount++;
        }
      });
      setItems((prevItems) => {
        const itemsAfterUpdate = prevItems.map((item) => updatedItemsMap.get(item.id) || item);
        return [...itemsAfterUpdate, ...newItems];
      });
      resolve({ importedCount, skippedCount });
    });
  }, [items]);
  reactExports.useEffect(() => {
    if (!loading) {
      console.log("Saving items to localStorage:", items.length);
      saveItems(items);
    }
  }, [items, loading]);
  return {
    items,
    setItems,
    history,
    loading,
    categories: categories2,
    units: units2,
    locations: locations2,
    suppliers: suppliers2,
    projects: projects2,
    cabinets,
    getItemById,
    addItem,
    updateItem,
    deleteItem,
    adjustQuantity,
    updateSettingsList,
    importItems
  };
}
class Logger {
  static instance;
  logs = [];
  settings = {
    enabled: true,
    consoleOutput: true,
    toastNotifications: false,
    logLevels: {
      debug: true,
      info: true,
      warn: true,
      error: true
    },
    logTypes: {
      system: true,
      audit: true,
      performance: true,
      security: true
    },
    maxEntries: 1e3
  };
  constructor() {
    const savedSettings = localStorage.getItem("logSettings");
    if (savedSettings) {
      this.settings = { ...this.settings, ...JSON.parse(savedSettings) };
    }
  }
  static getInstance() {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }
  getSettings() {
    return this.settings;
  }
  updateSettings(newSettings) {
    this.settings = { ...this.settings, ...newSettings };
    localStorage.setItem("logSettings", JSON.stringify(this.settings));
  }
  log(level, type, message, details, component) {
    if (!this.settings.enabled) return;
    if (!this.settings.logLevels[level]) return;
    if (!this.settings.logTypes[type]) return;
    const entry = {
      timestamp: /* @__PURE__ */ new Date(),
      level,
      type,
      message,
      details,
      component
    };
    this.logs.push(entry);
    if (this.logs.length > this.settings.maxEntries) {
      this.logs = this.logs.slice(-this.settings.maxEntries);
    }
    if (this.settings.consoleOutput) {
      const logMethod = level === "error" ? "error" : level === "warn" ? "warn" : level === "info" ? "info" : "log";
      console[logMethod](`[${type.toUpperCase()}] ${message}`, details || "");
    }
    if (this.settings.toastNotifications && (level === "error" || level === "warn")) {
      const toastMessage = level === "error" ? ue.error : ue.warning;
      toastMessage(message, {
        description: details ? JSON.stringify(details) : void 0
      });
    }
  }
  getLogs() {
    return this.logs;
  }
  clearLogs() {
    this.logs = [];
  }
  // Convenience methods
  debug(type, message, details, component) {
    this.log("debug", type, message, details, component);
  }
  info(type, message, details, component) {
    this.log("info", type, message, details, component);
  }
  warn(type, message, details, component) {
    this.log("warn", type, message, details, component);
  }
  error(type, message, details, component) {
    this.log("error", type, message, details, component);
  }
}
const logger = Logger.getInstance();
function flattenCategories$1(categories2) {
  const flattened = [];
  const traverse = (node, parentPath = "") => {
    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
    flattened.push(currentPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, currentPath));
    }
  };
  if (!categories2 || !Array.isArray(categories2)) {
    return [];
  }
  categories2.forEach((category) => traverse(category));
  return flattened.sort();
}
function flattenLocations(locations2) {
  const flattened = [];
  const traverse = (node, parentPath = "") => {
    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
    flattened.push(currentPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, currentPath));
    }
  };
  locations2.forEach((location2) => traverse(location2));
  return flattened.sort();
}
function BatchOperations({ selectedItems, onClearSelection, onItemsUpdated, onDelete }) {
  const { categories: categories2, locations: locations2, projects: projects2, setItems, cabinets } = useInventory();
  useNavigate();
  const { user } = useAuth();
  const [isBatchEditOpen, setIsBatchEditOpen] = reactExports.useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = reactExports.useState(false);
  const [batchEditValues, setBatchEditValues] = reactExports.useState({});
  const [isUpdating, setIsUpdating] = reactExports.useState(false);
  const [availableSubcategories, setAvailableSubcategories] = reactExports.useState([]);
  const [availableCabinets, setAvailableCabinets] = reactExports.useState([]);
  const flattenedCategories = reactExports.useMemo(() => flattenCategories$1(categories2 || []), [categories2]);
  const flattenedLocationPaths = reactExports.useMemo(() => flattenLocations(locations2 || []), [locations2]);
  reactExports.useEffect(() => {
    if (batchEditValues.category && batchEditValues.category !== "nochange") {
      const categoryParts = batchEditValues.category.split("/");
      categoryParts[categoryParts.length - 1];
      let foundCategory;
      const findCategory = (nodes, path = []) => {
        if (!nodes) return void 0;
        for (const node of nodes) {
          const currentPath = [...path, node.name];
          if (currentPath.join("/") === batchEditValues.category) {
            return node;
          }
          const found = findCategory(node.children, currentPath);
          if (found) return found;
        }
        return void 0;
      };
      foundCategory = findCategory(categories2);
      if (foundCategory && foundCategory.children && foundCategory.children.length > 0) {
        setAvailableSubcategories(foundCategory.children.map((child) => child.name));
      } else {
        setAvailableSubcategories([]);
      }
    } else {
      setAvailableSubcategories([]);
    }
  }, [batchEditValues.category, categories2]);
  reactExports.useEffect(() => {
    if (batchEditValues.location && batchEditValues.location !== "nochange" && cabinets) {
      const locationName = batchEditValues.location.split("/").pop() || "";
      logger.info("system", "Looking for cabinets for location", { locationName });
      logger.info("system", "Available cabinets", { cabinets });
      const locationCabinets = cabinets.filter((cabinet) => cabinet.locationId === locationName);
      logger.info("system", "Found cabinets for location", { locationCabinets });
      setAvailableCabinets(locationCabinets);
    } else {
      setAvailableCabinets([]);
    }
  }, [batchEditValues.location, cabinets]);
  reactExports.useEffect(() => {
    if (!isBatchEditOpen) {
      setBatchEditValues({});
    }
  }, [isBatchEditOpen]);
  const handleBatchDelete = async () => {
    if (selectedItems.length === 0) {
      ue.error("Please select items to delete");
      return;
    }
    try {
      const currentItems = getItems();
      const updatedItems = currentItems.filter((item) => !selectedItems.some((selected) => selected.id === item.id));
      localStorage.setItem("inventoryItems", JSON.stringify(updatedItems));
      setItems(updatedItems);
      onClearSelection();
      setIsDeleteDialogOpen(false);
      window.location.reload();
      ue.success(`Deleted ${selectedItems.length} items`);
      logger.info("system", "Successfully deleted items", { count: selectedItems.length });
    } catch (error) {
      logger.error("system", "Error in batch delete", error);
      console.error("Error in batch delete:", error);
      ue.error("Failed to delete items");
    }
  };
  const handleBatchEdit = async () => {
    setIsUpdating(true);
    try {
      const currentItems = getItems();
      logger.info("system", "Starting batch edit", {
        selectedCount: selectedItems.length,
        batchEditValues
      });
      let successCount = 0;
      const updatedItems = currentItems.map((item) => {
        const isSelected = selectedItems.some((selected) => selected.id === item.id);
        if (!isSelected) return item;
        const updates = {};
        if (batchEditValues.quantity !== void 0) {
          updates.quantity = Number(batchEditValues.quantity);
        }
        if (batchEditValues.category && batchEditValues.category !== "nochange") {
          updates.category = batchEditValues.category;
        }
        if (batchEditValues.subcategory && batchEditValues.subcategory !== "nochange") {
          updates.subcategory = batchEditValues.subcategory;
        }
        if (batchEditValues.location && batchEditValues.location !== "nochange") {
          updates.location = batchEditValues.location;
        }
        if (batchEditValues.cabinet && batchEditValues.cabinet !== "nochange") {
          updates.cabinet = batchEditValues.cabinet;
        }
        if (batchEditValues.project && batchEditValues.project !== "nochange") {
          updates.project = batchEditValues.project;
        }
        if (batchEditValues.unitSubcategory && batchEditValues.unitSubcategory !== "nochange") {
          updates.unitSubcategory = batchEditValues.unitSubcategory;
        }
        if (Object.keys(updates).length > 0) {
          successCount++;
          logger.info("system", "Updating item", { itemId: item.id, updates });
          return {
            ...item,
            ...updates,
            lastUpdated: /* @__PURE__ */ new Date(),
            lastModifiedBy: user?.username || user?.displayName || "Unknown"
          };
        }
        return item;
      });
      localStorage.setItem("inventoryItems", JSON.stringify(updatedItems));
      setItems(updatedItems);
      if (successCount > 0) {
        setBatchEditValues({});
        setIsBatchEditOpen(false);
        onClearSelection();
        window.location.reload();
        ue.success(`Successfully updated ${successCount} item${successCount !== 1 ? "s" : ""}`);
        logger.info("system", "Successfully updated items", { count: successCount });
      }
    } catch (error) {
      logger.error("system", "Error in batch edit", error);
      console.error("Error in batch edit:", error);
      ue.error("Failed to update items");
    } finally {
      setIsUpdating(false);
    }
  };
  const handleQuantityChange = (value) => {
    setBatchEditValues((prev) => ({ ...prev, quantity: value || void 0 }));
  };
  const handleCategoryChange = (value) => {
    setBatchEditValues((prev) => ({
      ...prev,
      category: value !== "nochange" ? value : void 0,
      // Clear subcategory when category changes
      subcategory: void 0
    }));
  };
  const handleLocationChange = (value) => {
    setBatchEditValues((prev) => ({
      ...prev,
      location: value !== "nochange" ? value : void 0,
      subcategory: void 0
      // Clear subcategory when location changes
    }));
  };
  const handleProjectChange = (value) => {
    setBatchEditValues((prev) => ({
      ...prev,
      project: value !== "nochange" ? value : void 0
    }));
  };
  const handleSubcategoryChange = (value) => {
    setBatchEditValues((prev) => ({
      ...prev,
      subcategory: value !== "nochange" ? value : void 0
    }));
  };
  const handleCabinetChange = (value) => {
    setBatchEditValues((prev) => ({
      ...prev,
      cabinet: value !== "nochange" ? value : void 0
    }));
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-x-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Button,
      {
        variant: "outline",
        size: "sm",
        onClick: onClearSelection,
        disabled: selectedItems.length === 0,
        children: [
          "Clear Selection (",
          selectedItems.length,
          ")"
        ]
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: isDeleteDialogOpen, onOpenChange: setIsDeleteDialogOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          variant: "destructive",
          size: "sm",
          disabled: selectedItems.length === 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "mr-2 h-4 w-4" }),
            "Delete Selected"
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Delete Items" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { children: [
            "Are you sure you want to delete ",
            selectedItems.length,
            " selected item",
            selectedItems.length !== 1 ? "s" : "",
            "? This action cannot be undone."
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => setIsDeleteDialogOpen(false), children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "destructive", onClick: handleBatchDelete, children: "Delete" })
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { open: isBatchEditOpen, onOpenChange: setIsBatchEditOpen, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          variant: "outline",
          size: "sm",
          disabled: selectedItems.length === 0,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Pen, { className: "mr-2 h-4 w-4" }),
            "Batch Edit (",
            selectedItems.length,
            ")"
          ]
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-[625px]", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Batch Edit Items" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-4 py-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "category", className: "text-right", children: "Category" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: batchEditValues.category || "nochange", onValueChange: handleCategoryChange, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { children: batchEditValues.category || "No change" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "nochange", children: "No change" }),
                flattenedCategories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: category, children: category }, category))
              ] })
            ] }) })
          ] }),
          availableSubcategories.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "subcategory", className: "text-right", children: "Subcategory" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: batchEditValues.subcategory || "nochange", onValueChange: handleSubcategoryChange, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { children: batchEditValues.subcategory || "No change" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "nochange", children: "No change" }),
                availableSubcategories.map((subcategory) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: subcategory, children: subcategory }, subcategory))
              ] })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "location", className: "text-right", children: "Location" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: batchEditValues.location || "nochange", onValueChange: handleLocationChange, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { children: batchEditValues.location || "No change" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "nochange", children: "No change" }),
                flattenedLocationPaths.map((location2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: location2, children: location2 }, location2))
              ] })
            ] }) })
          ] }),
          availableCabinets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "cabinet", className: "text-right", children: "Cabinet" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: batchEditValues.cabinet || "nochange", onValueChange: handleCabinetChange, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { children: batchEditValues.cabinet || "No change" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "nochange", children: "No change" }),
                availableCabinets.map((cabinet) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: cabinet.name, children: cabinet.name }, cabinet.id))
              ] })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "project", className: "text-right", children: "Project" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: batchEditValues.project || "nochange", onValueChange: handleProjectChange, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { children: batchEditValues.project || "No change" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "nochange", children: "No change" }),
                projects2.map((project) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: project.name, children: project.name }, project.id))
              ] })
            ] }) })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-4 items-center gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "quantity", className: "text-right", children: "Quantity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "col-span-3", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                id: "quantity",
                type: "number",
                min: "0",
                step: "1",
                placeholder: "Leave blank for no change",
                value: batchEditValues.quantity || "",
                onChange: (e3) => handleQuantityChange(e3.target.value)
              }
            ) })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => {
            setBatchEditValues({});
            setIsBatchEditOpen(false);
          }, children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleBatchEdit, disabled: isUpdating, children: isUpdating ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            "Updating ",
            selectedItems.length,
            " Items..."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            "Update ",
            selectedItems.length,
            " Items"
          ] }) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          DebugLogsButton,
          {
            onDownload: async () => {
              try {
                await logger.downloadLogs("batch-operations");
              } catch (error) {
                console.error("Error downloading logs:", error);
                ue.error("Failed to download logs");
              }
            },
            context: "batch-operations"
          }
        )
      ] })
    ] })
  ] });
}
var SWITCH_NAME = "Switch";
var [createSwitchContext, createSwitchScope] = createContextScope(SWITCH_NAME);
var [SwitchProvider, useSwitchContext] = createSwitchContext(SWITCH_NAME);
var Switch$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSwitch,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...switchProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: SWITCH_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(SwitchProvider, { scope: __scopeSwitch, checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "switch",
          "aria-checked": checked,
          "aria-required": required,
          "data-state": getState$1(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...switchProps,
          ref: composedRefs,
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        SwitchBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" }
        }
      )
    ] });
  }
);
Switch$1.displayName = SWITCH_NAME;
var THUMB_NAME$1 = "SwitchThumb";
var SwitchThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSwitch, ...thumbProps } = props;
    const context = useSwitchContext(THUMB_NAME$1, __scopeSwitch);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState$1(context.checked),
        "data-disabled": context.disabled ? "" : void 0,
        ...thumbProps,
        ref: forwardedRef
      }
    );
  }
);
SwitchThumb.displayName = THUMB_NAME$1;
var BUBBLE_INPUT_NAME$1 = "SwitchBubbleInput";
var SwitchBubbleInput = reactExports.forwardRef(
  ({
    __scopeSwitch,
    control,
    checked,
    bubbles = true,
    ...props
  }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious$1(checked);
    const controlSize = useSize(control);
    reactExports.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        setChecked.call(input, checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: checked,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
SwitchBubbleInput.displayName = BUBBLE_INPUT_NAME$1;
function getState$1(checked) {
  return checked ? "checked" : "unchecked";
}
var Root$2 = Switch$1;
var Thumb = SwitchThumb;
const Switch = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$2,
  {
    className: cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    ),
    ...props,
    ref,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Thumb,
      {
        className: cn(
          "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
        )
      }
    )
  }
));
Switch.displayName = Root$2.displayName;
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined$1 = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined$1(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy;
  const isArray = Array.isArray(data);
  const isFileListInstance = typeof FileList !== "undefined" ? data instanceof FileList : false;
  if (data instanceof Date) {
    copy = new Date(data);
  } else if (data instanceof Set) {
    copy = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {
    copy = isArray ? [] : {};
    if (!isArray && !isPlainObject(data)) {
      copy = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path, defaultValue2) => {
  if (!path || !isObject(object)) {
    return defaultValue2;
  }
  const result = compact(path.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined$1(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue2 : object[path] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path, value) => {
  let index2 = -1;
  const tempPath = isKey(path) ? [path] : stringToPath(path);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__" || key === "constructor" || key === "prototype") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React$1.createContext(null);
const useFormContext = () => React$1.useContext(HookFormContext);
const FormProvider = (props) => {
  const { children, ...data } = props;
  return React$1.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isPrimitive = (value) => isNullOrUndefined$1(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
const useDeepEqualEffect = (effect, deps) => {
  const ref = reactExports.useRef(deps);
  if (!deepEqual(deps, ref.current)) {
    ref.current = deps;
  }
  reactExports.useEffect(effect, ref.current);
};
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React$1.useState(control._formState);
  const _localProxyFormState = React$1.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  useDeepEqualEffect(() => control._subscribe({
    name,
    formState: _localProxyFormState.current,
    exact,
    callback: (formState2) => {
      !disabled && updateFormState({
        ...control._formState,
        ...formState2
      });
    }
  }), [name, disabled, exact]);
  React$1.useEffect(() => {
    _localProxyFormState.current.isValid && control._setValid(true);
  }, [control]);
  return React$1.useMemo(() => getProxyFormState(formState, control, _localProxyFormState.current, false), [formState, control]);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue2) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue2);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue: defaultValue2, disabled, exact } = props || {};
  const [value, updateValue] = React$1.useState(control._getWatch(name, defaultValue2));
  useDeepEqualEffect(() => control._subscribe({
    name,
    formState: {
      values: true
    },
    exact,
    callback: (formState) => !disabled && updateValue(generateWatchOutput(name, control._names, formState.values || control._formValues, false, defaultValue2))
  }), [name, defaultValue2, disabled, exact]);
  React$1.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _props = React$1.useRef(props);
  const _registerProps = React$1.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  const fieldState = React$1.useMemo(() => Object.defineProperties({}, {
    invalid: {
      enumerable: true,
      get: () => !!get(formState.errors, name)
    },
    isDirty: {
      enumerable: true,
      get: () => !!get(formState.dirtyFields, name)
    },
    isTouched: {
      enumerable: true,
      get: () => !!get(formState.touchedFields, name)
    },
    isValidating: {
      enumerable: true,
      get: () => !!get(formState.validatingFields, name)
    },
    error: {
      enumerable: true,
      get: () => get(formState.errors, name)
    }
  }), [formState, name]);
  const onChange = React$1.useCallback((event) => _registerProps.current.onChange({
    target: {
      value: getEventValue(event),
      name
    },
    type: EVENTS.CHANGE
  }), [name]);
  const onBlur = React$1.useCallback(() => _registerProps.current.onBlur({
    target: {
      value: get(control._formValues, name),
      name
    },
    type: EVENTS.BLUR
  }), [name, control._formValues]);
  const ref = React$1.useCallback((elm) => {
    const field2 = get(control._fields, name);
    if (field2 && elm) {
      field2._f.ref = {
        focus: () => elm.focus(),
        select: () => elm.select(),
        setCustomValidity: (message) => elm.setCustomValidity(message),
        reportValidity: () => elm.reportValidity()
      };
    }
  }, [control._fields, name]);
  const field = React$1.useMemo(() => ({
    name,
    value,
    ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
    onChange,
    onBlur,
    ref
  }), [name, disabled, formState.disabled, onChange, onBlur, ref, value]);
  React$1.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    control.register(name, {
      ..._props.current.rules,
      ...isBoolean(_props.current.disabled) ? { disabled: _props.current.disabled } : {}
    });
    const updateMounted = (name2, value2) => {
      const field2 = get(control._fields, name2);
      if (field2 && field2._f) {
        field2._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    !isArrayField && control.register(name);
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React$1.useEffect(() => {
    control._setDisabledField({
      disabled,
      name
    });
  }, [disabled, name, control]);
  return React$1.useMemo(() => ({
    field,
    formState,
    fieldState
  }), [field, formState, fieldState]);
}
const Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message || true
  }
} : {};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var createSubject = () => {
  let _observers = [];
  const next = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe2 = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o2) => o2 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe: subscribe2,
    unsubscribe
  };
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement$2 = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioInput = (element) => element.type === "radio";
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement$2(ref) && ref.isConnected;
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path) {
  const paths = Array.isArray(path) ? path : isKey(path) ? [path] : stringToPath(path);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined$1(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined$1(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var isRegex = (value) => value instanceof RegExp;
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => !!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isMessage = (value) => isString(value);
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabledFieldNames.has(name)) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement$2(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined$1(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined$1(min2) || !isNullOrUndefined$1(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined$1(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined$1(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined$1(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined$1(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined$1(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
const defaultOptions$1 = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions$1,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isReady: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  const _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.values || _options.defaultValues) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    disabled: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  let _proxySubscribeFormState = {
    ..._proxyFormState
  };
  const _subjects = {
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _setValid = async (shouldUpdateValid) => {
    if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {
      const isValid2 = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _setFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !_options.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue2 = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue2) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue2 : getFieldValue(field._f)) : setFieldValue(name, defaultValue2);
      _state.mount && _setValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!_options.disabled) {
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!get(_formState.dirtyFields, name);
        isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid2, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (_options.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(_options.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _runSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _runSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue2, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue2) ? _defaultValues : isString(names) ? { [names]: defaultValue2 } : defaultValue2
  }, isGlobal, defaultValue2);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement$2(fieldReference.ref) && isNullOrUndefined$1(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.state.next({
              name,
              values: cloneObject(_formValues)
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: cloneObject(_formValues)
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined$1(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.state.next({
      name: _state.mount ? name : void 0,
      values: cloneObject(_formValues)
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid2;
      const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.state.next({
        name,
        type: event.type,
        values: cloneObject(_formValues)
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
          if (_options.mode === "onBlur") {
            if (isBlurEvent) {
              _setValid();
            }
          } else if (!isBlurEvent) {
            _setValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _runSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid2, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _setValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue2) => isFunction(name) ? _subjects.state.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue2), payload)
  }) : _getWatch(name, defaultValue2, true);
  const _subscribe = (props2) => _subjects.state.subscribe({
    next: (formState) => {
      if (shouldSubscribeByName(props2.name, formState.name, props2.exact) && shouldRenderFormState(formState, props2.formState || _proxyFormState, _setFormState, props2.reRenderRoot)) {
        props2.callback({
          values: { ..._formValues },
          ..._formState,
          ...formState
        });
      }
    }
  }).unsubscribe;
  const subscribe2 = (props2) => {
    _state.mount = true;
    _proxySubscribeFormState = {
      ..._proxySubscribeFormState,
      ...props2.formState
    };
    return _subscribe({
      ...props2,
      formState: _proxySubscribeFormState
    });
  };
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.state.next({
      values: cloneObject(_formValues)
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _setValid();
  };
  const _setDisabledField = ({ disabled, name }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {
      disabled ? _names.disabled.add(name) : _names.disabled.delete(name);
    }
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _setDisabledField({
        disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,
        name
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || _options.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e3) => {
    let onValidError = void 0;
    if (e3) {
      e3.preventDefault && e3.preventDefault();
      e3.persist && e3.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _runSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    if (_names.disabled.size) {
      for (const name of _names.disabled) {
        set(fieldValues, name, void 0);
      }
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e3);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e3);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _setValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement$2(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        for (const fieldName of _names.mount) {
          setValue(fieldName, get(values, fieldName));
        }
      }
      _formValues = cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.state.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      disabled: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!_options.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();
      }
    }
  };
  const _setFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  const methods = {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _subscribe,
      _runSchema,
      _getWatch,
      _getDirty,
      _setValid,
      _setFieldArray,
      _setDisabledField,
      _setErrors,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _removeUnmounted,
      _disableForm,
      _subjects,
      _proxyFormState,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    subscribe: subscribe2,
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
  return {
    ...methods,
    formControl: methods
  };
}
const useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? React$1.useLayoutEffect : React$1.useEffect;
function useForm(props = {}) {
  const _formControl = React$1.useRef(void 0);
  const _values = React$1.useRef(void 0);
  const [formState, updateFormState] = React$1.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    isReady: false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...props.formControl ? props.formControl : createFormControl(props),
      formState
    };
    if (props.formControl && props.defaultValues && !isFunction(props.defaultValues)) {
      props.formControl.reset(props.defaultValues, props.resetOptions);
    }
  }
  const control = _formControl.current.control;
  control._options = props;
  useIsomorphicLayoutEffect$1(() => {
    const sub = control._subscribe({
      formState: control._proxyFormState,
      callback: () => updateFormState({ ...control._formState }),
      reRenderRoot: true
    });
    updateFormState((data) => ({
      ...data,
      isReady: true
    }));
    control._formState.isReady = true;
    return sub;
  }, [control]);
  React$1.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React$1.useEffect(() => {
    if (props.mode) {
      control._options.mode = props.mode;
    }
    if (props.reValidateMode) {
      control._options.reValidateMode = props.reValidateMode;
    }
    if (props.errors && !isEmptyObject(props.errors)) {
      control._setErrors(props.errors);
    }
  }, [control, props.errors, props.mode, props.reValidateMode]);
  React$1.useEffect(() => {
    props.shouldUnregister && control._subjects.state.next({
      values: control._getWatch()
    });
  }, [control, props.shouldUnregister]);
  React$1.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty2 = control._getDirty();
      if (isDirty2 !== formState.isDirty) {
        control._subjects.state.next({
          isDirty: isDirty2
        });
      }
    }
  }, [control, formState.isDirty]);
  React$1.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [control, props.values]);
  React$1.useEffect(() => {
    if (!control._state.mount) {
      control._setValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
const s3 = (e3, s4, o2) => {
  if (e3 && "reportValidity" in e3) {
    const r2 = get(o2, s4);
    e3.setCustomValidity(r2 && r2.message || ""), e3.reportValidity();
  }
}, o = (t3, e3) => {
  for (const o2 in e3.fields) {
    const r2 = e3.fields[o2];
    r2 && r2.ref && "reportValidity" in r2.ref ? s3(r2.ref, o2, t3) : r2.refs && r2.refs.forEach((e4) => s3(e4, o2, t3));
  }
}, r = (s4, r2) => {
  r2.shouldUseNativeValidation && o(s4, r2);
  const f2 = {};
  for (const o2 in s4) {
    const n2 = get(r2.fields, o2), a4 = Object.assign(s4[o2] || {}, { ref: n2 && n2.ref });
    if (i2(r2.names || Object.keys(s4), o2)) {
      const s5 = Object.assign({}, get(f2, o2));
      set(s5, "root", a4), set(f2, o2, s5);
    } else set(f2, o2, a4);
  }
  return f2;
}, i2 = (t3, e3) => t3.some((t4) => t4.startsWith(e3 + "."));
var n = function(r2, e3) {
  for (var n2 = {}; r2.length; ) {
    var t3 = r2[0], s4 = t3.code, i3 = t3.message, a4 = t3.path.join(".");
    if (!n2[a4]) if ("unionErrors" in t3) {
      var u3 = t3.unionErrors[0].errors[0];
      n2[a4] = { message: u3.message, type: u3.code };
    } else n2[a4] = { message: i3, type: s4 };
    if ("unionErrors" in t3 && t3.unionErrors.forEach(function(e4) {
      return e4.errors.forEach(function(e5) {
        return r2.push(e5);
      });
    }), e3) {
      var c3 = n2[a4].types, f2 = c3 && c3[t3.code];
      n2[a4] = appendErrors(a4, e3, n2, s4, f2 ? [].concat(f2, t3.message) : t3.message);
    }
    r2.shift();
  }
  return n2;
}, t2 = function(o$12, t3, s4) {
  return void 0 === s4 && (s4 = {}), function(i3, a4, u3) {
    try {
      return Promise.resolve(function(e3, n2) {
        try {
          var a5 = Promise.resolve(o$12["sync" === s4.mode ? "parse" : "parseAsync"](i3, t3)).then(function(e4) {
            return u3.shouldUseNativeValidation && o({}, u3), { errors: {}, values: s4.raw ? i3 : e4 };
          });
        } catch (r2) {
          return n2(r2);
        }
        return a5 && a5.then ? a5.then(void 0, n2) : a5;
      }(0, function(r$12) {
        if (function(r2) {
          return Array.isArray(null == r2 ? void 0 : r2.errors);
        }(r$12)) return { values: {}, errors: r(n(r$12.errors, !u3.shouldUseNativeValidation && "all" === u3.criteriaMode), u3) };
        throw r$12;
      }));
    } catch (r2) {
      return Promise.reject(r2);
    }
  };
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e3) {
      return obj[e3];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys2 = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys2.push(key);
      }
    }
    return keys2;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t3 = typeof data;
  switch (t3) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i3 = 0;
          while (i3 < issue.path.length) {
            const el2 = issue.path[i3];
            const terminal = i3 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i3++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m4) => !!m4).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x3) => !!x3)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s4 of results) {
      if (s4.status === "aborted")
        return INVALID;
      if (s4.status === "dirty")
        status.dirty();
      arrayValue.push(s4.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x3) => x3.status === "aborted";
const isDirty = (x3) => x3.status === "dirty";
const isValid = (x3) => x3.status === "valid";
const isAsync = (x3) => typeof Promise !== "undefined" && x3 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || true : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e3 = new Error(message);
  return e3.name = "SuppressedError", e3.error = error, e3.suppressed = suppressed, e3;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    var _a, _b;
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if ((_b = (_a = err === null || err === void 0 ? void 0 : err.message) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === null || _b === void 0 ? void 0 : _b.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a) {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch2) => ch2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch2) => ch2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64url");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch (_a) {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i3) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i3) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i3));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys2 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys2 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a4, b2) {
  const aType = getParsedType(a4);
  const bType = getParsedType(b2);
  if (a4 === b2) {
    return { valid: true, data: a4 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a4).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a4, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a4[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a4.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a4.length; index2++) {
      const itemA = a4[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a4 === +b2) {
    return { valid: true, data: a4 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x3) => !!x3);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i3) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i3)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x3) => !!x3),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e3) => {
          error.addIssue(makeArgsIssue(args, e3));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e3) => {
          error.addIssue(makeReturnsIssue(result, e3));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a4, b2) {
    return new ZodPipeline({
      in: a4,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function cleanParams(params, data) {
  const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p22 = typeof p2 === "string" ? { message: p2 } : p2;
  return p22;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      const r2 = check(data);
      if (r2 instanceof Promise) {
        return r2.then((r3) => {
          var _a2, _b2;
          if (!r3) {
            const params = cleanParams(_params, data);
            const _fatal = (_b2 = (_a2 = params.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r2) {
        const params = cleanParams(_params, data);
        const _fatal = (_b = (_a = params.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z2 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
const Form = FormProvider;
const FormFieldContext = reactExports.createContext(
  {}
);
const FormField = ({
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormFieldContext.Provider, { value: { name: props.name }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Controller, { ...props }) });
};
const useFormField = () => {
  const fieldContext = reactExports.useContext(FormFieldContext);
  const itemContext = reactExports.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const fieldState = getFieldState(fieldContext.name, formState);
  const { id: id2 } = itemContext;
  return {
    id: id2,
    name: fieldContext.name,
    formItemId: `${id2}-form-item`,
    formDescriptionId: `${id2}-form-item-description`,
    formMessageId: `${id2}-form-item-message`,
    ...fieldState
  };
};
const FormItemContext = reactExports.createContext(
  {}
);
const FormItem = reactExports.forwardRef(({ className, ...props }, ref) => {
  const id2 = reactExports.useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormItemContext.Provider, { value: { id: id2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("space-y-2", className), ...props }) });
});
FormItem.displayName = "FormItem";
const FormLabel = reactExports.forwardRef(({ className, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label$1,
    {
      ref,
      className: cn(className),
      ...props
    }
  );
});
FormLabel.displayName = "FormLabel";
const FormControl = reactExports.forwardRef(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Slot$3,
    {
      ref,
      id: formItemId,
      "aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
      "aria-invalid": !!error,
      ...props
    }
  );
});
FormControl.displayName = "FormControl";
const FormDescription = reactExports.forwardRef(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formDescriptionId,
      className: cn("text-sm text-muted-foreground", className),
      ...props
    }
  );
});
FormDescription.displayName = "FormDescription";
const FormMessage = reactExports.forwardRef(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message) : children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formMessageId,
      className: cn("text-sm font-medium text-destructive", className),
      ...props,
      children: body
    }
  );
});
FormMessage.displayName = "FormMessage";
var TABS_NAME = "Tabs";
var [createTabsContext, createTabsScope] = createContextScope(TABS_NAME, [
  createRovingFocusGroupScope
]);
var useRovingFocusGroupScope = createRovingFocusGroupScope();
var [TabsProvider, useTabsContext] = createTabsContext(TABS_NAME);
var Tabs$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeTabs,
      value: valueProp,
      onValueChange,
      defaultValue: defaultValue2,
      orientation = "horizontal",
      dir,
      activationMode = "automatic",
      ...tabsProps
    } = props;
    const direction = useDirection(dir);
    const [value, setValue] = useControllableState({
      prop: valueProp,
      onChange: onValueChange,
      defaultProp: defaultValue2 ?? "",
      caller: TABS_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      TabsProvider,
      {
        scope: __scopeTabs,
        baseId: useId(),
        value,
        onValueChange: setValue,
        orientation,
        dir: direction,
        activationMode,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            "data-orientation": orientation,
            ...tabsProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
Tabs$1.displayName = TABS_NAME;
var TAB_LIST_NAME = "TabsList";
var TabsList$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, loop = true, ...listProps } = props;
    const context = useTabsContext(TAB_LIST_NAME, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Root$7,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        orientation: context.orientation,
        dir: context.dir,
        loop,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            role: "tablist",
            "aria-orientation": context.orientation,
            ...listProps,
            ref: forwardedRef
          }
        )
      }
    );
  }
);
TabsList$1.displayName = TAB_LIST_NAME;
var TRIGGER_NAME$1 = "TabsTrigger";
var TabsTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, disabled = false, ...triggerProps } = props;
    const context = useTabsContext(TRIGGER_NAME$1, __scopeTabs);
    const rovingFocusGroupScope = useRovingFocusGroupScope(__scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Item$1,
      {
        asChild: true,
        ...rovingFocusGroupScope,
        focusable: !disabled,
        active: isSelected,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.button,
          {
            type: "button",
            role: "tab",
            "aria-selected": isSelected,
            "aria-controls": contentId,
            "data-state": isSelected ? "active" : "inactive",
            "data-disabled": disabled ? "" : void 0,
            disabled,
            id: triggerId,
            ...triggerProps,
            ref: forwardedRef,
            onMouseDown: composeEventHandlers(props.onMouseDown, (event) => {
              if (!disabled && event.button === 0 && event.ctrlKey === false) {
                context.onValueChange(value);
              } else {
                event.preventDefault();
              }
            }),
            onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
              if ([" ", "Enter"].includes(event.key)) context.onValueChange(value);
            }),
            onFocus: composeEventHandlers(props.onFocus, () => {
              const isAutomaticActivation = context.activationMode !== "manual";
              if (!isSelected && !disabled && isAutomaticActivation) {
                context.onValueChange(value);
              }
            })
          }
        )
      }
    );
  }
);
TabsTrigger$1.displayName = TRIGGER_NAME$1;
var CONTENT_NAME$1 = "TabsContent";
var TabsContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeTabs, value, forceMount, children, ...contentProps } = props;
    const context = useTabsContext(CONTENT_NAME$1, __scopeTabs);
    const triggerId = makeTriggerId(context.baseId, value);
    const contentId = makeContentId(context.baseId, value);
    const isSelected = value === context.value;
    const isMountAnimationPreventedRef = reactExports.useRef(isSelected);
    reactExports.useEffect(() => {
      const rAF = requestAnimationFrame(() => isMountAnimationPreventedRef.current = false);
      return () => cancelAnimationFrame(rAF);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isSelected, children: ({ present }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": isSelected ? "active" : "inactive",
        "data-orientation": context.orientation,
        role: "tabpanel",
        "aria-labelledby": triggerId,
        hidden: !present,
        id: contentId,
        tabIndex: 0,
        ...contentProps,
        ref: forwardedRef,
        style: {
          ...props.style,
          animationDuration: isMountAnimationPreventedRef.current ? "0s" : void 0
        },
        children: present && children
      }
    ) });
  }
);
TabsContent$1.displayName = CONTENT_NAME$1;
function makeTriggerId(baseId, value) {
  return `${baseId}-trigger-${value}`;
}
function makeContentId(baseId, value) {
  return `${baseId}-content-${value}`;
}
var Root2$2 = Tabs$1;
var List = TabsList$1;
var Trigger = TabsTrigger$1;
var Content = TabsContent$1;
const Tabs = Root2$2;
const TabsList = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  List,
  {
    ref,
    className: cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    ),
    ...props
  }
));
TabsList.displayName = List.displayName;
const TabsTrigger = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Trigger,
  {
    ref,
    className: cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    ),
    ...props
  }
));
TabsTrigger.displayName = Trigger.displayName;
const TabsContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Content,
  {
    ref,
    className: cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    ),
    ...props
  }
));
TabsContent.displayName = Content.displayName;
var Html5QrcodeSupportedFormats;
(function(Html5QrcodeSupportedFormats2) {
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["QR_CODE"] = 0] = "QR_CODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["AZTEC"] = 1] = "AZTEC";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODABAR"] = 2] = "CODABAR";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_39"] = 3] = "CODE_39";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_93"] = 4] = "CODE_93";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["CODE_128"] = 5] = "CODE_128";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["DATA_MATRIX"] = 6] = "DATA_MATRIX";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["MAXICODE"] = 7] = "MAXICODE";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["ITF"] = 8] = "ITF";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_13"] = 9] = "EAN_13";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["EAN_8"] = 10] = "EAN_8";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["PDF_417"] = 11] = "PDF_417";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_14"] = 12] = "RSS_14";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_A"] = 14] = "UPC_A";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_E"] = 15] = "UPC_E";
  Html5QrcodeSupportedFormats2[Html5QrcodeSupportedFormats2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
})(Html5QrcodeSupportedFormats || (Html5QrcodeSupportedFormats = {}));
var html5QrcodeSupportedFormatsTextMap = /* @__PURE__ */ new Map([
  [Html5QrcodeSupportedFormats.QR_CODE, "QR_CODE"],
  [Html5QrcodeSupportedFormats.AZTEC, "AZTEC"],
  [Html5QrcodeSupportedFormats.CODABAR, "CODABAR"],
  [Html5QrcodeSupportedFormats.CODE_39, "CODE_39"],
  [Html5QrcodeSupportedFormats.CODE_93, "CODE_93"],
  [Html5QrcodeSupportedFormats.CODE_128, "CODE_128"],
  [Html5QrcodeSupportedFormats.DATA_MATRIX, "DATA_MATRIX"],
  [Html5QrcodeSupportedFormats.MAXICODE, "MAXICODE"],
  [Html5QrcodeSupportedFormats.ITF, "ITF"],
  [Html5QrcodeSupportedFormats.EAN_13, "EAN_13"],
  [Html5QrcodeSupportedFormats.EAN_8, "EAN_8"],
  [Html5QrcodeSupportedFormats.PDF_417, "PDF_417"],
  [Html5QrcodeSupportedFormats.RSS_14, "RSS_14"],
  [Html5QrcodeSupportedFormats.RSS_EXPANDED, "RSS_EXPANDED"],
  [Html5QrcodeSupportedFormats.UPC_A, "UPC_A"],
  [Html5QrcodeSupportedFormats.UPC_E, "UPC_E"],
  [Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION, "UPC_EAN_EXTENSION"]
]);
var DecodedTextType;
(function(DecodedTextType2) {
  DecodedTextType2[DecodedTextType2["UNKNOWN"] = 0] = "UNKNOWN";
  DecodedTextType2[DecodedTextType2["URL"] = 1] = "URL";
})(DecodedTextType || (DecodedTextType = {}));
function isValidHtml5QrcodeSupportedFormats(format2) {
  return Object.values(Html5QrcodeSupportedFormats).includes(format2);
}
var Html5QrcodeScanType;
(function(Html5QrcodeScanType2) {
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_CAMERA"] = 0] = "SCAN_TYPE_CAMERA";
  Html5QrcodeScanType2[Html5QrcodeScanType2["SCAN_TYPE_FILE"] = 1] = "SCAN_TYPE_FILE";
})(Html5QrcodeScanType || (Html5QrcodeScanType = {}));
var Html5QrcodeConstants = function() {
  function Html5QrcodeConstants2() {
  }
  Html5QrcodeConstants2.GITHUB_PROJECT_URL = "https://github.com/mebjas/html5-qrcode";
  Html5QrcodeConstants2.SCAN_DEFAULT_FPS = 2;
  Html5QrcodeConstants2.DEFAULT_DISABLE_FLIP = false;
  Html5QrcodeConstants2.DEFAULT_REMEMBER_LAST_CAMERA_USED = true;
  Html5QrcodeConstants2.DEFAULT_SUPPORTED_SCAN_TYPE = [
    Html5QrcodeScanType.SCAN_TYPE_CAMERA,
    Html5QrcodeScanType.SCAN_TYPE_FILE
  ];
  return Html5QrcodeConstants2;
}();
var QrcodeResultFormat = function() {
  function QrcodeResultFormat2(format2, formatName) {
    this.format = format2;
    this.formatName = formatName;
  }
  QrcodeResultFormat2.prototype.toString = function() {
    return this.formatName;
  };
  QrcodeResultFormat2.create = function(format2) {
    if (!html5QrcodeSupportedFormatsTextMap.has(format2)) {
      throw "".concat(format2, " not in html5QrcodeSupportedFormatsTextMap");
    }
    return new QrcodeResultFormat2(format2, html5QrcodeSupportedFormatsTextMap.get(format2));
  };
  return QrcodeResultFormat2;
}();
var Html5QrcodeResultFactory = function() {
  function Html5QrcodeResultFactory2() {
  }
  Html5QrcodeResultFactory2.createFromText = function(decodedText) {
    var qrcodeResult = {
      text: decodedText
    };
    return {
      decodedText,
      result: qrcodeResult
    };
  };
  Html5QrcodeResultFactory2.createFromQrcodeResult = function(qrcodeResult) {
    return {
      decodedText: qrcodeResult.text,
      result: qrcodeResult
    };
  };
  return Html5QrcodeResultFactory2;
}();
var Html5QrcodeErrorTypes;
(function(Html5QrcodeErrorTypes2) {
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["UNKWOWN_ERROR"] = 0] = "UNKWOWN_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["IMPLEMENTATION_ERROR"] = 1] = "IMPLEMENTATION_ERROR";
  Html5QrcodeErrorTypes2[Html5QrcodeErrorTypes2["NO_CODE_FOUND_ERROR"] = 2] = "NO_CODE_FOUND_ERROR";
})(Html5QrcodeErrorTypes || (Html5QrcodeErrorTypes = {}));
var Html5QrcodeErrorFactory = function() {
  function Html5QrcodeErrorFactory2() {
  }
  Html5QrcodeErrorFactory2.createFrom = function(error) {
    return {
      errorMessage: error,
      type: Html5QrcodeErrorTypes.UNKWOWN_ERROR
    };
  };
  return Html5QrcodeErrorFactory2;
}();
var BaseLoggger = function() {
  function BaseLoggger2(verbose) {
    this.verbose = verbose;
  }
  BaseLoggger2.prototype.log = function(message) {
    if (this.verbose) {
      console.log(message);
    }
  };
  BaseLoggger2.prototype.warn = function(message) {
    if (this.verbose) {
      console.warn(message);
    }
  };
  BaseLoggger2.prototype.logError = function(message, isExperimental) {
    if (this.verbose || isExperimental === true) {
      console.error(message);
    }
  };
  BaseLoggger2.prototype.logErrors = function(errors) {
    if (errors.length === 0) {
      throw "Logger#logError called without arguments";
    }
    if (this.verbose) {
      console.error(errors);
    }
  };
  return BaseLoggger2;
}();
function isNullOrUndefined(obj) {
  return typeof obj === "undefined" || obj === null;
}
function clip(value, minValue, maxValue) {
  if (value > maxValue) {
    return maxValue;
  }
  if (value < minValue) {
    return minValue;
  }
  return value;
}
var Html5QrcodeStrings = function() {
  function Html5QrcodeStrings2() {
  }
  Html5QrcodeStrings2.codeParseError = function(exception) {
    return "QR code parse error, error = ".concat(exception);
  };
  Html5QrcodeStrings2.errorGettingUserMedia = function(error) {
    return "Error getting userMedia, error = ".concat(error);
  };
  Html5QrcodeStrings2.onlyDeviceSupportedError = function() {
    return "The device doesn't support navigator.mediaDevices , only supported cameraIdOrConfig in this case is deviceId parameter (string).";
  };
  Html5QrcodeStrings2.cameraStreamingNotSupported = function() {
    return "Camera streaming not supported by the browser.";
  };
  Html5QrcodeStrings2.unableToQuerySupportedDevices = function() {
    return "Unable to query supported devices, unknown error.";
  };
  Html5QrcodeStrings2.insecureContextCameraQueryError = function() {
    return "Camera access is only supported in secure context like https or localhost.";
  };
  Html5QrcodeStrings2.scannerPaused = function() {
    return "Scanner paused";
  };
  return Html5QrcodeStrings2;
}();
var Html5QrcodeScannerStrings = function() {
  function Html5QrcodeScannerStrings2() {
  }
  Html5QrcodeScannerStrings2.scanningStatus = function() {
    return "Scanning";
  };
  Html5QrcodeScannerStrings2.idleStatus = function() {
    return "Idle";
  };
  Html5QrcodeScannerStrings2.errorStatus = function() {
    return "Error";
  };
  Html5QrcodeScannerStrings2.permissionStatus = function() {
    return "Permission";
  };
  Html5QrcodeScannerStrings2.noCameraFoundErrorStatus = function() {
    return "No Cameras";
  };
  Html5QrcodeScannerStrings2.lastMatch = function(decodedText) {
    return "Last Match: ".concat(decodedText);
  };
  Html5QrcodeScannerStrings2.codeScannerTitle = function() {
    return "Code Scanner";
  };
  Html5QrcodeScannerStrings2.cameraPermissionTitle = function() {
    return "Request Camera Permissions";
  };
  Html5QrcodeScannerStrings2.cameraPermissionRequesting = function() {
    return "Requesting camera permissions...";
  };
  Html5QrcodeScannerStrings2.noCameraFound = function() {
    return "No camera found";
  };
  Html5QrcodeScannerStrings2.scanButtonStopScanningText = function() {
    return "Stop Scanning";
  };
  Html5QrcodeScannerStrings2.scanButtonStartScanningText = function() {
    return "Start Scanning";
  };
  Html5QrcodeScannerStrings2.torchOnButton = function() {
    return "Switch On Torch";
  };
  Html5QrcodeScannerStrings2.torchOffButton = function() {
    return "Switch Off Torch";
  };
  Html5QrcodeScannerStrings2.torchOnFailedMessage = function() {
    return "Failed to turn on torch";
  };
  Html5QrcodeScannerStrings2.torchOffFailedMessage = function() {
    return "Failed to turn off torch";
  };
  Html5QrcodeScannerStrings2.scanButtonScanningStarting = function() {
    return "Launching Camera...";
  };
  Html5QrcodeScannerStrings2.textIfCameraScanSelected = function() {
    return "Scan an Image File";
  };
  Html5QrcodeScannerStrings2.textIfFileScanSelected = function() {
    return "Scan using camera directly";
  };
  Html5QrcodeScannerStrings2.selectCamera = function() {
    return "Select Camera";
  };
  Html5QrcodeScannerStrings2.fileSelectionChooseImage = function() {
    return "Choose Image";
  };
  Html5QrcodeScannerStrings2.fileSelectionChooseAnother = function() {
    return "Choose Another";
  };
  Html5QrcodeScannerStrings2.fileSelectionNoImageSelected = function() {
    return "No image choosen";
  };
  Html5QrcodeScannerStrings2.anonymousCameraPrefix = function() {
    return "Anonymous Camera";
  };
  Html5QrcodeScannerStrings2.dragAndDropMessage = function() {
    return "Or drop an image to scan";
  };
  Html5QrcodeScannerStrings2.dragAndDropMessageOnlyImages = function() {
    return "Or drop an image to scan (other files not supported)";
  };
  Html5QrcodeScannerStrings2.zoom = function() {
    return "zoom";
  };
  Html5QrcodeScannerStrings2.loadingImage = function() {
    return "Loading image...";
  };
  Html5QrcodeScannerStrings2.cameraScanAltText = function() {
    return "Camera based scan";
  };
  Html5QrcodeScannerStrings2.fileScanAltText = function() {
    return "Fule based scan";
  };
  return Html5QrcodeScannerStrings2;
}();
var LibraryInfoStrings = function() {
  function LibraryInfoStrings2() {
  }
  LibraryInfoStrings2.poweredBy = function() {
    return "Powered by ";
  };
  LibraryInfoStrings2.reportIssues = function() {
    return "Report issues";
  };
  return LibraryInfoStrings2;
}();
var VideoConstraintsUtil = function() {
  function VideoConstraintsUtil2() {
  }
  VideoConstraintsUtil2.isMediaStreamConstraintsValid = function(videoConstraints, logger2) {
    if (typeof videoConstraints !== "object") {
      var typeofVideoConstraints = typeof videoConstraints;
      logger2.logError("videoConstraints should be of type object, the " + "object passed is of type ".concat(typeofVideoConstraints, "."), true);
      return false;
    }
    var bannedKeys = [
      "autoGainControl",
      "channelCount",
      "echoCancellation",
      "latency",
      "noiseSuppression",
      "sampleRate",
      "sampleSize",
      "volume"
    ];
    var bannedkeysSet = new Set(bannedKeys);
    var keysInVideoConstraints = Object.keys(videoConstraints);
    for (var _i = 0, keysInVideoConstraints_1 = keysInVideoConstraints; _i < keysInVideoConstraints_1.length; _i++) {
      var key = keysInVideoConstraints_1[_i];
      if (bannedkeysSet.has(key)) {
        logger2.logError("".concat(key, " is not supported videoConstaints."), true);
        return false;
      }
    }
    return true;
  };
  return VideoConstraintsUtil2;
}();
var zxingJs_umd$1 = { exports: {} };
(function(module, exports) {
  (function(global2, factory) {
    factory(exports);
  })(commonjsGlobal, function(exports2) {
    function isNullOrUndefined2(obj) {
      return obj === null || obj === void 0;
    }
    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b2) {
      d4.__proto__ = b2;
    } || function(d4, b2) {
      for (var p2 in b2) if (b2.hasOwnProperty(p2)) d4[p2] = b2[p2];
    };
    function __extends2(d4, b2) {
      extendStatics(d4, b2);
      function __() {
        this.constructor = d4;
      }
      d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
    }
    function fixProto(target, prototype) {
      var setPrototypeOf = Object.setPrototypeOf;
      setPrototypeOf ? setPrototypeOf(target, prototype) : target.__proto__ = prototype;
    }
    function fixStack(target, fn) {
      if (fn === void 0) {
        fn = target.constructor;
      }
      var captureStackTrace = Error.captureStackTrace;
      captureStackTrace && captureStackTrace(target, fn);
    }
    var CustomError = function(_super) {
      __extends2(CustomError2, _super);
      function CustomError2(message) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        Object.defineProperty(_this, "name", {
          value: _newTarget.name,
          enumerable: false
        });
        fixProto(_this, _newTarget.prototype);
        fixStack(_this);
        return _this;
      }
      return CustomError2;
    }(Error);
    class Exception extends CustomError {
      /**
       * Allows Exception to be constructed directly
       * with some message and prototype definition.
       */
      constructor(message = void 0) {
        super(message);
        this.message = message;
      }
      getKind() {
        const ex = this.constructor;
        return ex.kind;
      }
    }
    Exception.kind = "Exception";
    class ArgumentException extends Exception {
    }
    ArgumentException.kind = "ArgumentException";
    class IllegalArgumentException extends Exception {
    }
    IllegalArgumentException.kind = "IllegalArgumentException";
    class BinaryBitmap {
      constructor(binarizer) {
        this.binarizer = binarizer;
        if (binarizer === null) {
          throw new IllegalArgumentException("Binarizer must be non-null.");
        }
      }
      /**
       * @return The width of the bitmap.
       */
      getWidth() {
        return this.binarizer.getWidth();
      }
      /**
       * @return The height of the bitmap.
       */
      getHeight() {
        return this.binarizer.getHeight();
      }
      /**
       * Converts one row of luminance data to 1 bit data. May actually do the conversion, or return
       * cached data. Callers should assume this method is expensive and call it as seldom as possible.
       * This method is intended for decoding 1D barcodes and may choose to apply sharpening.
       *
       * @param y The row to fetch, which must be in [0, bitmap height)
       * @param row An optional preallocated array. If null or too small, it will be ignored.
       *            If used, the Binarizer will call BitArray.clear(). Always use the returned object.
       * @return The array of bits for this row (true means black).
       * @throws NotFoundException if row can't be binarized
       */
      getBlackRow(y4, row) {
        return this.binarizer.getBlackRow(y4, row);
      }
      /**
       * Converts a 2D array of luminance data to 1 bit. As above, assume this method is expensive
       * and do not call it repeatedly. This method is intended for decoding 2D barcodes and may or
       * may not apply sharpening. Therefore, a row from this matrix may not be identical to one
       * fetched using getBlackRow(), so don't mix and match between them.
       *
       * @return The 2D array of bits for the image (true means black).
       * @throws NotFoundException if image can't be binarized to make a matrix
       */
      getBlackMatrix() {
        if (this.matrix === null || this.matrix === void 0) {
          this.matrix = this.binarizer.getBlackMatrix();
        }
        return this.matrix;
      }
      /**
       * @return Whether this bitmap can be cropped.
       */
      isCropSupported() {
        return this.binarizer.getLuminanceSource().isCropSupported();
      }
      /**
       * Returns a new object with cropped image data. Implementations may keep a reference to the
       * original data rather than a copy. Only callable if isCropSupported() is true.
       *
       * @param left The left coordinate, which must be in [0,getWidth())
       * @param top The top coordinate, which must be in [0,getHeight())
       * @param width The width of the rectangle to crop.
       * @param height The height of the rectangle to crop.
       * @return A cropped version of this object.
       */
      crop(left, top, width, height) {
        const newSource = this.binarizer.getLuminanceSource().crop(left, top, width, height);
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /**
       * @return Whether this bitmap supports counter-clockwise rotation.
       */
      isRotateSupported() {
        return this.binarizer.getLuminanceSource().isRotateSupported();
      }
      /**
       * Returns a new object with rotated image data by 90 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /**
       * Returns a new object with rotated image data by 45 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise45() {
        const newSource = this.binarizer.getLuminanceSource().rotateCounterClockwise45();
        return new BinaryBitmap(this.binarizer.createBinarizer(newSource));
      }
      /*@Override*/
      toString() {
        try {
          return this.getBlackMatrix().toString();
        } catch (e3) {
          return "";
        }
      }
    }
    class ChecksumException extends Exception {
      static getChecksumInstance() {
        return new ChecksumException();
      }
    }
    ChecksumException.kind = "ChecksumException";
    class Binarizer {
      constructor(source) {
        this.source = source;
      }
      getLuminanceSource() {
        return this.source;
      }
      getWidth() {
        return this.source.getWidth();
      }
      getHeight() {
        return this.source.getHeight();
      }
    }
    class System {
      // public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
      /**
       * Makes a copy of a array.
       */
      static arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
          dest[destPos++] = src[srcPos++];
        }
      }
      /**
       * Returns the current time in milliseconds.
       */
      static currentTimeMillis() {
        return Date.now();
      }
    }
    class IndexOutOfBoundsException extends Exception {
    }
    IndexOutOfBoundsException.kind = "IndexOutOfBoundsException";
    class ArrayIndexOutOfBoundsException extends IndexOutOfBoundsException {
      constructor(index2 = void 0, message = void 0) {
        super(message);
        this.index = index2;
        this.message = message;
      }
    }
    ArrayIndexOutOfBoundsException.kind = "ArrayIndexOutOfBoundsException";
    class Arrays {
      /**
       * Assigns the specified int value to each element of the specified array
       * of ints.
       *
       * @param a the array to be filled
       * @param val the value to be stored in all elements of the array
       */
      static fill(a4, val) {
        for (let i3 = 0, len = a4.length; i3 < len; i3++)
          a4[i3] = val;
      }
      /**
       * Assigns the specified int value to each element of the specified
       * range of the specified array of ints.  The range to be filled
       * extends from index {@code fromIndex}, inclusive, to index
       * {@code toIndex}, exclusive.  (If {@code fromIndex==toIndex}, the
       * range to be filled is empty.)
       *
       * @param a the array to be filled
       * @param fromIndex the index of the first element (inclusive) to be
       *        filled with the specified value
       * @param toIndex the index of the last element (exclusive) to be
       *        filled with the specified value
       * @param val the value to be stored in all elements of the array
       * @throws IllegalArgumentException if {@code fromIndex > toIndex}
       * @throws ArrayIndexOutOfBoundsException if {@code fromIndex < 0} or
       *         {@code toIndex > a.length}
       */
      static fillWithin(a4, fromIndex, toIndex, val) {
        Arrays.rangeCheck(a4.length, fromIndex, toIndex);
        for (let i3 = fromIndex; i3 < toIndex; i3++)
          a4[i3] = val;
      }
      /**
       * Checks that {@code fromIndex} and {@code toIndex} are in
       * the range and throws an exception if they aren't.
       */
      static rangeCheck(arrayLength, fromIndex, toIndex) {
        if (fromIndex > toIndex) {
          throw new IllegalArgumentException("fromIndex(" + fromIndex + ") > toIndex(" + toIndex + ")");
        }
        if (fromIndex < 0) {
          throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (toIndex > arrayLength) {
          throw new ArrayIndexOutOfBoundsException(toIndex);
        }
      }
      static asList(...args) {
        return args;
      }
      static create(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x3) => Array.from({ length: cols }).fill(value));
      }
      static createInt32Array(rows, cols, value) {
        let arr = Array.from({ length: rows });
        return arr.map((x3) => Int32Array.from({ length: cols }).fill(value));
      }
      static equals(first, second) {
        if (!first) {
          return false;
        }
        if (!second) {
          return false;
        }
        if (!first.length) {
          return false;
        }
        if (!second.length) {
          return false;
        }
        if (first.length !== second.length) {
          return false;
        }
        for (let i3 = 0, length = first.length; i3 < length; i3++) {
          if (first[i3] !== second[i3]) {
            return false;
          }
        }
        return true;
      }
      static hashCode(a4) {
        if (a4 === null) {
          return 0;
        }
        let result = 1;
        for (const element of a4) {
          result = 31 * result + element;
        }
        return result;
      }
      static fillUint8Array(a4, value) {
        for (let i3 = 0; i3 !== a4.length; i3++) {
          a4[i3] = value;
        }
      }
      static copyOf(original, newLength) {
        return original.slice(0, newLength);
      }
      static copyOfUint8Array(original, newLength) {
        if (original.length <= newLength) {
          const newArray = new Uint8Array(newLength);
          newArray.set(original);
          return newArray;
        }
        return original.slice(0, newLength);
      }
      static copyOfRange(original, from, to) {
        const newLength = to - from;
        const copy = new Int32Array(newLength);
        System.arraycopy(original, from, copy, 0, newLength);
        return copy;
      }
      /*
      * Returns the index of of the element in a sorted array or (-n-1) where n is the insertion point
      * for the new element.
      * Parameters:
      *     ar - A sorted array
      *     el - An element to search for
      *     comparator - A comparator function. The function takes two arguments: (a, b) and returns:
      *        a negative number  if a is less than b;
      *        0 if a is equal to b;
      *        a positive number of a is greater than b.
      * The array may contain duplicate elements. If there are more than one equal elements in the array,
      * the returned value can be the index of any one of the equal elements.
      *
      * http://jsfiddle.net/aryzhov/pkfst550/
      */
      static binarySearch(ar, el2, comparator) {
        if (void 0 === comparator) {
          comparator = Arrays.numberComparator;
        }
        let m4 = 0;
        let n2 = ar.length - 1;
        while (m4 <= n2) {
          const k3 = n2 + m4 >> 1;
          const cmp = comparator(el2, ar[k3]);
          if (cmp > 0) {
            m4 = k3 + 1;
          } else if (cmp < 0) {
            n2 = k3 - 1;
          } else {
            return k3;
          }
        }
        return -m4 - 1;
      }
      static numberComparator(a4, b2) {
        return a4 - b2;
      }
    }
    class Integer {
      static numberOfTrailingZeros(i3) {
        let y4;
        if (i3 === 0)
          return 32;
        let n2 = 31;
        y4 = i3 << 16;
        if (y4 !== 0) {
          n2 -= 16;
          i3 = y4;
        }
        y4 = i3 << 8;
        if (y4 !== 0) {
          n2 -= 8;
          i3 = y4;
        }
        y4 = i3 << 4;
        if (y4 !== 0) {
          n2 -= 4;
          i3 = y4;
        }
        y4 = i3 << 2;
        if (y4 !== 0) {
          n2 -= 2;
          i3 = y4;
        }
        return n2 - (i3 << 1 >>> 31);
      }
      static numberOfLeadingZeros(i3) {
        if (i3 === 0) {
          return 32;
        }
        let n2 = 1;
        if (i3 >>> 16 === 0) {
          n2 += 16;
          i3 <<= 16;
        }
        if (i3 >>> 24 === 0) {
          n2 += 8;
          i3 <<= 8;
        }
        if (i3 >>> 28 === 0) {
          n2 += 4;
          i3 <<= 4;
        }
        if (i3 >>> 30 === 0) {
          n2 += 2;
          i3 <<= 2;
        }
        n2 -= i3 >>> 31;
        return n2;
      }
      static toHexString(i3) {
        return i3.toString(16);
      }
      static toBinaryString(intNumber) {
        return String(parseInt(String(intNumber), 2));
      }
      // Returns the number of one-bits in the two's complement binary representation of the specified int value. This function is sometimes referred to as the population count.
      // Returns:
      // the number of one-bits in the two's complement binary representation of the specified int value.
      static bitCount(i3) {
        i3 = i3 - (i3 >>> 1 & 1431655765);
        i3 = (i3 & 858993459) + (i3 >>> 2 & 858993459);
        i3 = i3 + (i3 >>> 4) & 252645135;
        i3 = i3 + (i3 >>> 8);
        i3 = i3 + (i3 >>> 16);
        return i3 & 63;
      }
      static truncDivision(dividend, divisor) {
        return Math.trunc(dividend / divisor);
      }
      /**
       * Converts A string to an integer.
       * @param s A string to convert into a number.
       * @param radix A value between 2 and 36 that specifies the base of the number in numString. If this argument is not supplied, strings with a prefix of '0x' are considered hexadecimal. All other strings are considered decimal.
       */
      static parseInt(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    Integer.MIN_VALUE_32_BITS = -2147483648;
    Integer.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class BitArray {
      // For testing only
      constructor(size2, bits) {
        if (void 0 === size2) {
          this.size = 0;
          this.bits = new Int32Array(1);
        } else {
          this.size = size2;
          if (void 0 === bits || null === bits) {
            this.bits = BitArray.makeArray(size2);
          } else {
            this.bits = bits;
          }
        }
      }
      getSize() {
        return this.size;
      }
      getSizeInBytes() {
        return Math.floor((this.size + 7) / 8);
      }
      ensureCapacity(size2) {
        if (size2 > this.bits.length * 32) {
          const newBits = BitArray.makeArray(size2);
          System.arraycopy(this.bits, 0, newBits, 0, this.bits.length);
          this.bits = newBits;
        }
      }
      /**
       * @param i bit to get
       * @return true iff bit i is set
       */
      get(i3) {
        return (this.bits[Math.floor(i3 / 32)] & 1 << (i3 & 31)) !== 0;
      }
      /**
       * Sets bit i.
       *
       * @param i bit to set
       */
      set(i3) {
        this.bits[Math.floor(i3 / 32)] |= 1 << (i3 & 31);
      }
      /**
       * Flips bit i.
       *
       * @param i bit to set
       */
      flip(i3) {
        this.bits[Math.floor(i3 / 32)] ^= 1 << (i3 & 31);
      }
      /**
       * @param from first bit to check
       * @return index of first bit that is set, starting from the given index, or size if none are set
       *  at or beyond this given index
       * @see #getNextUnset(int)
       */
      getNextSet(from) {
        const size2 = this.size;
        if (from >= size2) {
          return size2;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size2;
          }
          currentBits = bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size2 ? size2 : result;
      }
      /**
       * @param from index to start looking for unset bit
       * @return index of next unset bit, or {@code size} if none are unset until the end
       * @see #getNextSet(int)
       */
      getNextUnset(from) {
        const size2 = this.size;
        if (from >= size2) {
          return size2;
        }
        const bits = this.bits;
        let bitsOffset = Math.floor(from / 32);
        let currentBits = ~bits[bitsOffset];
        currentBits &= ~((1 << (from & 31)) - 1);
        const length = bits.length;
        while (currentBits === 0) {
          if (++bitsOffset === length) {
            return size2;
          }
          currentBits = ~bits[bitsOffset];
        }
        const result = bitsOffset * 32 + Integer.numberOfTrailingZeros(currentBits);
        return result > size2 ? size2 : result;
      }
      /**
       * Sets a block of 32 bits, starting at bit i.
       *
       * @param i first bit to set
       * @param newBits the new value of the next 32 bits. Note again that the least-significant bit
       * corresponds to bit i, the next-least-significant to i+1, and so on.
       */
      setBulk(i3, newBits) {
        this.bits[Math.floor(i3 / 32)] = newBits;
      }
      /**
       * Sets a range of bits.
       *
       * @param start start of range, inclusive.
       * @param end end of range, exclusive
       */
      setRange(start, end) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i3 = firstInt; i3 <= lastInt; i3++) {
          const firstBit = i3 > firstInt ? 0 : start & 31;
          const lastBit = i3 < lastInt ? 31 : end & 31;
          const mask = (2 << lastBit) - (1 << firstBit);
          bits[i3] |= mask;
        }
      }
      /**
       * Clears all bits (sets to false).
       */
      clear() {
        const max2 = this.bits.length;
        const bits = this.bits;
        for (let i3 = 0; i3 < max2; i3++) {
          bits[i3] = 0;
        }
      }
      /**
       * Efficient method to check if a range of bits is set, or not set.
       *
       * @param start start of range, inclusive.
       * @param end end of range, exclusive
       * @param value if true, checks that bits in range are set, otherwise checks that they are not set
       * 
       * @return true iff all bits are set or not set in range, according to value argument
       * @throws IllegalArgumentException if end is less than start or the range is not contained in the array
       */
      isRange(start, end, value) {
        if (end < start || start < 0 || end > this.size) {
          throw new IllegalArgumentException();
        }
        if (end === start) {
          return true;
        }
        end--;
        const firstInt = Math.floor(start / 32);
        const lastInt = Math.floor(end / 32);
        const bits = this.bits;
        for (let i3 = firstInt; i3 <= lastInt; i3++) {
          const firstBit = i3 > firstInt ? 0 : start & 31;
          const lastBit = i3 < lastInt ? 31 : end & 31;
          const mask = (2 << lastBit) - (1 << firstBit) & 4294967295;
          if ((bits[i3] & mask) !== (value ? mask : 0)) {
            return false;
          }
        }
        return true;
      }
      appendBit(bit) {
        this.ensureCapacity(this.size + 1);
        if (bit) {
          this.bits[Math.floor(this.size / 32)] |= 1 << (this.size & 31);
        }
        this.size++;
      }
      /**
       * Appends the least-significant bits, from value, in order from most-significant to
       * least-significant. For example, appending 6 bits from 0x000001E will append the bits
       * 0, 1, 1, 1, 1, 0 in that order.
       *
       * @param value {@code int} containing bits to append
       * @param numBits bits from value to append
       */
      appendBits(value, numBits) {
        if (numBits < 0 || numBits > 32) {
          throw new IllegalArgumentException("Num bits must be between 0 and 32");
        }
        this.ensureCapacity(this.size + numBits);
        for (let numBitsLeft = numBits; numBitsLeft > 0; numBitsLeft--) {
          this.appendBit((value >> numBitsLeft - 1 & 1) === 1);
        }
      }
      appendBitArray(other) {
        const otherSize = other.size;
        this.ensureCapacity(this.size + otherSize);
        for (let i3 = 0; i3 < otherSize; i3++) {
          this.appendBit(other.get(i3));
        }
      }
      xor(other) {
        if (this.size !== other.size) {
          throw new IllegalArgumentException("Sizes don't match");
        }
        const bits = this.bits;
        for (let i3 = 0, length = bits.length; i3 < length; i3++) {
          bits[i3] ^= other.bits[i3];
        }
      }
      /**
       *
       * @param bitOffset first bit to start writing
       * @param array array to write into. Bytes are written most-significant byte first. This is the opposite
       *  of the internal representation, which is exposed by {@link #getBitArray()}
       * @param offset position in array to start writing
       * @param numBytes how many bytes to write
       */
      toBytes(bitOffset, array, offset2, numBytes) {
        for (let i3 = 0; i3 < numBytes; i3++) {
          let theByte = 0;
          for (let j2 = 0; j2 < 8; j2++) {
            if (this.get(bitOffset)) {
              theByte |= 1 << 7 - j2;
            }
            bitOffset++;
          }
          array[offset2 + i3] = /*(byte)*/
          theByte;
        }
      }
      /**
       * @return underlying array of ints. The first element holds the first 32 bits, and the least
       *         significant bit is bit 0.
       */
      getBitArray() {
        return this.bits;
      }
      /**
       * Reverses all bits in the array.
       */
      reverse() {
        const newBits = new Int32Array(this.bits.length);
        const len = Math.floor((this.size - 1) / 32);
        const oldBitsLen = len + 1;
        const bits = this.bits;
        for (let i3 = 0; i3 < oldBitsLen; i3++) {
          let x3 = bits[i3];
          x3 = x3 >> 1 & 1431655765 | (x3 & 1431655765) << 1;
          x3 = x3 >> 2 & 858993459 | (x3 & 858993459) << 2;
          x3 = x3 >> 4 & 252645135 | (x3 & 252645135) << 4;
          x3 = x3 >> 8 & 16711935 | (x3 & 16711935) << 8;
          x3 = x3 >> 16 & 65535 | (x3 & 65535) << 16;
          newBits[len - i3] = /*(int)*/
          x3;
        }
        if (this.size !== oldBitsLen * 32) {
          const leftOffset = oldBitsLen * 32 - this.size;
          let currentInt = newBits[0] >>> leftOffset;
          for (let i3 = 1; i3 < oldBitsLen; i3++) {
            const nextInt = newBits[i3];
            currentInt |= nextInt << 32 - leftOffset;
            newBits[i3 - 1] = currentInt;
            currentInt = nextInt >>> leftOffset;
          }
          newBits[oldBitsLen - 1] = currentInt;
        }
        this.bits = newBits;
      }
      static makeArray(size2) {
        return new Int32Array(Math.floor((size2 + 31) / 32));
      }
      /*@Override*/
      equals(o2) {
        if (!(o2 instanceof BitArray)) {
          return false;
        }
        const other = o2;
        return this.size === other.size && Arrays.equals(this.bits, other.bits);
      }
      /*@Override*/
      hashCode() {
        return 31 * this.size + Arrays.hashCode(this.bits);
      }
      /*@Override*/
      toString() {
        let result = "";
        for (let i3 = 0, size2 = this.size; i3 < size2; i3++) {
          if ((i3 & 7) === 0) {
            result += " ";
          }
          result += this.get(i3) ? "X" : ".";
        }
        return result;
      }
      /*@Override*/
      clone() {
        return new BitArray(this.size, this.bits.slice());
      }
    }
    var DecodeHintType;
    (function(DecodeHintType2) {
      DecodeHintType2[DecodeHintType2["OTHER"] = 0] = "OTHER";
      DecodeHintType2[DecodeHintType2["PURE_BARCODE"] = 1] = "PURE_BARCODE";
      DecodeHintType2[DecodeHintType2["POSSIBLE_FORMATS"] = 2] = "POSSIBLE_FORMATS";
      DecodeHintType2[DecodeHintType2["TRY_HARDER"] = 3] = "TRY_HARDER";
      DecodeHintType2[DecodeHintType2["CHARACTER_SET"] = 4] = "CHARACTER_SET";
      DecodeHintType2[DecodeHintType2["ALLOWED_LENGTHS"] = 5] = "ALLOWED_LENGTHS";
      DecodeHintType2[DecodeHintType2["ASSUME_CODE_39_CHECK_DIGIT"] = 6] = "ASSUME_CODE_39_CHECK_DIGIT";
      DecodeHintType2[DecodeHintType2["ASSUME_GS1"] = 7] = "ASSUME_GS1";
      DecodeHintType2[DecodeHintType2["RETURN_CODABAR_START_END"] = 8] = "RETURN_CODABAR_START_END";
      DecodeHintType2[DecodeHintType2["NEED_RESULT_POINT_CALLBACK"] = 9] = "NEED_RESULT_POINT_CALLBACK";
      DecodeHintType2[DecodeHintType2["ALLOWED_EAN_EXTENSIONS"] = 10] = "ALLOWED_EAN_EXTENSIONS";
    })(DecodeHintType || (DecodeHintType = {}));
    var DecodeHintType$1 = DecodeHintType;
    class FormatException extends Exception {
      static getFormatInstance() {
        return new FormatException();
      }
    }
    FormatException.kind = "FormatException";
    var CharacterSetValueIdentifiers;
    (function(CharacterSetValueIdentifiers2) {
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp437"] = 0] = "Cp437";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_1"] = 1] = "ISO8859_1";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_2"] = 2] = "ISO8859_2";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_3"] = 3] = "ISO8859_3";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_4"] = 4] = "ISO8859_4";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_5"] = 5] = "ISO8859_5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_6"] = 6] = "ISO8859_6";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_7"] = 7] = "ISO8859_7";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_8"] = 8] = "ISO8859_8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_9"] = 9] = "ISO8859_9";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_10"] = 10] = "ISO8859_10";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_11"] = 11] = "ISO8859_11";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_13"] = 12] = "ISO8859_13";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_14"] = 13] = "ISO8859_14";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_15"] = 14] = "ISO8859_15";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ISO8859_16"] = 15] = "ISO8859_16";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["SJIS"] = 16] = "SJIS";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1250"] = 17] = "Cp1250";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1251"] = 18] = "Cp1251";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1252"] = 19] = "Cp1252";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Cp1256"] = 20] = "Cp1256";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UnicodeBigUnmarked"] = 21] = "UnicodeBigUnmarked";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["UTF8"] = 22] = "UTF8";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["ASCII"] = 23] = "ASCII";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["Big5"] = 24] = "Big5";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["GB18030"] = 25] = "GB18030";
      CharacterSetValueIdentifiers2[CharacterSetValueIdentifiers2["EUC_KR"] = 26] = "EUC_KR";
    })(CharacterSetValueIdentifiers || (CharacterSetValueIdentifiers = {}));
    class CharacterSetECI {
      constructor(valueIdentifier, valuesParam, name, ...otherEncodingNames) {
        this.valueIdentifier = valueIdentifier;
        this.name = name;
        if (typeof valuesParam === "number") {
          this.values = Int32Array.from([valuesParam]);
        } else {
          this.values = valuesParam;
        }
        this.otherEncodingNames = otherEncodingNames;
        CharacterSetECI.VALUE_IDENTIFIER_TO_ECI.set(valueIdentifier, this);
        CharacterSetECI.NAME_TO_ECI.set(name, this);
        const values = this.values;
        for (let i3 = 0, length = values.length; i3 !== length; i3++) {
          const v2 = values[i3];
          CharacterSetECI.VALUES_TO_ECI.set(v2, this);
        }
        for (const otherName of otherEncodingNames) {
          CharacterSetECI.NAME_TO_ECI.set(otherName, this);
        }
      }
      // CharacterSetECI(value: number /*int*/) {
      //   this(new Int32Array {value})
      // }
      // CharacterSetECI(value: number /*int*/, String... otherEncodingNames) {
      //   this.values = new Int32Array {value}
      //   this.otherEncodingNames = otherEncodingNames
      // }
      // CharacterSetECI(values: Int32Array, String... otherEncodingNames) {
      //   this.values = values
      //   this.otherEncodingNames = otherEncodingNames
      // }
      getValueIdentifier() {
        return this.valueIdentifier;
      }
      getName() {
        return this.name;
      }
      getValue() {
        return this.values[0];
      }
      /**
       * @param value character set ECI value
       * @return {@code CharacterSetECI} representing ECI of given value, or null if it is legal but
       *   unsupported
       * @throws FormatException if ECI value is invalid
       */
      static getCharacterSetECIByValue(value) {
        if (value < 0 || value >= 900) {
          throw new FormatException("incorect value");
        }
        const characterSet = CharacterSetECI.VALUES_TO_ECI.get(value);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      /**
       * @param name character set ECI encoding name
       * @return CharacterSetECI representing ECI for character encoding, or null if it is legal
       *   but unsupported
       */
      static getCharacterSetECIByName(name) {
        const characterSet = CharacterSetECI.NAME_TO_ECI.get(name);
        if (void 0 === characterSet) {
          throw new FormatException("incorect value");
        }
        return characterSet;
      }
      equals(o2) {
        if (!(o2 instanceof CharacterSetECI)) {
          return false;
        }
        const other = o2;
        return this.getName() === other.getName();
      }
    }
    CharacterSetECI.VALUE_IDENTIFIER_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.VALUES_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.NAME_TO_ECI = /* @__PURE__ */ new Map();
    CharacterSetECI.Cp437 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp437, Int32Array.from([0, 2]), "Cp437");
    CharacterSetECI.ISO8859_1 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_1, Int32Array.from([1, 3]), "ISO-8859-1", "ISO88591", "ISO8859_1");
    CharacterSetECI.ISO8859_2 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_2, 4, "ISO-8859-2", "ISO88592", "ISO8859_2");
    CharacterSetECI.ISO8859_3 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_3, 5, "ISO-8859-3", "ISO88593", "ISO8859_3");
    CharacterSetECI.ISO8859_4 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_4, 6, "ISO-8859-4", "ISO88594", "ISO8859_4");
    CharacterSetECI.ISO8859_5 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_5, 7, "ISO-8859-5", "ISO88595", "ISO8859_5");
    CharacterSetECI.ISO8859_6 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_6, 8, "ISO-8859-6", "ISO88596", "ISO8859_6");
    CharacterSetECI.ISO8859_7 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_7, 9, "ISO-8859-7", "ISO88597", "ISO8859_7");
    CharacterSetECI.ISO8859_8 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_8, 10, "ISO-8859-8", "ISO88598", "ISO8859_8");
    CharacterSetECI.ISO8859_9 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_9, 11, "ISO-8859-9", "ISO88599", "ISO8859_9");
    CharacterSetECI.ISO8859_10 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_10, 12, "ISO-8859-10", "ISO885910", "ISO8859_10");
    CharacterSetECI.ISO8859_11 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_11, 13, "ISO-8859-11", "ISO885911", "ISO8859_11");
    CharacterSetECI.ISO8859_13 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_13, 15, "ISO-8859-13", "ISO885913", "ISO8859_13");
    CharacterSetECI.ISO8859_14 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_14, 16, "ISO-8859-14", "ISO885914", "ISO8859_14");
    CharacterSetECI.ISO8859_15 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_15, 17, "ISO-8859-15", "ISO885915", "ISO8859_15");
    CharacterSetECI.ISO8859_16 = new CharacterSetECI(CharacterSetValueIdentifiers.ISO8859_16, 18, "ISO-8859-16", "ISO885916", "ISO8859_16");
    CharacterSetECI.SJIS = new CharacterSetECI(CharacterSetValueIdentifiers.SJIS, 20, "SJIS", "Shift_JIS");
    CharacterSetECI.Cp1250 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1250, 21, "Cp1250", "windows-1250");
    CharacterSetECI.Cp1251 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1251, 22, "Cp1251", "windows-1251");
    CharacterSetECI.Cp1252 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1252, 23, "Cp1252", "windows-1252");
    CharacterSetECI.Cp1256 = new CharacterSetECI(CharacterSetValueIdentifiers.Cp1256, 24, "Cp1256", "windows-1256");
    CharacterSetECI.UnicodeBigUnmarked = new CharacterSetECI(CharacterSetValueIdentifiers.UnicodeBigUnmarked, 25, "UnicodeBigUnmarked", "UTF-16BE", "UnicodeBig");
    CharacterSetECI.UTF8 = new CharacterSetECI(CharacterSetValueIdentifiers.UTF8, 26, "UTF8", "UTF-8");
    CharacterSetECI.ASCII = new CharacterSetECI(CharacterSetValueIdentifiers.ASCII, Int32Array.from([27, 170]), "ASCII", "US-ASCII");
    CharacterSetECI.Big5 = new CharacterSetECI(CharacterSetValueIdentifiers.Big5, 28, "Big5");
    CharacterSetECI.GB18030 = new CharacterSetECI(CharacterSetValueIdentifiers.GB18030, 29, "GB18030", "GB2312", "EUC_CN", "GBK");
    CharacterSetECI.EUC_KR = new CharacterSetECI(CharacterSetValueIdentifiers.EUC_KR, 30, "EUC_KR", "EUC-KR");
    class UnsupportedOperationException extends Exception {
    }
    UnsupportedOperationException.kind = "UnsupportedOperationException";
    class StringEncoding {
      /**
       * Decodes some Uint8Array to a string format.
       */
      static decode(bytes, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customDecoder) {
          return this.customDecoder(bytes, encodingName);
        }
        if (typeof TextDecoder === "undefined" || this.shouldDecodeOnFallback(encodingName)) {
          return this.decodeFallback(bytes, encodingName);
        }
        return new TextDecoder(encodingName).decode(bytes);
      }
      /**
       * Checks if the decoding method should use the fallback for decoding
       * once Node TextDecoder doesn't support all encoding formats.
       *
       * @param encodingName
       */
      static shouldDecodeOnFallback(encodingName) {
        return !StringEncoding.isBrowser() && encodingName === "ISO-8859-1";
      }
      /**
       * Encodes some string into a Uint8Array.
       */
      static encode(s4, encoding) {
        const encodingName = this.encodingName(encoding);
        if (this.customEncoder) {
          return this.customEncoder(s4, encodingName);
        }
        if (typeof TextEncoder === "undefined") {
          return this.encodeFallback(s4);
        }
        return new TextEncoder().encode(s4);
      }
      static isBrowser() {
        return typeof window !== "undefined" && {}.toString.call(window) === "[object Window]";
      }
      /**
       * Returns the string value from some encoding character set.
       */
      static encodingName(encoding) {
        return typeof encoding === "string" ? encoding : encoding.getName();
      }
      /**
       * Returns character set from some encoding character set.
       */
      static encodingCharacterSet(encoding) {
        if (encoding instanceof CharacterSetECI) {
          return encoding;
        }
        return CharacterSetECI.getCharacterSetECIByName(encoding);
      }
      /**
       * Runs a fallback for the native decoding funcion.
       */
      static decodeFallback(bytes, encoding) {
        const characterSet = this.encodingCharacterSet(encoding);
        if (StringEncoding.isDecodeFallbackSupported(characterSet)) {
          let s4 = "";
          for (let i3 = 0, length = bytes.length; i3 < length; i3++) {
            let h4 = bytes[i3].toString(16);
            if (h4.length < 2) {
              h4 = "0" + h4;
            }
            s4 += "%" + h4;
          }
          return decodeURIComponent(s4);
        }
        if (characterSet.equals(CharacterSetECI.UnicodeBigUnmarked)) {
          return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
        }
        throw new UnsupportedOperationException(`Encoding ${this.encodingName(encoding)} not supported by fallback.`);
      }
      static isDecodeFallbackSupported(characterSet) {
        return characterSet.equals(CharacterSetECI.UTF8) || characterSet.equals(CharacterSetECI.ISO8859_1) || characterSet.equals(CharacterSetECI.ASCII);
      }
      /**
       * Runs a fallback for the native encoding funcion.
       *
       * @see https://stackoverflow.com/a/17192845/4367683
       */
      static encodeFallback(s4) {
        const encodedURIstring = btoa(unescape(encodeURIComponent(s4)));
        const charList = encodedURIstring.split("");
        const uintArray = [];
        for (let i3 = 0; i3 < charList.length; i3++) {
          uintArray.push(charList[i3].charCodeAt(0));
        }
        return new Uint8Array(uintArray);
      }
    }
    class StringUtils {
      // SHIFT_JIS.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING) ||
      // EUC_JP.equalsIgnoreCase(PLATFORM_DEFAULT_ENCODING);
      static castAsNonUtf8Char(code, encoding = null) {
        const e3 = encoding ? encoding.getName() : this.ISO88591;
        return StringEncoding.decode(new Uint8Array([code]), e3);
      }
      /**
       * @param bytes bytes encoding a string, whose encoding should be guessed
       * @param hints decode hints if applicable
       * @return name of guessed encoding; at the moment will only guess one of:
       *  {@link #SHIFT_JIS}, {@link #UTF8}, {@link #ISO88591}, or the platform
       *  default encoding if none of these can possibly be correct
       */
      static guessEncoding(bytes, hints) {
        if (hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.CHARACTER_SET)) {
          return hints.get(DecodeHintType$1.CHARACTER_SET).toString();
        }
        const length = bytes.length;
        let canBeISO88591 = true;
        let canBeShiftJIS = true;
        let canBeUTF8 = true;
        let utf8BytesLeft = 0;
        let utf2BytesChars = 0;
        let utf3BytesChars = 0;
        let utf4BytesChars = 0;
        let sjisBytesLeft = 0;
        let sjisKatakanaChars = 0;
        let sjisCurKatakanaWordLength = 0;
        let sjisCurDoubleBytesWordLength = 0;
        let sjisMaxKatakanaWordLength = 0;
        let sjisMaxDoubleBytesWordLength = 0;
        let isoHighOther = 0;
        const utf8bom = bytes.length > 3 && bytes[0] === /*(byte) */
        239 && bytes[1] === /*(byte) */
        187 && bytes[2] === /*(byte) */
        191;
        for (let i3 = 0; i3 < length && (canBeISO88591 || canBeShiftJIS || canBeUTF8); i3++) {
          const value = bytes[i3] & 255;
          if (canBeUTF8) {
            if (utf8BytesLeft > 0) {
              if ((value & 128) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft--;
              }
            } else if ((value & 128) !== 0) {
              if ((value & 64) === 0) {
                canBeUTF8 = false;
              } else {
                utf8BytesLeft++;
                if ((value & 32) === 0) {
                  utf2BytesChars++;
                } else {
                  utf8BytesLeft++;
                  if ((value & 16) === 0) {
                    utf3BytesChars++;
                  } else {
                    utf8BytesLeft++;
                    if ((value & 8) === 0) {
                      utf4BytesChars++;
                    } else {
                      canBeUTF8 = false;
                    }
                  }
                }
              }
            }
          }
          if (canBeISO88591) {
            if (value > 127 && value < 160) {
              canBeISO88591 = false;
            } else if (value > 159) {
              if (value < 192 || value === 215 || value === 247) {
                isoHighOther++;
              }
            }
          }
          if (canBeShiftJIS) {
            if (sjisBytesLeft > 0) {
              if (value < 64 || value === 127 || value > 252) {
                canBeShiftJIS = false;
              } else {
                sjisBytesLeft--;
              }
            } else if (value === 128 || value === 160 || value > 239) {
              canBeShiftJIS = false;
            } else if (value > 160 && value < 224) {
              sjisKatakanaChars++;
              sjisCurDoubleBytesWordLength = 0;
              sjisCurKatakanaWordLength++;
              if (sjisCurKatakanaWordLength > sjisMaxKatakanaWordLength) {
                sjisMaxKatakanaWordLength = sjisCurKatakanaWordLength;
              }
            } else if (value > 127) {
              sjisBytesLeft++;
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength++;
              if (sjisCurDoubleBytesWordLength > sjisMaxDoubleBytesWordLength) {
                sjisMaxDoubleBytesWordLength = sjisCurDoubleBytesWordLength;
              }
            } else {
              sjisCurKatakanaWordLength = 0;
              sjisCurDoubleBytesWordLength = 0;
            }
          }
        }
        if (canBeUTF8 && utf8BytesLeft > 0) {
          canBeUTF8 = false;
        }
        if (canBeShiftJIS && sjisBytesLeft > 0) {
          canBeShiftJIS = false;
        }
        if (canBeUTF8 && (utf8bom || utf2BytesChars + utf3BytesChars + utf4BytesChars > 0)) {
          return StringUtils.UTF8;
        }
        if (canBeShiftJIS && (StringUtils.ASSUME_SHIFT_JIS || sjisMaxKatakanaWordLength >= 3 || sjisMaxDoubleBytesWordLength >= 3)) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeISO88591 && canBeShiftJIS) {
          return sjisMaxKatakanaWordLength === 2 && sjisKatakanaChars === 2 || isoHighOther * 10 >= length ? StringUtils.SHIFT_JIS : StringUtils.ISO88591;
        }
        if (canBeISO88591) {
          return StringUtils.ISO88591;
        }
        if (canBeShiftJIS) {
          return StringUtils.SHIFT_JIS;
        }
        if (canBeUTF8) {
          return StringUtils.UTF8;
        }
        return StringUtils.PLATFORM_DEFAULT_ENCODING;
      }
      /**
       *
       * @see https://stackoverflow.com/a/13439711/4367683
       *
       * @param append The new string to append.
       * @param args Argumets values to be formated.
       */
      static format(append, ...args) {
        let i3 = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (args[++i3] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = args[i3];
              break;
            case "c":
              val = args[i3][0];
              break;
            case "f":
              val = parseFloat(args[i3]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(args[i3]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(args[i3]).toExponential(exp);
              break;
            case "x":
              val = parseInt(args[i3]).toString(base ? base : 16);
              break;
            case "d":
              val = parseFloat(parseInt(args[i3], base ? base : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
          let size2 = parseInt(p1);
          let ch2 = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size2)
            val = p0 !== void 0 ? val + ch2 : ch2 + val;
          return val;
        }
        let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return append.replace(regex, callback);
      }
      /**
       *
       */
      static getBytes(str, encoding) {
        return StringEncoding.encode(str, encoding);
      }
      /**
       * Returns the charcode at the specified index or at index zero.
       */
      static getCharCode(str, index2 = 0) {
        return str.charCodeAt(index2);
      }
      /**
       * Returns char for given charcode
       */
      static getCharAt(charCode) {
        return String.fromCharCode(charCode);
      }
    }
    StringUtils.SHIFT_JIS = CharacterSetECI.SJIS.getName();
    StringUtils.GB2312 = "GB2312";
    StringUtils.ISO88591 = CharacterSetECI.ISO8859_1.getName();
    StringUtils.EUC_JP = "EUC_JP";
    StringUtils.UTF8 = CharacterSetECI.UTF8.getName();
    StringUtils.PLATFORM_DEFAULT_ENCODING = StringUtils.UTF8;
    StringUtils.ASSUME_SHIFT_JIS = false;
    class StringBuilder {
      constructor(value = "") {
        this.value = value;
      }
      enableDecoding(encoding) {
        this.encoding = encoding;
        return this;
      }
      append(s4) {
        if (typeof s4 === "string") {
          this.value += s4.toString();
        } else if (this.encoding) {
          this.value += StringUtils.castAsNonUtf8Char(s4, this.encoding);
        } else {
          this.value += String.fromCharCode(s4);
        }
        return this;
      }
      appendChars(str, offset2, len) {
        for (let i3 = offset2; offset2 < offset2 + len; i3++) {
          this.append(str[i3]);
        }
        return this;
      }
      length() {
        return this.value.length;
      }
      charAt(n2) {
        return this.value.charAt(n2);
      }
      deleteCharAt(n2) {
        this.value = this.value.substr(0, n2) + this.value.substring(n2 + 1);
      }
      setCharAt(n2, c3) {
        this.value = this.value.substr(0, n2) + c3 + this.value.substr(n2 + 1);
      }
      substring(start, end) {
        return this.value.substring(start, end);
      }
      /**
       * @note helper method for RSS Expanded
       */
      setLengthToZero() {
        this.value = "";
      }
      toString() {
        return this.value;
      }
      insert(n2, c3) {
        this.value = this.value.substr(0, n2) + c3 + this.value.substr(n2 + c3.length);
      }
    }
    class BitMatrix {
      /**
       * Creates an empty square {@link BitMatrix}.
       *
       * @param dimension height and width
       */
      // public constructor(dimension: number /*int*/) {
      //   this(dimension, dimension)
      // }
      /**
       * Creates an empty {@link BitMatrix}.
       *
       * @param width bit matrix width
       * @param height bit matrix height
       */
      // public constructor(width: number /*int*/, height: number /*int*/) {
      //   if (width < 1 || height < 1) {
      //     throw new IllegalArgumentException("Both dimensions must be greater than 0")
      //   }
      //   this.width = width
      //   this.height = height
      //   this.rowSize = (width + 31) / 32
      //   bits = new int[rowSize * height];
      // }
      constructor(width, height, rowSize, bits) {
        this.width = width;
        this.height = height;
        this.rowSize = rowSize;
        this.bits = bits;
        if (void 0 === height || null === height) {
          height = width;
        }
        this.height = height;
        if (width < 1 || height < 1) {
          throw new IllegalArgumentException("Both dimensions must be greater than 0");
        }
        if (void 0 === rowSize || null === rowSize) {
          rowSize = Math.floor((width + 31) / 32);
        }
        this.rowSize = rowSize;
        if (void 0 === bits || null === bits) {
          this.bits = new Int32Array(this.rowSize * this.height);
        }
      }
      /**
       * Interprets a 2D array of booleans as a {@link BitMatrix}, where "true" means an "on" bit.
       *
       * @function parse
       * @param image bits of the image, as a row-major 2D array. Elements are arrays representing rows
       * @return {@link BitMatrix} representation of image
       */
      static parseFromBooleanArray(image) {
        const height = image.length;
        const width = image[0].length;
        const bits = new BitMatrix(width, height);
        for (let i3 = 0; i3 < height; i3++) {
          const imageI = image[i3];
          for (let j2 = 0; j2 < width; j2++) {
            if (imageI[j2]) {
              bits.set(j2, i3);
            }
          }
        }
        return bits;
      }
      /**
       *
       * @function parse
       * @param stringRepresentation
       * @param setString
       * @param unsetString
       */
      static parseFromString(stringRepresentation, setString, unsetString) {
        if (stringRepresentation === null) {
          throw new IllegalArgumentException("stringRepresentation cannot be null");
        }
        const bits = new Array(stringRepresentation.length);
        let bitsPos = 0;
        let rowStartPos = 0;
        let rowLength = -1;
        let nRows = 0;
        let pos = 0;
        while (pos < stringRepresentation.length) {
          if (stringRepresentation.charAt(pos) === "\n" || stringRepresentation.charAt(pos) === "\r") {
            if (bitsPos > rowStartPos) {
              if (rowLength === -1) {
                rowLength = bitsPos - rowStartPos;
              } else if (bitsPos - rowStartPos !== rowLength) {
                throw new IllegalArgumentException("row lengths do not match");
              }
              rowStartPos = bitsPos;
              nRows++;
            }
            pos++;
          } else if (stringRepresentation.substring(pos, pos + setString.length) === setString) {
            pos += setString.length;
            bits[bitsPos] = true;
            bitsPos++;
          } else if (stringRepresentation.substring(pos, pos + unsetString.length) === unsetString) {
            pos += unsetString.length;
            bits[bitsPos] = false;
            bitsPos++;
          } else {
            throw new IllegalArgumentException("illegal character encountered: " + stringRepresentation.substring(pos));
          }
        }
        if (bitsPos > rowStartPos) {
          if (rowLength === -1) {
            rowLength = bitsPos - rowStartPos;
          } else if (bitsPos - rowStartPos !== rowLength) {
            throw new IllegalArgumentException("row lengths do not match");
          }
          nRows++;
        }
        const matrix = new BitMatrix(rowLength, nRows);
        for (let i3 = 0; i3 < bitsPos; i3++) {
          if (bits[i3]) {
            matrix.set(Math.floor(i3 % rowLength), Math.floor(i3 / rowLength));
          }
        }
        return matrix;
      }
      /**
       * <p>Gets the requested bit, where true means black.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       * @return value of given bit in matrix
       */
      get(x3, y4) {
        const offset2 = y4 * this.rowSize + Math.floor(x3 / 32);
        return (this.bits[offset2] >>> (x3 & 31) & 1) !== 0;
      }
      /**
       * <p>Sets the given bit to true.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       */
      set(x3, y4) {
        const offset2 = y4 * this.rowSize + Math.floor(x3 / 32);
        this.bits[offset2] |= 1 << (x3 & 31) & 4294967295;
      }
      unset(x3, y4) {
        const offset2 = y4 * this.rowSize + Math.floor(x3 / 32);
        this.bits[offset2] &= ~(1 << (x3 & 31) & 4294967295);
      }
      /**
       * <p>Flips the given bit.</p>
       *
       * @param x The horizontal component (i.e. which column)
       * @param y The vertical component (i.e. which row)
       */
      flip(x3, y4) {
        const offset2 = y4 * this.rowSize + Math.floor(x3 / 32);
        this.bits[offset2] ^= 1 << (x3 & 31) & 4294967295;
      }
      /**
       * Exclusive-or (XOR): Flip the bit in this {@code BitMatrix} if the corresponding
       * mask bit is set.
       *
       * @param mask XOR mask
       */
      xor(mask) {
        if (this.width !== mask.getWidth() || this.height !== mask.getHeight() || this.rowSize !== mask.getRowSize()) {
          throw new IllegalArgumentException("input matrix dimensions do not match");
        }
        const rowArray = new BitArray(Math.floor(this.width / 32) + 1);
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y4 = 0, height = this.height; y4 < height; y4++) {
          const offset2 = y4 * rowSize;
          const row = mask.getRow(y4, rowArray).getBitArray();
          for (let x3 = 0; x3 < rowSize; x3++) {
            bits[offset2 + x3] ^= row[x3];
          }
        }
      }
      /**
       * Clears all bits (sets to false).
       */
      clear() {
        const bits = this.bits;
        const max2 = bits.length;
        for (let i3 = 0; i3 < max2; i3++) {
          bits[i3] = 0;
        }
      }
      /**
       * <p>Sets a square region of the bit matrix to true.</p>
       *
       * @param left The horizontal position to begin at (inclusive)
       * @param top The vertical position to begin at (inclusive)
       * @param width The width of the region
       * @param height The height of the region
       */
      setRegion(left, top, width, height) {
        if (top < 0 || left < 0) {
          throw new IllegalArgumentException("Left and top must be nonnegative");
        }
        if (height < 1 || width < 1) {
          throw new IllegalArgumentException("Height and width must be at least 1");
        }
        const right = left + width;
        const bottom = top + height;
        if (bottom > this.height || right > this.width) {
          throw new IllegalArgumentException("The region must fit inside the matrix");
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        for (let y4 = top; y4 < bottom; y4++) {
          const offset2 = y4 * rowSize;
          for (let x3 = left; x3 < right; x3++) {
            bits[offset2 + Math.floor(x3 / 32)] |= 1 << (x3 & 31) & 4294967295;
          }
        }
      }
      /**
       * A fast method to retrieve one row of data from the matrix as a BitArray.
       *
       * @param y The row to retrieve
       * @param row An optional caller-allocated BitArray, will be allocated if null or too small
       * @return The resulting BitArray - this reference should always be used even when passing
       *         your own row
       */
      getRow(y4, row) {
        if (row === null || row === void 0 || row.getSize() < this.width) {
          row = new BitArray(this.width);
        } else {
          row.clear();
        }
        const rowSize = this.rowSize;
        const bits = this.bits;
        const offset2 = y4 * rowSize;
        for (let x3 = 0; x3 < rowSize; x3++) {
          row.setBulk(x3 * 32, bits[offset2 + x3]);
        }
        return row;
      }
      /**
       * @param y row to set
       * @param row {@link BitArray} to copy from
       */
      setRow(y4, row) {
        System.arraycopy(row.getBitArray(), 0, this.bits, y4 * this.rowSize, this.rowSize);
      }
      /**
       * Modifies this {@code BitMatrix} to represent the same but rotated 180 degrees
       */
      rotate180() {
        const width = this.getWidth();
        const height = this.getHeight();
        let topRow = new BitArray(width);
        let bottomRow = new BitArray(width);
        for (let i3 = 0, length = Math.floor((height + 1) / 2); i3 < length; i3++) {
          topRow = this.getRow(i3, topRow);
          bottomRow = this.getRow(height - 1 - i3, bottomRow);
          topRow.reverse();
          bottomRow.reverse();
          this.setRow(i3, bottomRow);
          this.setRow(height - 1 - i3, topRow);
        }
      }
      /**
       * This is useful in detecting the enclosing rectangle of a 'pure' barcode.
       *
       * @return {@code left,top,width,height} enclosing rectangle of all 1 bits, or null if it is all white
       */
      getEnclosingRectangle() {
        const width = this.width;
        const height = this.height;
        const rowSize = this.rowSize;
        const bits = this.bits;
        let left = width;
        let top = height;
        let right = -1;
        let bottom = -1;
        for (let y4 = 0; y4 < height; y4++) {
          for (let x32 = 0; x32 < rowSize; x32++) {
            const theBits = bits[y4 * rowSize + x32];
            if (theBits !== 0) {
              if (y4 < top) {
                top = y4;
              }
              if (y4 > bottom) {
                bottom = y4;
              }
              if (x32 * 32 < left) {
                let bit = 0;
                while ((theBits << 31 - bit & 4294967295) === 0) {
                  bit++;
                }
                if (x32 * 32 + bit < left) {
                  left = x32 * 32 + bit;
                }
              }
              if (x32 * 32 + 31 > right) {
                let bit = 31;
                while (theBits >>> bit === 0) {
                  bit--;
                }
                if (x32 * 32 + bit > right) {
                  right = x32 * 32 + bit;
                }
              }
            }
          }
        }
        if (right < left || bottom < top) {
          return null;
        }
        return Int32Array.from([left, top, right - left + 1, bottom - top + 1]);
      }
      /**
       * This is useful in detecting a corner of a 'pure' barcode.
       *
       * @return {@code x,y} coordinate of top-left-most 1 bit, or null if it is all white
       */
      getTopLeftOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = 0;
        while (bitsOffset < bits.length && bits[bitsOffset] === 0) {
          bitsOffset++;
        }
        if (bitsOffset === bits.length) {
          return null;
        }
        const y4 = bitsOffset / rowSize;
        let x3 = bitsOffset % rowSize * 32;
        const theBits = bits[bitsOffset];
        let bit = 0;
        while ((theBits << 31 - bit & 4294967295) === 0) {
          bit++;
        }
        x3 += bit;
        return Int32Array.from([x3, y4]);
      }
      getBottomRightOnBit() {
        const rowSize = this.rowSize;
        const bits = this.bits;
        let bitsOffset = bits.length - 1;
        while (bitsOffset >= 0 && bits[bitsOffset] === 0) {
          bitsOffset--;
        }
        if (bitsOffset < 0) {
          return null;
        }
        const y4 = Math.floor(bitsOffset / rowSize);
        let x3 = Math.floor(bitsOffset % rowSize) * 32;
        const theBits = bits[bitsOffset];
        let bit = 31;
        while (theBits >>> bit === 0) {
          bit--;
        }
        x3 += bit;
        return Int32Array.from([x3, y4]);
      }
      /**
       * @return The width of the matrix
       */
      getWidth() {
        return this.width;
      }
      /**
       * @return The height of the matrix
       */
      getHeight() {
        return this.height;
      }
      /**
       * @return The row size of the matrix
       */
      getRowSize() {
        return this.rowSize;
      }
      /*@Override*/
      equals(o2) {
        if (!(o2 instanceof BitMatrix)) {
          return false;
        }
        const other = o2;
        return this.width === other.width && this.height === other.height && this.rowSize === other.rowSize && Arrays.equals(this.bits, other.bits);
      }
      /*@Override*/
      hashCode() {
        let hash = this.width;
        hash = 31 * hash + this.width;
        hash = 31 * hash + this.height;
        hash = 31 * hash + this.rowSize;
        hash = 31 * hash + Arrays.hashCode(this.bits);
        return hash;
      }
      /**
       * @return string representation using "X" for set and " " for unset bits
       */
      /*@Override*/
      // public toString(): string {
      //   return toString(": "X, "  ")
      // }
      /**
       * @param setString representation of a set bit
       * @param unsetString representation of an unset bit
       * @return string representation of entire matrix utilizing given strings
       */
      // public toString(setString: string = "X ", unsetString: string = "  "): string {
      //   return this.buildToString(setString, unsetString, "\n")
      // }
      /**
       * @param setString representation of a set bit
       * @param unsetString representation of an unset bit
       * @param lineSeparator newline character in string representation
       * @return string representation of entire matrix utilizing given strings and line separator
       * @deprecated call {@link #toString(String,String)} only, which uses \n line separator always
       */
      // @Deprecated
      toString(setString = "X ", unsetString = "  ", lineSeparator = "\n") {
        return this.buildToString(setString, unsetString, lineSeparator);
      }
      buildToString(setString, unsetString, lineSeparator) {
        let result = new StringBuilder();
        for (let y4 = 0, height = this.height; y4 < height; y4++) {
          for (let x3 = 0, width = this.width; x3 < width; x3++) {
            result.append(this.get(x3, y4) ? setString : unsetString);
          }
          result.append(lineSeparator);
        }
        return result.toString();
      }
      /*@Override*/
      clone() {
        return new BitMatrix(this.width, this.height, this.rowSize, this.bits.slice());
      }
    }
    class NotFoundException extends Exception {
      static getNotFoundInstance() {
        return new NotFoundException();
      }
    }
    NotFoundException.kind = "NotFoundException";
    class GlobalHistogramBinarizer extends Binarizer {
      constructor(source) {
        super(source);
        this.luminances = GlobalHistogramBinarizer.EMPTY;
        this.buckets = new Int32Array(GlobalHistogramBinarizer.LUMINANCE_BUCKETS);
      }
      // Applies simple sharpening to the row data to improve performance of the 1D Readers.
      /*@Override*/
      getBlackRow(y4, row) {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        if (row === void 0 || row === null || row.getSize() < width) {
          row = new BitArray(width);
        } else {
          row.clear();
        }
        this.initArrays(width);
        const localLuminances = source.getRow(y4, this.luminances);
        const localBuckets = this.buckets;
        for (let x3 = 0; x3 < width; x3++) {
          localBuckets[(localLuminances[x3] & 255) >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        if (width < 3) {
          for (let x3 = 0; x3 < width; x3++) {
            if ((localLuminances[x3] & 255) < blackPoint) {
              row.set(x3);
            }
          }
        } else {
          let left = localLuminances[0] & 255;
          let center = localLuminances[1] & 255;
          for (let x3 = 1; x3 < width - 1; x3++) {
            const right = localLuminances[x3 + 1] & 255;
            if ((center * 4 - left - right) / 2 < blackPoint) {
              row.set(x3);
            }
            left = center;
            center = right;
          }
        }
        return row;
      }
      // Does not sharpen the data, as this call is intended to only be used by 2D Readers.
      /*@Override*/
      getBlackMatrix() {
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        const matrix = new BitMatrix(width, height);
        this.initArrays(width);
        const localBuckets = this.buckets;
        for (let y4 = 1; y4 < 5; y4++) {
          const row = Math.floor(height * y4 / 5);
          const localLuminances2 = source.getRow(row, this.luminances);
          const right = Math.floor(width * 4 / 5);
          for (let x3 = Math.floor(width / 5); x3 < right; x3++) {
            const pixel = localLuminances2[x3] & 255;
            localBuckets[pixel >> GlobalHistogramBinarizer.LUMINANCE_SHIFT]++;
          }
        }
        const blackPoint = GlobalHistogramBinarizer.estimateBlackPoint(localBuckets);
        const localLuminances = source.getMatrix();
        for (let y4 = 0; y4 < height; y4++) {
          const offset2 = y4 * width;
          for (let x3 = 0; x3 < width; x3++) {
            const pixel = localLuminances[offset2 + x3] & 255;
            if (pixel < blackPoint) {
              matrix.set(x3, y4);
            }
          }
        }
        return matrix;
      }
      /*@Override*/
      createBinarizer(source) {
        return new GlobalHistogramBinarizer(source);
      }
      initArrays(luminanceSize) {
        if (this.luminances.length < luminanceSize) {
          this.luminances = new Uint8ClampedArray(luminanceSize);
        }
        const buckets = this.buckets;
        for (let x3 = 0; x3 < GlobalHistogramBinarizer.LUMINANCE_BUCKETS; x3++) {
          buckets[x3] = 0;
        }
      }
      static estimateBlackPoint(buckets) {
        const numBuckets = buckets.length;
        let maxBucketCount = 0;
        let firstPeak = 0;
        let firstPeakSize = 0;
        for (let x3 = 0; x3 < numBuckets; x3++) {
          if (buckets[x3] > firstPeakSize) {
            firstPeak = x3;
            firstPeakSize = buckets[x3];
          }
          if (buckets[x3] > maxBucketCount) {
            maxBucketCount = buckets[x3];
          }
        }
        let secondPeak = 0;
        let secondPeakScore = 0;
        for (let x3 = 0; x3 < numBuckets; x3++) {
          const distanceToBiggest = x3 - firstPeak;
          const score = buckets[x3] * distanceToBiggest * distanceToBiggest;
          if (score > secondPeakScore) {
            secondPeak = x3;
            secondPeakScore = score;
          }
        }
        if (firstPeak > secondPeak) {
          const temp = firstPeak;
          firstPeak = secondPeak;
          secondPeak = temp;
        }
        if (secondPeak - firstPeak <= numBuckets / 16) {
          throw new NotFoundException();
        }
        let bestValley = secondPeak - 1;
        let bestValleyScore = -1;
        for (let x3 = secondPeak - 1; x3 > firstPeak; x3--) {
          const fromFirst = x3 - firstPeak;
          const score = fromFirst * fromFirst * (secondPeak - x3) * (maxBucketCount - buckets[x3]);
          if (score > bestValleyScore) {
            bestValley = x3;
            bestValleyScore = score;
          }
        }
        return bestValley << GlobalHistogramBinarizer.LUMINANCE_SHIFT;
      }
    }
    GlobalHistogramBinarizer.LUMINANCE_BITS = 5;
    GlobalHistogramBinarizer.LUMINANCE_SHIFT = 8 - GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.LUMINANCE_BUCKETS = 1 << GlobalHistogramBinarizer.LUMINANCE_BITS;
    GlobalHistogramBinarizer.EMPTY = Uint8ClampedArray.from([0]);
    class HybridBinarizer extends GlobalHistogramBinarizer {
      constructor(source) {
        super(source);
        this.matrix = null;
      }
      /**
       * Calculates the final BitMatrix once for all requests. This could be called once from the
       * constructor instead, but there are some advantages to doing it lazily, such as making
       * profiling easier, and not doing heavy lifting when callers don't expect it.
       */
      /*@Override*/
      getBlackMatrix() {
        if (this.matrix !== null) {
          return this.matrix;
        }
        const source = this.getLuminanceSource();
        const width = source.getWidth();
        const height = source.getHeight();
        if (width >= HybridBinarizer.MINIMUM_DIMENSION && height >= HybridBinarizer.MINIMUM_DIMENSION) {
          const luminances = source.getMatrix();
          let subWidth = width >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((width & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subWidth++;
          }
          let subHeight = height >> HybridBinarizer.BLOCK_SIZE_POWER;
          if ((height & HybridBinarizer.BLOCK_SIZE_MASK) !== 0) {
            subHeight++;
          }
          const blackPoints = HybridBinarizer.calculateBlackPoints(luminances, subWidth, subHeight, width, height);
          const newMatrix = new BitMatrix(width, height);
          HybridBinarizer.calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, newMatrix);
          this.matrix = newMatrix;
        } else {
          this.matrix = super.getBlackMatrix();
        }
        return this.matrix;
      }
      /*@Override*/
      createBinarizer(source) {
        return new HybridBinarizer(source);
      }
      /**
       * For each block in the image, calculate the average black point using a 5x5 grid
       * of the blocks around it. Also handles the corner cases (fractional blocks are computed based
       * on the last pixels in the row/column which are also used in the previous block).
       */
      static calculateThresholdForBlock(luminances, subWidth, subHeight, width, height, blackPoints, matrix) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        for (let y4 = 0; y4 < subHeight; y4++) {
          let yoffset = y4 << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          const top = HybridBinarizer.cap(y4, 2, subHeight - 3);
          for (let x3 = 0; x3 < subWidth; x3++) {
            let xoffset = x3 << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            const left = HybridBinarizer.cap(x3, 2, subWidth - 3);
            let sum = 0;
            for (let z3 = -2; z3 <= 2; z3++) {
              const blackRow = blackPoints[top + z3];
              sum += blackRow[left - 2] + blackRow[left - 1] + blackRow[left] + blackRow[left + 1] + blackRow[left + 2];
            }
            const average = sum / 25;
            HybridBinarizer.thresholdBlock(luminances, xoffset, yoffset, average, width, matrix);
          }
        }
      }
      static cap(value, min2, max2) {
        return value < min2 ? min2 : value > max2 ? max2 : value;
      }
      /**
       * Applies a single threshold to a block of pixels.
       */
      static thresholdBlock(luminances, xoffset, yoffset, threshold, stride, matrix) {
        for (let y4 = 0, offset2 = yoffset * stride + xoffset; y4 < HybridBinarizer.BLOCK_SIZE; y4++, offset2 += stride) {
          for (let x3 = 0; x3 < HybridBinarizer.BLOCK_SIZE; x3++) {
            if ((luminances[offset2 + x3] & 255) <= threshold) {
              matrix.set(xoffset + x3, yoffset + y4);
            }
          }
        }
      }
      /**
       * Calculates a single black point for each block of pixels and saves it away.
       * See the following thread for a discussion of this algorithm:
       *  http://groups.google.com/group/zxing/browse_thread/thread/d06efa2c35a7ddc0
       */
      static calculateBlackPoints(luminances, subWidth, subHeight, width, height) {
        const maxYOffset = height - HybridBinarizer.BLOCK_SIZE;
        const maxXOffset = width - HybridBinarizer.BLOCK_SIZE;
        const blackPoints = new Array(subHeight);
        for (let y4 = 0; y4 < subHeight; y4++) {
          blackPoints[y4] = new Int32Array(subWidth);
          let yoffset = y4 << HybridBinarizer.BLOCK_SIZE_POWER;
          if (yoffset > maxYOffset) {
            yoffset = maxYOffset;
          }
          for (let x3 = 0; x3 < subWidth; x3++) {
            let xoffset = x3 << HybridBinarizer.BLOCK_SIZE_POWER;
            if (xoffset > maxXOffset) {
              xoffset = maxXOffset;
            }
            let sum = 0;
            let min2 = 255;
            let max2 = 0;
            for (let yy = 0, offset2 = yoffset * width + xoffset; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset2 += width) {
              for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                const pixel = luminances[offset2 + xx] & 255;
                sum += pixel;
                if (pixel < min2) {
                  min2 = pixel;
                }
                if (pixel > max2) {
                  max2 = pixel;
                }
              }
              if (max2 - min2 > HybridBinarizer.MIN_DYNAMIC_RANGE) {
                for (yy++, offset2 += width; yy < HybridBinarizer.BLOCK_SIZE; yy++, offset2 += width) {
                  for (let xx = 0; xx < HybridBinarizer.BLOCK_SIZE; xx++) {
                    sum += luminances[offset2 + xx] & 255;
                  }
                }
              }
            }
            let average = sum >> HybridBinarizer.BLOCK_SIZE_POWER * 2;
            if (max2 - min2 <= HybridBinarizer.MIN_DYNAMIC_RANGE) {
              average = min2 / 2;
              if (y4 > 0 && x3 > 0) {
                const averageNeighborBlackPoint = (blackPoints[y4 - 1][x3] + 2 * blackPoints[y4][x3 - 1] + blackPoints[y4 - 1][x3 - 1]) / 4;
                if (min2 < averageNeighborBlackPoint) {
                  average = averageNeighborBlackPoint;
                }
              }
            }
            blackPoints[y4][x3] = average;
          }
        }
        return blackPoints;
      }
    }
    HybridBinarizer.BLOCK_SIZE_POWER = 3;
    HybridBinarizer.BLOCK_SIZE = 1 << HybridBinarizer.BLOCK_SIZE_POWER;
    HybridBinarizer.BLOCK_SIZE_MASK = HybridBinarizer.BLOCK_SIZE - 1;
    HybridBinarizer.MINIMUM_DIMENSION = HybridBinarizer.BLOCK_SIZE * 5;
    HybridBinarizer.MIN_DYNAMIC_RANGE = 24;
    class LuminanceSource {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      /**
       * @return The width of the bitmap.
       */
      getWidth() {
        return this.width;
      }
      /**
       * @return The height of the bitmap.
       */
      getHeight() {
        return this.height;
      }
      /**
       * @return Whether this subclass supports cropping.
       */
      isCropSupported() {
        return false;
      }
      /**
       * Returns a new object with cropped image data. Implementations may keep a reference to the
       * original data rather than a copy. Only callable if isCropSupported() is true.
       *
       * @param left The left coordinate, which must be in [0,getWidth())
       * @param top The top coordinate, which must be in [0,getHeight())
       * @param width The width of the rectangle to crop.
       * @param height The height of the rectangle to crop.
       * @return A cropped version of this object.
       */
      crop(left, top, width, height) {
        throw new UnsupportedOperationException("This luminance source does not support cropping.");
      }
      /**
       * @return Whether this subclass supports counter-clockwise rotation.
       */
      isRotateSupported() {
        return false;
      }
      /**
       * Returns a new object with rotated image data by 90 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 90 degrees.");
      }
      /**
       * Returns a new object with rotated image data by 45 degrees counterclockwise.
       * Only callable if {@link #isRotateSupported()} is true.
       *
       * @return A rotated version of this object.
       */
      rotateCounterClockwise45() {
        throw new UnsupportedOperationException("This luminance source does not support rotation by 45 degrees.");
      }
      /*@Override*/
      toString() {
        const row = new Uint8ClampedArray(this.width);
        let result = new StringBuilder();
        for (let y4 = 0; y4 < this.height; y4++) {
          const sourceRow = this.getRow(y4, row);
          for (let x3 = 0; x3 < this.width; x3++) {
            const luminance = sourceRow[x3] & 255;
            let c3;
            if (luminance < 64) {
              c3 = "#";
            } else if (luminance < 128) {
              c3 = "+";
            } else if (luminance < 192) {
              c3 = ".";
            } else {
              c3 = " ";
            }
            result.append(c3);
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class InvertedLuminanceSource extends LuminanceSource {
      constructor(delegate) {
        super(delegate.getWidth(), delegate.getHeight());
        this.delegate = delegate;
      }
      /*@Override*/
      getRow(y4, row) {
        const sourceRow = this.delegate.getRow(y4, row);
        const width = this.getWidth();
        for (let i3 = 0; i3 < width; i3++) {
          sourceRow[i3] = /*(byte)*/
          255 - (sourceRow[i3] & 255);
        }
        return sourceRow;
      }
      /*@Override*/
      getMatrix() {
        const matrix = this.delegate.getMatrix();
        const length = this.getWidth() * this.getHeight();
        const invertedMatrix = new Uint8ClampedArray(length);
        for (let i3 = 0; i3 < length; i3++) {
          invertedMatrix[i3] = /*(byte)*/
          255 - (matrix[i3] & 255);
        }
        return invertedMatrix;
      }
      /*@Override*/
      isCropSupported() {
        return this.delegate.isCropSupported();
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new InvertedLuminanceSource(this.delegate.crop(left, top, width, height));
      }
      /*@Override*/
      isRotateSupported() {
        return this.delegate.isRotateSupported();
      }
      /**
       * @return original delegate {@link LuminanceSource} since invert undoes itself
       */
      /*@Override*/
      invert() {
        return this.delegate;
      }
      /*@Override*/
      rotateCounterClockwise() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise());
      }
      /*@Override*/
      rotateCounterClockwise45() {
        return new InvertedLuminanceSource(this.delegate.rotateCounterClockwise45());
      }
    }
    class HTMLCanvasElementLuminanceSource extends LuminanceSource {
      constructor(canvas) {
        super(canvas.width, canvas.height);
        this.canvas = canvas;
        this.tempCanvasElement = null;
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(canvas);
      }
      static makeBufferFromCanvasImageData(canvas) {
        const imageData = canvas.getContext("2d").getImageData(0, 0, canvas.width, canvas.height);
        return HTMLCanvasElementLuminanceSource.toGrayscaleBuffer(imageData.data, canvas.width, canvas.height);
      }
      static toGrayscaleBuffer(imageBuffer, width, height) {
        const grayscaleBuffer = new Uint8ClampedArray(width * height);
        for (let i3 = 0, j2 = 0, length = imageBuffer.length; i3 < length; i3 += 4, j2++) {
          let gray;
          const alpha = imageBuffer[i3 + 3];
          if (alpha === 0) {
            gray = 255;
          } else {
            const pixelR = imageBuffer[i3];
            const pixelG = imageBuffer[i3 + 1];
            const pixelB = imageBuffer[i3 + 2];
            gray = 306 * pixelR + 601 * pixelG + 117 * pixelB + 512 >> 10;
          }
          grayscaleBuffer[j2] = gray;
        }
        return grayscaleBuffer;
      }
      getRow(y4, row) {
        if (y4 < 0 || y4 >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y4);
        }
        const width = this.getWidth();
        const start = y4 * width;
        if (row === null) {
          row = this.buffer.slice(start, start + width);
        } else {
          if (row.length < width) {
            row = new Uint8ClampedArray(width);
          }
          row.set(this.buffer.slice(start, start + width));
        }
        return row;
      }
      getMatrix() {
        return this.buffer;
      }
      isCropSupported() {
        return true;
      }
      crop(left, top, width, height) {
        super.crop(left, top, width, height);
        return this;
      }
      /**
       * This is always true, since the image is a gray-scale image.
       *
       * @return true
       */
      isRotateSupported() {
        return true;
      }
      rotateCounterClockwise() {
        this.rotate(-90);
        return this;
      }
      rotateCounterClockwise45() {
        this.rotate(-45);
        return this;
      }
      getTempCanvasElement() {
        if (null === this.tempCanvasElement) {
          const tempCanvasElement = this.canvas.ownerDocument.createElement("canvas");
          tempCanvasElement.width = this.canvas.width;
          tempCanvasElement.height = this.canvas.height;
          this.tempCanvasElement = tempCanvasElement;
        }
        return this.tempCanvasElement;
      }
      rotate(angle) {
        const tempCanvasElement = this.getTempCanvasElement();
        const tempContext = tempCanvasElement.getContext("2d");
        const angleRadians = angle * HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS;
        const width = this.canvas.width;
        const height = this.canvas.height;
        const newWidth = Math.ceil(Math.abs(Math.cos(angleRadians)) * width + Math.abs(Math.sin(angleRadians)) * height);
        const newHeight = Math.ceil(Math.abs(Math.sin(angleRadians)) * width + Math.abs(Math.cos(angleRadians)) * height);
        tempCanvasElement.width = newWidth;
        tempCanvasElement.height = newHeight;
        tempContext.translate(newWidth / 2, newHeight / 2);
        tempContext.rotate(angleRadians);
        tempContext.drawImage(this.canvas, width / -2, height / -2);
        this.buffer = HTMLCanvasElementLuminanceSource.makeBufferFromCanvasImageData(tempCanvasElement);
        return this;
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    HTMLCanvasElementLuminanceSource.DEGREE_TO_RADIANS = Math.PI / 180;
    class VideoInputDevice {
      /**
       * Creates an instance of VideoInputDevice.
       *
       * @param {string} deviceId the video input device id
       * @param {string} label the label of the device if available
       */
      constructor(deviceId, label, groupId) {
        this.deviceId = deviceId;
        this.label = label;
        this.kind = "videoinput";
        this.groupId = groupId || void 0;
      }
      /** @inheritdoc */
      toJSON() {
        return {
          kind: this.kind,
          groupId: this.groupId,
          deviceId: this.deviceId,
          label: this.label
        };
      }
    }
    var __awaiter2 = (globalThis || commonjsGlobal || self || window || void 0) && (globalThis || commonjsGlobal || self || window || void 0).__awaiter || function(thisArg, _arguments, P2, generator) {
      function adopt(value) {
        return value instanceof P2 ? value : new P2(function(resolve) {
          resolve(value);
        });
      }
      return new (P2 || (P2 = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    class BrowserCodeReader {
      /**
       * Creates an instance of BrowserCodeReader.
       * @param {Reader} reader The reader instance to decode the barcode
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent successful decode tries
       *
       * @memberOf BrowserCodeReader
       */
      constructor(reader, timeBetweenScansMillis = 500, _hints) {
        this.reader = reader;
        this.timeBetweenScansMillis = timeBetweenScansMillis;
        this._hints = _hints;
        this._stopContinuousDecode = false;
        this._stopAsyncDecode = false;
        this._timeBetweenDecodingAttempts = 0;
      }
      /**
       * If navigator is present.
       */
      get hasNavigator() {
        return typeof navigator !== "undefined";
      }
      /**
       * If mediaDevices under navigator is supported.
       */
      get isMediaDevicesSuported() {
        return this.hasNavigator && !!navigator.mediaDevices;
      }
      /**
       * If enumerateDevices under navigator is supported.
       */
      get canEnumerateDevices() {
        return !!(this.isMediaDevicesSuported && navigator.mediaDevices.enumerateDevices);
      }
      /** Time between two decoding tries in milli seconds. */
      get timeBetweenDecodingAttempts() {
        return this._timeBetweenDecodingAttempts;
      }
      /**
       * Change the time span the decoder waits between two decoding tries.
       *
       * @param {number} millis Time between two decoding tries in milli seconds.
       */
      set timeBetweenDecodingAttempts(millis) {
        this._timeBetweenDecodingAttempts = millis < 0 ? 0 : millis;
      }
      /**
       * Sets the hints.
       */
      set hints(hints) {
        this._hints = hints || null;
      }
      /**
       * Sets the hints.
       */
      get hints() {
        return this._hints;
      }
      /**
       * Lists all the available video input devices.
       */
      listVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this.hasNavigator) {
            throw new Error("Can't enumerate devices, navigator is not present.");
          }
          if (!this.canEnumerateDevices) {
            throw new Error("Can't enumerate devices, method not supported.");
          }
          const devices = yield navigator.mediaDevices.enumerateDevices();
          const videoDevices = [];
          for (const device of devices) {
            const kind = device.kind === "video" ? "videoinput" : device.kind;
            if (kind !== "videoinput") {
              continue;
            }
            const deviceId = device.deviceId || device.id;
            const label = device.label || `Video device ${videoDevices.length + 1}`;
            const groupId = device.groupId;
            const videoDevice = { deviceId, label, kind, groupId };
            videoDevices.push(videoDevice);
          }
          return videoDevices;
        });
      }
      /**
       * Obtain the list of available devices with type 'videoinput'.
       *
       * @returns {Promise<VideoInputDevice[]>} an array of available video input devices
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `listVideoInputDevices` instead.
       */
      getVideoInputDevices() {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          return devices.map((d4) => new VideoInputDevice(d4.deviceId, d4.label));
        });
      }
      /**
       * Let's you find a device using it's Id.
       */
      findDeviceById(deviceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          const devices = yield this.listVideoInputDevices();
          if (!devices) {
            return null;
          }
          return devices.find((x3) => x3.deviceId === deviceId);
        });
      }
      /**
       * Decodes the barcode from the device specified by deviceId while showing the video in the specified video element.
       *
       * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `decodeOnceFromVideoDevice` instead.
       */
      decodeFromInputVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeOnceFromVideoDevice(deviceId, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from the device specified by deviceId while showing the video in the specified video element.
       *
       * @param deviceId the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromVideoDevice(deviceId, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeOnceFromConstraints(constraints, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param constraints the media stream constraints to get s valid media stream to decode from
       * @param video the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromConstraints(constraints, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeOnceFromStream(stream, videoSource);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeOnceFromStream(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          const result = yield this.decodeOnce(video);
          return result;
        });
      }
      /**
       * Continuously decodes the barcode from the device specified by device while showing the video in the specified video element.
       *
       * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<void>}
       *
       * @memberOf BrowserCodeReader
       *
       * @deprecated Use `decodeFromVideoDevice` instead.
       */
      decodeFromInputVideoDeviceContinuously(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          return yield this.decodeFromVideoDevice(deviceId, videoSource, callbackFn);
        });
      }
      /**
       * Continuously tries to decode the barcode from the device specified by device while showing the video in the specified video element.
       *
       * @param {string|null} [deviceId] the id of one of the devices obtained after calling getVideoInputDevices. Can be undefined, in this case it will decode from one of the available devices, preffering the main camera (environment facing) if available.
       * @param {string|HTMLVideoElement|null} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<void>}
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromVideoDevice(deviceId, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          let videoConstraints;
          if (!deviceId) {
            videoConstraints = { facingMode: "environment" };
          } else {
            videoConstraints = { deviceId: { exact: deviceId } };
          }
          const constraints = { video: videoConstraints };
          return yield this.decodeFromConstraints(constraints, videoSource, callbackFn);
        });
      }
      /**
       * Continuously tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromConstraints(constraints, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          const stream = yield navigator.mediaDevices.getUserMedia(constraints);
          return yield this.decodeFromStream(stream, videoSource, callbackFn);
        });
      }
      /**
       * In one attempt, tries to decode the barcode from a stream obtained from the given constraints while showing the video in the specified video element.
       *
       * @param {MediaStream} [constraints] the media stream constraints to get s valid media stream to decode from
       * @param {string|HTMLVideoElement} [video] the video element in page where to show the video while decoding. Can be either an element id or directly an HTMLVideoElement. Can be undefined, in which case no video will be shown.
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromStream(stream, videoSource, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          this.reset();
          const video = yield this.attachStreamToVideo(stream, videoSource);
          return yield this.decodeContinuously(video, callbackFn);
        });
      }
      /**
       * Breaks the decoding loop.
       */
      stopAsyncDecode() {
        this._stopAsyncDecode = true;
      }
      /**
       * Breaks the decoding loop.
       */
      stopContinuousDecode() {
        this._stopContinuousDecode = true;
      }
      /**
       * Sets the new stream and request a new decoding-with-delay.
       *
       * @param stream The stream to be shown in the video element.
       * @param decodeFn A callback for the decode method.
       */
      attachStreamToVideo(stream, videoSource) {
        return __awaiter2(this, void 0, void 0, function* () {
          const videoElement = this.prepareVideoElement(videoSource);
          this.addVideoSource(videoElement, stream);
          this.videoElement = videoElement;
          this.stream = stream;
          yield this.playVideoOnLoadAsync(videoElement);
          return videoElement;
        });
      }
      /**
       *
       * @param videoElement
       */
      playVideoOnLoadAsync(videoElement) {
        return new Promise((resolve, reject) => this.playVideoOnLoad(videoElement, () => resolve()));
      }
      /**
       * Binds listeners and callbacks to the videoElement.
       *
       * @param element
       * @param callbackFn
       */
      playVideoOnLoad(element, callbackFn) {
        this.videoEndedListener = () => this.stopStreams();
        this.videoCanPlayListener = () => this.tryPlayVideo(element);
        element.addEventListener("ended", this.videoEndedListener);
        element.addEventListener("canplay", this.videoCanPlayListener);
        element.addEventListener("playing", callbackFn);
        this.tryPlayVideo(element);
      }
      /**
       * Checks if the given video element is currently playing.
       */
      isVideoPlaying(video) {
        return video.currentTime > 0 && !video.paused && !video.ended && video.readyState > 2;
      }
      /**
       * Just tries to play the video and logs any errors.
       * The play call is only made is the video is not already playing.
       */
      tryPlayVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this.isVideoPlaying(videoElement)) {
            console.warn("Trying to play video that is already playing.");
            return;
          }
          try {
            yield videoElement.play();
          } catch (_a) {
            console.warn("It was not possible to play the video.");
          }
        });
      }
      /**
       * Searches and validates a media element.
       */
      getMediaElement(mediaElementId, type) {
        const mediaElement = document.getElementById(mediaElementId);
        if (!mediaElement) {
          throw new ArgumentException(`element with id '${mediaElementId}' not found`);
        }
        if (mediaElement.nodeName.toLowerCase() !== type.toLowerCase()) {
          throw new ArgumentException(`element with id '${mediaElementId}' must be an ${type} element`);
        }
        return mediaElement;
      }
      /**
       * Decodes the barcode from an image.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromImage(source, url2) {
        if (!source && !url2) {
          throw new ArgumentException("either imageElement with a src set or an url must be provided");
        }
        if (url2 && !source) {
          return this.decodeFromImageUrl(url2);
        }
        return this.decodeFromImageElement(source);
      }
      /**
       * Decodes the barcode from a video.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       */
      decodeFromVideo(source, url2) {
        if (!source && !url2) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url2 && !source) {
          return this.decodeFromVideoUrl(url2);
        }
        return this.decodeFromVideoElement(source);
      }
      /**
       * Decodes continuously the barcode from a video.
       *
       * @param {(string|HTMLImageElement)} [source] The image element that can be either an element id or the element itself. Can be undefined in which case the decoding will be done from the imageUrl parameter.
       * @param {string} [url]
       * @returns {Promise<Result>} The decoding result.
       *
       * @memberOf BrowserCodeReader
       *
       * @experimental
       */
      decodeFromVideoContinuously(source, url2, callbackFn) {
        if (void 0 === source && void 0 === url2) {
          throw new ArgumentException("Either an element with a src set or an URL must be provided");
        }
        if (url2 && !source) {
          return this.decodeFromVideoUrlContinuously(url2, callbackFn);
        }
        return this.decodeFromVideoElementContinuously(source, callbackFn);
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromImageElement(source) {
        if (!source) {
          throw new ArgumentException("An image element must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement(source);
        this.imageElement = element;
        let task;
        if (this.isImageLoaded(element)) {
          task = this.decodeOnce(element, false, true);
        } else {
          task = this._decodeOnLoadImage(element);
        }
        return task;
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromVideoElement(source) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideo(element);
      }
      /**
       * Decodes something from an image HTML element.
       */
      decodeFromVideoElementContinuously(source, callbackFn) {
        const element = this._decodeFromVideoElementSetup(source);
        return this._decodeOnLoadVideoContinuously(element, callbackFn);
      }
      /**
       * Sets up the video source so it can be decoded when loaded.
       *
       * @param source The video source element.
       */
      _decodeFromVideoElementSetup(source) {
        if (!source) {
          throw new ArgumentException("A video element must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement(source);
        this.videoElement = element;
        return element;
      }
      /**
       * Decodes an image from a URL.
       */
      decodeFromImageUrl(url2) {
        if (!url2) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareImageElement();
        this.imageElement = element;
        const decodeTask = this._decodeOnLoadImage(element);
        element.src = url2;
        return decodeTask;
      }
      /**
       * Decodes an image from a URL.
       */
      decodeFromVideoUrl(url2) {
        if (!url2) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElement(element);
        element.src = url2;
        return decodeTask;
      }
      /**
       * Decodes an image from a URL.
       *
       * @experimental
       */
      decodeFromVideoUrlContinuously(url2, callbackFn) {
        if (!url2) {
          throw new ArgumentException("An URL must be provided.");
        }
        this.reset();
        const element = this.prepareVideoElement();
        const decodeTask = this.decodeFromVideoElementContinuously(element, callbackFn);
        element.src = url2;
        return decodeTask;
      }
      _decodeOnLoadImage(element) {
        return new Promise((resolve, reject) => {
          this.imageLoadedListener = () => this.decodeOnce(element, false, true).then(resolve, reject);
          element.addEventListener("load", this.imageLoadedListener);
        });
      }
      _decodeOnLoadVideo(videoElement) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          return yield this.decodeOnce(videoElement);
        });
      }
      _decodeOnLoadVideoContinuously(videoElement, callbackFn) {
        return __awaiter2(this, void 0, void 0, function* () {
          yield this.playVideoOnLoadAsync(videoElement);
          this.decodeContinuously(videoElement, callbackFn);
        });
      }
      isImageLoaded(img) {
        if (!img.complete) {
          return false;
        }
        if (img.naturalWidth === 0) {
          return false;
        }
        return true;
      }
      prepareImageElement(imageSource) {
        let imageElement;
        if (typeof imageSource === "undefined") {
          imageElement = document.createElement("img");
          imageElement.width = 200;
          imageElement.height = 200;
        }
        if (typeof imageSource === "string") {
          imageElement = this.getMediaElement(imageSource, "img");
        }
        if (imageSource instanceof HTMLImageElement) {
          imageElement = imageSource;
        }
        return imageElement;
      }
      /**
       * Sets a HTMLVideoElement for scanning or creates a new one.
       *
       * @param videoSource The HTMLVideoElement to be set.
       */
      prepareVideoElement(videoSource) {
        let videoElement;
        if (!videoSource && typeof document !== "undefined") {
          videoElement = document.createElement("video");
          videoElement.width = 200;
          videoElement.height = 200;
        }
        if (typeof videoSource === "string") {
          videoElement = this.getMediaElement(videoSource, "video");
        }
        if (videoSource instanceof HTMLVideoElement) {
          videoElement = videoSource;
        }
        videoElement.setAttribute("autoplay", "true");
        videoElement.setAttribute("muted", "true");
        videoElement.setAttribute("playsinline", "true");
        return videoElement;
      }
      /**
       * Tries to decode from the video input until it finds some value.
       */
      decodeOnce(element, retryIfNotFound = true, retryIfChecksumOrFormatError = true) {
        this._stopAsyncDecode = false;
        const loop = (resolve, reject) => {
          if (this._stopAsyncDecode) {
            reject(new NotFoundException("Video stream has ended before any code could be detected."));
            this._stopAsyncDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            resolve(result);
          } catch (e3) {
            const ifNotFound = retryIfNotFound && e3 instanceof NotFoundException;
            const isChecksumOrFormatError = e3 instanceof ChecksumException || e3 instanceof FormatException;
            const ifChecksumOrFormat = isChecksumOrFormatError && retryIfChecksumOrFormatError;
            if (ifNotFound || ifChecksumOrFormat) {
              return setTimeout(loop, this._timeBetweenDecodingAttempts, resolve, reject);
            }
            reject(e3);
          }
        };
        return new Promise((resolve, reject) => loop(resolve, reject));
      }
      /**
       * Continuously decodes from video input.
       */
      decodeContinuously(element, callbackFn) {
        this._stopContinuousDecode = false;
        const loop = () => {
          if (this._stopContinuousDecode) {
            this._stopContinuousDecode = void 0;
            return;
          }
          try {
            const result = this.decode(element);
            callbackFn(result, null);
            setTimeout(loop, this.timeBetweenScansMillis);
          } catch (e3) {
            callbackFn(null, e3);
            const isChecksumOrFormatError = e3 instanceof ChecksumException || e3 instanceof FormatException;
            const isNotFound = e3 instanceof NotFoundException;
            if (isChecksumOrFormatError || isNotFound) {
              setTimeout(loop, this._timeBetweenDecodingAttempts);
            }
          }
        };
        loop();
      }
      /**
       * Gets the BinaryBitmap for ya! (and decodes it)
       */
      decode(element) {
        const binaryBitmap = this.createBinaryBitmap(element);
        return this.decodeBitmap(binaryBitmap);
      }
      /**
       * Returns true if media element is indeed a {@link HtmlVideoElement}.
       */
      _isHTMLVideoElement(mediaElement) {
        const potentialVideo = mediaElement;
        return potentialVideo.videoWidth !== 0;
      }
      /**
       * Overwriting this allows you to manipulate the next frame in anyway
       * you want before decode.
       */
      drawFrameOnCanvas(srcElement, dimensions, canvasElementContext) {
        if (!dimensions) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.videoWidth,
            sHeight: srcElement.videoHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.videoWidth,
            dHeight: srcElement.videoHeight
          };
        }
        if (!canvasElementContext) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(
          srcElement,
          dimensions.sx,
          dimensions.sy,
          dimensions.sWidth,
          dimensions.sHeight,
          dimensions.dx,
          dimensions.dy,
          dimensions.dWidth,
          dimensions.dHeight
        );
      }
      /**
       * Ovewriting this allows you to manipulate the snapshot image in anyway
       *  you want before decode.
       */
      drawImageOnCanvas(srcElement, dimensions, canvasElementContext = this.captureCanvasContext) {
        if (!dimensions) {
          dimensions = {
            sx: 0,
            sy: 0,
            sWidth: srcElement.naturalWidth,
            sHeight: srcElement.naturalHeight,
            dx: 0,
            dy: 0,
            dWidth: srcElement.naturalWidth,
            dHeight: srcElement.naturalHeight
          };
        }
        if (!canvasElementContext) {
          canvasElementContext = this.captureCanvasContext;
        }
        canvasElementContext.drawImage(
          srcElement,
          dimensions.sx,
          dimensions.sy,
          dimensions.sWidth,
          dimensions.sHeight,
          dimensions.dx,
          dimensions.dy,
          dimensions.dWidth,
          dimensions.dHeight
        );
      }
      /**
       * Creates a binaryBitmap based in some image source.
       *
       * @param mediaElement HTML element containing drawable image source.
       */
      createBinaryBitmap(mediaElement) {
        this.getCaptureCanvasContext(mediaElement);
        if (this._isHTMLVideoElement(mediaElement)) {
          this.drawFrameOnCanvas(mediaElement);
        } else {
          this.drawImageOnCanvas(mediaElement);
        }
        const canvas = this.getCaptureCanvas(mediaElement);
        const luminanceSource = new HTMLCanvasElementLuminanceSource(canvas);
        const hybridBinarizer = new HybridBinarizer(luminanceSource);
        return new BinaryBitmap(hybridBinarizer);
      }
      getCaptureCanvasContext(mediaElement) {
        if (!this.captureCanvasContext) {
          const elem = this.getCaptureCanvas(mediaElement);
          const ctx = elem.getContext("2d");
          this.captureCanvasContext = ctx;
        }
        return this.captureCanvasContext;
      }
      getCaptureCanvas(mediaElement) {
        if (!this.captureCanvas) {
          const elem = this.createCaptureCanvas(mediaElement);
          this.captureCanvas = elem;
        }
        return this.captureCanvas;
      }
      /**
       * Call the encapsulated readers decode
       */
      decodeBitmap(binaryBitmap) {
        return this.reader.decode(binaryBitmap, this._hints);
      }
      /**
       * 🖌 Prepares the canvas for capture and scan frames.
       */
      createCaptureCanvas(mediaElement) {
        if (typeof document === "undefined") {
          this._destroyCaptureCanvas();
          return null;
        }
        const canvasElement = document.createElement("canvas");
        let width;
        let height;
        if (typeof mediaElement !== "undefined") {
          if (mediaElement instanceof HTMLVideoElement) {
            width = mediaElement.videoWidth;
            height = mediaElement.videoHeight;
          } else if (mediaElement instanceof HTMLImageElement) {
            width = mediaElement.naturalWidth || mediaElement.width;
            height = mediaElement.naturalHeight || mediaElement.height;
          }
        }
        canvasElement.style.width = width + "px";
        canvasElement.style.height = height + "px";
        canvasElement.width = width;
        canvasElement.height = height;
        return canvasElement;
      }
      /**
       * Stops the continuous scan and cleans the stream.
       */
      stopStreams() {
        if (this.stream) {
          this.stream.getVideoTracks().forEach((t3) => t3.stop());
          this.stream = void 0;
        }
        if (this._stopAsyncDecode === false) {
          this.stopAsyncDecode();
        }
        if (this._stopContinuousDecode === false) {
          this.stopContinuousDecode();
        }
      }
      /**
       * Resets the code reader to the initial state. Cancels any ongoing barcode scanning from video or camera.
       *
       * @memberOf BrowserCodeReader
       */
      reset() {
        this.stopStreams();
        this._destroyVideoElement();
        this._destroyImageElement();
        this._destroyCaptureCanvas();
      }
      _destroyVideoElement() {
        if (!this.videoElement) {
          return;
        }
        if (typeof this.videoEndedListener !== "undefined") {
          this.videoElement.removeEventListener("ended", this.videoEndedListener);
        }
        if (typeof this.videoPlayingEventListener !== "undefined") {
          this.videoElement.removeEventListener("playing", this.videoPlayingEventListener);
        }
        if (typeof this.videoCanPlayListener !== "undefined") {
          this.videoElement.removeEventListener("loadedmetadata", this.videoCanPlayListener);
        }
        this.cleanVideoSource(this.videoElement);
        this.videoElement = void 0;
      }
      _destroyImageElement() {
        if (!this.imageElement) {
          return;
        }
        if (void 0 !== this.imageLoadedListener) {
          this.imageElement.removeEventListener("load", this.imageLoadedListener);
        }
        this.imageElement.src = void 0;
        this.imageElement.removeAttribute("src");
        this.imageElement = void 0;
      }
      /**
       * Cleans canvas references 🖌
       */
      _destroyCaptureCanvas() {
        this.captureCanvasContext = void 0;
        this.captureCanvas = void 0;
      }
      /**
       * Defines what the videoElement src will be.
       *
       * @param videoElement
       * @param stream
       */
      addVideoSource(videoElement, stream) {
        try {
          videoElement.srcObject = stream;
        } catch (err) {
          videoElement.src = URL.createObjectURL(stream);
        }
      }
      /**
       * Unbinds a HTML video src property.
       *
       * @param videoElement
       */
      cleanVideoSource(videoElement) {
        try {
          videoElement.srcObject = null;
        } catch (err) {
          videoElement.src = "";
        }
        this.videoElement.removeAttribute("src");
      }
    }
    class Result {
      // public constructor(private text: string,
      //               Uint8Array rawBytes,
      //               ResultPoconst resultPoints: Int32Array,
      //               BarcodeFormat format) {
      //   this(text, rawBytes, resultPoints, format, System.currentTimeMillis())
      // }
      // public constructor(text: string,
      //               Uint8Array rawBytes,
      //               ResultPoconst resultPoints: Int32Array,
      //               BarcodeFormat format,
      //               long timestamp) {
      //   this(text, rawBytes, rawBytes == null ? 0 : 8 * rawBytes.length,
      //        resultPoints, format, timestamp)
      // }
      constructor(text, rawBytes, numBits = rawBytes == null ? 0 : 8 * rawBytes.length, resultPoints, format2, timestamp = System.currentTimeMillis()) {
        this.text = text;
        this.rawBytes = rawBytes;
        this.numBits = numBits;
        this.resultPoints = resultPoints;
        this.format = format2;
        this.timestamp = timestamp;
        this.text = text;
        this.rawBytes = rawBytes;
        if (void 0 === numBits || null === numBits) {
          this.numBits = rawBytes === null || rawBytes === void 0 ? 0 : 8 * rawBytes.length;
        } else {
          this.numBits = numBits;
        }
        this.resultPoints = resultPoints;
        this.format = format2;
        this.resultMetadata = null;
        if (void 0 === timestamp || null === timestamp) {
          this.timestamp = System.currentTimeMillis();
        } else {
          this.timestamp = timestamp;
        }
      }
      /**
       * @return raw text encoded by the barcode
       */
      getText() {
        return this.text;
      }
      /**
       * @return raw bytes encoded by the barcode, if applicable, otherwise {@code null}
       */
      getRawBytes() {
        return this.rawBytes;
      }
      /**
       * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
       * @since 3.3.0
       */
      getNumBits() {
        return this.numBits;
      }
      /**
       * @return points related to the barcode in the image. These are typically points
       *         identifying finder patterns or the corners of the barcode. The exact meaning is
       *         specific to the type of barcode that was decoded.
       */
      getResultPoints() {
        return this.resultPoints;
      }
      /**
       * @return {@link BarcodeFormat} representing the format of the barcode that was decoded
       */
      getBarcodeFormat() {
        return this.format;
      }
      /**
       * @return {@link Map} mapping {@link ResultMetadataType} keys to values. May be
       *   {@code null}. This contains optional metadata about what was detected about the barcode,
       *   like orientation.
       */
      getResultMetadata() {
        return this.resultMetadata;
      }
      putMetadata(type, value) {
        if (this.resultMetadata === null) {
          this.resultMetadata = /* @__PURE__ */ new Map();
        }
        this.resultMetadata.set(type, value);
      }
      putAllMetadata(metadata) {
        if (metadata !== null) {
          if (this.resultMetadata === null) {
            this.resultMetadata = metadata;
          } else {
            this.resultMetadata = new Map(metadata);
          }
        }
      }
      addResultPoints(newPoints) {
        const oldPoints = this.resultPoints;
        if (oldPoints === null) {
          this.resultPoints = newPoints;
        } else if (newPoints !== null && newPoints.length > 0) {
          const allPoints = new Array(oldPoints.length + newPoints.length);
          System.arraycopy(oldPoints, 0, allPoints, 0, oldPoints.length);
          System.arraycopy(newPoints, 0, allPoints, oldPoints.length, newPoints.length);
          this.resultPoints = allPoints;
        }
      }
      getTimestamp() {
        return this.timestamp;
      }
      /*@Override*/
      toString() {
        return this.text;
      }
    }
    var BarcodeFormat;
    (function(BarcodeFormat2) {
      BarcodeFormat2[BarcodeFormat2["AZTEC"] = 0] = "AZTEC";
      BarcodeFormat2[BarcodeFormat2["CODABAR"] = 1] = "CODABAR";
      BarcodeFormat2[BarcodeFormat2["CODE_39"] = 2] = "CODE_39";
      BarcodeFormat2[BarcodeFormat2["CODE_93"] = 3] = "CODE_93";
      BarcodeFormat2[BarcodeFormat2["CODE_128"] = 4] = "CODE_128";
      BarcodeFormat2[BarcodeFormat2["DATA_MATRIX"] = 5] = "DATA_MATRIX";
      BarcodeFormat2[BarcodeFormat2["EAN_8"] = 6] = "EAN_8";
      BarcodeFormat2[BarcodeFormat2["EAN_13"] = 7] = "EAN_13";
      BarcodeFormat2[BarcodeFormat2["ITF"] = 8] = "ITF";
      BarcodeFormat2[BarcodeFormat2["MAXICODE"] = 9] = "MAXICODE";
      BarcodeFormat2[BarcodeFormat2["PDF_417"] = 10] = "PDF_417";
      BarcodeFormat2[BarcodeFormat2["QR_CODE"] = 11] = "QR_CODE";
      BarcodeFormat2[BarcodeFormat2["RSS_14"] = 12] = "RSS_14";
      BarcodeFormat2[BarcodeFormat2["RSS_EXPANDED"] = 13] = "RSS_EXPANDED";
      BarcodeFormat2[BarcodeFormat2["UPC_A"] = 14] = "UPC_A";
      BarcodeFormat2[BarcodeFormat2["UPC_E"] = 15] = "UPC_E";
      BarcodeFormat2[BarcodeFormat2["UPC_EAN_EXTENSION"] = 16] = "UPC_EAN_EXTENSION";
    })(BarcodeFormat || (BarcodeFormat = {}));
    var BarcodeFormat$1 = BarcodeFormat;
    var ResultMetadataType;
    (function(ResultMetadataType2) {
      ResultMetadataType2[ResultMetadataType2["OTHER"] = 0] = "OTHER";
      ResultMetadataType2[ResultMetadataType2["ORIENTATION"] = 1] = "ORIENTATION";
      ResultMetadataType2[ResultMetadataType2["BYTE_SEGMENTS"] = 2] = "BYTE_SEGMENTS";
      ResultMetadataType2[ResultMetadataType2["ERROR_CORRECTION_LEVEL"] = 3] = "ERROR_CORRECTION_LEVEL";
      ResultMetadataType2[ResultMetadataType2["ISSUE_NUMBER"] = 4] = "ISSUE_NUMBER";
      ResultMetadataType2[ResultMetadataType2["SUGGESTED_PRICE"] = 5] = "SUGGESTED_PRICE";
      ResultMetadataType2[ResultMetadataType2["POSSIBLE_COUNTRY"] = 6] = "POSSIBLE_COUNTRY";
      ResultMetadataType2[ResultMetadataType2["UPC_EAN_EXTENSION"] = 7] = "UPC_EAN_EXTENSION";
      ResultMetadataType2[ResultMetadataType2["PDF417_EXTRA_METADATA"] = 8] = "PDF417_EXTRA_METADATA";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_SEQUENCE"] = 9] = "STRUCTURED_APPEND_SEQUENCE";
      ResultMetadataType2[ResultMetadataType2["STRUCTURED_APPEND_PARITY"] = 10] = "STRUCTURED_APPEND_PARITY";
    })(ResultMetadataType || (ResultMetadataType = {}));
    var ResultMetadataType$1 = ResultMetadataType;
    class DecoderResult {
      // public constructor(rawBytes: Uint8Array,
      //                      text: string,
      //                      List<Uint8Array> byteSegments,
      //                      String ecLevel) {
      //   this(rawBytes, text, byteSegments, ecLevel, -1, -1)
      // }
      constructor(rawBytes, text, byteSegments, ecLevel, structuredAppendSequenceNumber = -1, structuredAppendParity = -1) {
        this.rawBytes = rawBytes;
        this.text = text;
        this.byteSegments = byteSegments;
        this.ecLevel = ecLevel;
        this.structuredAppendSequenceNumber = structuredAppendSequenceNumber;
        this.structuredAppendParity = structuredAppendParity;
        this.numBits = rawBytes === void 0 || rawBytes === null ? 0 : 8 * rawBytes.length;
      }
      /**
       * @return raw bytes representing the result, or {@code null} if not applicable
       */
      getRawBytes() {
        return this.rawBytes;
      }
      /**
       * @return how many bits of {@link #getRawBytes()} are valid; typically 8 times its length
       * @since 3.3.0
       */
      getNumBits() {
        return this.numBits;
      }
      /**
       * @param numBits overrides the number of bits that are valid in {@link #getRawBytes()}
       * @since 3.3.0
       */
      setNumBits(numBits) {
        this.numBits = numBits;
      }
      /**
       * @return text representation of the result
       */
      getText() {
        return this.text;
      }
      /**
       * @return list of byte segments in the result, or {@code null} if not applicable
       */
      getByteSegments() {
        return this.byteSegments;
      }
      /**
       * @return name of error correction level used, or {@code null} if not applicable
       */
      getECLevel() {
        return this.ecLevel;
      }
      /**
       * @return number of errors corrected, or {@code null} if not applicable
       */
      getErrorsCorrected() {
        return this.errorsCorrected;
      }
      setErrorsCorrected(errorsCorrected) {
        this.errorsCorrected = errorsCorrected;
      }
      /**
       * @return number of erasures corrected, or {@code null} if not applicable
       */
      getErasures() {
        return this.erasures;
      }
      setErasures(erasures) {
        this.erasures = erasures;
      }
      /**
       * @return arbitrary additional metadata
       */
      getOther() {
        return this.other;
      }
      setOther(other) {
        this.other = other;
      }
      hasStructuredAppend() {
        return this.structuredAppendParity >= 0 && this.structuredAppendSequenceNumber >= 0;
      }
      getStructuredAppendParity() {
        return this.structuredAppendParity;
      }
      getStructuredAppendSequenceNumber() {
        return this.structuredAppendSequenceNumber;
      }
    }
    class AbstractGenericGF {
      /**
       * @return 2 to the power of a in GF(size)
       */
      exp(a4) {
        return this.expTable[a4];
      }
      /**
       * @return base 2 log of a in GF(size)
       */
      log(a4) {
        if (a4 === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a4];
      }
      /**
       * Implements both addition and subtraction -- they are the same in GF(size).
       *
       * @return sum/difference of a and b
       */
      static addOrSubtract(a4, b2) {
        return a4 ^ b2;
      }
    }
    class GenericGFPoly {
      /**
       * @param field the {@link GenericGF} instance representing the field to use
       * to perform computations
       * @param coefficients coefficients as ints representing elements of GF(size), arranged
       * from most significant (highest-power term) coefficient to least significant
       * @throws IllegalArgumentException if argument is null or empty,
       * or if leading coefficient is 0 and this is not a
       * constant polynomial (that is, it is not the monomial "0")
       */
      constructor(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field;
        const coefficientsLength = coefficients.length;
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = 1;
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = Int32Array.from([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      /**
       * @return degree of this polynomial
       */
      getDegree() {
        return this.coefficients.length - 1;
      }
      /**
       * @return true iff this polynomial is the monomial "0"
       */
      isZero() {
        return this.coefficients[0] === 0;
      }
      /**
       * @return coefficient of x^degree term in this polynomial
       */
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      /**
       * @return evaluation of this polynomial at a given point
       */
      evaluateAt(a4) {
        if (a4 === 0) {
          return this.getCoefficient(0);
        }
        const coefficients = this.coefficients;
        let result;
        if (a4 === 1) {
          result = 0;
          for (let i3 = 0, length = coefficients.length; i3 !== length; i3++) {
            const coefficient = coefficients[i3];
            result = AbstractGenericGF.addOrSubtract(result, coefficient);
          }
          return result;
        }
        result = coefficients[0];
        const size2 = coefficients.length;
        const field = this.field;
        for (let i3 = 1; i3 < size2; i3++) {
          result = AbstractGenericGF.addOrSubtract(field.multiply(a4, result), coefficients[i3]);
        }
        return result;
      }
      addOrSubtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          const temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        const lengthDiff = largerCoefficients.length - smallerCoefficients.length;
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i3 = lengthDiff; i3 < largerCoefficients.length; i3++) {
          sumDiff[i3] = AbstractGenericGF.addOrSubtract(smallerCoefficients[i3 - lengthDiff], largerCoefficients[i3]);
        }
        return new GenericGFPoly(this.field, sumDiff);
      }
      multiply(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (this.isZero() || other.isZero()) {
          return this.field.getZero();
        }
        const aCoefficients = this.coefficients;
        const aLength = aCoefficients.length;
        const bCoefficients = other.coefficients;
        const bLength = bCoefficients.length;
        const product = new Int32Array(aLength + bLength - 1);
        const field = this.field;
        for (let i3 = 0; i3 < aLength; i3++) {
          const aCoeff = aCoefficients[i3];
          for (let j2 = 0; j2 < bLength; j2++) {
            product[i3 + j2] = AbstractGenericGF.addOrSubtract(product[i3 + j2], field.multiply(aCoeff, bCoefficients[j2]));
          }
        }
        return new GenericGFPoly(field, product);
      }
      multiplyScalar(scalar) {
        if (scalar === 0) {
          return this.field.getZero();
        }
        if (scalar === 1) {
          return this;
        }
        const size2 = this.coefficients.length;
        const field = this.field;
        const product = new Int32Array(size2);
        const coefficients = this.coefficients;
        for (let i3 = 0; i3 < size2; i3++) {
          product[i3] = field.multiply(coefficients[i3], scalar);
        }
        return new GenericGFPoly(field, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.field.getZero();
        }
        const coefficients = this.coefficients;
        const size2 = coefficients.length;
        const product = new Int32Array(size2 + degree);
        const field = this.field;
        for (let i3 = 0; i3 < size2; i3++) {
          product[i3] = field.multiply(coefficients[i3], coefficient);
        }
        return new GenericGFPoly(field, product);
      }
      divide(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("GenericGFPolys do not have same GenericGF field");
        }
        if (other.isZero()) {
          throw new IllegalArgumentException("Divide by 0");
        }
        const field = this.field;
        let quotient = field.getZero();
        let remainder = this;
        const denominatorLeadingTerm = other.getCoefficient(other.getDegree());
        const inverseDenominatorLeadingTerm = field.inverse(denominatorLeadingTerm);
        while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
          const degreeDifference = remainder.getDegree() - other.getDegree();
          const scale = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
          const term = other.multiplyByMonomial(degreeDifference, scale);
          const iterationQuotient = field.buildMonomial(degreeDifference, scale);
          quotient = quotient.addOrSubtract(iterationQuotient);
          remainder = remainder.addOrSubtract(term);
        }
        return [quotient, remainder];
      }
      /*@Override*/
      toString() {
        let result = "";
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = this.getCoefficient(degree);
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result += " - ";
              coefficient = -coefficient;
            } else {
              if (result.length > 0) {
                result += " + ";
              }
            }
            if (degree === 0 || coefficient !== 1) {
              const alphaPower = this.field.log(coefficient);
              if (alphaPower === 0) {
                result += "1";
              } else if (alphaPower === 1) {
                result += "a";
              } else {
                result += "a^";
                result += alphaPower;
              }
            }
            if (degree !== 0) {
              if (degree === 1) {
                result += "x";
              } else {
                result += "x^";
                result += degree;
              }
            }
          }
        }
        return result;
      }
    }
    class ArithmeticException extends Exception {
    }
    ArithmeticException.kind = "ArithmeticException";
    class GenericGF extends AbstractGenericGF {
      /**
       * Create a representation of GF(size) using the given primitive polynomial.
       *
       * @param primitive irreducible polynomial whose coefficients are represented by
       *  the bits of an int, where the least-significant bit represents the constant
       *  coefficient
       * @param size the size of the field
       * @param b the factor b in the generator polynomial can be 0- or 1-based
       *  (g(x) = (x+a^b)(x+a^(b+1))...(x+a^(b+2t-1))).
       *  In most cases it should be 1, but for QR code it is 0.
       */
      constructor(primitive, size2, generatorBase) {
        super();
        this.primitive = primitive;
        this.size = size2;
        this.generatorBase = generatorBase;
        const expTable = new Int32Array(size2);
        let x3 = 1;
        for (let i3 = 0; i3 < size2; i3++) {
          expTable[i3] = x3;
          x3 *= 2;
          if (x3 >= size2) {
            x3 ^= primitive;
            x3 &= size2 - 1;
          }
        }
        this.expTable = expTable;
        const logTable = new Int32Array(size2);
        for (let i3 = 0; i3 < size2 - 1; i3++) {
          logTable[expTable[i3]] = i3;
        }
        this.logTable = logTable;
        this.zero = new GenericGFPoly(this, Int32Array.from([0]));
        this.one = new GenericGFPoly(this, Int32Array.from([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      /**
       * @return the monomial representing coefficient * x^degree
       */
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        const coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new GenericGFPoly(this, coefficients);
      }
      /**
       * @return multiplicative inverse of a
       */
      inverse(a4) {
        if (a4 === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.size - this.logTable[a4] - 1];
      }
      /**
       * @return product of a and b in GF(size)
       */
      multiply(a4, b2) {
        if (a4 === 0 || b2 === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a4] + this.logTable[b2]) % (this.size - 1)];
      }
      getSize() {
        return this.size;
      }
      getGeneratorBase() {
        return this.generatorBase;
      }
      /*@Override*/
      toString() {
        return "GF(0x" + Integer.toHexString(this.primitive) + "," + this.size + ")";
      }
      equals(o2) {
        return o2 === this;
      }
    }
    GenericGF.AZTEC_DATA_12 = new GenericGF(4201, 4096, 1);
    GenericGF.AZTEC_DATA_10 = new GenericGF(1033, 1024, 1);
    GenericGF.AZTEC_DATA_6 = new GenericGF(67, 64, 1);
    GenericGF.AZTEC_PARAM = new GenericGF(19, 16, 1);
    GenericGF.QR_CODE_FIELD_256 = new GenericGF(285, 256, 0);
    GenericGF.DATA_MATRIX_FIELD_256 = new GenericGF(301, 256, 1);
    GenericGF.AZTEC_DATA_8 = GenericGF.DATA_MATRIX_FIELD_256;
    GenericGF.MAXICODE_FIELD_64 = GenericGF.AZTEC_DATA_6;
    class ReedSolomonException extends Exception {
    }
    ReedSolomonException.kind = "ReedSolomonException";
    class IllegalStateException extends Exception {
    }
    IllegalStateException.kind = "IllegalStateException";
    class ReedSolomonDecoder {
      constructor(field) {
        this.field = field;
      }
      /**
       * <p>Decodes given set of received codewords, which include both data and error-correction
       * codewords. Really, this means it uses Reed-Solomon to detect and correct errors, in-place,
       * in the input.</p>
       *
       * @param received data and error-correction codewords
       * @param twoS number of error-correction codewords available
       * @throws ReedSolomonException if decoding fails for any reason
       */
      decode(received, twoS) {
        const field = this.field;
        const poly = new GenericGFPoly(field, received);
        const syndromeCoefficients = new Int32Array(twoS);
        let noError = true;
        for (let i3 = 0; i3 < twoS; i3++) {
          const evalResult = poly.evaluateAt(field.exp(i3 + field.getGeneratorBase()));
          syndromeCoefficients[syndromeCoefficients.length - 1 - i3] = evalResult;
          if (evalResult !== 0) {
            noError = false;
          }
        }
        if (noError) {
          return;
        }
        const syndrome = new GenericGFPoly(field, syndromeCoefficients);
        const sigmaOmega = this.runEuclideanAlgorithm(field.buildMonomial(twoS, 1), syndrome, twoS);
        const sigma = sigmaOmega[0];
        const omega = sigmaOmega[1];
        const errorLocations = this.findErrorLocations(sigma);
        const errorMagnitudes = this.findErrorMagnitudes(omega, errorLocations);
        for (let i3 = 0; i3 < errorLocations.length; i3++) {
          const position = received.length - 1 - field.log(errorLocations[i3]);
          if (position < 0) {
            throw new ReedSolomonException("Bad error location");
          }
          received[position] = GenericGF.addOrSubtract(received[position], errorMagnitudes[i3]);
        }
      }
      runEuclideanAlgorithm(a4, b2, R3) {
        if (a4.getDegree() < b2.getDegree()) {
          const temp = a4;
          a4 = b2;
          b2 = temp;
        }
        const field = this.field;
        let rLast = a4;
        let r2 = b2;
        let tLast = field.getZero();
        let t3 = field.getOne();
        while (r2.getDegree() >= (R3 / 2 | 0)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r2;
          tLast = t3;
          if (rLast.isZero()) {
            throw new ReedSolomonException("r_{i-1} was zero");
          }
          r2 = rLastLast;
          let q3 = field.getZero();
          const denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          const dltInverse = field.inverse(denominatorLeadingTerm);
          while (r2.getDegree() >= rLast.getDegree() && !r2.isZero()) {
            const degreeDiff = r2.getDegree() - rLast.getDegree();
            const scale = field.multiply(r2.getCoefficient(r2.getDegree()), dltInverse);
            q3 = q3.addOrSubtract(field.buildMonomial(degreeDiff, scale));
            r2 = r2.addOrSubtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t3 = q3.multiply(tLast).addOrSubtract(tLastLast);
          if (r2.getDegree() >= rLast.getDegree()) {
            throw new IllegalStateException("Division algorithm failed to reduce polynomial?");
          }
        }
        const sigmaTildeAtZero = t3.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw new ReedSolomonException("sigmaTilde(0) was zero");
        }
        const inverse = field.inverse(sigmaTildeAtZero);
        const sigma = t3.multiplyScalar(inverse);
        const omega = r2.multiplyScalar(inverse);
        return [sigma, omega];
      }
      findErrorLocations(errorLocator) {
        const numErrors = errorLocator.getDegree();
        if (numErrors === 1) {
          return Int32Array.from([errorLocator.getCoefficient(1)]);
        }
        const result = new Int32Array(numErrors);
        let e3 = 0;
        const field = this.field;
        for (let i3 = 1; i3 < field.getSize() && e3 < numErrors; i3++) {
          if (errorLocator.evaluateAt(i3) === 0) {
            result[e3] = field.inverse(i3);
            e3++;
          }
        }
        if (e3 !== numErrors) {
          throw new ReedSolomonException("Error locator degree does not match number of roots");
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocations) {
        const s4 = errorLocations.length;
        const result = new Int32Array(s4);
        const field = this.field;
        for (let i3 = 0; i3 < s4; i3++) {
          const xiInverse = field.inverse(errorLocations[i3]);
          let denominator = 1;
          for (let j2 = 0; j2 < s4; j2++) {
            if (i3 !== j2) {
              const term = field.multiply(errorLocations[j2], xiInverse);
              const termPlus1 = (term & 1) === 0 ? term | 1 : term & -2;
              denominator = field.multiply(denominator, termPlus1);
            }
          }
          result[i3] = field.multiply(errorEvaluator.evaluateAt(xiInverse), field.inverse(denominator));
          if (field.getGeneratorBase() !== 0) {
            result[i3] = field.multiply(result[i3], xiInverse);
          }
        }
        return result;
      }
    }
    var Table2;
    (function(Table3) {
      Table3[Table3["UPPER"] = 0] = "UPPER";
      Table3[Table3["LOWER"] = 1] = "LOWER";
      Table3[Table3["MIXED"] = 2] = "MIXED";
      Table3[Table3["DIGIT"] = 3] = "DIGIT";
      Table3[Table3["PUNCT"] = 4] = "PUNCT";
      Table3[Table3["BINARY"] = 5] = "BINARY";
    })(Table2 || (Table2 = {}));
    class Decoder {
      decode(detectorResult) {
        this.ddata = detectorResult;
        let matrix = detectorResult.getBits();
        let rawbits = this.extractBits(matrix);
        let correctedBits = this.correctBits(rawbits);
        let rawBytes = Decoder.convertBoolArrayToByteArray(correctedBits);
        let result = Decoder.getEncodedData(correctedBits);
        let decoderResult = new DecoderResult(rawBytes, result, null, null);
        decoderResult.setNumBits(correctedBits.length);
        return decoderResult;
      }
      // This method is used for testing the high-level encoder
      static highLevelDecode(correctedBits) {
        return this.getEncodedData(correctedBits);
      }
      /**
       * Gets the string encoded in the aztec code bits
       *
       * @return the decoded string
       */
      static getEncodedData(correctedBits) {
        let endIndex = correctedBits.length;
        let latchTable = Table2.UPPER;
        let shiftTable = Table2.UPPER;
        let result = "";
        let index2 = 0;
        while (index2 < endIndex) {
          if (shiftTable === Table2.BINARY) {
            if (endIndex - index2 < 5) {
              break;
            }
            let length = Decoder.readCode(correctedBits, index2, 5);
            index2 += 5;
            if (length === 0) {
              if (endIndex - index2 < 11) {
                break;
              }
              length = Decoder.readCode(correctedBits, index2, 11) + 31;
              index2 += 11;
            }
            for (let charCount = 0; charCount < length; charCount++) {
              if (endIndex - index2 < 8) {
                index2 = endIndex;
                break;
              }
              const code = Decoder.readCode(correctedBits, index2, 8);
              result += /*(char)*/
              StringUtils.castAsNonUtf8Char(code);
              index2 += 8;
            }
            shiftTable = latchTable;
          } else {
            let size2 = shiftTable === Table2.DIGIT ? 4 : 5;
            if (endIndex - index2 < size2) {
              break;
            }
            let code = Decoder.readCode(correctedBits, index2, size2);
            index2 += size2;
            let str = Decoder.getCharacter(shiftTable, code);
            if (str.startsWith("CTRL_")) {
              latchTable = shiftTable;
              shiftTable = Decoder.getTable(str.charAt(5));
              if (str.charAt(6) === "L") {
                latchTable = shiftTable;
              }
            } else {
              result += str;
              shiftTable = latchTable;
            }
          }
        }
        return result;
      }
      /**
       * gets the table corresponding to the char passed
       */
      static getTable(t3) {
        switch (t3) {
          case "L":
            return Table2.LOWER;
          case "P":
            return Table2.PUNCT;
          case "M":
            return Table2.MIXED;
          case "D":
            return Table2.DIGIT;
          case "B":
            return Table2.BINARY;
          case "U":
          default:
            return Table2.UPPER;
        }
      }
      /**
       * Gets the character (or string) corresponding to the passed code in the given table
       *
       * @param table the table used
       * @param code the code of the character
       */
      static getCharacter(table, code) {
        switch (table) {
          case Table2.UPPER:
            return Decoder.UPPER_TABLE[code];
          case Table2.LOWER:
            return Decoder.LOWER_TABLE[code];
          case Table2.MIXED:
            return Decoder.MIXED_TABLE[code];
          case Table2.PUNCT:
            return Decoder.PUNCT_TABLE[code];
          case Table2.DIGIT:
            return Decoder.DIGIT_TABLE[code];
          default:
            throw new IllegalStateException("Bad table");
        }
      }
      /**
       * <p>Performs RS error correction on an array of bits.</p>
       *
       * @return the corrected array
       * @throws FormatException if the input contains too many errors
       */
      correctBits(rawbits) {
        let gf;
        let codewordSize;
        if (this.ddata.getNbLayers() <= 2) {
          codewordSize = 6;
          gf = GenericGF.AZTEC_DATA_6;
        } else if (this.ddata.getNbLayers() <= 8) {
          codewordSize = 8;
          gf = GenericGF.AZTEC_DATA_8;
        } else if (this.ddata.getNbLayers() <= 22) {
          codewordSize = 10;
          gf = GenericGF.AZTEC_DATA_10;
        } else {
          codewordSize = 12;
          gf = GenericGF.AZTEC_DATA_12;
        }
        let numDataCodewords = this.ddata.getNbDatablocks();
        let numCodewords = rawbits.length / codewordSize;
        if (numCodewords < numDataCodewords) {
          throw new FormatException();
        }
        let offset2 = rawbits.length % codewordSize;
        let dataWords = new Int32Array(numCodewords);
        for (let i3 = 0; i3 < numCodewords; i3++, offset2 += codewordSize) {
          dataWords[i3] = Decoder.readCode(rawbits, offset2, codewordSize);
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(gf);
          rsDecoder.decode(dataWords, numCodewords - numDataCodewords);
        } catch (ex) {
          throw new FormatException(ex);
        }
        let mask = (1 << codewordSize) - 1;
        let stuffedBits = 0;
        for (let i3 = 0; i3 < numDataCodewords; i3++) {
          let dataWord = dataWords[i3];
          if (dataWord === 0 || dataWord === mask) {
            throw new FormatException();
          } else if (dataWord === 1 || dataWord === mask - 1) {
            stuffedBits++;
          }
        }
        let correctedBits = new Array(numDataCodewords * codewordSize - stuffedBits);
        let index2 = 0;
        for (let i3 = 0; i3 < numDataCodewords; i3++) {
          let dataWord = dataWords[i3];
          if (dataWord === 1 || dataWord === mask - 1) {
            correctedBits.fill(dataWord > 1, index2, index2 + codewordSize - 1);
            index2 += codewordSize - 1;
          } else {
            for (let bit = codewordSize - 1; bit >= 0; --bit) {
              correctedBits[index2++] = (dataWord & 1 << bit) !== 0;
            }
          }
        }
        return correctedBits;
      }
      /**
       * Gets the array of bits from an Aztec Code matrix
       *
       * @return the array of bits
       */
      extractBits(matrix) {
        let compact2 = this.ddata.isCompact();
        let layers = this.ddata.getNbLayers();
        let baseMatrixSize = (compact2 ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let rawbits = new Array(this.totalBitsInLayer(layers, compact2));
        if (compact2) {
          for (let i3 = 0; i3 < alignmentMap.length; i3++) {
            alignmentMap[i3] = i3;
          }
        } else {
          let matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = baseMatrixSize / 2;
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i3 = 0; i3 < origCenter; i3++) {
            let newOffset = i3 + Integer.truncDivision(i3, 15);
            alignmentMap[origCenter - i3 - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i3] = center + newOffset + 1;
          }
        }
        for (let i3 = 0, rowOffset = 0; i3 < layers; i3++) {
          let rowSize = (layers - i3) * 4 + (compact2 ? 9 : 12);
          let low = i3 * 2;
          let high = baseMatrixSize - 1 - low;
          for (let j2 = 0; j2 < rowSize; j2++) {
            let columnOffset = j2 * 2;
            for (let k3 = 0; k3 < 2; k3++) {
              rawbits[rowOffset + columnOffset + k3] = matrix.get(alignmentMap[low + k3], alignmentMap[low + j2]);
              rawbits[rowOffset + 2 * rowSize + columnOffset + k3] = matrix.get(alignmentMap[low + j2], alignmentMap[high - k3]);
              rawbits[rowOffset + 4 * rowSize + columnOffset + k3] = matrix.get(alignmentMap[high - k3], alignmentMap[high - j2]);
              rawbits[rowOffset + 6 * rowSize + columnOffset + k3] = matrix.get(alignmentMap[high - j2], alignmentMap[low + k3]);
            }
          }
          rowOffset += rowSize * 8;
        }
        return rawbits;
      }
      /**
       * Reads a code of given length and at given index in an array of bits
       */
      static readCode(rawbits, startIndex, length) {
        let res = 0;
        for (let i3 = startIndex; i3 < startIndex + length; i3++) {
          res <<= 1;
          if (rawbits[i3]) {
            res |= 1;
          }
        }
        return res;
      }
      /**
       * Reads a code of length 8 in an array of bits, padding with zeros
       */
      static readByte(rawbits, startIndex) {
        let n2 = rawbits.length - startIndex;
        if (n2 >= 8) {
          return Decoder.readCode(rawbits, startIndex, 8);
        }
        return Decoder.readCode(rawbits, startIndex, n2) << 8 - n2;
      }
      /**
       * Packs a bit array into bytes, most significant bit first
       */
      static convertBoolArrayToByteArray(boolArr) {
        let byteArr = new Uint8Array((boolArr.length + 7) / 8);
        for (let i3 = 0; i3 < byteArr.length; i3++) {
          byteArr[i3] = Decoder.readByte(boolArr, 8 * i3);
        }
        return byteArr;
      }
      totalBitsInLayer(layers, compact2) {
        return ((compact2 ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Decoder.UPPER_TABLE = [
      "CTRL_PS",
      " ",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "CTRL_LL",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder.LOWER_TABLE = [
      "CTRL_PS",
      " ",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "CTRL_US",
      "CTRL_ML",
      "CTRL_DL",
      "CTRL_BS"
    ];
    Decoder.MIXED_TABLE = [
      // Module parse failed: Octal literal in strict mode (50:29)
      // so number string were scaped
      "CTRL_PS",
      " ",
      "\\1",
      "\\2",
      "\\3",
      "\\4",
      "\\5",
      "\\6",
      "\\7",
      "\b",
      "	",
      "\n",
      "\\13",
      "\f",
      "\r",
      "\\33",
      "\\34",
      "\\35",
      "\\36",
      "\\37",
      "@",
      "\\",
      "^",
      "_",
      "`",
      "|",
      "~",
      "\\177",
      "CTRL_LL",
      "CTRL_UL",
      "CTRL_PL",
      "CTRL_BS"
    ];
    Decoder.PUNCT_TABLE = [
      "",
      "\r",
      "\r\n",
      ". ",
      ", ",
      ": ",
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "[",
      "]",
      "{",
      "}",
      "CTRL_UL"
    ];
    Decoder.DIGIT_TABLE = [
      "CTRL_PS",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ",",
      ".",
      "CTRL_UL",
      "CTRL_US"
    ];
    class MathUtils {
      constructor() {
      }
      /**
       * Ends up being a bit faster than {@link Math#round(float)}. This merely rounds its
       * argument to the nearest int, where x.5 rounds up to x+1. Semantics of this shortcut
       * differ slightly from {@link Math#round(float)} in that half rounds down for negative
       * values. -2.5 rounds to -3, not -2. For purposes here it makes no difference.
       *
       * @param d real value to round
       * @return nearest {@code int}
       */
      static round(d4) {
        if (NaN === d4)
          return 0;
        if (d4 <= Number.MIN_SAFE_INTEGER)
          return Number.MIN_SAFE_INTEGER;
        if (d4 >= Number.MAX_SAFE_INTEGER)
          return Number.MAX_SAFE_INTEGER;
        return (
          /*(int) */
          d4 + (d4 < 0 ? -0.5 : 0.5) | 0
        );
      }
      // TYPESCRIPTPORT: maybe remove round method and call directly Math.round, it looks like it doesn't make sense for js
      /**
       * @param aX point A x coordinate
       * @param aY point A y coordinate
       * @param bX point B x coordinate
       * @param bY point B y coordinate
       * @return Euclidean distance between points A and B
       */
      static distance(aX, aY, bX, bY) {
        const xDiff = aX - bX;
        const yDiff = aY - bY;
        return (
          /*(float) */
          Math.sqrt(xDiff * xDiff + yDiff * yDiff)
        );
      }
      /**
       * @param aX point A x coordinate
       * @param aY point A y coordinate
       * @param bX point B x coordinate
       * @param bY point B y coordinate
       * @return Euclidean distance between points A and B
       */
      // public static distance(aX: number /*int*/, aY: number /*int*/, bX: number /*int*/, bY: number /*int*/): float {
      //   const xDiff = aX - bX
      //   const yDiff = aY - bY
      //   return (float) Math.sqrt(xDiff * xDiff + yDiff * yDiff);
      // }
      /**
       * @param array values to sum
       * @return sum of values in array
       */
      static sum(array) {
        let count2 = 0;
        for (let i3 = 0, length = array.length; i3 !== length; i3++) {
          const a4 = array[i3];
          count2 += a4;
        }
        return count2;
      }
    }
    class Float {
      /**
       * SincTS has no difference between int and float, there's all numbers,
       * this is used only to polyfill Java code.
       */
      static floatToIntBits(f2) {
        return f2;
      }
    }
    Float.MAX_VALUE = Number.MAX_SAFE_INTEGER;
    class ResultPoint {
      constructor(x3, y4) {
        this.x = x3;
        this.y = y4;
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
      /*@Override*/
      equals(other) {
        if (other instanceof ResultPoint) {
          const otherPoint = other;
          return this.x === otherPoint.x && this.y === otherPoint.y;
        }
        return false;
      }
      /*@Override*/
      hashCode() {
        return 31 * Float.floatToIntBits(this.x) + Float.floatToIntBits(this.y);
      }
      /*@Override*/
      toString() {
        return "(" + this.x + "," + this.y + ")";
      }
      /**
       * Orders an array of three ResultPoints in an order [A,B,C] such that AB is less than AC
       * and BC is less than AC, and the angle between BC and BA is less than 180 degrees.
       *
       * @param patterns array of three {@code ResultPoint} to order
       */
      static orderBestPatterns(patterns) {
        const zeroOneDistance = this.distance(patterns[0], patterns[1]);
        const oneTwoDistance = this.distance(patterns[1], patterns[2]);
        const zeroTwoDistance = this.distance(patterns[0], patterns[2]);
        let pointA;
        let pointB;
        let pointC;
        if (oneTwoDistance >= zeroOneDistance && oneTwoDistance >= zeroTwoDistance) {
          pointB = patterns[0];
          pointA = patterns[1];
          pointC = patterns[2];
        } else if (zeroTwoDistance >= oneTwoDistance && zeroTwoDistance >= zeroOneDistance) {
          pointB = patterns[1];
          pointA = patterns[0];
          pointC = patterns[2];
        } else {
          pointB = patterns[2];
          pointA = patterns[0];
          pointC = patterns[1];
        }
        if (this.crossProductZ(pointA, pointB, pointC) < 0) {
          const temp = pointA;
          pointA = pointC;
          pointC = temp;
        }
        patterns[0] = pointA;
        patterns[1] = pointB;
        patterns[2] = pointC;
      }
      /**
       * @param pattern1 first pattern
       * @param pattern2 second pattern
       * @return distance between two points
       */
      static distance(pattern1, pattern2) {
        return MathUtils.distance(pattern1.x, pattern1.y, pattern2.x, pattern2.y);
      }
      /**
       * Returns the z component of the cross product between vectors BC and BA.
       */
      static crossProductZ(pointA, pointB, pointC) {
        const bX = pointB.x;
        const bY = pointB.y;
        return (pointC.x - bX) * (pointA.y - bY) - (pointC.y - bY) * (pointA.x - bX);
      }
    }
    class DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class AztecDetectorResult extends DetectorResult {
      constructor(bits, points, compact2, nbDatablocks, nbLayers) {
        super(bits, points);
        this.compact = compact2;
        this.nbDatablocks = nbDatablocks;
        this.nbLayers = nbLayers;
      }
      getNbLayers() {
        return this.nbLayers;
      }
      getNbDatablocks() {
        return this.nbDatablocks;
      }
      isCompact() {
        return this.compact;
      }
    }
    class WhiteRectangleDetector {
      // public constructor(private image: BitMatrix) /*throws NotFoundException*/ {
      //   this(image, INIT_SIZE, image.getWidth() / 2, image.getHeight() / 2)
      // }
      /**
       * @param image barcode image to find a rectangle in
       * @param initSize initial size of search area around center
       * @param x x position of search center
       * @param y y position of search center
       * @throws NotFoundException if image is too small to accommodate {@code initSize}
       */
      constructor(image, initSize, x3, y4) {
        this.image = image;
        this.height = image.getHeight();
        this.width = image.getWidth();
        if (void 0 === initSize || null === initSize) {
          initSize = WhiteRectangleDetector.INIT_SIZE;
        }
        if (void 0 === x3 || null === x3) {
          x3 = image.getWidth() / 2 | 0;
        }
        if (void 0 === y4 || null === y4) {
          y4 = image.getHeight() / 2 | 0;
        }
        const halfsize = initSize / 2 | 0;
        this.leftInit = x3 - halfsize;
        this.rightInit = x3 + halfsize;
        this.upInit = y4 - halfsize;
        this.downInit = y4 + halfsize;
        if (this.upInit < 0 || this.leftInit < 0 || this.downInit >= this.height || this.rightInit >= this.width) {
          throw new NotFoundException();
        }
      }
      /**
       * <p>
       * Detects a candidate barcode-like rectangular region within an image. It
       * starts around the center of the image, increases the size of the candidate
       * region until it finds a white rectangular region.
       * </p>
       *
       * @return {@link ResultPoint}[] describing the corners of the rectangular
       *         region. The first and last points are opposed on the diagonal, as
       *         are the second and third. The first point will be the topmost
       *         point and the last, the bottommost. The second point will be
       *         leftmost and the third, the rightmost
       * @throws NotFoundException if no Data Matrix Code can be found
       */
      detect() {
        let left = this.leftInit;
        let right = this.rightInit;
        let up = this.upInit;
        let down = this.downInit;
        let sizeExceeded = false;
        let aBlackPointFoundOnBorder = true;
        let atLeastOneBlackPointFoundOnBorder = false;
        let atLeastOneBlackPointFoundOnRight = false;
        let atLeastOneBlackPointFoundOnBottom = false;
        let atLeastOneBlackPointFoundOnLeft = false;
        let atLeastOneBlackPointFoundOnTop = false;
        const width = this.width;
        const height = this.height;
        while (aBlackPointFoundOnBorder) {
          aBlackPointFoundOnBorder = false;
          let rightBorderNotWhite = true;
          while ((rightBorderNotWhite || !atLeastOneBlackPointFoundOnRight) && right < width) {
            rightBorderNotWhite = this.containsBlackPoint(up, down, right, false);
            if (rightBorderNotWhite) {
              right++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnRight = true;
            } else if (!atLeastOneBlackPointFoundOnRight) {
              right++;
            }
          }
          if (right >= width) {
            sizeExceeded = true;
            break;
          }
          let bottomBorderNotWhite = true;
          while ((bottomBorderNotWhite || !atLeastOneBlackPointFoundOnBottom) && down < height) {
            bottomBorderNotWhite = this.containsBlackPoint(left, right, down, true);
            if (bottomBorderNotWhite) {
              down++;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnBottom = true;
            } else if (!atLeastOneBlackPointFoundOnBottom) {
              down++;
            }
          }
          if (down >= height) {
            sizeExceeded = true;
            break;
          }
          let leftBorderNotWhite = true;
          while ((leftBorderNotWhite || !atLeastOneBlackPointFoundOnLeft) && left >= 0) {
            leftBorderNotWhite = this.containsBlackPoint(up, down, left, false);
            if (leftBorderNotWhite) {
              left--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnLeft = true;
            } else if (!atLeastOneBlackPointFoundOnLeft) {
              left--;
            }
          }
          if (left < 0) {
            sizeExceeded = true;
            break;
          }
          let topBorderNotWhite = true;
          while ((topBorderNotWhite || !atLeastOneBlackPointFoundOnTop) && up >= 0) {
            topBorderNotWhite = this.containsBlackPoint(left, right, up, true);
            if (topBorderNotWhite) {
              up--;
              aBlackPointFoundOnBorder = true;
              atLeastOneBlackPointFoundOnTop = true;
            } else if (!atLeastOneBlackPointFoundOnTop) {
              up--;
            }
          }
          if (up < 0) {
            sizeExceeded = true;
            break;
          }
          if (aBlackPointFoundOnBorder) {
            atLeastOneBlackPointFoundOnBorder = true;
          }
        }
        if (!sizeExceeded && atLeastOneBlackPointFoundOnBorder) {
          const maxSize = right - left;
          let z3 = null;
          for (let i3 = 1; z3 === null && i3 < maxSize; i3++) {
            z3 = this.getBlackPointOnSegment(left, down - i3, left + i3, down);
          }
          if (z3 == null) {
            throw new NotFoundException();
          }
          let t3 = null;
          for (let i3 = 1; t3 === null && i3 < maxSize; i3++) {
            t3 = this.getBlackPointOnSegment(left, up + i3, left + i3, up);
          }
          if (t3 == null) {
            throw new NotFoundException();
          }
          let x3 = null;
          for (let i3 = 1; x3 === null && i3 < maxSize; i3++) {
            x3 = this.getBlackPointOnSegment(right, up + i3, right - i3, up);
          }
          if (x3 == null) {
            throw new NotFoundException();
          }
          let y4 = null;
          for (let i3 = 1; y4 === null && i3 < maxSize; i3++) {
            y4 = this.getBlackPointOnSegment(right, down - i3, right - i3, down);
          }
          if (y4 == null) {
            throw new NotFoundException();
          }
          return this.centerEdges(y4, z3, x3, t3);
        } else {
          throw new NotFoundException();
        }
      }
      getBlackPointOnSegment(aX, aY, bX, bY) {
        const dist = MathUtils.round(MathUtils.distance(aX, aY, bX, bY));
        const xStep = (bX - aX) / dist;
        const yStep = (bY - aY) / dist;
        const image = this.image;
        for (let i3 = 0; i3 < dist; i3++) {
          const x3 = MathUtils.round(aX + i3 * xStep);
          const y4 = MathUtils.round(aY + i3 * yStep);
          if (image.get(x3, y4)) {
            return new ResultPoint(x3, y4);
          }
        }
        return null;
      }
      /**
       * recenters the points of a constant distance towards the center
       *
       * @param y bottom most point
       * @param z left most point
       * @param x right most point
       * @param t top most point
       * @return {@link ResultPoint}[] describing the corners of the rectangular
       *         region. The first and last points are opposed on the diagonal, as
       *         are the second and third. The first point will be the topmost
       *         point and the last, the bottommost. The second point will be
       *         leftmost and the third, the rightmost
       */
      centerEdges(y4, z3, x3, t3) {
        const yi2 = y4.getX();
        const yj2 = y4.getY();
        const zi2 = z3.getX();
        const zj2 = z3.getY();
        const xi2 = x3.getX();
        const xj2 = x3.getY();
        const ti2 = t3.getX();
        const tj2 = t3.getY();
        const CORR = WhiteRectangleDetector.CORR;
        if (yi2 < this.width / 2) {
          return [
            new ResultPoint(ti2 - CORR, tj2 + CORR),
            new ResultPoint(zi2 + CORR, zj2 + CORR),
            new ResultPoint(xi2 - CORR, xj2 - CORR),
            new ResultPoint(yi2 + CORR, yj2 - CORR)
          ];
        } else {
          return [
            new ResultPoint(ti2 + CORR, tj2 + CORR),
            new ResultPoint(zi2 + CORR, zj2 - CORR),
            new ResultPoint(xi2 - CORR, xj2 + CORR),
            new ResultPoint(yi2 - CORR, yj2 - CORR)
          ];
        }
      }
      /**
       * Determines whether a segment contains a black point
       *
       * @param a          min value of the scanned coordinate
       * @param b          max value of the scanned coordinate
       * @param fixed      value of fixed coordinate
       * @param horizontal set to true if scan must be horizontal, false if vertical
       * @return true if a black point has been found, else false.
       */
      containsBlackPoint(a4, b2, fixed, horizontal) {
        const image = this.image;
        if (horizontal) {
          for (let x3 = a4; x3 <= b2; x3++) {
            if (image.get(x3, fixed)) {
              return true;
            }
          }
        } else {
          for (let y4 = a4; y4 <= b2; y4++) {
            if (image.get(fixed, y4)) {
              return true;
            }
          }
        }
        return false;
      }
    }
    WhiteRectangleDetector.INIT_SIZE = 10;
    WhiteRectangleDetector.CORR = 1;
    class GridSampler {
      /**
       * <p>Checks a set of points that have been transformed to sample points on an image against
       * the image's dimensions to see if the point are even within the image.</p>
       *
       * <p>This method will actually "nudge" the endpoints back onto the image if they are found to be
       * barely (less than 1 pixel) off the image. This accounts for imperfect detection of finder
       * patterns in an image where the QR Code runs all the way to the image border.</p>
       *
       * <p>For efficiency, the method will check points from either end of the line until one is found
       * to be within the image. Because the set of points are assumed to be linear, this is valid.</p>
       *
       * @param image image into which the points should map
       * @param points actual points in x1,y1,...,xn,yn form
       * @throws NotFoundException if an endpoint is lies outside the image boundaries
       */
      static checkAndNudgePoints(image, points) {
        const width = image.getWidth();
        const height = image.getHeight();
        let nudged = true;
        for (let offset2 = 0; offset2 < points.length && nudged; offset2 += 2) {
          const x3 = Math.floor(points[offset2]);
          const y4 = Math.floor(points[offset2 + 1]);
          if (x3 < -1 || x3 > width || y4 < -1 || y4 > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x3 === -1) {
            points[offset2] = 0;
            nudged = true;
          } else if (x3 === width) {
            points[offset2] = width - 1;
            nudged = true;
          }
          if (y4 === -1) {
            points[offset2 + 1] = 0;
            nudged = true;
          } else if (y4 === height) {
            points[offset2 + 1] = height - 1;
            nudged = true;
          }
        }
        nudged = true;
        for (let offset2 = points.length - 2; offset2 >= 0 && nudged; offset2 -= 2) {
          const x3 = Math.floor(points[offset2]);
          const y4 = Math.floor(points[offset2 + 1]);
          if (x3 < -1 || x3 > width || y4 < -1 || y4 > height) {
            throw new NotFoundException();
          }
          nudged = false;
          if (x3 === -1) {
            points[offset2] = 0;
            nudged = true;
          } else if (x3 === width) {
            points[offset2] = width - 1;
            nudged = true;
          }
          if (y4 === -1) {
            points[offset2 + 1] = 0;
            nudged = true;
          } else if (y4 === height) {
            points[offset2 + 1] = height - 1;
            nudged = true;
          }
        }
      }
    }
    class PerspectiveTransform {
      constructor(a11, a21, a31, a12, a22, a32, a13, a23, a33) {
        this.a11 = a11;
        this.a21 = a21;
        this.a31 = a31;
        this.a12 = a12;
        this.a22 = a22;
        this.a32 = a32;
        this.a13 = a13;
        this.a23 = a23;
        this.a33 = a33;
      }
      static quadrilateralToQuadrilateral(x0, y0, x1, y1, x22, y22, x3, y32, x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p) {
        const qToS = PerspectiveTransform.quadrilateralToSquare(x0, y0, x1, y1, x22, y22, x3, y32);
        const sToQ = PerspectiveTransform.squareToQuadrilateral(x0p, y0p, x1p, y1p, x2p, y2p, x3p, y3p);
        return sToQ.times(qToS);
      }
      transformPoints(points) {
        const max2 = points.length;
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        for (let i3 = 0; i3 < max2; i3 += 2) {
          const x3 = points[i3];
          const y4 = points[i3 + 1];
          const denominator = a13 * x3 + a23 * y4 + a33;
          points[i3] = (a11 * x3 + a21 * y4 + a31) / denominator;
          points[i3 + 1] = (a12 * x3 + a22 * y4 + a32) / denominator;
        }
      }
      transformPointsWithValues(xValues, yValues) {
        const a11 = this.a11;
        const a12 = this.a12;
        const a13 = this.a13;
        const a21 = this.a21;
        const a22 = this.a22;
        const a23 = this.a23;
        const a31 = this.a31;
        const a32 = this.a32;
        const a33 = this.a33;
        const n2 = xValues.length;
        for (let i3 = 0; i3 < n2; i3++) {
          const x3 = xValues[i3];
          const y4 = yValues[i3];
          const denominator = a13 * x3 + a23 * y4 + a33;
          xValues[i3] = (a11 * x3 + a21 * y4 + a31) / denominator;
          yValues[i3] = (a12 * x3 + a22 * y4 + a32) / denominator;
        }
      }
      static squareToQuadrilateral(x0, y0, x1, y1, x22, y22, x3, y32) {
        const dx3 = x0 - x1 + x22 - x3;
        const dy3 = y0 - y1 + y22 - y32;
        if (dx3 === 0 && dy3 === 0) {
          return new PerspectiveTransform(x1 - x0, x22 - x1, x0, y1 - y0, y22 - y1, y0, 0, 0, 1);
        } else {
          const dx1 = x1 - x22;
          const dx2 = x3 - x22;
          const dy1 = y1 - y22;
          const dy2 = y32 - y22;
          const denominator = dx1 * dy2 - dx2 * dy1;
          const a13 = (dx3 * dy2 - dx2 * dy3) / denominator;
          const a23 = (dx1 * dy3 - dx3 * dy1) / denominator;
          return new PerspectiveTransform(x1 - x0 + a13 * x1, x3 - x0 + a23 * x3, x0, y1 - y0 + a13 * y1, y32 - y0 + a23 * y32, y0, a13, a23, 1);
        }
      }
      static quadrilateralToSquare(x0, y0, x1, y1, x22, y22, x3, y32) {
        return PerspectiveTransform.squareToQuadrilateral(x0, y0, x1, y1, x22, y22, x3, y32).buildAdjoint();
      }
      buildAdjoint() {
        return new PerspectiveTransform(this.a22 * this.a33 - this.a23 * this.a32, this.a23 * this.a31 - this.a21 * this.a33, this.a21 * this.a32 - this.a22 * this.a31, this.a13 * this.a32 - this.a12 * this.a33, this.a11 * this.a33 - this.a13 * this.a31, this.a12 * this.a31 - this.a11 * this.a32, this.a12 * this.a23 - this.a13 * this.a22, this.a13 * this.a21 - this.a11 * this.a23, this.a11 * this.a22 - this.a12 * this.a21);
      }
      times(other) {
        return new PerspectiveTransform(this.a11 * other.a11 + this.a21 * other.a12 + this.a31 * other.a13, this.a11 * other.a21 + this.a21 * other.a22 + this.a31 * other.a23, this.a11 * other.a31 + this.a21 * other.a32 + this.a31 * other.a33, this.a12 * other.a11 + this.a22 * other.a12 + this.a32 * other.a13, this.a12 * other.a21 + this.a22 * other.a22 + this.a32 * other.a23, this.a12 * other.a31 + this.a22 * other.a32 + this.a32 * other.a33, this.a13 * other.a11 + this.a23 * other.a12 + this.a33 * other.a13, this.a13 * other.a21 + this.a23 * other.a22 + this.a33 * other.a23, this.a13 * other.a31 + this.a23 * other.a32 + this.a33 * other.a33);
      }
    }
    class DefaultGridSampler extends GridSampler {
      /*@Override*/
      sampleGrid(image, dimensionX, dimensionY, p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY) {
        const transform = PerspectiveTransform.quadrilateralToQuadrilateral(p1ToX, p1ToY, p2ToX, p2ToY, p3ToX, p3ToY, p4ToX, p4ToY, p1FromX, p1FromY, p2FromX, p2FromY, p3FromX, p3FromY, p4FromX, p4FromY);
        return this.sampleGridWithTransform(image, dimensionX, dimensionY, transform);
      }
      /*@Override*/
      sampleGridWithTransform(image, dimensionX, dimensionY, transform) {
        if (dimensionX <= 0 || dimensionY <= 0) {
          throw new NotFoundException();
        }
        const bits = new BitMatrix(dimensionX, dimensionY);
        const points = new Float32Array(2 * dimensionX);
        for (let y4 = 0; y4 < dimensionY; y4++) {
          const max2 = points.length;
          const iValue = y4 + 0.5;
          for (let x3 = 0; x3 < max2; x3 += 2) {
            points[x3] = x3 / 2 + 0.5;
            points[x3 + 1] = iValue;
          }
          transform.transformPoints(points);
          GridSampler.checkAndNudgePoints(image, points);
          try {
            for (let x3 = 0; x3 < max2; x3 += 2) {
              if (image.get(Math.floor(points[x3]), Math.floor(points[x3 + 1]))) {
                bits.set(x3 / 2, y4);
              }
            }
          } catch (aioobe) {
            throw new NotFoundException();
          }
        }
        return bits;
      }
    }
    class GridSamplerInstance {
      /**
       * Sets the implementation of GridSampler used by the library. One global
       * instance is stored, which may sound problematic. But, the implementation provided
       * ought to be appropriate for the entire platform, and all uses of this library
       * in the whole lifetime of the JVM. For instance, an Android activity can swap in
       * an implementation that takes advantage of native platform libraries.
       *
       * @param newGridSampler The platform-specific object to install.
       */
      static setGridSampler(newGridSampler) {
        GridSamplerInstance.gridSampler = newGridSampler;
      }
      /**
       * @return the current implementation of GridSampler
       */
      static getInstance() {
        return GridSamplerInstance.gridSampler;
      }
    }
    GridSamplerInstance.gridSampler = new DefaultGridSampler();
    class Point {
      constructor(x3, y4) {
        this.x = x3;
        this.y = y4;
      }
      toResultPoint() {
        return new ResultPoint(this.getX(), this.getY());
      }
      getX() {
        return this.x;
      }
      getY() {
        return this.y;
      }
    }
    class Detector {
      constructor(image) {
        this.EXPECTED_CORNER_BITS = new Int32Array([
          3808,
          476,
          2107,
          1799
        ]);
        this.image = image;
      }
      detect() {
        return this.detectMirror(false);
      }
      /**
       * Detects an Aztec Code in an image.
       *
       * @param isMirror if true, image is a mirror-image of original
       * @return {@link AztecDetectorResult} encapsulating results of detecting an Aztec Code
       * @throws NotFoundException if no Aztec Code can be found
       */
      detectMirror(isMirror) {
        let pCenter = this.getMatrixCenter();
        let bullsEyeCorners = this.getBullsEyeCorners(pCenter);
        if (isMirror) {
          let temp = bullsEyeCorners[0];
          bullsEyeCorners[0] = bullsEyeCorners[2];
          bullsEyeCorners[2] = temp;
        }
        this.extractParameters(bullsEyeCorners);
        let bits = this.sampleGrid(this.image, bullsEyeCorners[this.shift % 4], bullsEyeCorners[(this.shift + 1) % 4], bullsEyeCorners[(this.shift + 2) % 4], bullsEyeCorners[(this.shift + 3) % 4]);
        let corners = this.getMatrixCornerPoints(bullsEyeCorners);
        return new AztecDetectorResult(bits, corners, this.compact, this.nbDataBlocks, this.nbLayers);
      }
      /**
       * Extracts the number of data layers and data blocks from the layer around the bull's eye.
       *
       * @param bullsEyeCorners the array of bull's eye corners
       * @throws NotFoundException in case of too many errors or invalid parameters
       */
      extractParameters(bullsEyeCorners) {
        if (!this.isValidPoint(bullsEyeCorners[0]) || !this.isValidPoint(bullsEyeCorners[1]) || !this.isValidPoint(bullsEyeCorners[2]) || !this.isValidPoint(bullsEyeCorners[3])) {
          throw new NotFoundException();
        }
        let length = 2 * this.nbCenterLayers;
        let sides2 = new Int32Array([
          this.sampleLine(bullsEyeCorners[0], bullsEyeCorners[1], length),
          this.sampleLine(bullsEyeCorners[1], bullsEyeCorners[2], length),
          this.sampleLine(bullsEyeCorners[2], bullsEyeCorners[3], length),
          this.sampleLine(bullsEyeCorners[3], bullsEyeCorners[0], length)
          // Top
        ]);
        this.shift = this.getRotation(sides2, length);
        let parameterData = 0;
        for (let i3 = 0; i3 < 4; i3++) {
          let side = sides2[(this.shift + i3) % 4];
          if (this.compact) {
            parameterData <<= 7;
            parameterData += side >> 1 & 127;
          } else {
            parameterData <<= 10;
            parameterData += (side >> 2 & 31 << 5) + (side >> 1 & 31);
          }
        }
        let correctedData = this.getCorrectedParameterData(parameterData, this.compact);
        if (this.compact) {
          this.nbLayers = (correctedData >> 6) + 1;
          this.nbDataBlocks = (correctedData & 63) + 1;
        } else {
          this.nbLayers = (correctedData >> 11) + 1;
          this.nbDataBlocks = (correctedData & 2047) + 1;
        }
      }
      getRotation(sides2, length) {
        let cornerBits = 0;
        sides2.forEach((side, idx, arr) => {
          let t3 = (side >> length - 2 << 1) + (side & 1);
          cornerBits = (cornerBits << 3) + t3;
        });
        cornerBits = ((cornerBits & 1) << 11) + (cornerBits >> 1);
        for (let shift2 = 0; shift2 < 4; shift2++) {
          if (Integer.bitCount(cornerBits ^ this.EXPECTED_CORNER_BITS[shift2]) <= 2) {
            return shift2;
          }
        }
        throw new NotFoundException();
      }
      /**
       * Corrects the parameter bits using Reed-Solomon algorithm.
       *
       * @param parameterData parameter bits
       * @param compact true if this is a compact Aztec code
       * @throws NotFoundException if the array contains too many errors
       */
      getCorrectedParameterData(parameterData, compact2) {
        let numCodewords;
        let numDataCodewords;
        if (compact2) {
          numCodewords = 7;
          numDataCodewords = 2;
        } else {
          numCodewords = 10;
          numDataCodewords = 4;
        }
        let numECCodewords = numCodewords - numDataCodewords;
        let parameterWords = new Int32Array(numCodewords);
        for (let i3 = numCodewords - 1; i3 >= 0; --i3) {
          parameterWords[i3] = parameterData & 15;
          parameterData >>= 4;
        }
        try {
          let rsDecoder = new ReedSolomonDecoder(GenericGF.AZTEC_PARAM);
          rsDecoder.decode(parameterWords, numECCodewords);
        } catch (ignored) {
          throw new NotFoundException();
        }
        let result = 0;
        for (let i3 = 0; i3 < numDataCodewords; i3++) {
          result = (result << 4) + parameterWords[i3];
        }
        return result;
      }
      /**
       * Finds the corners of a bull-eye centered on the passed point.
       * This returns the centers of the diagonal points just outside the bull's eye
       * Returns [topRight, bottomRight, bottomLeft, topLeft]
       *
       * @param pCenter Center point
       * @return The corners of the bull-eye
       * @throws NotFoundException If no valid bull-eye can be found
       */
      getBullsEyeCorners(pCenter) {
        let pina = pCenter;
        let pinb = pCenter;
        let pinc = pCenter;
        let pind = pCenter;
        let color = true;
        for (this.nbCenterLayers = 1; this.nbCenterLayers < 9; this.nbCenterLayers++) {
          let pouta = this.getFirstDifferent(pina, color, 1, -1);
          let poutb = this.getFirstDifferent(pinb, color, 1, 1);
          let poutc = this.getFirstDifferent(pinc, color, -1, 1);
          let poutd = this.getFirstDifferent(pind, color, -1, -1);
          if (this.nbCenterLayers > 2) {
            let q3 = this.distancePoint(poutd, pouta) * this.nbCenterLayers / (this.distancePoint(pind, pina) * (this.nbCenterLayers + 2));
            if (q3 < 0.75 || q3 > 1.25 || !this.isWhiteOrBlackRectangle(pouta, poutb, poutc, poutd)) {
              break;
            }
          }
          pina = pouta;
          pinb = poutb;
          pinc = poutc;
          pind = poutd;
          color = !color;
        }
        if (this.nbCenterLayers !== 5 && this.nbCenterLayers !== 7) {
          throw new NotFoundException();
        }
        this.compact = this.nbCenterLayers === 5;
        let pinax = new ResultPoint(pina.getX() + 0.5, pina.getY() - 0.5);
        let pinbx = new ResultPoint(pinb.getX() + 0.5, pinb.getY() + 0.5);
        let pincx = new ResultPoint(pinc.getX() - 0.5, pinc.getY() + 0.5);
        let pindx = new ResultPoint(pind.getX() - 0.5, pind.getY() - 0.5);
        return this.expandSquare([pinax, pinbx, pincx, pindx], 2 * this.nbCenterLayers - 3, 2 * this.nbCenterLayers);
      }
      /**
       * Finds a candidate center point of an Aztec code from an image
       *
       * @return the center point
       */
      getMatrixCenter() {
        let pointA;
        let pointB;
        let pointC;
        let pointD;
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e3) {
          let cx3 = this.image.getWidth() / 2;
          let cy2 = this.image.getHeight() / 2;
          pointA = this.getFirstDifferent(new Point(cx3 + 7, cy2 - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx3 + 7, cy2 + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx3 - 7, cy2 + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx3 - 7, cy2 - 7), false, -1, -1).toResultPoint();
        }
        let cx2 = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        let cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        try {
          let cornerPoints = new WhiteRectangleDetector(this.image, 15, cx2, cy).detect();
          pointA = cornerPoints[0];
          pointB = cornerPoints[1];
          pointC = cornerPoints[2];
          pointD = cornerPoints[3];
        } catch (e3) {
          pointA = this.getFirstDifferent(new Point(cx2 + 7, cy - 7), false, 1, -1).toResultPoint();
          pointB = this.getFirstDifferent(new Point(cx2 + 7, cy + 7), false, 1, 1).toResultPoint();
          pointC = this.getFirstDifferent(new Point(cx2 - 7, cy + 7), false, -1, 1).toResultPoint();
          pointD = this.getFirstDifferent(new Point(cx2 - 7, cy - 7), false, -1, -1).toResultPoint();
        }
        cx2 = MathUtils.round((pointA.getX() + pointD.getX() + pointB.getX() + pointC.getX()) / 4);
        cy = MathUtils.round((pointA.getY() + pointD.getY() + pointB.getY() + pointC.getY()) / 4);
        return new Point(cx2, cy);
      }
      /**
       * Gets the Aztec code corners from the bull's eye corners and the parameters.
       *
       * @param bullsEyeCorners the array of bull's eye corners
       * @return the array of aztec code corners
       */
      getMatrixCornerPoints(bullsEyeCorners) {
        return this.expandSquare(bullsEyeCorners, 2 * this.nbCenterLayers, this.getDimension());
      }
      /**
       * Creates a BitMatrix by sampling the provided image.
       * topLeft, topRight, bottomRight, and bottomLeft are the centers of the squares on the
       * diagonal just outside the bull's eye.
       */
      sampleGrid(image, topLeft, topRight, bottomRight, bottomLeft) {
        let sampler = GridSamplerInstance.getInstance();
        let dimension = this.getDimension();
        let low = dimension / 2 - this.nbCenterLayers;
        let high = dimension / 2 + this.nbCenterLayers;
        return sampler.sampleGrid(
          image,
          dimension,
          dimension,
          low,
          low,
          // topleft
          high,
          low,
          // topright
          high,
          high,
          // bottomright
          low,
          high,
          // bottomleft
          topLeft.getX(),
          topLeft.getY(),
          topRight.getX(),
          topRight.getY(),
          bottomRight.getX(),
          bottomRight.getY(),
          bottomLeft.getX(),
          bottomLeft.getY()
        );
      }
      /**
       * Samples a line.
       *
       * @param p1   start point (inclusive)
       * @param p2   end point (exclusive)
       * @param size number of bits
       * @return the array of bits as an int (first bit is high-order bit of result)
       */
      sampleLine(p1, p2, size2) {
        let result = 0;
        let d4 = this.distanceResultPoint(p1, p2);
        let moduleSize = d4 / size2;
        let px = p1.getX();
        let py = p1.getY();
        let dx = moduleSize * (p2.getX() - p1.getX()) / d4;
        let dy = moduleSize * (p2.getY() - p1.getY()) / d4;
        for (let i3 = 0; i3 < size2; i3++) {
          if (this.image.get(MathUtils.round(px + i3 * dx), MathUtils.round(py + i3 * dy))) {
            result |= 1 << size2 - i3 - 1;
          }
        }
        return result;
      }
      /**
       * @return true if the border of the rectangle passed in parameter is compound of white points only
       *         or black points only
       */
      isWhiteOrBlackRectangle(p1, p2, p3, p4) {
        let corr = 3;
        p1 = new Point(p1.getX() - corr, p1.getY() + corr);
        p2 = new Point(p2.getX() - corr, p2.getY() - corr);
        p3 = new Point(p3.getX() + corr, p3.getY() - corr);
        p4 = new Point(p4.getX() + corr, p4.getY() + corr);
        let cInit = this.getColor(p4, p1);
        if (cInit === 0) {
          return false;
        }
        let c3 = this.getColor(p1, p2);
        if (c3 !== cInit) {
          return false;
        }
        c3 = this.getColor(p2, p3);
        if (c3 !== cInit) {
          return false;
        }
        c3 = this.getColor(p3, p4);
        return c3 === cInit;
      }
      /**
       * Gets the color of a segment
       *
       * @return 1 if segment more than 90% black, -1 if segment is more than 90% white, 0 else
       */
      getColor(p1, p2) {
        let d4 = this.distancePoint(p1, p2);
        let dx = (p2.getX() - p1.getX()) / d4;
        let dy = (p2.getY() - p1.getY()) / d4;
        let error = 0;
        let px = p1.getX();
        let py = p1.getY();
        let colorModel = this.image.get(p1.getX(), p1.getY());
        let iMax = Math.ceil(d4);
        for (let i3 = 0; i3 < iMax; i3++) {
          px += dx;
          py += dy;
          if (this.image.get(MathUtils.round(px), MathUtils.round(py)) !== colorModel) {
            error++;
          }
        }
        let errRatio = error / d4;
        if (errRatio > 0.1 && errRatio < 0.9) {
          return 0;
        }
        return errRatio <= 0.1 === colorModel ? 1 : -1;
      }
      /**
       * Gets the coordinate of the first point with a different color in the given direction
       */
      getFirstDifferent(init, color, dx, dy) {
        let x3 = init.getX() + dx;
        let y4 = init.getY() + dy;
        while (this.isValid(x3, y4) && this.image.get(x3, y4) === color) {
          x3 += dx;
          y4 += dy;
        }
        x3 -= dx;
        y4 -= dy;
        while (this.isValid(x3, y4) && this.image.get(x3, y4) === color) {
          x3 += dx;
        }
        x3 -= dx;
        while (this.isValid(x3, y4) && this.image.get(x3, y4) === color) {
          y4 += dy;
        }
        y4 -= dy;
        return new Point(x3, y4);
      }
      /**
       * Expand the square represented by the corner points by pushing out equally in all directions
       *
       * @param cornerPoints the corners of the square, which has the bull's eye at its center
       * @param oldSide the original length of the side of the square in the target bit matrix
       * @param newSide the new length of the size of the square in the target bit matrix
       * @return the corners of the expanded square
       */
      expandSquare(cornerPoints, oldSide, newSide) {
        let ratio = newSide / (2 * oldSide);
        let dx = cornerPoints[0].getX() - cornerPoints[2].getX();
        let dy = cornerPoints[0].getY() - cornerPoints[2].getY();
        let centerx = (cornerPoints[0].getX() + cornerPoints[2].getX()) / 2;
        let centery = (cornerPoints[0].getY() + cornerPoints[2].getY()) / 2;
        let result0 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result2 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        dx = cornerPoints[1].getX() - cornerPoints[3].getX();
        dy = cornerPoints[1].getY() - cornerPoints[3].getY();
        centerx = (cornerPoints[1].getX() + cornerPoints[3].getX()) / 2;
        centery = (cornerPoints[1].getY() + cornerPoints[3].getY()) / 2;
        let result1 = new ResultPoint(centerx + ratio * dx, centery + ratio * dy);
        let result3 = new ResultPoint(centerx - ratio * dx, centery - ratio * dy);
        let results = [result0, result1, result2, result3];
        return results;
      }
      isValid(x3, y4) {
        return x3 >= 0 && x3 < this.image.getWidth() && y4 > 0 && y4 < this.image.getHeight();
      }
      isValidPoint(point) {
        let x3 = MathUtils.round(point.getX());
        let y4 = MathUtils.round(point.getY());
        return this.isValid(x3, y4);
      }
      distancePoint(a4, b2) {
        return MathUtils.distance(a4.getX(), a4.getY(), b2.getX(), b2.getY());
      }
      distanceResultPoint(a4, b2) {
        return MathUtils.distance(a4.getX(), a4.getY(), b2.getX(), b2.getY());
      }
      getDimension() {
        if (this.compact) {
          return 4 * this.nbLayers + 11;
        }
        if (this.nbLayers <= 4) {
          return 4 * this.nbLayers + 15;
        }
        return 4 * this.nbLayers + 2 * (Integer.truncDivision(this.nbLayers - 4, 8) + 1) + 15;
      }
    }
    class AztecReader {
      /**
       * Locates and decodes a Data Matrix code in an image.
       *
       * @return a String representing the content encoded by the Data Matrix code
       * @throws NotFoundException if a Data Matrix code cannot be found
       * @throws FormatException if a Data Matrix code cannot be decoded
       */
      decode(image, hints = null) {
        let exception = null;
        let detector = new Detector(image.getBlackMatrix());
        let points = null;
        let decoderResult = null;
        try {
          let detectorResult = detector.detectMirror(false);
          points = detectorResult.getPoints();
          this.reportFoundResultPoints(hints, points);
          decoderResult = new Decoder().decode(detectorResult);
        } catch (e3) {
          exception = e3;
        }
        if (decoderResult == null) {
          try {
            let detectorResult = detector.detectMirror(true);
            points = detectorResult.getPoints();
            this.reportFoundResultPoints(hints, points);
            decoderResult = new Decoder().decode(detectorResult);
          } catch (e3) {
            if (exception != null) {
              throw exception;
            }
            throw e3;
          }
        }
        let result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), decoderResult.getNumBits(), points, BarcodeFormat$1.AZTEC, System.currentTimeMillis());
        let byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        let ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      reportFoundResultPoints(hints, points) {
        if (hints != null) {
          let rpcb = hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (rpcb != null) {
            points.forEach((point, idx, arr) => {
              rpcb.foundPossibleResultPoint(point);
            });
          }
        }
      }
      // @Override
      reset() {
      }
    }
    class BrowserAztecCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserAztecCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       *
       * @memberOf BrowserAztecCodeReader
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new AztecReader(), timeBetweenScansMillis);
      }
    }
    class OneDReader {
      /*
      @Override
      public Result decode(BinaryBitmap image) throws NotFoundException, FormatException {
        return decode(image, null);
      }
      */
      // Note that we don't try rotation without the try harder flag, even if rotation was supported.
      // @Override
      decode(image, hints) {
        try {
          return this.doDecode(image, hints);
        } catch (nfe) {
          const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
          if (tryHarder && image.isRotateSupported()) {
            const rotatedImage = image.rotateCounterClockwise();
            const result = this.doDecode(rotatedImage, hints);
            const metadata = result.getResultMetadata();
            let orientation = 270;
            if (metadata !== null && metadata.get(ResultMetadataType$1.ORIENTATION) === true) {
              orientation = orientation + metadata.get(ResultMetadataType$1.ORIENTATION) % 360;
            }
            result.putMetadata(ResultMetadataType$1.ORIENTATION, orientation);
            const points = result.getResultPoints();
            if (points !== null) {
              const height = rotatedImage.getHeight();
              for (let i3 = 0; i3 < points.length; i3++) {
                points[i3] = new ResultPoint(height - points[i3].getY() - 1, points[i3].getX());
              }
            }
            return result;
          } else {
            throw new NotFoundException();
          }
        }
      }
      // @Override
      reset() {
      }
      /**
       * We're going to examine rows from the middle outward, searching alternately above and below the
       * middle, and farther out each time. rowStep is the number of rows between each successive
       * attempt above and below the middle. So we'd scan row middle, then middle - rowStep, then
       * middle + rowStep, then middle - (2 * rowStep), etc.
       * rowStep is bigger as the image is taller, but is always at least 1. We've somewhat arbitrarily
       * decided that moving up and down by about 1/16 of the image is pretty good; we try more of the
       * image if "trying harder".
       *
       * @param image The image to decode
       * @param hints Any hints that were requested
       * @return The contents of the decoded barcode
       * @throws NotFoundException Any spontaneous errors which occur
       */
      doDecode(image, hints) {
        const width = image.getWidth();
        const height = image.getHeight();
        let row = new BitArray(width);
        const tryHarder = hints && hints.get(DecodeHintType$1.TRY_HARDER) === true;
        const rowStep = Math.max(1, height >> (tryHarder ? 8 : 5));
        let maxLines;
        if (tryHarder) {
          maxLines = height;
        } else {
          maxLines = 15;
        }
        const middle = Math.trunc(height / 2);
        for (let x3 = 0; x3 < maxLines; x3++) {
          const rowStepsAboveOrBelow = Math.trunc((x3 + 1) / 2);
          const isAbove = (x3 & 1) === 0;
          const rowNumber = middle + rowStep * (isAbove ? rowStepsAboveOrBelow : -rowStepsAboveOrBelow);
          if (rowNumber < 0 || rowNumber >= height) {
            break;
          }
          try {
            row = image.getBlackRow(rowNumber, row);
          } catch (ignored) {
            continue;
          }
          for (let attempt = 0; attempt < 2; attempt++) {
            if (attempt === 1) {
              row.reverse();
              if (hints && hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK) === true) {
                const newHints = /* @__PURE__ */ new Map();
                hints.forEach((hint, key) => newHints.set(key, hint));
                newHints.delete(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
                hints = newHints;
              }
            }
            try {
              const result = this.decodeRow(rowNumber, row, hints);
              if (attempt === 1) {
                result.putMetadata(ResultMetadataType$1.ORIENTATION, 180);
                const points = result.getResultPoints();
                if (points !== null) {
                  points[0] = new ResultPoint(width - points[0].getX() - 1, points[0].getY());
                  points[1] = new ResultPoint(width - points[1].getX() - 1, points[1].getY());
                }
              }
              return result;
            } catch (re2) {
            }
          }
        }
        throw new NotFoundException();
      }
      /**
       * Records the size of successive runs of white and black pixels in a row, starting at a given point.
       * The values are recorded in the given array, and the number of runs recorded is equal to the size
       * of the array. If the row starts on a white pixel at the given start point, then the first count
       * recorded is the run of white pixels starting from that point; likewise it is the count of a run
       * of black pixels if the row begin on a black pixels at that point.
       *
       * @param row row to count from
       * @param start offset into row to start at
       * @param counters array into which to record counts
       * @throws NotFoundException if counters cannot be filled entirely from row before running out
       *  of pixels
       */
      static recordPattern(row, start, counters) {
        const numCounters = counters.length;
        for (let index2 = 0; index2 < numCounters; index2++)
          counters[index2] = 0;
        const end = row.getSize();
        if (start >= end) {
          throw new NotFoundException();
        }
        let isWhite = !row.get(start);
        let counterPosition = 0;
        let i3 = start;
        while (i3 < end) {
          if (row.get(i3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (++counterPosition === numCounters) {
              break;
            } else {
              counters[counterPosition] = 1;
              isWhite = !isWhite;
            }
          }
          i3++;
        }
        if (!(counterPosition === numCounters || counterPosition === numCounters - 1 && i3 === end)) {
          throw new NotFoundException();
        }
      }
      static recordPatternInReverse(row, start, counters) {
        let numTransitionsLeft = counters.length;
        let last = row.get(start);
        while (start > 0 && numTransitionsLeft >= 0) {
          if (row.get(--start) !== last) {
            numTransitionsLeft--;
            last = !last;
          }
        }
        if (numTransitionsLeft >= 0) {
          throw new NotFoundException();
        }
        OneDReader.recordPattern(row, start + 1, counters);
      }
      /**
       * Determines how closely a set of observed counts of runs of black/white values matches a given
       * target pattern. This is reported as the ratio of the total variance from the expected pattern
       * proportions across all pattern elements, to the length of the pattern.
       *
       * @param counters observed counters
       * @param pattern expected pattern
       * @param maxIndividualVariance The most any counter can differ before we give up
       * @return ratio of total variance between counters and pattern compared to total pattern size
       */
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        const numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i3 = 0; i3 < numCounters; i3++) {
          total += counters[i3];
          patternLength += pattern[i3];
        }
        if (total < patternLength) {
          return Number.POSITIVE_INFINITY;
        }
        const unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x3 = 0; x3 < numCounters; x3++) {
          const counter = counters[x3];
          const scaledPattern = pattern[x3] * unitBarWidth;
          const variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return Number.POSITIVE_INFINITY;
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    class Code128Reader extends OneDReader {
      static findStartPattern(row) {
        const width = row.getSize();
        const rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let patternStart = rowOffset;
        let isWhite = false;
        const patternLength = 6;
        for (let i3 = rowOffset; i3 < width; i3++) {
          if (row.get(i3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
              let bestMatch = -1;
              for (let startCode = Code128Reader.CODE_START_A; startCode <= Code128Reader.CODE_START_C; startCode++) {
                const variance = OneDReader.patternMatchVariance(counters, Code128Reader.CODE_PATTERNS[startCode], Code128Reader.MAX_INDIVIDUAL_VARIANCE);
                if (variance < bestVariance) {
                  bestVariance = variance;
                  bestMatch = startCode;
                }
              }
              if (bestMatch >= 0 && row.isRange(Math.max(0, patternStart - (i3 - patternStart) / 2), patternStart, false)) {
                return Int32Array.from([patternStart, i3, bestMatch]);
              }
              patternStart += counters[0] + counters[1];
              counters = counters.slice(2, counters.length - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeCode(row, counters, rowOffset) {
        OneDReader.recordPattern(row, rowOffset, counters);
        let bestVariance = Code128Reader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        for (let d4 = 0; d4 < Code128Reader.CODE_PATTERNS.length; d4++) {
          const pattern = Code128Reader.CODE_PATTERNS[d4];
          const variance = this.patternMatchVariance(counters, pattern, Code128Reader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = d4;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
      decodeRow(rowNumber, row, hints) {
        const convertFNC1 = hints && hints.get(DecodeHintType$1.ASSUME_GS1) === true;
        const startPatternInfo = Code128Reader.findStartPattern(row);
        const startCode = startPatternInfo[2];
        let currentRawCodesIndex = 0;
        const rawCodes = new Uint8Array(20);
        rawCodes[currentRawCodesIndex++] = startCode;
        let codeSet;
        switch (startCode) {
          case Code128Reader.CODE_START_A:
            codeSet = Code128Reader.CODE_CODE_A;
            break;
          case Code128Reader.CODE_START_B:
            codeSet = Code128Reader.CODE_CODE_B;
            break;
          case Code128Reader.CODE_START_C:
            codeSet = Code128Reader.CODE_CODE_C;
            break;
          default:
            throw new FormatException();
        }
        let done = false;
        let isNextShifted = false;
        let result = "";
        let lastStart = startPatternInfo[0];
        let nextStart = startPatternInfo[1];
        const counters = Int32Array.from([0, 0, 0, 0, 0, 0]);
        let lastCode = 0;
        let code = 0;
        let checksumTotal = startCode;
        let multiplier = 0;
        let lastCharacterWasPrintable = true;
        let upperMode = false;
        let shiftUpperMode = false;
        while (!done) {
          const unshift = isNextShifted;
          isNextShifted = false;
          lastCode = code;
          code = Code128Reader.decodeCode(row, counters, nextStart);
          rawCodes[currentRawCodesIndex++] = code;
          if (code !== Code128Reader.CODE_STOP) {
            lastCharacterWasPrintable = true;
          }
          if (code !== Code128Reader.CODE_STOP) {
            multiplier++;
            checksumTotal += multiplier * code;
          }
          lastStart = nextStart;
          nextStart += counters.reduce((previous, current) => previous + current, 0);
          switch (code) {
            case Code128Reader.CODE_START_A:
            case Code128Reader.CODE_START_B:
            case Code128Reader.CODE_START_C:
              throw new FormatException();
          }
          switch (codeSet) {
            case Code128Reader.CODE_CODE_A:
              if (code < 64) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(code - 64);
                } else {
                  result += String.fromCharCode(code + 64);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_A:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_B:
              if (code < 96) {
                if (shiftUpperMode === upperMode) {
                  result += String.fromCharCode(" ".charCodeAt(0) + code);
                } else {
                  result += String.fromCharCode(" ".charCodeAt(0) + code + 128);
                }
                shiftUpperMode = false;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_FNC_2:
                  case Code128Reader.CODE_FNC_3:
                    break;
                  case Code128Reader.CODE_FNC_4_B:
                    if (!upperMode && shiftUpperMode) {
                      upperMode = true;
                      shiftUpperMode = false;
                    } else if (upperMode && shiftUpperMode) {
                      upperMode = false;
                      shiftUpperMode = false;
                    } else {
                      shiftUpperMode = true;
                    }
                    break;
                  case Code128Reader.CODE_SHIFT:
                    isNextShifted = true;
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_C:
                    codeSet = Code128Reader.CODE_CODE_C;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
            case Code128Reader.CODE_CODE_C:
              if (code < 100) {
                if (code < 10) {
                  result += "0";
                }
                result += code;
              } else {
                if (code !== Code128Reader.CODE_STOP) {
                  lastCharacterWasPrintable = false;
                }
                switch (code) {
                  case Code128Reader.CODE_FNC_1:
                    if (convertFNC1) {
                      if (result.length === 0) {
                        result += "]C1";
                      } else {
                        result += String.fromCharCode(29);
                      }
                    }
                    break;
                  case Code128Reader.CODE_CODE_A:
                    codeSet = Code128Reader.CODE_CODE_A;
                    break;
                  case Code128Reader.CODE_CODE_B:
                    codeSet = Code128Reader.CODE_CODE_B;
                    break;
                  case Code128Reader.CODE_STOP:
                    done = true;
                    break;
                }
              }
              break;
          }
          if (unshift) {
            codeSet = codeSet === Code128Reader.CODE_CODE_A ? Code128Reader.CODE_CODE_B : Code128Reader.CODE_CODE_A;
          }
        }
        const lastPatternSize = nextStart - lastStart;
        nextStart = row.getNextUnset(nextStart);
        if (!row.isRange(nextStart, Math.min(row.getSize(), nextStart + (nextStart - lastStart) / 2), false)) {
          throw new NotFoundException();
        }
        checksumTotal -= multiplier * lastCode;
        if (checksumTotal % 103 !== lastCode) {
          throw new ChecksumException();
        }
        const resultLength = result.length;
        if (resultLength === 0) {
          throw new NotFoundException();
        }
        if (resultLength > 0 && lastCharacterWasPrintable) {
          if (codeSet === Code128Reader.CODE_CODE_C) {
            result = result.substring(0, resultLength - 2);
          } else {
            result = result.substring(0, resultLength - 1);
          }
        }
        const left = (startPatternInfo[1] + startPatternInfo[0]) / 2;
        const right = lastStart + lastPatternSize / 2;
        const rawCodesSize = rawCodes.length;
        const rawBytes = new Uint8Array(rawCodesSize);
        for (let i3 = 0; i3 < rawCodesSize; i3++) {
          rawBytes[i3] = rawCodes[i3];
        }
        const points = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        return new Result(result, rawBytes, 0, points, BarcodeFormat$1.CODE_128, (/* @__PURE__ */ new Date()).getTime());
      }
    }
    Code128Reader.CODE_PATTERNS = [
      Int32Array.from([2, 1, 2, 2, 2, 2]),
      Int32Array.from([2, 2, 2, 1, 2, 2]),
      Int32Array.from([2, 2, 2, 2, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 2, 3]),
      Int32Array.from([1, 2, 1, 3, 2, 2]),
      Int32Array.from([1, 3, 1, 2, 2, 2]),
      Int32Array.from([1, 2, 2, 2, 1, 3]),
      Int32Array.from([1, 2, 2, 3, 1, 2]),
      Int32Array.from([1, 3, 2, 2, 1, 2]),
      Int32Array.from([2, 2, 1, 2, 1, 3]),
      Int32Array.from([2, 2, 1, 3, 1, 2]),
      Int32Array.from([2, 3, 1, 2, 1, 2]),
      Int32Array.from([1, 1, 2, 2, 3, 2]),
      Int32Array.from([1, 2, 2, 1, 3, 2]),
      Int32Array.from([1, 2, 2, 2, 3, 1]),
      Int32Array.from([1, 1, 3, 2, 2, 2]),
      Int32Array.from([1, 2, 3, 1, 2, 2]),
      Int32Array.from([1, 2, 3, 2, 2, 1]),
      Int32Array.from([2, 2, 3, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 3, 2]),
      Int32Array.from([2, 2, 1, 2, 3, 1]),
      Int32Array.from([2, 1, 3, 2, 1, 2]),
      Int32Array.from([2, 2, 3, 1, 1, 2]),
      Int32Array.from([3, 1, 2, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 2, 2, 2]),
      Int32Array.from([3, 2, 1, 1, 2, 2]),
      Int32Array.from([3, 2, 1, 2, 2, 1]),
      Int32Array.from([3, 1, 2, 2, 1, 2]),
      Int32Array.from([3, 2, 2, 1, 1, 2]),
      Int32Array.from([3, 2, 2, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 2, 3]),
      Int32Array.from([2, 1, 2, 3, 2, 1]),
      Int32Array.from([2, 3, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 3, 2, 3]),
      Int32Array.from([1, 3, 1, 1, 2, 3]),
      Int32Array.from([1, 3, 1, 3, 2, 1]),
      Int32Array.from([1, 1, 2, 3, 1, 3]),
      Int32Array.from([1, 3, 2, 1, 1, 3]),
      Int32Array.from([1, 3, 2, 3, 1, 1]),
      Int32Array.from([2, 1, 1, 3, 1, 3]),
      Int32Array.from([2, 3, 1, 1, 1, 3]),
      Int32Array.from([2, 3, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 3, 3]),
      Int32Array.from([1, 1, 2, 3, 3, 1]),
      Int32Array.from([1, 3, 2, 1, 3, 1]),
      Int32Array.from([1, 1, 3, 1, 2, 3]),
      Int32Array.from([1, 1, 3, 3, 2, 1]),
      Int32Array.from([1, 3, 3, 1, 2, 1]),
      Int32Array.from([3, 1, 3, 1, 2, 1]),
      Int32Array.from([2, 1, 1, 3, 3, 1]),
      Int32Array.from([2, 3, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 3, 1, 1, 3]),
      Int32Array.from([2, 1, 3, 3, 1, 1]),
      Int32Array.from([2, 1, 3, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 2, 3]),
      Int32Array.from([3, 1, 1, 3, 2, 1]),
      Int32Array.from([3, 3, 1, 1, 2, 1]),
      Int32Array.from([3, 1, 2, 1, 1, 3]),
      Int32Array.from([3, 1, 2, 3, 1, 1]),
      Int32Array.from([3, 3, 2, 1, 1, 1]),
      Int32Array.from([3, 1, 4, 1, 1, 1]),
      Int32Array.from([2, 2, 1, 4, 1, 1]),
      Int32Array.from([4, 3, 1, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2, 4]),
      Int32Array.from([1, 1, 1, 4, 2, 2]),
      Int32Array.from([1, 2, 1, 1, 2, 4]),
      Int32Array.from([1, 2, 1, 4, 2, 1]),
      Int32Array.from([1, 4, 1, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 2, 2, 1]),
      Int32Array.from([1, 1, 2, 2, 1, 4]),
      Int32Array.from([1, 1, 2, 4, 1, 2]),
      Int32Array.from([1, 2, 2, 1, 1, 4]),
      Int32Array.from([1, 2, 2, 4, 1, 1]),
      Int32Array.from([1, 4, 2, 1, 1, 2]),
      Int32Array.from([1, 4, 2, 2, 1, 1]),
      Int32Array.from([2, 4, 1, 2, 1, 1]),
      Int32Array.from([2, 2, 1, 1, 1, 4]),
      Int32Array.from([4, 1, 3, 1, 1, 1]),
      Int32Array.from([2, 4, 1, 1, 1, 2]),
      Int32Array.from([1, 3, 4, 1, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 4, 2]),
      Int32Array.from([1, 2, 1, 1, 4, 2]),
      Int32Array.from([1, 2, 1, 2, 4, 1]),
      Int32Array.from([1, 1, 4, 2, 1, 2]),
      Int32Array.from([1, 2, 4, 1, 1, 2]),
      Int32Array.from([1, 2, 4, 2, 1, 1]),
      Int32Array.from([4, 1, 1, 2, 1, 2]),
      Int32Array.from([4, 2, 1, 1, 1, 2]),
      Int32Array.from([4, 2, 1, 2, 1, 1]),
      Int32Array.from([2, 1, 2, 1, 4, 1]),
      Int32Array.from([2, 1, 4, 1, 2, 1]),
      Int32Array.from([4, 1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 1, 1, 4, 3]),
      Int32Array.from([1, 1, 1, 3, 4, 1]),
      Int32Array.from([1, 3, 1, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 1, 3]),
      Int32Array.from([1, 1, 4, 3, 1, 1]),
      Int32Array.from([4, 1, 1, 1, 1, 3]),
      Int32Array.from([4, 1, 1, 3, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 4, 1]),
      Int32Array.from([1, 1, 4, 1, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 4, 1]),
      Int32Array.from([4, 1, 1, 1, 3, 1]),
      Int32Array.from([2, 1, 1, 4, 1, 2]),
      Int32Array.from([2, 1, 1, 2, 1, 4]),
      Int32Array.from([2, 1, 1, 2, 3, 2]),
      Int32Array.from([2, 3, 3, 1, 1, 1, 2])
    ];
    Code128Reader.MAX_AVG_VARIANCE = 0.25;
    Code128Reader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    Code128Reader.CODE_SHIFT = 98;
    Code128Reader.CODE_CODE_C = 99;
    Code128Reader.CODE_CODE_B = 100;
    Code128Reader.CODE_CODE_A = 101;
    Code128Reader.CODE_FNC_1 = 102;
    Code128Reader.CODE_FNC_2 = 97;
    Code128Reader.CODE_FNC_3 = 96;
    Code128Reader.CODE_FNC_4_A = 101;
    Code128Reader.CODE_FNC_4_B = 100;
    Code128Reader.CODE_START_A = 103;
    Code128Reader.CODE_START_B = 104;
    Code128Reader.CODE_START_C = 105;
    Code128Reader.CODE_STOP = 106;
    class Code39Reader extends OneDReader {
      /**
       * Creates a reader that assumes all encoded data is data, and does not treat the final
       * character as a check digit. It will not decoded "extended Code 39" sequences.
       */
      // public Code39Reader() {
      //   this(false);
      // }
      /**
       * Creates a reader that can be configured to check the last character as a check digit.
       * It will not decoded "extended Code 39" sequences.
       *
       * @param usingCheckDigit if true, treat the last data character as a check digit, not
       * data, and verify that the checksum passes.
       */
      // public Code39Reader(boolean usingCheckDigit) {
      //   this(usingCheckDigit, false);
      // }
      /**
       * Creates a reader that can be configured to check the last character as a check digit,
       * or optionally attempt to decode "extended Code 39" sequences that are used to encode
       * the full ASCII character set.
       *
       * @param usingCheckDigit if true, treat the last data character as a check digit, not
       * data, and verify that the checksum passes.
       * @param extendedMode if true, will attempt to decode extended Code 39 sequences in the
       * text.
       */
      constructor(usingCheckDigit = false, extendedMode = false) {
        super();
        this.usingCheckDigit = usingCheckDigit;
        this.extendedMode = extendedMode;
        this.decodeRowResult = "";
        this.counters = new Int32Array(9);
      }
      decodeRow(rowNumber, row, hints) {
        let theCounters = this.counters;
        theCounters.fill(0);
        this.decodeRowResult = "";
        let start = Code39Reader.findAsteriskPattern(row, theCounters);
        let nextStart = row.getNextSet(start[1]);
        let end = row.getSize();
        let decodedChar;
        let lastStart;
        do {
          Code39Reader.recordPattern(row, nextStart, theCounters);
          let pattern = Code39Reader.toNarrowWidePattern(theCounters);
          if (pattern < 0) {
            throw new NotFoundException();
          }
          decodedChar = Code39Reader.patternToChar(pattern);
          this.decodeRowResult += decodedChar;
          lastStart = nextStart;
          for (let counter of theCounters) {
            nextStart += counter;
          }
          nextStart = row.getNextSet(nextStart);
        } while (decodedChar !== "*");
        this.decodeRowResult = this.decodeRowResult.substring(0, this.decodeRowResult.length - 1);
        let lastPatternSize = 0;
        for (let counter of theCounters) {
          lastPatternSize += counter;
        }
        let whiteSpaceAfterEnd = nextStart - lastStart - lastPatternSize;
        if (nextStart !== end && whiteSpaceAfterEnd * 2 < lastPatternSize) {
          throw new NotFoundException();
        }
        if (this.usingCheckDigit) {
          let max2 = this.decodeRowResult.length - 1;
          let total = 0;
          for (let i3 = 0; i3 < max2; i3++) {
            total += Code39Reader.ALPHABET_STRING.indexOf(this.decodeRowResult.charAt(i3));
          }
          if (this.decodeRowResult.charAt(max2) !== Code39Reader.ALPHABET_STRING.charAt(total % 43)) {
            throw new ChecksumException();
          }
          this.decodeRowResult = this.decodeRowResult.substring(0, max2);
        }
        if (this.decodeRowResult.length === 0) {
          throw new NotFoundException();
        }
        let resultString;
        if (this.extendedMode) {
          resultString = Code39Reader.decodeExtended(this.decodeRowResult);
        } else {
          resultString = this.decodeRowResult;
        }
        let left = (start[1] + start[0]) / 2;
        let right = lastStart + lastPatternSize / 2;
        return new Result(resultString, null, 0, [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)], BarcodeFormat$1.CODE_39, (/* @__PURE__ */ new Date()).getTime());
      }
      static findAsteriskPattern(row, counters) {
        let width = row.getSize();
        let rowOffset = row.getNextSet(0);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let isWhite = false;
        let patternLength = counters.length;
        for (let i3 = rowOffset; i3 < width; i3++) {
          if (row.get(i3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (this.toNarrowWidePattern(counters) === Code39Reader.ASTERISK_ENCODING && row.isRange(Math.max(0, patternStart - Math.floor((i3 - patternStart) / 2)), patternStart, false)) {
                return [patternStart, i3];
              }
              patternStart += counters[0] + counters[1];
              counters.copyWithin(0, 2, 2 + counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      // For efficiency, returns -1 on failure. Not throwing here saved as many as 700 exceptions
      // per image when using some of our blackbox images.
      static toNarrowWidePattern(counters) {
        let numCounters = counters.length;
        let maxNarrowCounter = 0;
        let wideCounters;
        do {
          let minCounter = 2147483647;
          for (let counter of counters) {
            if (counter < minCounter && counter > maxNarrowCounter) {
              minCounter = counter;
            }
          }
          maxNarrowCounter = minCounter;
          wideCounters = 0;
          let totalWideCountersWidth = 0;
          let pattern = 0;
          for (let i3 = 0; i3 < numCounters; i3++) {
            let counter = counters[i3];
            if (counter > maxNarrowCounter) {
              pattern |= 1 << numCounters - 1 - i3;
              wideCounters++;
              totalWideCountersWidth += counter;
            }
          }
          if (wideCounters === 3) {
            for (let i3 = 0; i3 < numCounters && wideCounters > 0; i3++) {
              let counter = counters[i3];
              if (counter > maxNarrowCounter) {
                wideCounters--;
                if (counter * 2 >= totalWideCountersWidth) {
                  return -1;
                }
              }
            }
            return pattern;
          }
        } while (wideCounters > 3);
        return -1;
      }
      static patternToChar(pattern) {
        for (let i3 = 0; i3 < Code39Reader.CHARACTER_ENCODINGS.length; i3++) {
          if (Code39Reader.CHARACTER_ENCODINGS[i3] === pattern) {
            return Code39Reader.ALPHABET_STRING.charAt(i3);
          }
        }
        if (pattern === Code39Reader.ASTERISK_ENCODING) {
          return "*";
        }
        throw new NotFoundException();
      }
      static decodeExtended(encoded) {
        let length = encoded.length;
        let decoded = "";
        for (let i3 = 0; i3 < length; i3++) {
          let c3 = encoded.charAt(i3);
          if (c3 === "+" || c3 === "$" || c3 === "%" || c3 === "/") {
            let next = encoded.charAt(i3 + 1);
            let decodedChar = "\0";
            switch (c3) {
              case "+":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 32);
                } else {
                  throw new FormatException();
                }
                break;
              case "$":
                if (next >= "A" && next <= "Z") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 64);
                } else {
                  throw new FormatException();
                }
                break;
              case "%":
                if (next >= "A" && next <= "E") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 38);
                } else if (next >= "F" && next <= "J") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 11);
                } else if (next >= "K" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 16);
                } else if (next >= "P" && next <= "T") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) + 43);
                } else if (next === "U") {
                  decodedChar = "\0";
                } else if (next === "V") {
                  decodedChar = "@";
                } else if (next === "W") {
                  decodedChar = "`";
                } else if (next === "X" || next === "Y" || next === "Z") {
                  decodedChar = "";
                } else {
                  throw new FormatException();
                }
                break;
              case "/":
                if (next >= "A" && next <= "O") {
                  decodedChar = String.fromCharCode(next.charCodeAt(0) - 32);
                } else if (next === "Z") {
                  decodedChar = ":";
                } else {
                  throw new FormatException();
                }
                break;
            }
            decoded += decodedChar;
            i3++;
          } else {
            decoded += c3;
          }
        }
        return decoded;
      }
    }
    Code39Reader.ALPHABET_STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%";
    Code39Reader.CHARACTER_ENCODINGS = [
      52,
      289,
      97,
      352,
      49,
      304,
      112,
      37,
      292,
      100,
      265,
      73,
      328,
      25,
      280,
      88,
      13,
      268,
      76,
      28,
      259,
      67,
      322,
      19,
      274,
      82,
      7,
      262,
      70,
      22,
      385,
      193,
      448,
      145,
      400,
      208,
      133,
      388,
      196,
      168,
      162,
      138,
      42
      // /-%
    ];
    Code39Reader.ASTERISK_ENCODING = 148;
    class ITFReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.narrowLineWidth = -1;
      }
      // See ITFWriter.PATTERNS
      /*
      
        /!**
         * Patterns of Wide / Narrow lines to indicate each digit
         *!/
        */
      decodeRow(rowNumber, row, hints) {
        let startRange = this.decodeStart(row);
        let endRange = this.decodeEnd(row);
        let result = new StringBuilder();
        ITFReader.decodeMiddle(row, startRange[1], endRange[0], result);
        let resultString = result.toString();
        let allowedLengths = null;
        if (hints != null) {
          allowedLengths = hints.get(DecodeHintType$1.ALLOWED_LENGTHS);
        }
        if (allowedLengths == null) {
          allowedLengths = ITFReader.DEFAULT_ALLOWED_LENGTHS;
        }
        let length = resultString.length;
        let lengthOK = false;
        let maxAllowedLength = 0;
        for (let value of allowedLengths) {
          if (length === value) {
            lengthOK = true;
            break;
          }
          if (value > maxAllowedLength) {
            maxAllowedLength = value;
          }
        }
        if (!lengthOK && length > maxAllowedLength) {
          lengthOK = true;
        }
        if (!lengthOK) {
          throw new FormatException();
        }
        const points = [new ResultPoint(startRange[1], rowNumber), new ResultPoint(endRange[0], rowNumber)];
        let resultReturn = new Result(
          resultString,
          null,
          // no natural byte representation for these barcodes
          0,
          points,
          BarcodeFormat$1.ITF,
          (/* @__PURE__ */ new Date()).getTime()
        );
        return resultReturn;
      }
      /*
      /!**
       * @param row          row of black/white values to search
       * @param payloadStart offset of start pattern
       * @param resultString {@link StringBuilder} to append decoded chars to
       * @throws NotFoundException if decoding could not complete successfully
       *!/*/
      static decodeMiddle(row, payloadStart, payloadEnd, resultString) {
        let counterDigitPair = new Int32Array(10);
        let counterBlack = new Int32Array(5);
        let counterWhite = new Int32Array(5);
        counterDigitPair.fill(0);
        counterBlack.fill(0);
        counterWhite.fill(0);
        while (payloadStart < payloadEnd) {
          OneDReader.recordPattern(row, payloadStart, counterDigitPair);
          for (let k3 = 0; k3 < 5; k3++) {
            let twoK = 2 * k3;
            counterBlack[k3] = counterDigitPair[twoK];
            counterWhite[k3] = counterDigitPair[twoK + 1];
          }
          let bestMatch = ITFReader.decodeDigit(counterBlack);
          resultString.append(bestMatch.toString());
          bestMatch = this.decodeDigit(counterWhite);
          resultString.append(bestMatch.toString());
          counterDigitPair.forEach(function(counterDigit) {
            payloadStart += counterDigit;
          });
        }
      }
      /*/!**
       * Identify where the start of the middle / payload section starts.
       *
       * @param row row of black/white values to search
       * @return Array, containing index of start of 'start block' and end of
       *         'start block'
       *!/*/
      decodeStart(row) {
        let endStart = ITFReader.skipWhiteSpace(row);
        let startPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.START_PATTERN);
        this.narrowLineWidth = (startPattern[1] - startPattern[0]) / 4;
        this.validateQuietZone(row, startPattern[0]);
        return startPattern;
      }
      /*/!**
       * The start & end patterns must be pre/post fixed by a quiet zone. This
       * zone must be at least 10 times the width of a narrow line.  Scan back until
       * we either get to the start of the barcode or match the necessary number of
       * quiet zone pixels.
       *
       * Note: Its assumed the row is reversed when using this method to find
       * quiet zone after the end pattern.
       *
       * ref: http://www.barcode-1.net/i25code.html
       *
       * @param row bit array representing the scanned barcode.
       * @param startPattern index into row of the start or end pattern.
       * @throws NotFoundException if the quiet zone cannot be found
       *!/*/
      validateQuietZone(row, startPattern) {
        let quietCount = this.narrowLineWidth * 10;
        quietCount = quietCount < startPattern ? quietCount : startPattern;
        for (let i3 = startPattern - 1; quietCount > 0 && i3 >= 0; i3--) {
          if (row.get(i3)) {
            break;
          }
          quietCount--;
        }
        if (quietCount !== 0) {
          throw new NotFoundException();
        }
      }
      /*
      /!**
       * Skip all whitespace until we get to the first black line.
       *
       * @param row row of black/white values to search
       * @return index of the first black line.
       * @throws NotFoundException Throws exception if no black lines are found in the row
       *!/*/
      static skipWhiteSpace(row) {
        const width = row.getSize();
        const endStart = row.getNextSet(0);
        if (endStart === width) {
          throw new NotFoundException();
        }
        return endStart;
      }
      /*/!**
       * Identify where the end of the middle / payload section ends.
       *
       * @param row row of black/white values to search
       * @return Array, containing index of start of 'end block' and end of 'end
       *         block'
       *!/*/
      decodeEnd(row) {
        row.reverse();
        try {
          let endStart = ITFReader.skipWhiteSpace(row);
          let endPattern;
          try {
            endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[0]);
          } catch (error) {
            if (error instanceof NotFoundException) {
              endPattern = ITFReader.findGuardPattern(row, endStart, ITFReader.END_PATTERN_REVERSED[1]);
            }
          }
          this.validateQuietZone(row, endPattern[0]);
          let temp = endPattern[0];
          endPattern[0] = row.getSize() - endPattern[1];
          endPattern[1] = row.getSize() - temp;
          return endPattern;
        } finally {
          row.reverse();
        }
      }
      /*
      /!**
       * @param row       row of black/white values to search
       * @param rowOffset position to start search
       * @param pattern   pattern of counts of number of black and white pixels that are
       *                  being searched for as a pattern
       * @return start/end horizontal offset of guard pattern, as an array of two
       *         ints
       * @throws NotFoundException if pattern is not found
       *!/*/
      static findGuardPattern(row, rowOffset, pattern) {
        let patternLength = pattern.length;
        let counters = new Int32Array(patternLength);
        let width = row.getSize();
        let isWhite = false;
        let counterPosition = 0;
        let patternStart = rowOffset;
        counters.fill(0);
        for (let x3 = rowOffset; x3 < width; x3++) {
          if (row.get(x3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE) < ITFReader.MAX_AVG_VARIANCE) {
                return [patternStart, x3];
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      /*/!**
       * Attempts to decode a sequence of ITF black/white lines into single
       * digit.
       *
       * @param counters the counts of runs of observed black/white/black/... values
       * @return The decoded digit
       * @throws NotFoundException if digit cannot be decoded
       *!/*/
      static decodeDigit(counters) {
        let bestVariance = ITFReader.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max2 = ITFReader.PATTERNS.length;
        for (let i3 = 0; i3 < max2; i3++) {
          let pattern = ITFReader.PATTERNS[i3];
          let variance = OneDReader.patternMatchVariance(counters, pattern, ITFReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i3;
          } else if (variance === bestVariance) {
            bestMatch = -1;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch % 10;
        } else {
          throw new NotFoundException();
        }
      }
    }
    ITFReader.PATTERNS = [
      Int32Array.from([1, 1, 2, 2, 1]),
      Int32Array.from([2, 1, 1, 1, 2]),
      Int32Array.from([1, 2, 1, 1, 2]),
      Int32Array.from([2, 2, 1, 1, 1]),
      Int32Array.from([1, 1, 2, 1, 2]),
      Int32Array.from([2, 1, 2, 1, 1]),
      Int32Array.from([1, 2, 2, 1, 1]),
      Int32Array.from([1, 1, 1, 2, 2]),
      Int32Array.from([2, 1, 1, 2, 1]),
      Int32Array.from([1, 2, 1, 2, 1]),
      Int32Array.from([1, 1, 3, 3, 1]),
      Int32Array.from([3, 1, 1, 1, 3]),
      Int32Array.from([1, 3, 1, 1, 3]),
      Int32Array.from([3, 3, 1, 1, 1]),
      Int32Array.from([1, 1, 3, 1, 3]),
      Int32Array.from([3, 1, 3, 1, 1]),
      Int32Array.from([1, 3, 3, 1, 1]),
      Int32Array.from([1, 1, 1, 3, 3]),
      Int32Array.from([3, 1, 1, 3, 1]),
      Int32Array.from([1, 3, 1, 3, 1])
      // 9
    ];
    ITFReader.MAX_AVG_VARIANCE = 0.38;
    ITFReader.MAX_INDIVIDUAL_VARIANCE = 0.5;
    ITFReader.DEFAULT_ALLOWED_LENGTHS = [6, 8, 10, 12, 14];
    ITFReader.START_PATTERN = Int32Array.from([1, 1, 1, 1]);
    ITFReader.END_PATTERN_REVERSED = [
      Int32Array.from([1, 1, 2]),
      Int32Array.from([1, 1, 3])
      // 3x
    ];
    class AbstractUPCEANReader extends OneDReader {
      constructor() {
        super(...arguments);
        this.decodeRowStringBuffer = "";
      }
      static findStartGuardPattern(row) {
        let foundStart = false;
        let startRange;
        let nextStart = 0;
        let counters = Int32Array.from([0, 0, 0]);
        while (!foundStart) {
          counters = Int32Array.from([0, 0, 0]);
          startRange = AbstractUPCEANReader.findGuardPattern(row, nextStart, false, this.START_END_PATTERN, counters);
          let start = startRange[0];
          nextStart = startRange[1];
          let quietStart = start - (nextStart - start);
          if (quietStart >= 0) {
            foundStart = row.isRange(quietStart, start, false);
          }
        }
        return startRange;
      }
      static checkChecksum(s4) {
        return AbstractUPCEANReader.checkStandardUPCEANChecksum(s4);
      }
      static checkStandardUPCEANChecksum(s4) {
        let length = s4.length;
        if (length === 0)
          return false;
        let check = parseInt(s4.charAt(length - 1), 10);
        return AbstractUPCEANReader.getStandardUPCEANChecksum(s4.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s4) {
        let length = s4.length;
        let sum = 0;
        for (let i3 = length - 1; i3 >= 0; i3 -= 2) {
          let digit = s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i3 = length - 2; i3 >= 0; i3 -= 2) {
          let digit = s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
      static decodeEnd(row, endStart) {
        return AbstractUPCEANReader.findGuardPattern(row, endStart, false, AbstractUPCEANReader.START_END_PATTERN, new Int32Array(AbstractUPCEANReader.START_END_PATTERN.length).fill(0));
      }
      /**
       * @throws NotFoundException
       */
      static findGuardPatternWithoutCounters(row, rowOffset, whiteFirst, pattern) {
        return this.findGuardPattern(row, rowOffset, whiteFirst, pattern, new Int32Array(pattern.length));
      }
      /**
       * @param row row of black/white values to search
       * @param rowOffset position to start search
       * @param whiteFirst if true, indicates that the pattern specifies white/black/white/...
       * pixel counts, otherwise, it is interpreted as black/white/black/...
       * @param pattern pattern of counts of number of black and white pixels that are being
       * searched for as a pattern
       * @param counters array of counters, as long as pattern, to re-use
       * @return start/end horizontal offset of guard pattern, as an array of two ints
       * @throws NotFoundException if pattern is not found
       */
      static findGuardPattern(row, rowOffset, whiteFirst, pattern, counters) {
        let width = row.getSize();
        rowOffset = whiteFirst ? row.getNextUnset(rowOffset) : row.getNextSet(rowOffset);
        let counterPosition = 0;
        let patternStart = rowOffset;
        let patternLength = pattern.length;
        let isWhite = whiteFirst;
        for (let x3 = rowOffset; x3 < width; x3++) {
          if (row.get(x3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE) < AbstractUPCEANReader.MAX_AVG_VARIANCE) {
                return Int32Array.from([patternStart, x3]);
              }
              patternStart += counters[0] + counters[1];
              let slice = counters.slice(2, counters.length - 1);
              for (let i3 = 0; i3 < counterPosition - 1; i3++) {
                counters[i3] = slice[i3];
              }
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static decodeDigit(row, counters, rowOffset, patterns) {
        this.recordPattern(row, rowOffset, counters);
        let bestVariance = this.MAX_AVG_VARIANCE;
        let bestMatch = -1;
        let max2 = patterns.length;
        for (let i3 = 0; i3 < max2; i3++) {
          let pattern = patterns[i3];
          let variance = OneDReader.patternMatchVariance(counters, pattern, AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE);
          if (variance < bestVariance) {
            bestVariance = variance;
            bestMatch = i3;
          }
        }
        if (bestMatch >= 0) {
          return bestMatch;
        } else {
          throw new NotFoundException();
        }
      }
    }
    AbstractUPCEANReader.MAX_AVG_VARIANCE = 0.48;
    AbstractUPCEANReader.MAX_INDIVIDUAL_VARIANCE = 0.7;
    AbstractUPCEANReader.START_END_PATTERN = Int32Array.from([1, 1, 1]);
    AbstractUPCEANReader.MIDDLE_PATTERN = Int32Array.from([1, 1, 1, 1, 1]);
    AbstractUPCEANReader.END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    AbstractUPCEANReader.L_PATTERNS = [
      Int32Array.from([3, 2, 1, 1]),
      Int32Array.from([2, 2, 2, 1]),
      Int32Array.from([2, 1, 2, 2]),
      Int32Array.from([1, 4, 1, 1]),
      Int32Array.from([1, 1, 3, 2]),
      Int32Array.from([1, 2, 3, 1]),
      Int32Array.from([1, 1, 1, 4]),
      Int32Array.from([1, 3, 1, 2]),
      Int32Array.from([1, 2, 1, 3]),
      Int32Array.from([3, 1, 1, 2])
    ];
    class UPCEANExtension5Support {
      constructor() {
        this.CHECK_DIGIT_ENCODINGS = [24, 20, 18, 17, 12, 6, 3, 10, 9, 5];
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension5Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x3 = 0; x3 < 5 && rowOffset < end; x3++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(
            row,
            counters,
            rowOffset,
            AbstractUPCEANReader.L_AND_G_PATTERNS
          );
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 4 - x3;
          }
          if (x3 !== 4) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 5) {
          throw new NotFoundException();
        }
        let checkDigit = this.determineCheckDigit(lgPatternFound);
        if (UPCEANExtension5Support.extensionChecksum(resultString.toString()) !== checkDigit) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static extensionChecksum(s4) {
        let length = s4.length;
        let sum = 0;
        for (let i3 = length - 2; i3 >= 0; i3 -= 2) {
          sum += s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        for (let i3 = length - 1; i3 >= 0; i3 -= 2) {
          sum += s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
        }
        sum *= 3;
        return sum % 10;
      }
      determineCheckDigit(lgPatternFound) {
        for (let d4 = 0; d4 < 10; d4++) {
          if (lgPatternFound === this.CHECK_DIGIT_ENCODINGS[d4]) {
            return d4;
          }
        }
        throw new NotFoundException();
      }
      static parseExtensionString(raw) {
        if (raw.length !== 5) {
          return null;
        }
        let value = UPCEANExtension5Support.parseExtension5String(raw);
        if (value == null) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.SUGGESTED_PRICE, value]]);
      }
      static parseExtension5String(raw) {
        let currency;
        switch (raw.charAt(0)) {
          case "0":
            currency = "£";
            break;
          case "5":
            currency = "$";
            break;
          case "9":
            switch (raw) {
              case "90000":
                return null;
              case "99991":
                return "0.00";
              case "99990":
                return "Used";
            }
            currency = "";
            break;
          default:
            currency = "";
            break;
        }
        let rawAmount = parseInt(raw.substring(1));
        let unitsString = (rawAmount / 100).toString();
        let hundredths = rawAmount % 100;
        let hundredthsString = hundredths < 10 ? "0" + hundredths : hundredths.toString();
        return currency + unitsString + "." + hundredthsString;
      }
    }
    class UPCEANExtension2Support {
      constructor() {
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
        this.decodeRowStringBuffer = "";
      }
      decodeRow(rowNumber, row, extensionStartRange) {
        let result = this.decodeRowStringBuffer;
        let end = this.decodeMiddle(row, extensionStartRange, result);
        let resultString = result.toString();
        let extensionData = UPCEANExtension2Support.parseExtensionString(resultString);
        let resultPoints = [
          new ResultPoint((extensionStartRange[0] + extensionStartRange[1]) / 2, rowNumber),
          new ResultPoint(end, rowNumber)
        ];
        let extensionResult = new Result(resultString, null, 0, resultPoints, BarcodeFormat$1.UPC_EAN_EXTENSION, (/* @__PURE__ */ new Date()).getTime());
        if (extensionData != null) {
          extensionResult.putAllMetadata(extensionData);
        }
        return extensionResult;
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let checkParity = 0;
        for (let x3 = 0; x3 < 2 && rowOffset < end; x3++) {
          let bestMatch = AbstractUPCEANReader.decodeDigit(row, counters, rowOffset, AbstractUPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            checkParity |= 1 << 1 - x3;
          }
          if (x3 !== 1) {
            rowOffset = row.getNextSet(rowOffset);
            rowOffset = row.getNextUnset(rowOffset);
          }
        }
        if (resultString.length !== 2) {
          throw new NotFoundException();
        }
        if (parseInt(resultString.toString()) % 4 !== checkParity) {
          throw new NotFoundException();
        }
        return rowOffset;
      }
      static parseExtensionString(raw) {
        if (raw.length !== 2) {
          return null;
        }
        return /* @__PURE__ */ new Map([[ResultMetadataType$1.ISSUE_NUMBER, parseInt(raw)]]);
      }
    }
    class UPCEANExtensionSupport {
      static decodeRow(rowNumber, row, rowOffset) {
        let extensionStartRange = AbstractUPCEANReader.findGuardPattern(
          row,
          rowOffset,
          false,
          this.EXTENSION_START_PATTERN,
          new Int32Array(this.EXTENSION_START_PATTERN.length).fill(0)
        );
        try {
          let fiveSupport = new UPCEANExtension5Support();
          return fiveSupport.decodeRow(rowNumber, row, extensionStartRange);
        } catch (err) {
          let twoSupport = new UPCEANExtension2Support();
          return twoSupport.decodeRow(rowNumber, row, extensionStartRange);
        }
      }
    }
    UPCEANExtensionSupport.EXTENSION_START_PATTERN = Int32Array.from([1, 1, 2]);
    class UPCEANReader extends AbstractUPCEANReader {
      constructor() {
        super();
        this.decodeRowStringBuffer = "";
        UPCEANReader.L_AND_G_PATTERNS = UPCEANReader.L_PATTERNS.map((arr) => Int32Array.from(arr));
        for (let i3 = 10; i3 < 20; i3++) {
          let widths = UPCEANReader.L_PATTERNS[i3 - 10];
          let reversedWidths = new Int32Array(widths.length);
          for (let j2 = 0; j2 < widths.length; j2++) {
            reversedWidths[j2] = widths[widths.length - j2 - 1];
          }
          UPCEANReader.L_AND_G_PATTERNS[i3] = reversedWidths;
        }
      }
      decodeRow(rowNumber, row, hints) {
        let startGuardRange = UPCEANReader.findStartGuardPattern(row);
        let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((startGuardRange[0] + startGuardRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let budello = this.decodeMiddle(row, startGuardRange, this.decodeRowStringBuffer);
        let endStart = budello.rowOffset;
        let result = budello.resultString;
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint(endStart, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let endRange = this.decodeEnd(row, endStart);
        if (resultPointCallback != null) {
          const resultPoint2 = new ResultPoint((endRange[0] + endRange[1]) / 2, rowNumber);
          resultPointCallback.foundPossibleResultPoint(resultPoint2);
        }
        let end = endRange[1];
        let quietEnd = end + (end - endRange[0]);
        if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
          throw new NotFoundException();
        }
        let resultString = result.toString();
        if (resultString.length < 8) {
          throw new FormatException();
        }
        if (!UPCEANReader.checkChecksum(resultString)) {
          throw new ChecksumException();
        }
        let left = (startGuardRange[1] + startGuardRange[0]) / 2;
        let right = (endRange[1] + endRange[0]) / 2;
        let format2 = this.getBarcodeFormat();
        let resultPoint = [new ResultPoint(left, rowNumber), new ResultPoint(right, rowNumber)];
        let decodeResult = new Result(resultString, null, 0, resultPoint, format2, (/* @__PURE__ */ new Date()).getTime());
        let extensionLength = 0;
        try {
          let extensionResult = UPCEANExtensionSupport.decodeRow(rowNumber, row, endRange[1]);
          decodeResult.putMetadata(ResultMetadataType$1.UPC_EAN_EXTENSION, extensionResult.getText());
          decodeResult.putAllMetadata(extensionResult.getResultMetadata());
          decodeResult.addResultPoints(extensionResult.getResultPoints());
          extensionLength = extensionResult.getText().length;
        } catch (ignoreError) {
        }
        let allowedExtensions = hints == null ? null : hints.get(DecodeHintType$1.ALLOWED_EAN_EXTENSIONS);
        if (allowedExtensions != null) {
          let valid = false;
          for (let length in allowedExtensions) {
            if (extensionLength.toString() === length) {
              valid = true;
              break;
            }
          }
          if (!valid) {
            throw new NotFoundException();
          }
        }
        return decodeResult;
      }
      decodeEnd(row, endStart) {
        return UPCEANReader.findGuardPattern(
          row,
          endStart,
          false,
          UPCEANReader.START_END_PATTERN,
          new Int32Array(UPCEANReader.START_END_PATTERN.length).fill(0)
        );
      }
      static checkChecksum(s4) {
        return UPCEANReader.checkStandardUPCEANChecksum(s4);
      }
      static checkStandardUPCEANChecksum(s4) {
        let length = s4.length;
        if (length === 0)
          return false;
        let check = parseInt(s4.charAt(length - 1), 10);
        return UPCEANReader.getStandardUPCEANChecksum(s4.substring(0, length - 1)) === check;
      }
      static getStandardUPCEANChecksum(s4) {
        let length = s4.length;
        let sum = 0;
        for (let i3 = length - 1; i3 >= 0; i3 -= 2) {
          let digit = s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        sum *= 3;
        for (let i3 = length - 2; i3 >= 0; i3 -= 2) {
          let digit = s4.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          if (digit < 0 || digit > 9) {
            throw new FormatException();
          }
          sum += digit;
        }
        return (1e3 - sum) % 10;
      }
    }
    class EAN13Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        let counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x3 = 0; x3 < 6 && rowOffset < end; x3++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_AND_G_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x3;
          }
        }
        resultString = EAN13Reader.determineFirstDigit(resultString, lgPatternFound);
        let middleRange = UPCEANReader.findGuardPattern(
          row,
          rowOffset,
          true,
          UPCEANReader.MIDDLE_PATTERN,
          new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0)
        );
        rowOffset = middleRange[1];
        for (let x3 = 0; x3 < 6 && rowOffset < end; x3++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_13;
      }
      static determineFirstDigit(resultString, lgPatternFound) {
        for (let d4 = 0; d4 < 10; d4++) {
          if (lgPatternFound === this.FIRST_DIGIT_ENCODINGS[d4]) {
            resultString = String.fromCharCode("0".charCodeAt(0) + d4) + resultString;
            return resultString;
          }
        }
        throw new NotFoundException();
      }
    }
    EAN13Reader.FIRST_DIGIT_ENCODINGS = [0, 11, 13, 14, 19, 25, 28, 21, 22, 26];
    class EAN8Reader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = Int32Array.from([0, 0, 0, 0]);
      }
      decodeMiddle(row, startRange, resultString) {
        const counters = this.decodeMiddleCounters;
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let end = row.getSize();
        let rowOffset = startRange[1];
        for (let x3 = 0; x3 < 4 && rowOffset < end; x3++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        let middleRange = UPCEANReader.findGuardPattern(row, rowOffset, true, UPCEANReader.MIDDLE_PATTERN, new Int32Array(UPCEANReader.MIDDLE_PATTERN.length).fill(0));
        rowOffset = middleRange[1];
        for (let x3 = 0; x3 < 4 && rowOffset < end; x3++) {
          let bestMatch = UPCEANReader.decodeDigit(row, counters, rowOffset, UPCEANReader.L_PATTERNS);
          resultString += String.fromCharCode("0".charCodeAt(0) + bestMatch);
          for (let counter of counters) {
            rowOffset += counter;
          }
        }
        return { rowOffset, resultString };
      }
      getBarcodeFormat() {
        return BarcodeFormat$1.EAN_8;
      }
    }
    class UPCAReader extends UPCEANReader {
      constructor() {
        super(...arguments);
        this.ean13Reader = new EAN13Reader();
      }
      // @Override
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_A;
      }
      // Note that we don't try rotation without the try harder flag, even if rotation was supported.
      // @Override
      decode(image, hints) {
        return this.maybeReturnResult(this.ean13Reader.decode(image));
      }
      // @Override
      decodeRow(rowNumber, row, hints) {
        return this.maybeReturnResult(this.ean13Reader.decodeRow(rowNumber, row, hints));
      }
      // @Override
      decodeMiddle(row, startRange, resultString) {
        return this.ean13Reader.decodeMiddle(row, startRange, resultString);
      }
      maybeReturnResult(result) {
        let text = result.getText();
        if (text.charAt(0) === "0") {
          let upcaResult = new Result(text.substring(1), null, null, result.getResultPoints(), BarcodeFormat$1.UPC_A);
          if (result.getResultMetadata() != null) {
            upcaResult.putAllMetadata(result.getResultMetadata());
          }
          return upcaResult;
        } else {
          throw new NotFoundException();
        }
      }
      reset() {
        this.ean13Reader.reset();
      }
    }
    class UPCEReader extends UPCEANReader {
      constructor() {
        super();
        this.decodeMiddleCounters = new Int32Array(4);
      }
      /**
       * @throws NotFoundException
       */
      // @Override
      decodeMiddle(row, startRange, result) {
        const counters = this.decodeMiddleCounters.map((x3) => x3);
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        const end = row.getSize();
        let rowOffset = startRange[1];
        let lgPatternFound = 0;
        for (let x3 = 0; x3 < 6 && rowOffset < end; x3++) {
          const bestMatch = UPCEReader.decodeDigit(
            row,
            counters,
            rowOffset,
            UPCEReader.L_AND_G_PATTERNS
          );
          result += String.fromCharCode("0".charCodeAt(0) + bestMatch % 10);
          for (let counter of counters) {
            rowOffset += counter;
          }
          if (bestMatch >= 10) {
            lgPatternFound |= 1 << 5 - x3;
          }
        }
        let resultString = UPCEReader.determineNumSysAndCheckDigit(
          result,
          lgPatternFound
        );
        return { rowOffset, resultString };
      }
      /**
       * @throws NotFoundException
       */
      // @Override
      decodeEnd(row, endStart) {
        return UPCEReader.findGuardPatternWithoutCounters(
          row,
          endStart,
          true,
          UPCEReader.MIDDLE_END_PATTERN
        );
      }
      /**
       * @throws FormatException
       */
      // @Override
      checkChecksum(s4) {
        return UPCEANReader.checkChecksum(UPCEReader.convertUPCEtoUPCA(s4));
      }
      /**
       * @throws NotFoundException
       */
      static determineNumSysAndCheckDigit(resultString, lgPatternFound) {
        for (let numSys = 0; numSys <= 1; numSys++) {
          for (let d4 = 0; d4 < 10; d4++) {
            if (lgPatternFound === this.NUMSYS_AND_CHECK_DIGIT_PATTERNS[numSys][d4]) {
              let prefix = String.fromCharCode("0".charCodeAt(0) + numSys);
              let suffix = String.fromCharCode("0".charCodeAt(0) + d4);
              return prefix + resultString + suffix;
            }
          }
        }
        throw NotFoundException.getNotFoundInstance();
      }
      // @Override
      getBarcodeFormat() {
        return BarcodeFormat$1.UPC_E;
      }
      /**
       * Expands a UPC-E value back into its full, equivalent UPC-A code value.
       *
       * @param upce UPC-E code as string of digits
       * @return equivalent UPC-A code as string of digits
       */
      static convertUPCEtoUPCA(upce) {
        const upceChars = upce.slice(1, 7).split("").map((x3) => x3.charCodeAt(0));
        const result = new StringBuilder(
          /*12*/
        );
        result.append(upce.charAt(0));
        let lastChar = upceChars[5];
        switch (lastChar) {
          case 0:
          case 1:
          case 2:
            result.appendChars(upceChars, 0, 2);
            result.append(lastChar);
            result.append("0000");
            result.appendChars(upceChars, 2, 3);
            break;
          case 3:
            result.appendChars(upceChars, 0, 3);
            result.append("00000");
            result.appendChars(upceChars, 3, 2);
            break;
          case 4:
            result.appendChars(upceChars, 0, 4);
            result.append("00000");
            result.append(upceChars[4]);
            break;
          default:
            result.appendChars(upceChars, 0, 5);
            result.append("0000");
            result.append(lastChar);
            break;
        }
        if (upce.length >= 8) {
          result.append(upce.charAt(7));
        }
        return result.toString();
      }
    }
    UPCEReader.MIDDLE_END_PATTERN = Int32Array.from([1, 1, 1, 1, 1, 1]);
    UPCEReader.NUMSYS_AND_CHECK_DIGIT_PATTERNS = [
      Int32Array.from([56, 52, 50, 49, 44, 38, 35, 42, 41, 37]),
      Int32Array.from([7, 11, 13, 14, 19, 25, 28, 21, 22, 26])
    ];
    class MultiFormatUPCEANReader extends OneDReader {
      constructor(hints) {
        super();
        let possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        let readers = [];
        if (!isNullOrUndefined2(possibleFormats)) {
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_13) > -1) {
            readers.push(new EAN13Reader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.UPC_A) > -1) {
            readers.push(new UPCAReader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.EAN_8) > -1) {
            readers.push(new EAN8Reader());
          }
          if (possibleFormats.indexOf(BarcodeFormat$1.UPC_E) > -1) {
            readers.push(new UPCEReader());
          }
        } else {
          readers.push(new EAN13Reader());
          readers.push(new UPCAReader());
          readers.push(new EAN8Reader());
          readers.push(new UPCEReader());
        }
        this.readers = readers;
      }
      decodeRow(rowNumber, row, hints) {
        for (let reader of this.readers) {
          try {
            const result = reader.decodeRow(rowNumber, row, hints);
            const ean13MayBeUPCA = result.getBarcodeFormat() === BarcodeFormat$1.EAN_13 && result.getText().charAt(0) === "0";
            const possibleFormats = hints == null ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
            const canReturnUPCA = possibleFormats == null || possibleFormats.includes(BarcodeFormat$1.UPC_A);
            if (ean13MayBeUPCA && canReturnUPCA) {
              const rawBytes = result.getRawBytes();
              const resultUPCA = new Result(
                result.getText().substring(1),
                rawBytes,
                rawBytes ? rawBytes.length : null,
                result.getResultPoints(),
                BarcodeFormat$1.UPC_A
              );
              resultUPCA.putAllMetadata(result.getResultMetadata());
              return resultUPCA;
            }
            return result;
          } catch (err) {
          }
        }
        throw new NotFoundException();
      }
      reset() {
        for (let reader of this.readers) {
          reader.reset();
        }
      }
    }
    class AbstractRSSReader extends OneDReader {
      constructor() {
        super();
        this.decodeFinderCounters = new Int32Array(4);
        this.dataCharacterCounters = new Int32Array(8);
        this.oddRoundingErrors = new Array(4);
        this.evenRoundingErrors = new Array(4);
        this.oddCounts = new Array(this.dataCharacterCounters.length / 2);
        this.evenCounts = new Array(this.dataCharacterCounters.length / 2);
      }
      getDecodeFinderCounters() {
        return this.decodeFinderCounters;
      }
      getDataCharacterCounters() {
        return this.dataCharacterCounters;
      }
      getOddRoundingErrors() {
        return this.oddRoundingErrors;
      }
      getEvenRoundingErrors() {
        return this.evenRoundingErrors;
      }
      getOddCounts() {
        return this.oddCounts;
      }
      getEvenCounts() {
        return this.evenCounts;
      }
      parseFinderValue(counters, finderPatterns) {
        for (let value = 0; value < finderPatterns.length; value++) {
          if (OneDReader.patternMatchVariance(counters, finderPatterns[value], AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE) < AbstractRSSReader.MAX_AVG_VARIANCE) {
            return value;
          }
        }
        throw new NotFoundException();
      }
      /**
       * @param array values to sum
       * @return sum of values
       * @deprecated call {@link MathUtils#sum(int[])}
       */
      static count(array) {
        return MathUtils.sum(new Int32Array(array));
      }
      static increment(array, errors) {
        let index2 = 0;
        let biggestError = errors[0];
        for (let i3 = 1; i3 < array.length; i3++) {
          if (errors[i3] > biggestError) {
            biggestError = errors[i3];
            index2 = i3;
          }
        }
        array[index2]++;
      }
      static decrement(array, errors) {
        let index2 = 0;
        let biggestError = errors[0];
        for (let i3 = 1; i3 < array.length; i3++) {
          if (errors[i3] < biggestError) {
            biggestError = errors[i3];
            index2 = i3;
          }
        }
        array[index2]--;
      }
      static isFinderPattern(counters) {
        let firstTwoSum = counters[0] + counters[1];
        let sum = firstTwoSum + counters[2] + counters[3];
        let ratio = firstTwoSum / sum;
        if (ratio >= AbstractRSSReader.MIN_FINDER_PATTERN_RATIO && ratio <= AbstractRSSReader.MAX_FINDER_PATTERN_RATIO) {
          let minCounter = Number.MAX_SAFE_INTEGER;
          let maxCounter = Number.MIN_SAFE_INTEGER;
          for (let counter of counters) {
            if (counter > maxCounter) {
              maxCounter = counter;
            }
            if (counter < minCounter) {
              minCounter = counter;
            }
          }
          return maxCounter < 10 * minCounter;
        }
        return false;
      }
    }
    AbstractRSSReader.MAX_AVG_VARIANCE = 0.2;
    AbstractRSSReader.MAX_INDIVIDUAL_VARIANCE = 0.45;
    AbstractRSSReader.MIN_FINDER_PATTERN_RATIO = 9.5 / 12;
    AbstractRSSReader.MAX_FINDER_PATTERN_RATIO = 12.5 / 14;
    class DataCharacter {
      constructor(value, checksumPortion) {
        this.value = value;
        this.checksumPortion = checksumPortion;
      }
      getValue() {
        return this.value;
      }
      getChecksumPortion() {
        return this.checksumPortion;
      }
      toString() {
        return this.value + "(" + this.checksumPortion + ")";
      }
      equals(o2) {
        if (!(o2 instanceof DataCharacter)) {
          return false;
        }
        const that = o2;
        return this.value === that.value && this.checksumPortion === that.checksumPortion;
      }
      hashCode() {
        return this.value ^ this.checksumPortion;
      }
    }
    class FinderPattern {
      constructor(value, startEnd, start, end, rowNumber) {
        this.value = value;
        this.startEnd = startEnd;
        this.value = value;
        this.startEnd = startEnd;
        this.resultPoints = new Array();
        this.resultPoints.push(new ResultPoint(start, rowNumber));
        this.resultPoints.push(new ResultPoint(end, rowNumber));
      }
      getValue() {
        return this.value;
      }
      getStartEnd() {
        return this.startEnd;
      }
      getResultPoints() {
        return this.resultPoints;
      }
      equals(o2) {
        if (!(o2 instanceof FinderPattern)) {
          return false;
        }
        const that = o2;
        return this.value === that.value;
      }
      hashCode() {
        return this.value;
      }
    }
    class RSSUtils {
      constructor() {
      }
      static getRSSvalue(widths, maxWidth, noNarrow) {
        let n2 = 0;
        for (let width of widths) {
          n2 += width;
        }
        let val = 0;
        let narrowMask = 0;
        let elements = widths.length;
        for (let bar = 0; bar < elements - 1; bar++) {
          let elmWidth;
          for (elmWidth = 1, narrowMask |= 1 << bar; elmWidth < widths[bar]; elmWidth++, narrowMask &= ~(1 << bar)) {
            let subVal = RSSUtils.combins(n2 - elmWidth - 1, elements - bar - 2);
            if (noNarrow && narrowMask === 0 && n2 - elmWidth - (elements - bar - 1) >= elements - bar - 1) {
              subVal -= RSSUtils.combins(n2 - elmWidth - (elements - bar), elements - bar - 2);
            }
            if (elements - bar - 1 > 1) {
              let lessVal = 0;
              for (let mxwElement = n2 - elmWidth - (elements - bar - 2); mxwElement > maxWidth; mxwElement--) {
                lessVal += RSSUtils.combins(n2 - elmWidth - mxwElement - 1, elements - bar - 3);
              }
              subVal -= lessVal * (elements - 1 - bar);
            } else if (n2 - elmWidth > maxWidth) {
              subVal--;
            }
            val += subVal;
          }
          n2 -= elmWidth;
        }
        return val;
      }
      static combins(n2, r2) {
        let maxDenom;
        let minDenom;
        if (n2 - r2 > r2) {
          minDenom = r2;
          maxDenom = n2 - r2;
        } else {
          minDenom = n2 - r2;
          maxDenom = r2;
        }
        let val = 1;
        let j2 = 1;
        for (let i3 = n2; i3 > maxDenom; i3--) {
          val *= i3;
          if (j2 <= minDenom) {
            val /= j2;
            j2++;
          }
        }
        while (j2 <= minDenom) {
          val /= j2;
          j2++;
        }
        return val;
      }
    }
    class BitArrayBuilder {
      static buildBitArray(pairs) {
        let charNumber = pairs.length * 2 - 1;
        if (pairs[pairs.length - 1].getRightChar() == null) {
          charNumber -= 1;
        }
        let size2 = 12 * charNumber;
        let binary = new BitArray(size2);
        let accPos = 0;
        let firstPair = pairs[0];
        let firstValue = firstPair.getRightChar().getValue();
        for (let i3 = 11; i3 >= 0; --i3) {
          if ((firstValue & 1 << i3) != 0) {
            binary.set(accPos);
          }
          accPos++;
        }
        for (let i3 = 1; i3 < pairs.length; ++i3) {
          let currentPair = pairs[i3];
          let leftValue = currentPair.getLeftChar().getValue();
          for (let j2 = 11; j2 >= 0; --j2) {
            if ((leftValue & 1 << j2) != 0) {
              binary.set(accPos);
            }
            accPos++;
          }
          if (currentPair.getRightChar() != null) {
            let rightValue = currentPair.getRightChar().getValue();
            for (let j2 = 11; j2 >= 0; --j2) {
              if ((rightValue & 1 << j2) != 0) {
                binary.set(accPos);
              }
              accPos++;
            }
          }
        }
        return binary;
      }
    }
    class BlockParsedResult {
      constructor(finished, decodedInformation) {
        if (decodedInformation) {
          this.decodedInformation = null;
        } else {
          this.finished = finished;
          this.decodedInformation = decodedInformation;
        }
      }
      getDecodedInformation() {
        return this.decodedInformation;
      }
      isFinished() {
        return this.finished;
      }
    }
    class DecodedObject {
      constructor(newPosition) {
        this.newPosition = newPosition;
      }
      getNewPosition() {
        return this.newPosition;
      }
    }
    class DecodedChar extends DecodedObject {
      constructor(newPosition, value) {
        super(newPosition);
        this.value = value;
      }
      getValue() {
        return this.value;
      }
      isFNC1() {
        return this.value === DecodedChar.FNC1;
      }
    }
    DecodedChar.FNC1 = "$";
    class DecodedInformation extends DecodedObject {
      constructor(newPosition, newString, remainingValue) {
        super(newPosition);
        if (remainingValue) {
          this.remaining = true;
          this.remainingValue = this.remainingValue;
        } else {
          this.remaining = false;
          this.remainingValue = 0;
        }
        this.newString = newString;
      }
      getNewString() {
        return this.newString;
      }
      isRemaining() {
        return this.remaining;
      }
      getRemainingValue() {
        return this.remainingValue;
      }
    }
    class DecodedNumeric extends DecodedObject {
      constructor(newPosition, firstDigit, secondDigit) {
        super(newPosition);
        if (firstDigit < 0 || firstDigit > 10 || secondDigit < 0 || secondDigit > 10) {
          throw new FormatException();
        }
        this.firstDigit = firstDigit;
        this.secondDigit = secondDigit;
      }
      getFirstDigit() {
        return this.firstDigit;
      }
      getSecondDigit() {
        return this.secondDigit;
      }
      getValue() {
        return this.firstDigit * 10 + this.secondDigit;
      }
      isFirstDigitFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1;
      }
      isSecondDigitFNC1() {
        return this.secondDigit === DecodedNumeric.FNC1;
      }
      isAnyFNC1() {
        return this.firstDigit === DecodedNumeric.FNC1 || this.secondDigit === DecodedNumeric.FNC1;
      }
    }
    DecodedNumeric.FNC1 = 10;
    class FieldParser {
      constructor() {
      }
      static parseFieldsInGeneralPurpose(rawInformation) {
        if (!rawInformation) {
          return null;
        }
        if (rawInformation.length < 2) {
          throw new NotFoundException();
        }
        let firstTwoDigits = rawInformation.substring(0, 2);
        for (let dataLength of FieldParser.TWO_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstTwoDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(2, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(2, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 3) {
          throw new NotFoundException();
        }
        let firstThreeDigits = rawInformation.substring(0, 3);
        for (let dataLength of FieldParser.THREE_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(3, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(3, dataLength[1], rawInformation);
          }
        }
        for (let dataLength of FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstThreeDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        if (rawInformation.length < 4) {
          throw new NotFoundException();
        }
        let firstFourDigits = rawInformation.substring(0, 4);
        for (let dataLength of FieldParser.FOUR_DIGIT_DATA_LENGTH) {
          if (dataLength[0] === firstFourDigits) {
            if (dataLength[1] === FieldParser.VARIABLE_LENGTH) {
              return FieldParser.processVariableAI(4, dataLength[2], rawInformation);
            }
            return FieldParser.processFixedAI(4, dataLength[1], rawInformation);
          }
        }
        throw new NotFoundException();
      }
      static processFixedAI(aiSize, fieldSize, rawInformation) {
        if (rawInformation.length < aiSize) {
          throw new NotFoundException();
        }
        let ai2 = rawInformation.substring(0, aiSize);
        if (rawInformation.length < aiSize + fieldSize) {
          throw new NotFoundException();
        }
        let field = rawInformation.substring(aiSize, aiSize + fieldSize);
        let remaining = rawInformation.substring(aiSize + fieldSize);
        let result = "(" + ai2 + ")" + field;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
      static processVariableAI(aiSize, variableFieldSize, rawInformation) {
        let ai2 = rawInformation.substring(0, aiSize);
        let maxSize;
        if (rawInformation.length < aiSize + variableFieldSize) {
          maxSize = rawInformation.length;
        } else {
          maxSize = aiSize + variableFieldSize;
        }
        let field = rawInformation.substring(aiSize, maxSize);
        let remaining = rawInformation.substring(maxSize);
        let result = "(" + ai2 + ")" + field;
        let parsedAI = FieldParser.parseFieldsInGeneralPurpose(remaining);
        return parsedAI == null ? result : result + parsedAI;
      }
    }
    FieldParser.VARIABLE_LENGTH = [];
    FieldParser.TWO_DIGIT_DATA_LENGTH = [
      ["00", 18],
      ["01", 14],
      ["02", 14],
      ["10", FieldParser.VARIABLE_LENGTH, 20],
      ["11", 6],
      ["12", 6],
      ["13", 6],
      ["15", 6],
      ["17", 6],
      ["20", 2],
      ["21", FieldParser.VARIABLE_LENGTH, 20],
      ["22", FieldParser.VARIABLE_LENGTH, 29],
      ["30", FieldParser.VARIABLE_LENGTH, 8],
      ["37", FieldParser.VARIABLE_LENGTH, 8],
      // internal company codes
      ["90", FieldParser.VARIABLE_LENGTH, 30],
      ["91", FieldParser.VARIABLE_LENGTH, 30],
      ["92", FieldParser.VARIABLE_LENGTH, 30],
      ["93", FieldParser.VARIABLE_LENGTH, 30],
      ["94", FieldParser.VARIABLE_LENGTH, 30],
      ["95", FieldParser.VARIABLE_LENGTH, 30],
      ["96", FieldParser.VARIABLE_LENGTH, 30],
      ["97", FieldParser.VARIABLE_LENGTH, 3],
      ["98", FieldParser.VARIABLE_LENGTH, 30],
      ["99", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.THREE_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["240", FieldParser.VARIABLE_LENGTH, 30],
      ["241", FieldParser.VARIABLE_LENGTH, 30],
      ["242", FieldParser.VARIABLE_LENGTH, 6],
      ["250", FieldParser.VARIABLE_LENGTH, 30],
      ["251", FieldParser.VARIABLE_LENGTH, 30],
      ["253", FieldParser.VARIABLE_LENGTH, 17],
      ["254", FieldParser.VARIABLE_LENGTH, 20],
      ["400", FieldParser.VARIABLE_LENGTH, 30],
      ["401", FieldParser.VARIABLE_LENGTH, 30],
      ["402", 17],
      ["403", FieldParser.VARIABLE_LENGTH, 30],
      ["410", 13],
      ["411", 13],
      ["412", 13],
      ["413", 13],
      ["414", 13],
      ["420", FieldParser.VARIABLE_LENGTH, 20],
      ["421", FieldParser.VARIABLE_LENGTH, 15],
      ["422", 3],
      ["423", FieldParser.VARIABLE_LENGTH, 15],
      ["424", 3],
      ["425", 3],
      ["426", 3]
    ];
    FieldParser.THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["310", 6],
      ["311", 6],
      ["312", 6],
      ["313", 6],
      ["314", 6],
      ["315", 6],
      ["316", 6],
      ["320", 6],
      ["321", 6],
      ["322", 6],
      ["323", 6],
      ["324", 6],
      ["325", 6],
      ["326", 6],
      ["327", 6],
      ["328", 6],
      ["329", 6],
      ["330", 6],
      ["331", 6],
      ["332", 6],
      ["333", 6],
      ["334", 6],
      ["335", 6],
      ["336", 6],
      ["340", 6],
      ["341", 6],
      ["342", 6],
      ["343", 6],
      ["344", 6],
      ["345", 6],
      ["346", 6],
      ["347", 6],
      ["348", 6],
      ["349", 6],
      ["350", 6],
      ["351", 6],
      ["352", 6],
      ["353", 6],
      ["354", 6],
      ["355", 6],
      ["356", 6],
      ["357", 6],
      ["360", 6],
      ["361", 6],
      ["362", 6],
      ["363", 6],
      ["364", 6],
      ["365", 6],
      ["366", 6],
      ["367", 6],
      ["368", 6],
      ["369", 6],
      ["390", FieldParser.VARIABLE_LENGTH, 15],
      ["391", FieldParser.VARIABLE_LENGTH, 18],
      ["392", FieldParser.VARIABLE_LENGTH, 15],
      ["393", FieldParser.VARIABLE_LENGTH, 18],
      ["703", FieldParser.VARIABLE_LENGTH, 30]
    ];
    FieldParser.FOUR_DIGIT_DATA_LENGTH = [
      // Same format as above
      ["7001", 13],
      ["7002", FieldParser.VARIABLE_LENGTH, 30],
      ["7003", 10],
      ["8001", 14],
      ["8002", FieldParser.VARIABLE_LENGTH, 20],
      ["8003", FieldParser.VARIABLE_LENGTH, 30],
      ["8004", FieldParser.VARIABLE_LENGTH, 30],
      ["8005", 6],
      ["8006", 18],
      ["8007", FieldParser.VARIABLE_LENGTH, 30],
      ["8008", FieldParser.VARIABLE_LENGTH, 12],
      ["8018", 18],
      ["8020", FieldParser.VARIABLE_LENGTH, 25],
      ["8100", 6],
      ["8101", 10],
      ["8102", 2],
      ["8110", FieldParser.VARIABLE_LENGTH, 70],
      ["8200", FieldParser.VARIABLE_LENGTH, 70]
    ];
    class GeneralAppIdDecoder {
      constructor(information) {
        this.buffer = new StringBuilder();
        this.information = information;
      }
      decodeAllCodes(buff, initialPosition) {
        let currentPosition = initialPosition;
        let remaining = null;
        do {
          let info = this.decodeGeneralPurposeField(currentPosition, remaining);
          let parsedFields = FieldParser.parseFieldsInGeneralPurpose(info.getNewString());
          if (parsedFields != null) {
            buff.append(parsedFields);
          }
          if (info.isRemaining()) {
            remaining = "" + info.getRemainingValue();
          } else {
            remaining = null;
          }
          if (currentPosition === info.getNewPosition()) {
            break;
          }
          currentPosition = info.getNewPosition();
        } while (true);
        return buff.toString();
      }
      isStillNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          return pos + 4 <= this.information.getSize();
        }
        for (let i3 = pos; i3 < pos + 3; ++i3) {
          if (this.information.get(i3)) {
            return true;
          }
        }
        return this.information.get(pos + 3);
      }
      decodeNumeric(pos) {
        if (pos + 7 > this.information.getSize()) {
          let numeric2 = this.extractNumericValueFromBitArray(pos, 4);
          if (numeric2 === 0) {
            return new DecodedNumeric(this.information.getSize(), DecodedNumeric.FNC1, DecodedNumeric.FNC1);
          }
          return new DecodedNumeric(this.information.getSize(), numeric2 - 1, DecodedNumeric.FNC1);
        }
        let numeric = this.extractNumericValueFromBitArray(pos, 7);
        let digit1 = (numeric - 8) / 11;
        let digit2 = (numeric - 8) % 11;
        return new DecodedNumeric(pos + 7, digit1, digit2);
      }
      extractNumericValueFromBitArray(pos, bits) {
        return GeneralAppIdDecoder.extractNumericValueFromBitArray(this.information, pos, bits);
      }
      static extractNumericValueFromBitArray(information, pos, bits) {
        let value = 0;
        for (let i3 = 0; i3 < bits; ++i3) {
          if (information.get(pos + i3)) {
            value |= 1 << bits - i3 - 1;
          }
        }
        return value;
      }
      decodeGeneralPurposeField(pos, remaining) {
        this.buffer.setLengthToZero();
        if (remaining != null) {
          this.buffer.append(remaining);
        }
        this.current.setPosition(pos);
        let lastDecoded = this.parseBlocks();
        if (lastDecoded != null && lastDecoded.isRemaining()) {
          return new DecodedInformation(this.current.getPosition(), this.buffer.toString(), lastDecoded.getRemainingValue());
        }
        return new DecodedInformation(this.current.getPosition(), this.buffer.toString());
      }
      parseBlocks() {
        let isFinished;
        let result;
        do {
          let initialPosition = this.current.getPosition();
          if (this.current.isAlpha()) {
            result = this.parseAlphaBlock();
            isFinished = result.isFinished();
          } else if (this.current.isIsoIec646()) {
            result = this.parseIsoIec646Block();
            isFinished = result.isFinished();
          } else {
            result = this.parseNumericBlock();
            isFinished = result.isFinished();
          }
          let positionChanged = initialPosition !== this.current.getPosition();
          if (!positionChanged && !isFinished) {
            break;
          }
        } while (!isFinished);
        return result.getDecodedInformation();
      }
      parseNumericBlock() {
        while (this.isStillNumeric(this.current.getPosition())) {
          let numeric = this.decodeNumeric(this.current.getPosition());
          this.current.setPosition(numeric.getNewPosition());
          if (numeric.isFirstDigitFNC1()) {
            let information;
            if (numeric.isSecondDigitFNC1()) {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            } else {
              information = new DecodedInformation(this.current.getPosition(), this.buffer.toString(), numeric.getSecondDigit());
            }
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getFirstDigit());
          if (numeric.isSecondDigitFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(numeric.getSecondDigit());
        }
        if (this.isNumericToAlphaNumericLatch(this.current.getPosition())) {
          this.current.setAlpha();
          this.current.incrementPosition(4);
        }
        return new BlockParsedResult(false);
      }
      parseIsoIec646Block() {
        while (this.isStillIsoIec646(this.current.getPosition())) {
          let iso = this.decodeIsoIec646(this.current.getPosition());
          this.current.setPosition(iso.getNewPosition());
          if (iso.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(iso.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setAlpha();
        }
        return new BlockParsedResult(false);
      }
      parseAlphaBlock() {
        while (this.isStillAlpha(this.current.getPosition())) {
          let alpha = this.decodeAlphanumeric(this.current.getPosition());
          this.current.setPosition(alpha.getNewPosition());
          if (alpha.isFNC1()) {
            let information = new DecodedInformation(this.current.getPosition(), this.buffer.toString());
            return new BlockParsedResult(true, information);
          }
          this.buffer.append(alpha.getValue());
        }
        if (this.isAlphaOr646ToNumericLatch(this.current.getPosition())) {
          this.current.incrementPosition(3);
          this.current.setNumeric();
        } else if (this.isAlphaTo646ToAlphaLatch(this.current.getPosition())) {
          if (this.current.getPosition() + 5 < this.information.getSize()) {
            this.current.incrementPosition(5);
          } else {
            this.current.setPosition(this.information.getSize());
          }
          this.current.setIsoIec646();
        }
        return new BlockParsedResult(false);
      }
      isStillIsoIec646(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 7 > this.information.getSize()) {
          return false;
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 116) {
          return true;
        }
        if (pos + 8 > this.information.getSize()) {
          return false;
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        return eightBitValue >= 232 && eightBitValue < 253;
      }
      decodeIsoIec646(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sevenBitValue = this.extractNumericValueFromBitArray(pos, 7);
        if (sevenBitValue >= 64 && sevenBitValue < 90) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 1));
        }
        if (sevenBitValue >= 90 && sevenBitValue < 116) {
          return new DecodedChar(pos + 7, "" + (sevenBitValue + 7));
        }
        let eightBitValue = this.extractNumericValueFromBitArray(pos, 8);
        let c3;
        switch (eightBitValue) {
          case 232:
            c3 = "!";
            break;
          case 233:
            c3 = '"';
            break;
          case 234:
            c3 = "%";
            break;
          case 235:
            c3 = "&";
            break;
          case 236:
            c3 = "'";
            break;
          case 237:
            c3 = "(";
            break;
          case 238:
            c3 = ")";
            break;
          case 239:
            c3 = "*";
            break;
          case 240:
            c3 = "+";
            break;
          case 241:
            c3 = ",";
            break;
          case 242:
            c3 = "-";
            break;
          case 243:
            c3 = ".";
            break;
          case 244:
            c3 = "/";
            break;
          case 245:
            c3 = ":";
            break;
          case 246:
            c3 = ";";
            break;
          case 247:
            c3 = "<";
            break;
          case 248:
            c3 = "=";
            break;
          case 249:
            c3 = ">";
            break;
          case 250:
            c3 = "?";
            break;
          case 251:
            c3 = "_";
            break;
          case 252:
            c3 = " ";
            break;
          default:
            throw new FormatException();
        }
        return new DecodedChar(pos + 8, c3);
      }
      isStillAlpha(pos) {
        if (pos + 5 > this.information.getSize()) {
          return false;
        }
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue >= 5 && fiveBitValue < 16) {
          return true;
        }
        if (pos + 6 > this.information.getSize()) {
          return false;
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        return sixBitValue >= 16 && sixBitValue < 63;
      }
      decodeAlphanumeric(pos) {
        let fiveBitValue = this.extractNumericValueFromBitArray(pos, 5);
        if (fiveBitValue === 15) {
          return new DecodedChar(pos + 5, DecodedChar.FNC1);
        }
        if (fiveBitValue >= 5 && fiveBitValue < 15) {
          return new DecodedChar(pos + 5, "0" + (fiveBitValue - 5));
        }
        let sixBitValue = this.extractNumericValueFromBitArray(pos, 6);
        if (sixBitValue >= 32 && sixBitValue < 58) {
          return new DecodedChar(pos + 6, "" + (sixBitValue + 33));
        }
        let c3;
        switch (sixBitValue) {
          case 58:
            c3 = "*";
            break;
          case 59:
            c3 = ",";
            break;
          case 60:
            c3 = "-";
            break;
          case 61:
            c3 = ".";
            break;
          case 62:
            c3 = "/";
            break;
          default:
            throw new IllegalStateException("Decoding invalid alphanumeric value: " + sixBitValue);
        }
        return new DecodedChar(pos + 6, c3);
      }
      isAlphaTo646ToAlphaLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i3 = 0; i3 < 5 && i3 + pos < this.information.getSize(); ++i3) {
          if (i3 === 2) {
            if (!this.information.get(pos + 2)) {
              return false;
            }
          } else if (this.information.get(pos + i3)) {
            return false;
          }
        }
        return true;
      }
      isAlphaOr646ToNumericLatch(pos) {
        if (pos + 3 > this.information.getSize()) {
          return false;
        }
        for (let i3 = pos; i3 < pos + 3; ++i3) {
          if (this.information.get(i3)) {
            return false;
          }
        }
        return true;
      }
      isNumericToAlphaNumericLatch(pos) {
        if (pos + 1 > this.information.getSize()) {
          return false;
        }
        for (let i3 = 0; i3 < 4 && i3 + pos < this.information.getSize(); ++i3) {
          if (this.information.get(pos + i3)) {
            return false;
          }
        }
        return true;
      }
    }
    class AbstractExpandedDecoder {
      constructor(information) {
        this.information = information;
        this.generalDecoder = new GeneralAppIdDecoder(information);
      }
      getInformation() {
        return this.information;
      }
      getGeneralDecoder() {
        return this.generalDecoder;
      }
    }
    class AI01decoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedGtin(buf, currentPos) {
        buf.append("(01)");
        let initialPosition = buf.length();
        buf.append("9");
        this.encodeCompressedGtinWithoutAI(buf, currentPos, initialPosition);
      }
      encodeCompressedGtinWithoutAI(buf, currentPos, initialBufferPosition) {
        for (let i3 = 0; i3 < 4; ++i3) {
          let currentBlock = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos + 10 * i3, 10);
          if (currentBlock / 100 === 0) {
            buf.append("0");
          }
          if (currentBlock / 10 === 0) {
            buf.append("0");
          }
          buf.append(currentBlock);
        }
        AI01decoder.appendCheckDigit(buf, initialBufferPosition);
      }
      static appendCheckDigit(buf, currentPos) {
        let checkDigit = 0;
        for (let i3 = 0; i3 < 13; i3++) {
          let digit = buf.charAt(i3 + currentPos).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i3 & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buf.append(checkDigit);
      }
    }
    AI01decoder.GTIN_SIZE = 40;
    class AI01AndOtherAIs extends AI01decoder {
      // the second one is the encodation method, and the other two are for the variable length
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buff = new StringBuilder();
        buff.append("(01)");
        let initialGtinPosition = buff.length();
        let firstGtinDigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01AndOtherAIs.HEADER_SIZE, 4);
        buff.append(firstGtinDigit);
        this.encodeCompressedGtinWithoutAI(buff, AI01AndOtherAIs.HEADER_SIZE + 4, initialGtinPosition);
        return this.getGeneralDecoder().decodeAllCodes(buff, AI01AndOtherAIs.HEADER_SIZE + 44);
      }
    }
    AI01AndOtherAIs.HEADER_SIZE = 1 + 1 + 2;
    class AnyAIDecoder extends AbstractExpandedDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        let buf = new StringBuilder();
        return this.getGeneralDecoder().decodeAllCodes(buf, AnyAIDecoder.HEADER_SIZE);
      }
    }
    AnyAIDecoder.HEADER_SIZE = 2 + 1 + 2;
    class AI01weightDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      encodeCompressedWeight(buf, currentPos, weightSize) {
        let originalWeightNumeric = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, weightSize);
        this.addWeightCode(buf, originalWeightNumeric);
        let weightNumeric = this.checkWeight(originalWeightNumeric);
        let currentDivisor = 1e5;
        for (let i3 = 0; i3 < 5; ++i3) {
          if (weightNumeric / currentDivisor === 0) {
            buf.append("0");
          }
          currentDivisor /= 10;
        }
        buf.append(weightNumeric);
      }
    }
    class AI013x0xDecoder extends AI01weightDecoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE + AI013x0xDecoder.WEIGHT_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0xDecoder.HEADER_SIZE + AI01weightDecoder.GTIN_SIZE, AI013x0xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
    }
    AI013x0xDecoder.HEADER_SIZE = 4 + 1;
    AI013x0xDecoder.WEIGHT_SIZE = 15;
    class AI013103decoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        buf.append("(3103)");
      }
      checkWeight(weight) {
        return weight;
      }
    }
    class AI01320xDecoder extends AI013x0xDecoder {
      constructor(information) {
        super(information);
      }
      addWeightCode(buf, weight) {
        if (weight < 1e4) {
          buf.append("(3202)");
        } else {
          buf.append("(3203)");
        }
      }
      checkWeight(weight) {
        if (weight < 1e4) {
          return weight;
        }
        return weight - 1e4;
      }
    }
    class AI01392xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01392xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01392xDecoder.LAST_DIGIT_SIZE);
        buf.append("(392");
        buf.append(lastAIdigit);
        buf.append(")");
        let decodedInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01392xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01392xDecoder.LAST_DIGIT_SIZE, null);
        buf.append(decodedInformation.getNewString());
        return buf.toString();
      }
    }
    AI01392xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01392xDecoder.LAST_DIGIT_SIZE = 2;
    class AI01393xDecoder extends AI01decoder {
      constructor(information) {
        super(information);
      }
      parseInformation() {
        if (this.getInformation().getSize() < AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI01393xDecoder.HEADER_SIZE);
        let lastAIdigit = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE, AI01393xDecoder.LAST_DIGIT_SIZE);
        buf.append("(393");
        buf.append(lastAIdigit);
        buf.append(")");
        let firstThreeDigits = this.getGeneralDecoder().extractNumericValueFromBitArray(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE, AI01393xDecoder.FIRST_THREE_DIGITS_SIZE);
        if (firstThreeDigits / 100 == 0) {
          buf.append("0");
        }
        if (firstThreeDigits / 10 == 0) {
          buf.append("0");
        }
        buf.append(firstThreeDigits);
        let generalInformation = this.getGeneralDecoder().decodeGeneralPurposeField(AI01393xDecoder.HEADER_SIZE + AI01decoder.GTIN_SIZE + AI01393xDecoder.LAST_DIGIT_SIZE + AI01393xDecoder.FIRST_THREE_DIGITS_SIZE, null);
        buf.append(generalInformation.getNewString());
        return buf.toString();
      }
    }
    AI01393xDecoder.HEADER_SIZE = 5 + 1 + 2;
    AI01393xDecoder.LAST_DIGIT_SIZE = 2;
    AI01393xDecoder.FIRST_THREE_DIGITS_SIZE = 10;
    class AI013x0x1xDecoder extends AI01weightDecoder {
      constructor(information, firstAIdigits, dateCode) {
        super(information);
        this.dateCode = dateCode;
        this.firstAIdigits = firstAIdigits;
      }
      parseInformation() {
        if (this.getInformation().getSize() != AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE + AI013x0x1xDecoder.DATE_SIZE) {
          throw new NotFoundException();
        }
        let buf = new StringBuilder();
        this.encodeCompressedGtin(buf, AI013x0x1xDecoder.HEADER_SIZE);
        this.encodeCompressedWeight(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE, AI013x0x1xDecoder.WEIGHT_SIZE);
        this.encodeCompressedDate(buf, AI013x0x1xDecoder.HEADER_SIZE + AI013x0x1xDecoder.GTIN_SIZE + AI013x0x1xDecoder.WEIGHT_SIZE);
        return buf.toString();
      }
      encodeCompressedDate(buf, currentPos) {
        let numericDate = this.getGeneralDecoder().extractNumericValueFromBitArray(currentPos, AI013x0x1xDecoder.DATE_SIZE);
        if (numericDate == 38400) {
          return;
        }
        buf.append("(");
        buf.append(this.dateCode);
        buf.append(")");
        let day = numericDate % 32;
        numericDate /= 32;
        let month = numericDate % 12 + 1;
        numericDate /= 12;
        let year = numericDate;
        if (year / 10 == 0) {
          buf.append("0");
        }
        buf.append(year);
        if (month / 10 == 0) {
          buf.append("0");
        }
        buf.append(month);
        if (day / 10 == 0) {
          buf.append("0");
        }
        buf.append(day);
      }
      addWeightCode(buf, weight) {
        buf.append("(");
        buf.append(this.firstAIdigits);
        buf.append(weight / 1e5);
        buf.append(")");
      }
      checkWeight(weight) {
        return weight % 1e5;
      }
    }
    AI013x0x1xDecoder.HEADER_SIZE = 7 + 1;
    AI013x0x1xDecoder.WEIGHT_SIZE = 20;
    AI013x0x1xDecoder.DATE_SIZE = 16;
    function createDecoder(information) {
      try {
        if (information.get(1)) {
          return new AI01AndOtherAIs(information);
        }
        if (!information.get(2)) {
          return new AnyAIDecoder(information);
        }
        let fourBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 4);
        switch (fourBitEncodationMethod) {
          case 4:
            return new AI013103decoder(information);
          case 5:
            return new AI01320xDecoder(information);
        }
        let fiveBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 5);
        switch (fiveBitEncodationMethod) {
          case 12:
            return new AI01392xDecoder(information);
          case 13:
            return new AI01393xDecoder(information);
        }
        let sevenBitEncodationMethod = GeneralAppIdDecoder.extractNumericValueFromBitArray(information, 1, 7);
        switch (sevenBitEncodationMethod) {
          case 56:
            return new AI013x0x1xDecoder(information, "310", "11");
          case 57:
            return new AI013x0x1xDecoder(information, "320", "11");
          case 58:
            return new AI013x0x1xDecoder(information, "310", "13");
          case 59:
            return new AI013x0x1xDecoder(information, "320", "13");
          case 60:
            return new AI013x0x1xDecoder(information, "310", "15");
          case 61:
            return new AI013x0x1xDecoder(information, "320", "15");
          case 62:
            return new AI013x0x1xDecoder(information, "310", "17");
          case 63:
            return new AI013x0x1xDecoder(information, "320", "17");
        }
      } catch (e3) {
        console.log(e3);
        throw new IllegalStateException("unknown decoder: " + information);
      }
    }
    class ExpandedPair {
      constructor(leftChar, rightChar, finderPatter, mayBeLast) {
        this.leftchar = leftChar;
        this.rightchar = rightChar;
        this.finderpattern = finderPatter;
        this.maybeLast = mayBeLast;
      }
      mayBeLast() {
        return this.maybeLast;
      }
      getLeftChar() {
        return this.leftchar;
      }
      getRightChar() {
        return this.rightchar;
      }
      getFinderPattern() {
        return this.finderpattern;
      }
      mustBeLast() {
        return this.rightchar == null;
      }
      toString() {
        return "[ " + this.leftchar + ", " + this.rightchar + " : " + (this.finderpattern == null ? "null" : this.finderpattern.getValue()) + " ]";
      }
      static equals(o1, o2) {
        if (!(o1 instanceof ExpandedPair)) {
          return false;
        }
        return ExpandedPair.equalsOrNull(o1.leftchar, o2.leftchar) && ExpandedPair.equalsOrNull(o1.rightchar, o2.rightchar) && ExpandedPair.equalsOrNull(o1.finderpattern, o2.finderpattern);
      }
      static equalsOrNull(o1, o2) {
        return o1 === null ? o2 === null : ExpandedPair.equals(o1, o2);
      }
      hashCode() {
        let value = this.leftchar.getValue() ^ this.rightchar.getValue() ^ this.finderpattern.getValue();
        return value;
      }
    }
    class ExpandedRow {
      constructor(pairs, rowNumber, wasReversed) {
        this.pairs = pairs;
        this.rowNumber = rowNumber;
        this.wasReversed = wasReversed;
      }
      getPairs() {
        return this.pairs;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      isReversed() {
        return this.wasReversed;
      }
      // check implementation
      isEquivalent(otherPairs) {
        return this.checkEqualitity(this, otherPairs);
      }
      // @Override
      toString() {
        return "{ " + this.pairs + " }";
      }
      /**
       * Two rows are equal if they contain the same pairs in the same order.
       */
      // @Override
      // check implementation
      equals(o1, o2) {
        if (!(o1 instanceof ExpandedRow)) {
          return false;
        }
        return this.checkEqualitity(o1, o2) && o1.wasReversed === o2.wasReversed;
      }
      checkEqualitity(pair1, pair2) {
        if (!pair1 || !pair2)
          return;
        let result;
        pair1.forEach((e1, i3) => {
          pair2.forEach((e22) => {
            if (e1.getLeftChar().getValue() === e22.getLeftChar().getValue() && e1.getRightChar().getValue() === e22.getRightChar().getValue() && e1.getFinderPatter().getValue() === e22.getFinderPatter().getValue()) {
              result = true;
            }
          });
        });
        return result;
      }
    }
    class RSSExpandedReader extends AbstractRSSReader {
      constructor(verbose) {
        super(...arguments);
        this.pairs = new Array(RSSExpandedReader.MAX_PAIRS);
        this.rows = new Array();
        this.startEnd = [2];
        this.verbose = verbose === true;
      }
      decodeRow(rowNumber, row, hints) {
        this.pairs.length = 0;
        this.startFromEven = false;
        try {
          return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
        } catch (e3) {
          if (this.verbose) {
            console.log(e3);
          }
        }
        this.pairs.length = 0;
        this.startFromEven = true;
        return RSSExpandedReader.constructResult(this.decodeRow2pairs(rowNumber, row));
      }
      reset() {
        this.pairs.length = 0;
        this.rows.length = 0;
      }
      // Not private for testing
      decodeRow2pairs(rowNumber, row) {
        let done = false;
        while (!done) {
          try {
            this.pairs.push(this.retrieveNextPair(row, this.pairs, rowNumber));
          } catch (error) {
            if (error instanceof NotFoundException) {
              if (!this.pairs.length) {
                throw new NotFoundException();
              }
              done = true;
            }
          }
        }
        if (this.checkChecksum()) {
          return this.pairs;
        }
        let tryStackedDecode;
        if (this.rows.length) {
          tryStackedDecode = true;
        } else {
          tryStackedDecode = false;
        }
        this.storeRow(rowNumber, false);
        if (tryStackedDecode) {
          let ps = this.checkRowsBoolean(false);
          if (ps != null) {
            return ps;
          }
          ps = this.checkRowsBoolean(true);
          if (ps != null) {
            return ps;
          }
        }
        throw new NotFoundException();
      }
      // Need to Verify
      checkRowsBoolean(reverse) {
        if (this.rows.length > 25) {
          this.rows.length = 0;
          return null;
        }
        this.pairs.length = 0;
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        let ps = null;
        try {
          ps = this.checkRows(new Array(), 0);
        } catch (e3) {
          if (this.verbose) {
            console.log(e3);
          }
        }
        if (reverse) {
          this.rows = this.rows.reverse();
        }
        return ps;
      }
      // Try to construct a valid rows sequence
      // Recursion is used to implement backtracking
      checkRows(collectedRows, currentRow) {
        for (let i3 = currentRow; i3 < this.rows.length; i3++) {
          let row = this.rows[i3];
          this.pairs.length = 0;
          for (let collectedRow of collectedRows) {
            this.pairs.push(collectedRow.getPairs());
          }
          this.pairs.push(row.getPairs());
          if (!RSSExpandedReader.isValidSequence(this.pairs)) {
            continue;
          }
          if (this.checkChecksum()) {
            return this.pairs;
          }
          let rs = new Array(collectedRows);
          rs.push(row);
          try {
            return this.checkRows(rs, i3 + 1);
          } catch (e3) {
            if (this.verbose) {
              console.log(e3);
            }
          }
        }
        throw new NotFoundException();
      }
      // Whether the pairs form a valid find pattern sequence,
      // either complete or a prefix
      static isValidSequence(pairs) {
        for (let sequence of RSSExpandedReader.FINDER_PATTERN_SEQUENCES) {
          if (pairs.length > sequence.length) {
            continue;
          }
          let stop = true;
          for (let j2 = 0; j2 < pairs.length; j2++) {
            if (pairs[j2].getFinderPattern().getValue() != sequence[j2]) {
              stop = false;
              break;
            }
          }
          if (stop) {
            return true;
          }
        }
        return false;
      }
      storeRow(rowNumber, wasReversed) {
        let insertPos = 0;
        let prevIsSame = false;
        let nextIsSame = false;
        while (insertPos < this.rows.length) {
          let erow = this.rows[insertPos];
          if (erow.getRowNumber() > rowNumber) {
            nextIsSame = erow.isEquivalent(this.pairs);
            break;
          }
          prevIsSame = erow.isEquivalent(this.pairs);
          insertPos++;
        }
        if (nextIsSame || prevIsSame) {
          return;
        }
        if (RSSExpandedReader.isPartialRow(this.pairs, this.rows)) {
          return;
        }
        this.rows.push(insertPos, new ExpandedRow(this.pairs, rowNumber, wasReversed));
        this.removePartialRows(this.pairs, this.rows);
      }
      // Remove all the rows that contains only specified pairs
      removePartialRows(pairs, rows) {
        for (let row of rows) {
          if (row.getPairs().length === pairs.length) {
            continue;
          }
          for (let p2 of row.getPairs()) {
            for (let pp of pairs) {
              if (ExpandedPair.equals(p2, pp)) {
                break;
              }
            }
          }
        }
      }
      // Returns true when one of the rows already contains all the pairs
      static isPartialRow(pairs, rows) {
        for (let r2 of rows) {
          let allFound = true;
          for (let p2 of pairs) {
            let found = false;
            for (let pp of r2.getPairs()) {
              if (p2.equals(pp)) {
                found = true;
                break;
              }
            }
            if (!found) {
              allFound = false;
              break;
            }
          }
          if (allFound) {
            return true;
          }
        }
        return false;
      }
      // Only used for unit testing
      getRows() {
        return this.rows;
      }
      // Not private for unit testing
      static constructResult(pairs) {
        let binary = BitArrayBuilder.buildBitArray(pairs);
        let decoder = createDecoder(binary);
        let resultingString = decoder.parseInformation();
        let firstPoints = pairs[0].getFinderPattern().getResultPoints();
        let lastPoints = pairs[pairs.length - 1].getFinderPattern().getResultPoints();
        let points = [firstPoints[0], firstPoints[1], lastPoints[0], lastPoints[1]];
        return new Result(resultingString, null, null, points, BarcodeFormat$1.RSS_EXPANDED, null);
      }
      checkChecksum() {
        let firstPair = this.pairs.get(0);
        let checkCharacter = firstPair.getLeftChar();
        let firstCharacter = firstPair.getRightChar();
        if (firstCharacter == null) {
          return false;
        }
        let checksum = firstCharacter.getChecksumPortion();
        let s4 = 2;
        for (let i3 = 1; i3 < this.pairs.size(); ++i3) {
          let currentPair = this.pairs.get(i3);
          checksum += currentPair.getLeftChar().getChecksumPortion();
          s4++;
          let currentRightChar = currentPair.getRightChar();
          if (currentRightChar != null) {
            checksum += currentRightChar.getChecksumPortion();
            s4++;
          }
        }
        checksum %= 211;
        let checkCharacterValue = 211 * (s4 - 4) + checksum;
        return checkCharacterValue == checkCharacter.getValue();
      }
      static getNextSecondBar(row, initialPos) {
        let currentPos;
        if (row.get(initialPos)) {
          currentPos = row.getNextUnset(initialPos);
          currentPos = row.getNextSet(currentPos);
        } else {
          currentPos = row.getNextSet(initialPos);
          currentPos = row.getNextUnset(currentPos);
        }
        return currentPos;
      }
      // not private for testing
      retrieveNextPair(row, previousPairs, rowNumber) {
        let isOddPattern = previousPairs.length % 2 == 0;
        if (this.startFromEven) {
          isOddPattern = !isOddPattern;
        }
        let pattern;
        let keepFinding = true;
        let forcedOffset = -1;
        do {
          this.findNextPair(row, previousPairs, forcedOffset);
          pattern = this.parseFoundFinderPattern(row, rowNumber, isOddPattern);
          if (pattern == null) {
            forcedOffset = RSSExpandedReader.getNextSecondBar(row, this.startEnd[0]);
          } else {
            keepFinding = false;
          }
        } while (keepFinding);
        let leftChar = this.decodeDataCharacter(row, pattern, isOddPattern, true);
        if (!this.isEmptyPair(previousPairs) && previousPairs[previousPairs.length - 1].mustBeLast()) {
          throw new NotFoundException();
        }
        let rightChar;
        try {
          rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
        } catch (e3) {
          rightChar = null;
          if (this.verbose) {
            console.log(e3);
          }
        }
        return new ExpandedPair(leftChar, rightChar, pattern, true);
      }
      isEmptyPair(pairs) {
        if (pairs.length === 0) {
          return true;
        }
        return false;
      }
      findNextPair(row, previousPairs, forcedOffset) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let rowOffset;
        if (forcedOffset >= 0) {
          rowOffset = forcedOffset;
        } else if (this.isEmptyPair(previousPairs)) {
          rowOffset = 0;
        } else {
          let lastPair = previousPairs[previousPairs.length - 1];
          rowOffset = lastPair.getFinderPattern().getStartEnd()[1];
        }
        let searchingEvenPair = previousPairs.length % 2 != 0;
        if (this.startFromEven) {
          searchingEvenPair = !searchingEvenPair;
        }
        let isWhite = false;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (!isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x3 = rowOffset; x3 < width; x3++) {
          if (row.get(x3) != isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition == 3) {
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              if (RSSExpandedReader.isFinderPattern(counters)) {
                this.startEnd[0] = patternStart;
                this.startEnd[1] = x3;
                return;
              }
              if (searchingEvenPair) {
                RSSExpandedReader.reverseCounters(counters);
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      static reverseCounters(counters) {
        let length = counters.length;
        for (let i3 = 0; i3 < length / 2; ++i3) {
          let tmp = counters[i3];
          counters[i3] = counters[length - i3 - 1];
          counters[length - i3 - 1] = tmp;
        }
      }
      parseFoundFinderPattern(row, rowNumber, oddPattern) {
        let firstCounter;
        let start;
        let end;
        if (oddPattern) {
          let firstElementStart = this.startEnd[0] - 1;
          while (firstElementStart >= 0 && !row.get(firstElementStart)) {
            firstElementStart--;
          }
          firstElementStart++;
          firstCounter = this.startEnd[0] - firstElementStart;
          start = firstElementStart;
          end = this.startEnd[1];
        } else {
          start = this.startEnd[0];
          end = row.getNextUnset(this.startEnd[1] + 1);
          firstCounter = end - this.startEnd[1];
        }
        let counters = this.getDecodeFinderCounters();
        System.arraycopy(counters, 0, counters, 1, counters.length - 1);
        counters[0] = firstCounter;
        let value;
        try {
          value = this.parseFinderValue(counters, RSSExpandedReader.FINDER_PATTERNS);
        } catch (e3) {
          return null;
        }
        return new FinderPattern(value, [start, end], start, end, rowNumber);
      }
      decodeDataCharacter(row, pattern, isOddPattern, leftChar) {
        let counters = this.getDataCharacterCounters();
        for (let x3 = 0; x3 < counters.length; x3++) {
          counters[x3] = 0;
        }
        if (leftChar) {
          RSSExpandedReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          RSSExpandedReader.recordPattern(row, pattern.getStartEnd()[1], counters);
          for (let i3 = 0, j2 = counters.length - 1; i3 < j2; i3++, j2--) {
            let temp = counters[i3];
            counters[i3] = counters[j2];
            counters[j2] = temp;
          }
        }
        let numModules = 17;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let expectedElementWidth = (pattern.getStartEnd()[1] - pattern.getStartEnd()[0]) / 15;
        if (Math.abs(elementWidth - expectedElementWidth) / expectedElementWidth > 0.3) {
          throw new NotFoundException();
        }
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i3 = 0; i3 < counters.length; i3++) {
          let value2 = 1 * counters[i3] / elementWidth;
          let count2 = value2 + 0.5;
          if (count2 < 1) {
            if (value2 < 0.3) {
              throw new NotFoundException();
            }
            count2 = 1;
          } else if (count2 > 8) {
            if (value2 > 8.7) {
              throw new NotFoundException();
            }
            count2 = 8;
          }
          let offset2 = i3 / 2;
          if ((i3 & 1) == 0) {
            oddCounts[offset2] = count2;
            oddRoundingErrors[offset2] = value2 - count2;
          } else {
            evenCounts[offset2] = count2;
            evenRoundingErrors[offset2] = value2 - count2;
          }
        }
        this.adjustOddEvenCounts(numModules);
        let weightRowNumber = 4 * pattern.getValue() + (isOddPattern ? 0 : 2) + (leftChar ? 0 : 1) - 1;
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i3 = oddCounts.length - 1; i3 >= 0; i3--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i3];
            oddChecksumPortion += oddCounts[i3] * weight;
          }
          oddSum += oddCounts[i3];
        }
        let evenChecksumPortion = 0;
        for (let i3 = evenCounts.length - 1; i3 >= 0; i3--) {
          if (RSSExpandedReader.isNotA1left(pattern, isOddPattern, leftChar)) {
            let weight = RSSExpandedReader.WEIGHTS[weightRowNumber][2 * i3 + 1];
            evenChecksumPortion += evenCounts[i3] * weight;
          }
        }
        let checksumPortion = oddChecksumPortion + evenChecksumPortion;
        if ((oddSum & 1) != 0 || oddSum > 13 || oddSum < 4) {
          throw new NotFoundException();
        }
        let group = (13 - oddSum) / 2;
        let oddWidest = RSSExpandedReader.SYMBOL_WIDEST[group];
        let evenWidest = 9 - oddWidest;
        let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
        let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
        let tEven = RSSExpandedReader.EVEN_TOTAL_SUBSET[group];
        let gSum = RSSExpandedReader.GSUM[group];
        let value = vOdd * tEven + vEven + gSum;
        return new DataCharacter(value, checksumPortion);
      }
      static isNotA1left(pattern, isOddPattern, leftChar) {
        return !(pattern.getValue() == 0 && isOddPattern && leftChar);
      }
      adjustOddEvenCounts(numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        if (oddSum > 13) {
          decrementOdd = true;
        } else if (oddSum < 4) {
          incrementOdd = true;
        }
        let incrementEven = false;
        let decrementEven = false;
        if (evenSum > 13) {
          decrementEven = true;
        } else if (evenSum < 4) {
          incrementEven = true;
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) == 1;
        let evenParityBad = (evenSum & 1) == 0;
        if (mismatch == 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch == -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch == 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          RSSExpandedReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          RSSExpandedReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          RSSExpandedReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSSExpandedReader.SYMBOL_WIDEST = [7, 5, 4, 3, 1];
    RSSExpandedReader.EVEN_TOTAL_SUBSET = [4, 20, 52, 104, 204];
    RSSExpandedReader.GSUM = [0, 348, 1388, 2948, 3988];
    RSSExpandedReader.FINDER_PATTERNS = [
      Int32Array.from([1, 8, 4, 1]),
      Int32Array.from([3, 6, 4, 1]),
      Int32Array.from([3, 4, 6, 1]),
      Int32Array.from([3, 2, 8, 1]),
      Int32Array.from([2, 6, 5, 1]),
      Int32Array.from([2, 2, 9, 1])
      // F
    ];
    RSSExpandedReader.WEIGHTS = [
      [1, 3, 9, 27, 81, 32, 96, 77],
      [20, 60, 180, 118, 143, 7, 21, 63],
      [189, 145, 13, 39, 117, 140, 209, 205],
      [193, 157, 49, 147, 19, 57, 171, 91],
      [62, 186, 136, 197, 169, 85, 44, 132],
      [185, 133, 188, 142, 4, 12, 36, 108],
      [113, 128, 173, 97, 80, 29, 87, 50],
      [150, 28, 84, 41, 123, 158, 52, 156],
      [46, 138, 203, 187, 139, 206, 196, 166],
      [76, 17, 51, 153, 37, 111, 122, 155],
      [43, 129, 176, 106, 107, 110, 119, 146],
      [16, 48, 144, 10, 30, 90, 59, 177],
      [109, 116, 137, 200, 178, 112, 125, 164],
      [70, 210, 208, 202, 184, 130, 179, 115],
      [134, 191, 151, 31, 93, 68, 204, 190],
      [148, 22, 66, 198, 172, 94, 71, 2],
      [6, 18, 54, 162, 64, 192, 154, 40],
      [120, 149, 25, 75, 14, 42, 126, 167],
      [79, 26, 78, 23, 69, 207, 199, 175],
      [103, 98, 83, 38, 114, 131, 182, 124],
      [161, 61, 183, 127, 170, 88, 53, 159],
      [55, 165, 73, 8, 24, 72, 5, 15],
      [45, 135, 194, 160, 58, 174, 100, 89]
    ];
    RSSExpandedReader.FINDER_PAT_A = 0;
    RSSExpandedReader.FINDER_PAT_B = 1;
    RSSExpandedReader.FINDER_PAT_C = 2;
    RSSExpandedReader.FINDER_PAT_D = 3;
    RSSExpandedReader.FINDER_PAT_E = 4;
    RSSExpandedReader.FINDER_PAT_F = 5;
    RSSExpandedReader.FINDER_PATTERN_SEQUENCES = [
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_C],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F],
      [RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_A, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_B, RSSExpandedReader.FINDER_PAT_C, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_D, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_E, RSSExpandedReader.FINDER_PAT_F, RSSExpandedReader.FINDER_PAT_F]
    ];
    RSSExpandedReader.MAX_PAIRS = 11;
    class Pair extends DataCharacter {
      constructor(value, checksumPortion, finderPattern) {
        super(value, checksumPortion);
        this.count = 0;
        this.finderPattern = finderPattern;
      }
      getFinderPattern() {
        return this.finderPattern;
      }
      getCount() {
        return this.count;
      }
      incrementCount() {
        this.count++;
      }
    }
    class RSS14Reader extends AbstractRSSReader {
      constructor() {
        super(...arguments);
        this.possibleLeftPairs = [];
        this.possibleRightPairs = [];
      }
      decodeRow(rowNumber, row, hints) {
        const leftPair = this.decodePair(row, false, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleLeftPairs, leftPair);
        row.reverse();
        let rightPair = this.decodePair(row, true, rowNumber, hints);
        RSS14Reader.addOrTally(this.possibleRightPairs, rightPair);
        row.reverse();
        for (let left of this.possibleLeftPairs) {
          if (left.getCount() > 1) {
            for (let right of this.possibleRightPairs) {
              if (right.getCount() > 1 && RSS14Reader.checkChecksum(left, right)) {
                return RSS14Reader.constructResult(left, right);
              }
            }
          }
        }
        throw new NotFoundException();
      }
      static addOrTally(possiblePairs, pair) {
        if (pair == null) {
          return;
        }
        let found = false;
        for (let other of possiblePairs) {
          if (other.getValue() === pair.getValue()) {
            other.incrementCount();
            found = true;
            break;
          }
        }
        if (!found) {
          possiblePairs.push(pair);
        }
      }
      reset() {
        this.possibleLeftPairs.length = 0;
        this.possibleRightPairs.length = 0;
      }
      static constructResult(leftPair, rightPair) {
        let symbolValue = 4537077 * leftPair.getValue() + rightPair.getValue();
        let text = new String(symbolValue).toString();
        let buffer = new StringBuilder();
        for (let i3 = 13 - text.length; i3 > 0; i3--) {
          buffer.append("0");
        }
        buffer.append(text);
        let checkDigit = 0;
        for (let i3 = 0; i3 < 13; i3++) {
          let digit = buffer.charAt(i3).charCodeAt(0) - "0".charCodeAt(0);
          checkDigit += (i3 & 1) === 0 ? 3 * digit : digit;
        }
        checkDigit = 10 - checkDigit % 10;
        if (checkDigit === 10) {
          checkDigit = 0;
        }
        buffer.append(checkDigit.toString());
        let leftPoints = leftPair.getFinderPattern().getResultPoints();
        let rightPoints = rightPair.getFinderPattern().getResultPoints();
        return new Result(buffer.toString(), null, 0, [leftPoints[0], leftPoints[1], rightPoints[0], rightPoints[1]], BarcodeFormat$1.RSS_14, (/* @__PURE__ */ new Date()).getTime());
      }
      static checkChecksum(leftPair, rightPair) {
        let checkValue = (leftPair.getChecksumPortion() + 16 * rightPair.getChecksumPortion()) % 79;
        let targetCheckValue = 9 * leftPair.getFinderPattern().getValue() + rightPair.getFinderPattern().getValue();
        if (targetCheckValue > 72) {
          targetCheckValue--;
        }
        if (targetCheckValue > 8) {
          targetCheckValue--;
        }
        return checkValue === targetCheckValue;
      }
      decodePair(row, right, rowNumber, hints) {
        try {
          let startEnd = this.findFinderPattern(row, right);
          let pattern = this.parseFoundFinderPattern(row, rowNumber, right, startEnd);
          let resultPointCallback = hints == null ? null : hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK);
          if (resultPointCallback != null) {
            let center = (startEnd[0] + startEnd[1]) / 2;
            if (right) {
              center = row.getSize() - 1 - center;
            }
            resultPointCallback.foundPossibleResultPoint(new ResultPoint(center, rowNumber));
          }
          let outside = this.decodeDataCharacter(row, pattern, true);
          let inside = this.decodeDataCharacter(row, pattern, false);
          return new Pair(1597 * outside.getValue() + inside.getValue(), outside.getChecksumPortion() + 4 * inside.getChecksumPortion(), pattern);
        } catch (err) {
          return null;
        }
      }
      decodeDataCharacter(row, pattern, outsideChar) {
        let counters = this.getDataCharacterCounters();
        for (let x3 = 0; x3 < counters.length; x3++) {
          counters[x3] = 0;
        }
        if (outsideChar) {
          OneDReader.recordPatternInReverse(row, pattern.getStartEnd()[0], counters);
        } else {
          OneDReader.recordPattern(row, pattern.getStartEnd()[1] + 1, counters);
          for (let i3 = 0, j2 = counters.length - 1; i3 < j2; i3++, j2--) {
            let temp = counters[i3];
            counters[i3] = counters[j2];
            counters[j2] = temp;
          }
        }
        let numModules = outsideChar ? 16 : 15;
        let elementWidth = MathUtils.sum(new Int32Array(counters)) / numModules;
        let oddCounts = this.getOddCounts();
        let evenCounts = this.getEvenCounts();
        let oddRoundingErrors = this.getOddRoundingErrors();
        let evenRoundingErrors = this.getEvenRoundingErrors();
        for (let i3 = 0; i3 < counters.length; i3++) {
          let value = counters[i3] / elementWidth;
          let count2 = Math.floor(value + 0.5);
          if (count2 < 1) {
            count2 = 1;
          } else if (count2 > 8) {
            count2 = 8;
          }
          let offset2 = Math.floor(i3 / 2);
          if ((i3 & 1) === 0) {
            oddCounts[offset2] = count2;
            oddRoundingErrors[offset2] = value - count2;
          } else {
            evenCounts[offset2] = count2;
            evenRoundingErrors[offset2] = value - count2;
          }
        }
        this.adjustOddEvenCounts(outsideChar, numModules);
        let oddSum = 0;
        let oddChecksumPortion = 0;
        for (let i3 = oddCounts.length - 1; i3 >= 0; i3--) {
          oddChecksumPortion *= 9;
          oddChecksumPortion += oddCounts[i3];
          oddSum += oddCounts[i3];
        }
        let evenChecksumPortion = 0;
        let evenSum = 0;
        for (let i3 = evenCounts.length - 1; i3 >= 0; i3--) {
          evenChecksumPortion *= 9;
          evenChecksumPortion += evenCounts[i3];
          evenSum += evenCounts[i3];
        }
        let checksumPortion = oddChecksumPortion + 3 * evenChecksumPortion;
        if (outsideChar) {
          if ((oddSum & 1) !== 0 || oddSum > 12 || oddSum < 4) {
            throw new NotFoundException();
          }
          let group = (12 - oddSum) / 2;
          let oddWidest = RSS14Reader.OUTSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, false);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, true);
          let tEven = RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.OUTSIDE_GSUM[group];
          return new DataCharacter(vOdd * tEven + vEven + gSum, checksumPortion);
        } else {
          if ((evenSum & 1) !== 0 || evenSum > 10 || evenSum < 4) {
            throw new NotFoundException();
          }
          let group = (10 - evenSum) / 2;
          let oddWidest = RSS14Reader.INSIDE_ODD_WIDEST[group];
          let evenWidest = 9 - oddWidest;
          let vOdd = RSSUtils.getRSSvalue(oddCounts, oddWidest, true);
          let vEven = RSSUtils.getRSSvalue(evenCounts, evenWidest, false);
          let tOdd = RSS14Reader.INSIDE_ODD_TOTAL_SUBSET[group];
          let gSum = RSS14Reader.INSIDE_GSUM[group];
          return new DataCharacter(vEven * tOdd + vOdd + gSum, checksumPortion);
        }
      }
      findFinderPattern(row, rightFinderPattern) {
        let counters = this.getDecodeFinderCounters();
        counters[0] = 0;
        counters[1] = 0;
        counters[2] = 0;
        counters[3] = 0;
        let width = row.getSize();
        let isWhite = false;
        let rowOffset = 0;
        while (rowOffset < width) {
          isWhite = !row.get(rowOffset);
          if (rightFinderPattern === isWhite) {
            break;
          }
          rowOffset++;
        }
        let counterPosition = 0;
        let patternStart = rowOffset;
        for (let x3 = rowOffset; x3 < width; x3++) {
          if (row.get(x3) !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === 3) {
              if (AbstractRSSReader.isFinderPattern(counters)) {
                return [patternStart, x3];
              }
              patternStart += counters[0] + counters[1];
              counters[0] = counters[2];
              counters[1] = counters[3];
              counters[2] = 0;
              counters[3] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        throw new NotFoundException();
      }
      parseFoundFinderPattern(row, rowNumber, right, startEnd) {
        let firstIsBlack = row.get(startEnd[0]);
        let firstElementStart = startEnd[0] - 1;
        while (firstElementStart >= 0 && firstIsBlack !== row.get(firstElementStart)) {
          firstElementStart--;
        }
        firstElementStart++;
        const firstCounter = startEnd[0] - firstElementStart;
        const counters = this.getDecodeFinderCounters();
        const copy = new Int32Array(counters.length);
        System.arraycopy(counters, 0, copy, 1, counters.length - 1);
        copy[0] = firstCounter;
        const value = this.parseFinderValue(copy, RSS14Reader.FINDER_PATTERNS);
        let start = firstElementStart;
        let end = startEnd[1];
        if (right) {
          start = row.getSize() - 1 - start;
          end = row.getSize() - 1 - end;
        }
        return new FinderPattern(value, [firstElementStart, startEnd[1]], start, end, rowNumber);
      }
      adjustOddEvenCounts(outsideChar, numModules) {
        let oddSum = MathUtils.sum(new Int32Array(this.getOddCounts()));
        let evenSum = MathUtils.sum(new Int32Array(this.getEvenCounts()));
        let incrementOdd = false;
        let decrementOdd = false;
        let incrementEven = false;
        let decrementEven = false;
        if (outsideChar) {
          if (oddSum > 12) {
            decrementOdd = true;
          } else if (oddSum < 4) {
            incrementOdd = true;
          }
          if (evenSum > 12) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        } else {
          if (oddSum > 11) {
            decrementOdd = true;
          } else if (oddSum < 5) {
            incrementOdd = true;
          }
          if (evenSum > 10) {
            decrementEven = true;
          } else if (evenSum < 4) {
            incrementEven = true;
          }
        }
        let mismatch = oddSum + evenSum - numModules;
        let oddParityBad = (oddSum & 1) === (outsideChar ? 1 : 0);
        let evenParityBad = (evenSum & 1) === 1;
        if (mismatch === 1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            decrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            decrementEven = true;
          }
        } else if (mismatch === -1) {
          if (oddParityBad) {
            if (evenParityBad) {
              throw new NotFoundException();
            }
            incrementOdd = true;
          } else {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            incrementEven = true;
          }
        } else if (mismatch === 0) {
          if (oddParityBad) {
            if (!evenParityBad) {
              throw new NotFoundException();
            }
            if (oddSum < evenSum) {
              incrementOdd = true;
              decrementEven = true;
            } else {
              decrementOdd = true;
              incrementEven = true;
            }
          } else {
            if (evenParityBad) {
              throw new NotFoundException();
            }
          }
        } else {
          throw new NotFoundException();
        }
        if (incrementOdd) {
          if (decrementOdd) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (decrementOdd) {
          AbstractRSSReader.decrement(this.getOddCounts(), this.getOddRoundingErrors());
        }
        if (incrementEven) {
          if (decrementEven) {
            throw new NotFoundException();
          }
          AbstractRSSReader.increment(this.getEvenCounts(), this.getOddRoundingErrors());
        }
        if (decrementEven) {
          AbstractRSSReader.decrement(this.getEvenCounts(), this.getEvenRoundingErrors());
        }
      }
    }
    RSS14Reader.OUTSIDE_EVEN_TOTAL_SUBSET = [1, 10, 34, 70, 126];
    RSS14Reader.INSIDE_ODD_TOTAL_SUBSET = [4, 20, 48, 81];
    RSS14Reader.OUTSIDE_GSUM = [0, 161, 961, 2015, 2715];
    RSS14Reader.INSIDE_GSUM = [0, 336, 1036, 1516];
    RSS14Reader.OUTSIDE_ODD_WIDEST = [8, 6, 4, 3, 1];
    RSS14Reader.INSIDE_ODD_WIDEST = [2, 4, 6, 8];
    RSS14Reader.FINDER_PATTERNS = [
      Int32Array.from([3, 8, 2, 1]),
      Int32Array.from([3, 5, 5, 1]),
      Int32Array.from([3, 3, 7, 1]),
      Int32Array.from([3, 1, 9, 1]),
      Int32Array.from([2, 7, 4, 1]),
      Int32Array.from([2, 5, 6, 1]),
      Int32Array.from([2, 3, 8, 1]),
      Int32Array.from([1, 5, 7, 1]),
      Int32Array.from([1, 3, 9, 1])
    ];
    class MultiFormatOneDReader extends OneDReader {
      constructor(hints, verbose) {
        super();
        this.readers = [];
        this.verbose = verbose === true;
        const possibleFormats = !hints ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const useCode39CheckDigit = hints && hints.get(DecodeHintType$1.ASSUME_CODE_39_CHECK_DIGIT) !== void 0;
        if (possibleFormats) {
          if (possibleFormats.includes(BarcodeFormat$1.EAN_13) || possibleFormats.includes(BarcodeFormat$1.UPC_A) || possibleFormats.includes(BarcodeFormat$1.EAN_8) || possibleFormats.includes(BarcodeFormat$1.UPC_E)) {
            this.readers.push(new MultiFormatUPCEANReader(hints));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_39)) {
            this.readers.push(new Code39Reader(useCode39CheckDigit));
          }
          if (possibleFormats.includes(BarcodeFormat$1.CODE_128)) {
            this.readers.push(new Code128Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.ITF)) {
            this.readers.push(new ITFReader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_14)) {
            this.readers.push(new RSS14Reader());
          }
          if (possibleFormats.includes(BarcodeFormat$1.RSS_EXPANDED)) {
            this.readers.push(new RSSExpandedReader(this.verbose));
          }
        } else {
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code39Reader());
          this.readers.push(new MultiFormatUPCEANReader(hints));
          this.readers.push(new Code128Reader());
          this.readers.push(new ITFReader());
          this.readers.push(new RSS14Reader());
          this.readers.push(new RSSExpandedReader(this.verbose));
        }
      }
      // @Override
      decodeRow(rowNumber, row, hints) {
        for (let i3 = 0; i3 < this.readers.length; i3++) {
          try {
            return this.readers[i3].decodeRow(rowNumber, row, hints);
          } catch (re2) {
          }
        }
        throw new NotFoundException();
      }
      // @Override
      reset() {
        this.readers.forEach((reader) => reader.reset());
      }
    }
    class BrowserBarcodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserBarcodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       * @param {Map<DecodeHintType, any>} hints
       */
      constructor(timeBetweenScansMillis = 500, hints) {
        super(new MultiFormatOneDReader(hints), timeBetweenScansMillis, hints);
      }
    }
    class ECBlocks {
      constructor(ecCodewords, ecBlocks1, ecBlocks2) {
        this.ecCodewords = ecCodewords;
        this.ecBlocks = [ecBlocks1];
        ecBlocks2 && this.ecBlocks.push(ecBlocks2);
      }
      getECCodewords() {
        return this.ecCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB {
      constructor(count2, dataCodewords) {
        this.count = count2;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version {
      constructor(versionNumber, symbolSizeRows, symbolSizeColumns, dataRegionSizeRows, dataRegionSizeColumns, ecBlocks) {
        this.versionNumber = versionNumber;
        this.symbolSizeRows = symbolSizeRows;
        this.symbolSizeColumns = symbolSizeColumns;
        this.dataRegionSizeRows = dataRegionSizeRows;
        this.dataRegionSizeColumns = dataRegionSizeColumns;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks.getECCodewords();
        const ecbArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getSymbolSizeRows() {
        return this.symbolSizeRows;
      }
      getSymbolSizeColumns() {
        return this.symbolSizeColumns;
      }
      getDataRegionSizeRows() {
        return this.dataRegionSizeRows;
      }
      getDataRegionSizeColumns() {
        return this.dataRegionSizeColumns;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getECBlocks() {
        return this.ecBlocks;
      }
      /**
       * <p>Deduces version information from Data Matrix dimensions.</p>
       *
       * @param numRows Number of rows in modules
       * @param numColumns Number of columns in modules
       * @return Version for a Data Matrix Code of those dimensions
       * @throws FormatException if dimensions do correspond to a valid Data Matrix size
       */
      static getVersionForDimensions(numRows, numColumns) {
        if ((numRows & 1) !== 0 || (numColumns & 1) !== 0) {
          throw new FormatException();
        }
        for (let version of Version.VERSIONS) {
          if (version.symbolSizeRows === numRows && version.symbolSizeColumns === numColumns) {
            return version;
          }
        }
        throw new FormatException();
      }
      //  @Override
      toString() {
        return "" + this.versionNumber;
      }
      /**
       * See ISO 16022:2006 5.5.1 Table 7
       */
      static buildVersions() {
        return [
          new Version(1, 10, 10, 8, 8, new ECBlocks(5, new ECB(1, 3))),
          new Version(2, 12, 12, 10, 10, new ECBlocks(7, new ECB(1, 5))),
          new Version(3, 14, 14, 12, 12, new ECBlocks(10, new ECB(1, 8))),
          new Version(4, 16, 16, 14, 14, new ECBlocks(12, new ECB(1, 12))),
          new Version(5, 18, 18, 16, 16, new ECBlocks(14, new ECB(1, 18))),
          new Version(6, 20, 20, 18, 18, new ECBlocks(18, new ECB(1, 22))),
          new Version(7, 22, 22, 20, 20, new ECBlocks(20, new ECB(1, 30))),
          new Version(8, 24, 24, 22, 22, new ECBlocks(24, new ECB(1, 36))),
          new Version(9, 26, 26, 24, 24, new ECBlocks(28, new ECB(1, 44))),
          new Version(10, 32, 32, 14, 14, new ECBlocks(36, new ECB(1, 62))),
          new Version(11, 36, 36, 16, 16, new ECBlocks(42, new ECB(1, 86))),
          new Version(12, 40, 40, 18, 18, new ECBlocks(48, new ECB(1, 114))),
          new Version(13, 44, 44, 20, 20, new ECBlocks(56, new ECB(1, 144))),
          new Version(14, 48, 48, 22, 22, new ECBlocks(68, new ECB(1, 174))),
          new Version(15, 52, 52, 24, 24, new ECBlocks(42, new ECB(2, 102))),
          new Version(16, 64, 64, 14, 14, new ECBlocks(56, new ECB(2, 140))),
          new Version(17, 72, 72, 16, 16, new ECBlocks(36, new ECB(4, 92))),
          new Version(18, 80, 80, 18, 18, new ECBlocks(48, new ECB(4, 114))),
          new Version(19, 88, 88, 20, 20, new ECBlocks(56, new ECB(4, 144))),
          new Version(20, 96, 96, 22, 22, new ECBlocks(68, new ECB(4, 174))),
          new Version(21, 104, 104, 24, 24, new ECBlocks(56, new ECB(6, 136))),
          new Version(22, 120, 120, 18, 18, new ECBlocks(68, new ECB(6, 175))),
          new Version(23, 132, 132, 20, 20, new ECBlocks(62, new ECB(8, 163))),
          new Version(24, 144, 144, 22, 22, new ECBlocks(62, new ECB(8, 156), new ECB(2, 155))),
          new Version(25, 8, 18, 6, 16, new ECBlocks(7, new ECB(1, 5))),
          new Version(26, 8, 32, 6, 14, new ECBlocks(11, new ECB(1, 10))),
          new Version(27, 12, 26, 10, 24, new ECBlocks(14, new ECB(1, 16))),
          new Version(28, 12, 36, 10, 16, new ECBlocks(18, new ECB(1, 22))),
          new Version(29, 16, 36, 14, 16, new ECBlocks(24, new ECB(1, 32))),
          new Version(30, 16, 48, 14, 22, new ECBlocks(28, new ECB(1, 49)))
        ];
      }
    }
    Version.VERSIONS = Version.buildVersions();
    class BitMatrixParser {
      /**
       * @param bitMatrix {@link BitMatrix} to parse
       * @throws FormatException if dimension is < 8 or > 144 or not 0 mod 2
       */
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 8 || dimension > 144 || (dimension & 1) !== 0) {
          throw new FormatException();
        }
        this.version = BitMatrixParser.readVersion(bitMatrix);
        this.mappingBitMatrix = this.extractDataRegion(bitMatrix);
        this.readMappingMatrix = new BitMatrix(this.mappingBitMatrix.getWidth(), this.mappingBitMatrix.getHeight());
      }
      getVersion() {
        return this.version;
      }
      /**
       * <p>Creates the version object based on the dimension of the original bit matrix from
       * the datamatrix code.</p>
       *
       * <p>See ISO 16022:2006 Table 7 - ECC 200 symbol attributes</p>
       *
       * @param bitMatrix Original {@link BitMatrix} including alignment patterns
       * @return {@link Version} encapsulating the Data Matrix Code's "version"
       * @throws FormatException if the dimensions of the mapping matrix are not valid
       * Data Matrix dimensions.
       */
      static readVersion(bitMatrix) {
        const numRows = bitMatrix.getHeight();
        const numColumns = bitMatrix.getWidth();
        return Version.getVersionForDimensions(numRows, numColumns);
      }
      /**
       * <p>Reads the bits in the {@link BitMatrix} representing the mapping matrix (No alignment patterns)
       * in the correct order in order to reconstitute the codewords bytes contained within the
       * Data Matrix Code.</p>
       *
       * @return bytes encoded within the Data Matrix Code
       * @throws FormatException if the exact number of bytes expected is not read
       */
      readCodewords() {
        const result = new Int8Array(this.version.getTotalCodewords());
        let resultOffset = 0;
        let row = 4;
        let column = 0;
        const numRows = this.mappingBitMatrix.getHeight();
        const numColumns = this.mappingBitMatrix.getWidth();
        let corner1Read = false;
        let corner2Read = false;
        let corner3Read = false;
        let corner4Read = false;
        do {
          if (row === numRows && column === 0 && !corner1Read) {
            result[resultOffset++] = this.readCorner1(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner1Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 3) !== 0 && !corner2Read) {
            result[resultOffset++] = this.readCorner2(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner2Read = true;
          } else if (row === numRows + 4 && column === 2 && (numColumns & 7) === 0 && !corner3Read) {
            result[resultOffset++] = this.readCorner3(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner3Read = true;
          } else if (row === numRows - 2 && column === 0 && (numColumns & 7) === 4 && !corner4Read) {
            result[resultOffset++] = this.readCorner4(numRows, numColumns) & 255;
            row -= 2;
            column += 2;
            corner4Read = true;
          } else {
            do {
              if (row < numRows && column >= 0 && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row -= 2;
              column += 2;
            } while (row >= 0 && column < numColumns);
            row += 1;
            column += 3;
            do {
              if (row >= 0 && column < numColumns && !this.readMappingMatrix.get(column, row)) {
                result[resultOffset++] = this.readUtah(row, column, numRows, numColumns) & 255;
              }
              row += 2;
              column -= 2;
            } while (row < numRows && column >= 0);
            row += 3;
            column += 1;
          }
        } while (row < numRows || column < numColumns);
        if (resultOffset !== this.version.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      /**
       * <p>Reads a bit of the mapping matrix accounting for boundary wrapping.</p>
       *
       * @param row Row to read in the mapping matrix
       * @param column Column to read in the mapping matrix
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return value of the given bit in the mapping matrix
       */
      readModule(row, column, numRows, numColumns) {
        if (row < 0) {
          row += numRows;
          column += 4 - (numRows + 4 & 7);
        }
        if (column < 0) {
          column += numColumns;
          row += 4 - (numColumns + 4 & 7);
        }
        this.readMappingMatrix.set(column, row);
        return this.mappingBitMatrix.get(column, row);
      }
      /**
       * <p>Reads the 8 bits of the standard Utah-shaped pattern.</p>
       *
       * <p>See ISO 16022:2006, 5.8.1 Figure 6</p>
       *
       * @param row Current row in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
       * @param column Current column in the mapping matrix, anchored at the 8th bit (LSB) of the pattern
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the utah shape
       */
      readUtah(row, column, numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(row - 2, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 2, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row - 1, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(row, column, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 1.</p>
       *
       * <p>See ISO 16022:2006, Figure F.3</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 1
       */
      readCorner1(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 2.</p>
       *
       * <p>See ISO 16022:2006, Figure F.4</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 2
       */
      readCorner2(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 4, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 3.</p>
       *
       * <p>See ISO 16022:2006, Figure F.5</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 3
       */
      readCorner3(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 3, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Reads the 8 bits of the special corner condition 4.</p>
       *
       * <p>See ISO 16022:2006, Figure F.6</p>
       *
       * @param numRows Number of rows in the mapping matrix
       * @param numColumns Number of columns in the mapping matrix
       * @return byte from the Corner condition 4
       */
      readCorner4(numRows, numColumns) {
        let currentByte = 0;
        if (this.readModule(numRows - 3, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 2, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(numRows - 1, 0, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 2, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(0, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(1, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(2, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        currentByte <<= 1;
        if (this.readModule(3, numColumns - 1, numRows, numColumns)) {
          currentByte |= 1;
        }
        return currentByte;
      }
      /**
       * <p>Extracts the data region from a {@link BitMatrix} that contains
       * alignment patterns.</p>
       *
       * @param bitMatrix Original {@link BitMatrix} with alignment patterns
       * @return BitMatrix that has the alignment patterns removed
       */
      extractDataRegion(bitMatrix) {
        const symbolSizeRows = this.version.getSymbolSizeRows();
        const symbolSizeColumns = this.version.getSymbolSizeColumns();
        if (bitMatrix.getHeight() !== symbolSizeRows) {
          throw new IllegalArgumentException("Dimension of bitMatrix must match the version size");
        }
        const dataRegionSizeRows = this.version.getDataRegionSizeRows();
        const dataRegionSizeColumns = this.version.getDataRegionSizeColumns();
        const numDataRegionsRow = symbolSizeRows / dataRegionSizeRows | 0;
        const numDataRegionsColumn = symbolSizeColumns / dataRegionSizeColumns | 0;
        const sizeDataRegionRow = numDataRegionsRow * dataRegionSizeRows;
        const sizeDataRegionColumn = numDataRegionsColumn * dataRegionSizeColumns;
        const bitMatrixWithoutAlignment = new BitMatrix(sizeDataRegionColumn, sizeDataRegionRow);
        for (let dataRegionRow = 0; dataRegionRow < numDataRegionsRow; ++dataRegionRow) {
          const dataRegionRowOffset = dataRegionRow * dataRegionSizeRows;
          for (let dataRegionColumn = 0; dataRegionColumn < numDataRegionsColumn; ++dataRegionColumn) {
            const dataRegionColumnOffset = dataRegionColumn * dataRegionSizeColumns;
            for (let i3 = 0; i3 < dataRegionSizeRows; ++i3) {
              const readRowOffset = dataRegionRow * (dataRegionSizeRows + 2) + 1 + i3;
              const writeRowOffset = dataRegionRowOffset + i3;
              for (let j2 = 0; j2 < dataRegionSizeColumns; ++j2) {
                const readColumnOffset = dataRegionColumn * (dataRegionSizeColumns + 2) + 1 + j2;
                if (bitMatrix.get(readColumnOffset, readRowOffset)) {
                  const writeColumnOffset = dataRegionColumnOffset + j2;
                  bitMatrixWithoutAlignment.set(writeColumnOffset, writeRowOffset);
                }
              }
            }
          }
        }
        return bitMatrixWithoutAlignment;
      }
    }
    class DataBlock {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      /**
       * <p>When Data Matrix Codes use multiple data blocks, they actually interleave the bytes of each of them.
       * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
       * method will separate the data into original blocks.</p>
       *
       * @param rawCodewords bytes as read directly from the Data Matrix Code
       * @param version version of the Data Matrix Code
       * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
       *         Data Matrix Code
       */
      static getDataBlocks(rawCodewords, version) {
        const ecBlocks = version.getECBlocks();
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (let ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (let ecBlock of ecBlockArray) {
          for (let i3 = 0; i3 < ecBlock.getCount(); i3++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewords() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const longerBlocksTotalCodewords = result[0].codewords.length;
        const longerBlocksNumDataCodewords = longerBlocksTotalCodewords - ecBlocks.getECCodewords();
        const shorterBlocksNumDataCodewords = longerBlocksNumDataCodewords - 1;
        let rawCodewordsOffset = 0;
        for (let i3 = 0; i3 < shorterBlocksNumDataCodewords; i3++) {
          for (let j2 = 0; j2 < numResultBlocks; j2++) {
            result[j2].codewords[i3] = rawCodewords[rawCodewordsOffset++];
          }
        }
        const specialVersion = version.getVersionNumber() === 24;
        const numLongerBlocks = specialVersion ? 8 : numResultBlocks;
        for (let j2 = 0; j2 < numLongerBlocks; j2++) {
          result[j2].codewords[longerBlocksNumDataCodewords - 1] = rawCodewords[rawCodewordsOffset++];
        }
        const max2 = result[0].codewords.length;
        for (let i3 = longerBlocksNumDataCodewords; i3 < max2; i3++) {
          for (let j2 = 0; j2 < numResultBlocks; j2++) {
            const jOffset = specialVersion ? (j2 + 8) % numResultBlocks : j2;
            const iOffset = specialVersion && jOffset > 7 ? i3 - 1 : i3;
            result[jOffset].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        if (rawCodewordsOffset !== rawCodewords.length) {
          throw new IllegalArgumentException();
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    class BitSource {
      /**
       * @param bytes bytes from which this will read bits. Bits will be read from the first byte first.
       * Bits are read within a byte from most-significant to least-significant bit.
       */
      constructor(bytes) {
        this.bytes = bytes;
        this.byteOffset = 0;
        this.bitOffset = 0;
      }
      /**
       * @return index of next bit in current byte which would be read by the next call to {@link #readBits(int)}.
       */
      getBitOffset() {
        return this.bitOffset;
      }
      /**
       * @return index of next byte in input byte array which would be read by the next call to {@link #readBits(int)}.
       */
      getByteOffset() {
        return this.byteOffset;
      }
      /**
       * @param numBits number of bits to read
       * @return int representing the bits read. The bits will appear as the least-significant
       *         bits of the int
       * @throws IllegalArgumentException if numBits isn't in [1,32] or more than is available
       */
      readBits(numBits) {
        if (numBits < 1 || numBits > 32 || numBits > this.available()) {
          throw new IllegalArgumentException("" + numBits);
        }
        let result = 0;
        let bitOffset = this.bitOffset;
        let byteOffset = this.byteOffset;
        const bytes = this.bytes;
        if (bitOffset > 0) {
          const bitsLeft = 8 - bitOffset;
          const toRead = numBits < bitsLeft ? numBits : bitsLeft;
          const bitsToNotRead = bitsLeft - toRead;
          const mask = 255 >> 8 - toRead << bitsToNotRead;
          result = (bytes[byteOffset] & mask) >> bitsToNotRead;
          numBits -= toRead;
          bitOffset += toRead;
          if (bitOffset === 8) {
            bitOffset = 0;
            byteOffset++;
          }
        }
        if (numBits > 0) {
          while (numBits >= 8) {
            result = result << 8 | bytes[byteOffset] & 255;
            byteOffset++;
            numBits -= 8;
          }
          if (numBits > 0) {
            const bitsToNotRead = 8 - numBits;
            const mask = 255 >> bitsToNotRead << bitsToNotRead;
            result = result << numBits | (bytes[byteOffset] & mask) >> bitsToNotRead;
            bitOffset += numBits;
          }
        }
        this.bitOffset = bitOffset;
        this.byteOffset = byteOffset;
        return result;
      }
      /**
       * @return number of bits that can be read successfully
       */
      available() {
        return 8 * (this.bytes.length - this.byteOffset) - this.bitOffset;
      }
    }
    var Mode;
    (function(Mode2) {
      Mode2[Mode2["PAD_ENCODE"] = 0] = "PAD_ENCODE";
      Mode2[Mode2["ASCII_ENCODE"] = 1] = "ASCII_ENCODE";
      Mode2[Mode2["C40_ENCODE"] = 2] = "C40_ENCODE";
      Mode2[Mode2["TEXT_ENCODE"] = 3] = "TEXT_ENCODE";
      Mode2[Mode2["ANSIX12_ENCODE"] = 4] = "ANSIX12_ENCODE";
      Mode2[Mode2["EDIFACT_ENCODE"] = 5] = "EDIFACT_ENCODE";
      Mode2[Mode2["BASE256_ENCODE"] = 6] = "BASE256_ENCODE";
    })(Mode || (Mode = {}));
    class DecodedBitStreamParser {
      static decode(bytes) {
        const bits = new BitSource(bytes);
        const result = new StringBuilder();
        const resultTrailer = new StringBuilder();
        const byteSegments = new Array();
        let mode = Mode.ASCII_ENCODE;
        do {
          if (mode === Mode.ASCII_ENCODE) {
            mode = this.decodeAsciiSegment(bits, result, resultTrailer);
          } else {
            switch (mode) {
              case Mode.C40_ENCODE:
                this.decodeC40Segment(bits, result);
                break;
              case Mode.TEXT_ENCODE:
                this.decodeTextSegment(bits, result);
                break;
              case Mode.ANSIX12_ENCODE:
                this.decodeAnsiX12Segment(bits, result);
                break;
              case Mode.EDIFACT_ENCODE:
                this.decodeEdifactSegment(bits, result);
                break;
              case Mode.BASE256_ENCODE:
                this.decodeBase256Segment(bits, result, byteSegments);
                break;
              default:
                throw new FormatException();
            }
            mode = Mode.ASCII_ENCODE;
          }
        } while (mode !== Mode.PAD_ENCODE && bits.available() > 0);
        if (resultTrailer.length() > 0) {
          result.append(resultTrailer.toString());
        }
        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, null);
      }
      /**
       * See ISO 16022:2006, 5.2.3 and Annex C, Table C.2
       */
      static decodeAsciiSegment(bits, result, resultTrailer) {
        let upperShift = false;
        do {
          let oneByte = bits.readBits(8);
          if (oneByte === 0) {
            throw new FormatException();
          } else if (oneByte <= 128) {
            if (upperShift) {
              oneByte += 128;
            }
            result.append(String.fromCharCode(oneByte - 1));
            return Mode.ASCII_ENCODE;
          } else if (oneByte === 129) {
            return Mode.PAD_ENCODE;
          } else if (oneByte <= 229) {
            const value = oneByte - 130;
            if (value < 10) {
              result.append("0");
            }
            result.append("" + value);
          } else {
            switch (oneByte) {
              case 230:
                return Mode.C40_ENCODE;
              case 231:
                return Mode.BASE256_ENCODE;
              case 232:
                result.append(String.fromCharCode(29));
                break;
              case 233:
              case 234:
                break;
              case 235:
                upperShift = true;
                break;
              case 236:
                result.append("[)>05");
                resultTrailer.insert(0, "");
                break;
              case 237:
                result.append("[)>06");
                resultTrailer.insert(0, "");
                break;
              case 238:
                return Mode.ANSIX12_ENCODE;
              case 239:
                return Mode.TEXT_ENCODE;
              case 240:
                return Mode.EDIFACT_ENCODE;
              case 241:
                break;
              default:
                if (oneByte !== 254 || bits.available() !== 0) {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
        return Mode.ASCII_ENCODE;
      }
      /**
       * See ISO 16022:2006, 5.2.5 and Annex C, Table C.1
       */
      static decodeC40Segment(bits, result) {
        let upperShift = false;
        const cValues = [];
        let shift2 = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i3 = 0; i3 < 3; i3++) {
            const cValue = cValues[i3];
            switch (shift2) {
              case 0:
                if (cValue < 3) {
                  shift2 = cValue + 1;
                } else if (cValue < this.C40_BASIC_SET_CHARS.length) {
                  const c40char = this.C40_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift2 = 0;
                break;
              case 2:
                if (cValue < this.C40_SHIFT2_SET_CHARS.length) {
                  const c40char = this.C40_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(c40char.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(c40char);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift2 = 0;
                break;
              case 3:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 224));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue + 96));
                }
                shift2 = 0;
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.6 and Annex C, Table C.2
       */
      static decodeTextSegment(bits, result) {
        let upperShift = false;
        let cValues = [];
        let shift2 = 0;
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i3 = 0; i3 < 3; i3++) {
            const cValue = cValues[i3];
            switch (shift2) {
              case 0:
                if (cValue < 3) {
                  shift2 = cValue + 1;
                } else if (cValue < this.TEXT_BASIC_SET_CHARS.length) {
                  const textChar = this.TEXT_BASIC_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  throw new FormatException();
                }
                break;
              case 1:
                if (upperShift) {
                  result.append(String.fromCharCode(cValue + 128));
                  upperShift = false;
                } else {
                  result.append(String.fromCharCode(cValue));
                }
                shift2 = 0;
                break;
              case 2:
                if (cValue < this.TEXT_SHIFT2_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT2_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                } else {
                  switch (cValue) {
                    case 27:
                      result.append(String.fromCharCode(29));
                      break;
                    case 30:
                      upperShift = true;
                      break;
                    default:
                      throw new FormatException();
                  }
                }
                shift2 = 0;
                break;
              case 3:
                if (cValue < this.TEXT_SHIFT3_SET_CHARS.length) {
                  const textChar = this.TEXT_SHIFT3_SET_CHARS[cValue];
                  if (upperShift) {
                    result.append(String.fromCharCode(textChar.charCodeAt(0) + 128));
                    upperShift = false;
                  } else {
                    result.append(textChar);
                  }
                  shift2 = 0;
                } else {
                  throw new FormatException();
                }
                break;
              default:
                throw new FormatException();
            }
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.7
       */
      static decodeAnsiX12Segment(bits, result) {
        const cValues = [];
        do {
          if (bits.available() === 8) {
            return;
          }
          const firstByte = bits.readBits(8);
          if (firstByte === 254) {
            return;
          }
          this.parseTwoBytes(firstByte, bits.readBits(8), cValues);
          for (let i3 = 0; i3 < 3; i3++) {
            const cValue = cValues[i3];
            switch (cValue) {
              case 0:
                result.append("\r");
                break;
              case 1:
                result.append("*");
                break;
              case 2:
                result.append(">");
                break;
              case 3:
                result.append(" ");
                break;
              default:
                if (cValue < 14) {
                  result.append(String.fromCharCode(cValue + 44));
                } else if (cValue < 40) {
                  result.append(String.fromCharCode(cValue + 51));
                } else {
                  throw new FormatException();
                }
                break;
            }
          }
        } while (bits.available() > 0);
      }
      static parseTwoBytes(firstByte, secondByte, result) {
        let fullBitValue = (firstByte << 8) + secondByte - 1;
        let temp = Math.floor(fullBitValue / 1600);
        result[0] = temp;
        fullBitValue -= temp * 1600;
        temp = Math.floor(fullBitValue / 40);
        result[1] = temp;
        result[2] = fullBitValue - temp * 40;
      }
      /**
       * See ISO 16022:2006, 5.2.8 and Annex C Table C.3
       */
      static decodeEdifactSegment(bits, result) {
        do {
          if (bits.available() <= 16) {
            return;
          }
          for (let i3 = 0; i3 < 4; i3++) {
            let edifactValue = bits.readBits(6);
            if (edifactValue === 31) {
              const bitsLeft = 8 - bits.getBitOffset();
              if (bitsLeft !== 8) {
                bits.readBits(bitsLeft);
              }
              return;
            }
            if ((edifactValue & 32) === 0) {
              edifactValue |= 64;
            }
            result.append(String.fromCharCode(edifactValue));
          }
        } while (bits.available() > 0);
      }
      /**
       * See ISO 16022:2006, 5.2.9 and Annex B, B.2
       */
      static decodeBase256Segment(bits, result, byteSegments) {
        let codewordPosition = 1 + bits.getByteOffset();
        const d1 = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        let count2;
        if (d1 === 0) {
          count2 = bits.available() / 8 | 0;
        } else if (d1 < 250) {
          count2 = d1;
        } else {
          count2 = 250 * (d1 - 249) + this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        if (count2 < 0) {
          throw new FormatException();
        }
        const bytes = new Uint8Array(count2);
        for (let i3 = 0; i3 < count2; i3++) {
          if (bits.available() < 8) {
            throw new FormatException();
          }
          bytes[i3] = this.unrandomize255State(bits.readBits(8), codewordPosition++);
        }
        byteSegments.push(bytes);
        try {
          result.append(StringEncoding.decode(bytes, StringUtils.ISO88591));
        } catch (uee) {
          throw new IllegalStateException("Platform does not support required encoding: " + uee.message);
        }
      }
      /**
       * See ISO 16022:2006, Annex B, B.2
       */
      static unrandomize255State(randomizedBase256Codeword, base256CodewordPosition) {
        const pseudoRandomNumber = 149 * base256CodewordPosition % 255 + 1;
        const tempVariable = randomizedBase256Codeword - pseudoRandomNumber;
        return tempVariable >= 0 ? tempVariable : tempVariable + 256;
      }
    }
    DecodedBitStreamParser.C40_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    DecodedBitStreamParser.C40_SHIFT2_SET_CHARS = [
      "!",
      '"',
      "#",
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "?",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_"
    ];
    DecodedBitStreamParser.TEXT_BASIC_SET_CHARS = [
      "*",
      "*",
      "*",
      " ",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z"
    ];
    DecodedBitStreamParser.TEXT_SHIFT2_SET_CHARS = DecodedBitStreamParser.C40_SHIFT2_SET_CHARS;
    DecodedBitStreamParser.TEXT_SHIFT3_SET_CHARS = [
      "`",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "{",
      "|",
      "}",
      "~",
      String.fromCharCode(127)
    ];
    class Decoder$1 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.DATA_MATRIX_FIELD_256);
      }
      /**
       * <p>Decodes a Data Matrix Code represented as a {@link BitMatrix}. A 1 or "true" is taken
       * to mean a black module.</p>
       *
       * @param bits booleans representing white/black Data Matrix Code modules
       * @return text and bytes encoded within the Data Matrix Code
       * @throws FormatException if the Data Matrix Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decode(bits) {
        const parser = new BitMatrixParser(bits);
        const version = parser.getVersion();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock.getDataBlocks(codewords, version);
        let totalBytes = 0;
        for (let db2 of dataBlocks) {
          totalBytes += db2.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        const dataBlocksCount = dataBlocks.length;
        for (let j2 = 0; j2 < dataBlocksCount; j2++) {
          const dataBlock = dataBlocks[j2];
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            resultBytes[i3 * dataBlocksCount + j2] = codewordBytes[i3];
          }
        }
        return DecodedBitStreamParser.decode(resultBytes);
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place using Reed-Solomon error correction.</p>
       *
       * @param codewordBytes data and error correction codewords
       * @param numDataCodewords number of codewords that are data bytes
       * @throws ChecksumException if error correction fails
       */
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i3 = 0; i3 < numDataCodewords; i3++) {
          codewordBytes[i3] = codewordsInts[i3];
        }
      }
    }
    class Detector$1 {
      constructor(image) {
        this.image = image;
        this.rectangleDetector = new WhiteRectangleDetector(this.image);
      }
      /**
       * <p>Detects a Data Matrix Code in an image.</p>
       *
       * @return {@link DetectorResult} encapsulating results of detecting a Data Matrix Code
       * @throws NotFoundException if no Data Matrix Code can be found
       */
      detect() {
        const cornerPoints = this.rectangleDetector.detect();
        let points = this.detectSolid1(cornerPoints);
        points = this.detectSolid2(points);
        points[3] = this.correctTopRight(points);
        if (!points[3]) {
          throw new NotFoundException();
        }
        points = this.shiftToModuleCenter(points);
        const topLeft = points[0];
        const bottomLeft = points[1];
        const bottomRight = points[2];
        const topRight = points[3];
        let dimensionTop = this.transitionsBetween(topLeft, topRight) + 1;
        let dimensionRight = this.transitionsBetween(bottomRight, topRight) + 1;
        if ((dimensionTop & 1) === 1) {
          dimensionTop += 1;
        }
        if ((dimensionRight & 1) === 1) {
          dimensionRight += 1;
        }
        if (4 * dimensionTop < 7 * dimensionRight && 4 * dimensionRight < 7 * dimensionTop) {
          dimensionTop = dimensionRight = Math.max(dimensionTop, dimensionRight);
        }
        let bits = Detector$1.sampleGrid(this.image, topLeft, bottomLeft, bottomRight, topRight, dimensionTop, dimensionRight);
        return new DetectorResult(bits, [topLeft, bottomLeft, bottomRight, topRight]);
      }
      static shiftPoint(point, to, div) {
        let x3 = (to.getX() - point.getX()) / (div + 1);
        let y4 = (to.getY() - point.getY()) / (div + 1);
        return new ResultPoint(point.getX() + x3, point.getY() + y4);
      }
      static moveAway(point, fromX, fromY) {
        let x3 = point.getX();
        let y4 = point.getY();
        if (x3 < fromX) {
          x3 -= 1;
        } else {
          x3 += 1;
        }
        if (y4 < fromY) {
          y4 -= 1;
        } else {
          y4 += 1;
        }
        return new ResultPoint(x3, y4);
      }
      /**
       * Detect a solid side which has minimum transition.
       */
      detectSolid1(cornerPoints) {
        let pointA = cornerPoints[0];
        let pointB = cornerPoints[1];
        let pointC = cornerPoints[3];
        let pointD = cornerPoints[2];
        let trAB = this.transitionsBetween(pointA, pointB);
        let trBC = this.transitionsBetween(pointB, pointC);
        let trCD = this.transitionsBetween(pointC, pointD);
        let trDA = this.transitionsBetween(pointD, pointA);
        let min2 = trAB;
        let points = [pointD, pointA, pointB, pointC];
        if (min2 > trBC) {
          min2 = trBC;
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        }
        if (min2 > trCD) {
          min2 = trCD;
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        if (min2 > trDA) {
          points[0] = pointC;
          points[1] = pointD;
          points[2] = pointA;
          points[3] = pointB;
        }
        return points;
      }
      /**
       * Detect a second solid side next to first solid side.
       */
      detectSolid2(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let tr = this.transitionsBetween(pointA, pointD);
        let pointBs = Detector$1.shiftPoint(pointB, pointC, (tr + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (tr + 1) * 4);
        let trBA = this.transitionsBetween(pointBs, pointA);
        let trCD = this.transitionsBetween(pointCs, pointD);
        if (trBA < trCD) {
          points[0] = pointA;
          points[1] = pointB;
          points[2] = pointC;
          points[3] = pointD;
        } else {
          points[0] = pointB;
          points[1] = pointC;
          points[2] = pointD;
          points[3] = pointA;
        }
        return points;
      }
      /**
       * Calculates the corner position of the white top right module.
       */
      correctTopRight(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let trTop = this.transitionsBetween(pointA, pointD);
        let trRight = this.transitionsBetween(pointB, pointD);
        let pointAs = Detector$1.shiftPoint(pointA, pointB, (trRight + 1) * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, (trTop + 1) * 4);
        trTop = this.transitionsBetween(pointAs, pointD);
        trRight = this.transitionsBetween(pointCs, pointD);
        let candidate1 = new ResultPoint(pointD.getX() + (pointC.getX() - pointB.getX()) / (trTop + 1), pointD.getY() + (pointC.getY() - pointB.getY()) / (trTop + 1));
        let candidate2 = new ResultPoint(pointD.getX() + (pointA.getX() - pointB.getX()) / (trRight + 1), pointD.getY() + (pointA.getY() - pointB.getY()) / (trRight + 1));
        if (!this.isValid(candidate1)) {
          if (this.isValid(candidate2)) {
            return candidate2;
          }
          return null;
        }
        if (!this.isValid(candidate2)) {
          return candidate1;
        }
        let sumc1 = this.transitionsBetween(pointAs, candidate1) + this.transitionsBetween(pointCs, candidate1);
        let sumc2 = this.transitionsBetween(pointAs, candidate2) + this.transitionsBetween(pointCs, candidate2);
        if (sumc1 > sumc2) {
          return candidate1;
        } else {
          return candidate2;
        }
      }
      /**
       * Shift the edge points to the module center.
       */
      shiftToModuleCenter(points) {
        let pointA = points[0];
        let pointB = points[1];
        let pointC = points[2];
        let pointD = points[3];
        let dimH = this.transitionsBetween(pointA, pointD) + 1;
        let dimV = this.transitionsBetween(pointC, pointD) + 1;
        let pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        let pointCs = Detector$1.shiftPoint(pointC, pointB, dimH * 4);
        dimH = this.transitionsBetween(pointAs, pointD) + 1;
        dimV = this.transitionsBetween(pointCs, pointD) + 1;
        if ((dimH & 1) === 1) {
          dimH += 1;
        }
        if ((dimV & 1) === 1) {
          dimV += 1;
        }
        let centerX = (pointA.getX() + pointB.getX() + pointC.getX() + pointD.getX()) / 4;
        let centerY = (pointA.getY() + pointB.getY() + pointC.getY() + pointD.getY()) / 4;
        pointA = Detector$1.moveAway(pointA, centerX, centerY);
        pointB = Detector$1.moveAway(pointB, centerX, centerY);
        pointC = Detector$1.moveAway(pointC, centerX, centerY);
        pointD = Detector$1.moveAway(pointD, centerX, centerY);
        let pointBs;
        let pointDs;
        pointAs = Detector$1.shiftPoint(pointA, pointB, dimV * 4);
        pointAs = Detector$1.shiftPoint(pointAs, pointD, dimH * 4);
        pointBs = Detector$1.shiftPoint(pointB, pointA, dimV * 4);
        pointBs = Detector$1.shiftPoint(pointBs, pointC, dimH * 4);
        pointCs = Detector$1.shiftPoint(pointC, pointD, dimV * 4);
        pointCs = Detector$1.shiftPoint(pointCs, pointB, dimH * 4);
        pointDs = Detector$1.shiftPoint(pointD, pointC, dimV * 4);
        pointDs = Detector$1.shiftPoint(pointDs, pointA, dimH * 4);
        return [pointAs, pointBs, pointCs, pointDs];
      }
      isValid(p2) {
        return p2.getX() >= 0 && p2.getX() < this.image.getWidth() && p2.getY() > 0 && p2.getY() < this.image.getHeight();
      }
      static sampleGrid(image, topLeft, bottomLeft, bottomRight, topRight, dimensionX, dimensionY) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGrid(image, dimensionX, dimensionY, 0.5, 0.5, dimensionX - 0.5, 0.5, dimensionX - 0.5, dimensionY - 0.5, 0.5, dimensionY - 0.5, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRight.getX(), bottomRight.getY(), bottomLeft.getX(), bottomLeft.getY());
      }
      /**
       * Counts the number of black/white transitions between two points, using something like Bresenham's algorithm.
       */
      transitionsBetween(from, to) {
        let fromX = Math.trunc(from.getX());
        let fromY = Math.trunc(from.getY());
        let toX = Math.trunc(to.getX());
        let toY = Math.trunc(to.getY());
        let steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        let dx = Math.abs(toX - fromX);
        let dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        let ystep = fromY < toY ? 1 : -1;
        let xstep = fromX < toX ? 1 : -1;
        let transitions = 0;
        let inBlack = this.image.get(steep ? fromY : fromX, steep ? fromX : fromY);
        for (let x3 = fromX, y4 = fromY; x3 !== toX; x3 += xstep) {
          let isBlack = this.image.get(steep ? y4 : x3, steep ? x3 : y4);
          if (isBlack !== inBlack) {
            transitions++;
            inBlack = isBlack;
          }
          error += dy;
          if (error > 0) {
            if (y4 === toY) {
              break;
            }
            y4 += ystep;
            error -= dx;
          }
        }
        return transitions;
      }
    }
    class DataMatrixReader {
      constructor() {
        this.decoder = new Decoder$1();
      }
      /**
       * Locates and decodes a Data Matrix code in an image.
       *
       * @return a String representing the content encoded by the Data Matrix code
       * @throws NotFoundException if a Data Matrix code cannot be found
       * @throws FormatException if a Data Matrix code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      // @Override
      // public Result decode(BinaryBitmap image) throws NotFoundException, ChecksumException, FormatException {
      //   return decode(image, null);
      // }
      // @Override
      decode(image, hints = null) {
        let decoderResult;
        let points;
        if (hints != null && hints.has(DecodeHintType$1.PURE_BARCODE)) {
          const bits = DataMatrixReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decode(bits);
          points = DataMatrixReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$1(image.getBlackMatrix()).detect();
          decoderResult = this.decoder.decode(detectorResult.getBits());
          points = detectorResult.getPoints();
        }
        const rawBytes = decoderResult.getRawBytes();
        const result = new Result(decoderResult.getText(), rawBytes, 8 * rawBytes.length, points, BarcodeFormat$1.DATA_MATRIX, System.currentTimeMillis());
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments != null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel != null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        return result;
      }
      // @Override
      reset() {
      }
      /**
       * This method detects a code in a "pure" image -- that is, pure monochrome image
       * which contains only an unrotated, unskewed, image of a code, with some white border
       * around it. This is a specialized method that works exceptionally fast in this special
       * case.
       *
       * @see com.google.zxing.qrcode.QRCodeReader#extractPureBits(BitMatrix)
       */
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack == null || rightBottomBlack == null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        const bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        const right = rightBottomBlack[0];
        const matrixWidth = (right - left + 1) / moduleSize;
        const matrixHeight = (bottom - top + 1) / moduleSize;
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        const nudge = moduleSize / 2;
        top += nudge;
        left += nudge;
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y4 = 0; y4 < matrixHeight; y4++) {
          const iOffset = top + y4 * moduleSize;
          for (let x3 = 0; x3 < matrixWidth; x3++) {
            if (image.get(left + x3 * moduleSize, iOffset)) {
              bits.set(x3, y4);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const width = image.getWidth();
        let x3 = leftTopBlack[0];
        const y4 = leftTopBlack[1];
        while (x3 < width && image.get(x3, y4)) {
          x3++;
        }
        if (x3 === width) {
          throw new NotFoundException();
        }
        const moduleSize = x3 - leftTopBlack[0];
        if (moduleSize === 0) {
          throw new NotFoundException();
        }
        return moduleSize;
      }
    }
    DataMatrixReader.NO_POINTS = [];
    class BrowserDatamatrixCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserQRCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new DataMatrixReader(), timeBetweenScansMillis);
      }
    }
    var ErrorCorrectionLevelValues;
    (function(ErrorCorrectionLevelValues2) {
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["L"] = 0] = "L";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["M"] = 1] = "M";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["Q"] = 2] = "Q";
      ErrorCorrectionLevelValues2[ErrorCorrectionLevelValues2["H"] = 3] = "H";
    })(ErrorCorrectionLevelValues || (ErrorCorrectionLevelValues = {}));
    class ErrorCorrectionLevel {
      constructor(value, stringValue, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.bits = bits;
        ErrorCorrectionLevel.FOR_BITS.set(bits, this);
        ErrorCorrectionLevel.FOR_VALUE.set(value, this);
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      static fromString(s4) {
        switch (s4) {
          case "L":
            return ErrorCorrectionLevel.L;
          case "M":
            return ErrorCorrectionLevel.M;
          case "Q":
            return ErrorCorrectionLevel.Q;
          case "H":
            return ErrorCorrectionLevel.H;
          default:
            throw new ArgumentException(s4 + "not available");
        }
      }
      toString() {
        return this.stringValue;
      }
      equals(o2) {
        if (!(o2 instanceof ErrorCorrectionLevel)) {
          return false;
        }
        const other = o2;
        return this.value === other.value;
      }
      /**
       * @param bits int containing the two bits encoding a QR Code's error correction level
       * @return ErrorCorrectionLevel representing the encoded error correction level
       */
      static forBits(bits) {
        if (bits < 0 || bits >= ErrorCorrectionLevel.FOR_BITS.size) {
          throw new IllegalArgumentException();
        }
        return ErrorCorrectionLevel.FOR_BITS.get(bits);
      }
    }
    ErrorCorrectionLevel.FOR_BITS = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.FOR_VALUE = /* @__PURE__ */ new Map();
    ErrorCorrectionLevel.L = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.L, "L", 1);
    ErrorCorrectionLevel.M = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.M, "M", 0);
    ErrorCorrectionLevel.Q = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.Q, "Q", 3);
    ErrorCorrectionLevel.H = new ErrorCorrectionLevel(ErrorCorrectionLevelValues.H, "H", 2);
    class FormatInformation {
      constructor(formatInfo) {
        this.errorCorrectionLevel = ErrorCorrectionLevel.forBits(formatInfo >> 3 & 3);
        this.dataMask = /*(byte) */
        formatInfo & 7;
      }
      static numBitsDiffering(a4, b2) {
        return Integer.bitCount(a4 ^ b2);
      }
      /**
       * @param maskedFormatInfo1 format info indicator, with mask still applied
       * @param maskedFormatInfo2 second copy of same info; both are checked at the same time
       *  to establish best match
       * @return information about the format it specifies, or {@code null}
       *  if doesn't seem to match any known pattern
       */
      static decodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        const formatInfo = FormatInformation.doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2);
        if (formatInfo !== null) {
          return formatInfo;
        }
        return FormatInformation.doDecodeFormatInformation(maskedFormatInfo1 ^ FormatInformation.FORMAT_INFO_MASK_QR, maskedFormatInfo2 ^ FormatInformation.FORMAT_INFO_MASK_QR);
      }
      static doDecodeFormatInformation(maskedFormatInfo1, maskedFormatInfo2) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestFormatInfo = 0;
        for (const decodeInfo of FormatInformation.FORMAT_INFO_DECODE_LOOKUP) {
          const targetInfo = decodeInfo[0];
          if (targetInfo === maskedFormatInfo1 || targetInfo === maskedFormatInfo2) {
            return new FormatInformation(decodeInfo[1]);
          }
          let bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo1, targetInfo);
          if (bitsDifference < bestDifference) {
            bestFormatInfo = decodeInfo[1];
            bestDifference = bitsDifference;
          }
          if (maskedFormatInfo1 !== maskedFormatInfo2) {
            bitsDifference = FormatInformation.numBitsDiffering(maskedFormatInfo2, targetInfo);
            if (bitsDifference < bestDifference) {
              bestFormatInfo = decodeInfo[1];
              bestDifference = bitsDifference;
            }
          }
        }
        if (bestDifference <= 3) {
          return new FormatInformation(bestFormatInfo);
        }
        return null;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getDataMask() {
        return this.dataMask;
      }
      /*@Override*/
      hashCode() {
        return this.errorCorrectionLevel.getBits() << 3 | this.dataMask;
      }
      /*@Override*/
      equals(o2) {
        if (!(o2 instanceof FormatInformation)) {
          return false;
        }
        const other = o2;
        return this.errorCorrectionLevel === other.errorCorrectionLevel && this.dataMask === other.dataMask;
      }
    }
    FormatInformation.FORMAT_INFO_MASK_QR = 21522;
    FormatInformation.FORMAT_INFO_DECODE_LOOKUP = [
      Int32Array.from([21522, 0]),
      Int32Array.from([20773, 1]),
      Int32Array.from([24188, 2]),
      Int32Array.from([23371, 3]),
      Int32Array.from([17913, 4]),
      Int32Array.from([16590, 5]),
      Int32Array.from([20375, 6]),
      Int32Array.from([19104, 7]),
      Int32Array.from([30660, 8]),
      Int32Array.from([29427, 9]),
      Int32Array.from([32170, 10]),
      Int32Array.from([30877, 11]),
      Int32Array.from([26159, 12]),
      Int32Array.from([25368, 13]),
      Int32Array.from([27713, 14]),
      Int32Array.from([26998, 15]),
      Int32Array.from([5769, 16]),
      Int32Array.from([5054, 17]),
      Int32Array.from([7399, 18]),
      Int32Array.from([6608, 19]),
      Int32Array.from([1890, 20]),
      Int32Array.from([597, 21]),
      Int32Array.from([3340, 22]),
      Int32Array.from([2107, 23]),
      Int32Array.from([13663, 24]),
      Int32Array.from([12392, 25]),
      Int32Array.from([16177, 26]),
      Int32Array.from([14854, 27]),
      Int32Array.from([9396, 28]),
      Int32Array.from([8579, 29]),
      Int32Array.from([11994, 30]),
      Int32Array.from([11245, 31])
    ];
    class ECBlocks$1 {
      constructor(ecCodewordsPerBlock, ...ecBlocks) {
        this.ecCodewordsPerBlock = ecCodewordsPerBlock;
        this.ecBlocks = ecBlocks;
      }
      getECCodewordsPerBlock() {
        return this.ecCodewordsPerBlock;
      }
      getNumBlocks() {
        let total = 0;
        const ecBlocks = this.ecBlocks;
        for (const ecBlock of ecBlocks) {
          total += ecBlock.getCount();
        }
        return total;
      }
      getTotalECCodewords() {
        return this.ecCodewordsPerBlock * this.getNumBlocks();
      }
      getECBlocks() {
        return this.ecBlocks;
      }
    }
    class ECB$1 {
      constructor(count2, dataCodewords) {
        this.count = count2;
        this.dataCodewords = dataCodewords;
      }
      getCount() {
        return this.count;
      }
      getDataCodewords() {
        return this.dataCodewords;
      }
    }
    class Version$1 {
      constructor(versionNumber, alignmentPatternCenters, ...ecBlocks) {
        this.versionNumber = versionNumber;
        this.alignmentPatternCenters = alignmentPatternCenters;
        this.ecBlocks = ecBlocks;
        let total = 0;
        const ecCodewords = ecBlocks[0].getECCodewordsPerBlock();
        const ecbArray = ecBlocks[0].getECBlocks();
        for (const ecBlock of ecbArray) {
          total += ecBlock.getCount() * (ecBlock.getDataCodewords() + ecCodewords);
        }
        this.totalCodewords = total;
      }
      getVersionNumber() {
        return this.versionNumber;
      }
      getAlignmentPatternCenters() {
        return this.alignmentPatternCenters;
      }
      getTotalCodewords() {
        return this.totalCodewords;
      }
      getDimensionForVersion() {
        return 17 + 4 * this.versionNumber;
      }
      getECBlocksForLevel(ecLevel) {
        return this.ecBlocks[ecLevel.getValue()];
      }
      /**
       * <p>Deduces version information purely from QR Code dimensions.</p>
       *
       * @param dimension dimension in modules
       * @return Version for a QR Code of that dimension
       * @throws FormatException if dimension is not 1 mod 4
       */
      static getProvisionalVersionForDimension(dimension) {
        if (dimension % 4 !== 1) {
          throw new FormatException();
        }
        try {
          return this.getVersionForNumber((dimension - 17) / 4);
        } catch (ignored) {
          throw new FormatException();
        }
      }
      static getVersionForNumber(versionNumber) {
        if (versionNumber < 1 || versionNumber > 40) {
          throw new IllegalArgumentException();
        }
        return Version$1.VERSIONS[versionNumber - 1];
      }
      static decodeVersionInformation(versionBits) {
        let bestDifference = Number.MAX_SAFE_INTEGER;
        let bestVersion = 0;
        for (let i3 = 0; i3 < Version$1.VERSION_DECODE_INFO.length; i3++) {
          const targetVersion = Version$1.VERSION_DECODE_INFO[i3];
          if (targetVersion === versionBits) {
            return Version$1.getVersionForNumber(i3 + 7);
          }
          const bitsDifference = FormatInformation.numBitsDiffering(versionBits, targetVersion);
          if (bitsDifference < bestDifference) {
            bestVersion = i3 + 7;
            bestDifference = bitsDifference;
          }
        }
        if (bestDifference <= 3) {
          return Version$1.getVersionForNumber(bestVersion);
        }
        return null;
      }
      /**
       * See ISO 18004:2006 Annex E
       */
      buildFunctionPattern() {
        const dimension = this.getDimensionForVersion();
        const bitMatrix = new BitMatrix(dimension);
        bitMatrix.setRegion(0, 0, 9, 9);
        bitMatrix.setRegion(dimension - 8, 0, 8, 9);
        bitMatrix.setRegion(0, dimension - 8, 9, 8);
        const max2 = this.alignmentPatternCenters.length;
        for (let x3 = 0; x3 < max2; x3++) {
          const i3 = this.alignmentPatternCenters[x3] - 2;
          for (let y4 = 0; y4 < max2; y4++) {
            if (x3 === 0 && (y4 === 0 || y4 === max2 - 1) || x3 === max2 - 1 && y4 === 0) {
              continue;
            }
            bitMatrix.setRegion(this.alignmentPatternCenters[y4] - 2, i3, 5, 5);
          }
        }
        bitMatrix.setRegion(6, 9, 1, dimension - 17);
        bitMatrix.setRegion(9, 6, dimension - 17, 1);
        if (this.versionNumber > 6) {
          bitMatrix.setRegion(dimension - 11, 0, 3, 6);
          bitMatrix.setRegion(0, dimension - 11, 6, 3);
        }
        return bitMatrix;
      }
      /*@Override*/
      toString() {
        return "" + this.versionNumber;
      }
    }
    Version$1.VERSION_DECODE_INFO = Int32Array.from([
      31892,
      34236,
      39577,
      42195,
      48118,
      51042,
      55367,
      58893,
      63784,
      68472,
      70749,
      76311,
      79154,
      84390,
      87683,
      92361,
      96236,
      102084,
      102881,
      110507,
      110734,
      117786,
      119615,
      126325,
      127568,
      133589,
      136944,
      141498,
      145311,
      150283,
      152622,
      158308,
      161089,
      167017
    ]);
    Version$1.VERSIONS = [
      new Version$1(1, new Int32Array(0), new ECBlocks$1(7, new ECB$1(1, 19)), new ECBlocks$1(10, new ECB$1(1, 16)), new ECBlocks$1(13, new ECB$1(1, 13)), new ECBlocks$1(17, new ECB$1(1, 9))),
      new Version$1(2, Int32Array.from([6, 18]), new ECBlocks$1(10, new ECB$1(1, 34)), new ECBlocks$1(16, new ECB$1(1, 28)), new ECBlocks$1(22, new ECB$1(1, 22)), new ECBlocks$1(28, new ECB$1(1, 16))),
      new Version$1(3, Int32Array.from([6, 22]), new ECBlocks$1(15, new ECB$1(1, 55)), new ECBlocks$1(26, new ECB$1(1, 44)), new ECBlocks$1(18, new ECB$1(2, 17)), new ECBlocks$1(22, new ECB$1(2, 13))),
      new Version$1(4, Int32Array.from([6, 26]), new ECBlocks$1(20, new ECB$1(1, 80)), new ECBlocks$1(18, new ECB$1(2, 32)), new ECBlocks$1(26, new ECB$1(2, 24)), new ECBlocks$1(16, new ECB$1(4, 9))),
      new Version$1(5, Int32Array.from([6, 30]), new ECBlocks$1(26, new ECB$1(1, 108)), new ECBlocks$1(24, new ECB$1(2, 43)), new ECBlocks$1(18, new ECB$1(2, 15), new ECB$1(2, 16)), new ECBlocks$1(22, new ECB$1(2, 11), new ECB$1(2, 12))),
      new Version$1(6, Int32Array.from([6, 34]), new ECBlocks$1(18, new ECB$1(2, 68)), new ECBlocks$1(16, new ECB$1(4, 27)), new ECBlocks$1(24, new ECB$1(4, 19)), new ECBlocks$1(28, new ECB$1(4, 15))),
      new Version$1(7, Int32Array.from([6, 22, 38]), new ECBlocks$1(20, new ECB$1(2, 78)), new ECBlocks$1(18, new ECB$1(4, 31)), new ECBlocks$1(18, new ECB$1(2, 14), new ECB$1(4, 15)), new ECBlocks$1(26, new ECB$1(4, 13), new ECB$1(1, 14))),
      new Version$1(8, Int32Array.from([6, 24, 42]), new ECBlocks$1(24, new ECB$1(2, 97)), new ECBlocks$1(22, new ECB$1(2, 38), new ECB$1(2, 39)), new ECBlocks$1(22, new ECB$1(4, 18), new ECB$1(2, 19)), new ECBlocks$1(26, new ECB$1(4, 14), new ECB$1(2, 15))),
      new Version$1(9, Int32Array.from([6, 26, 46]), new ECBlocks$1(30, new ECB$1(2, 116)), new ECBlocks$1(22, new ECB$1(3, 36), new ECB$1(2, 37)), new ECBlocks$1(20, new ECB$1(4, 16), new ECB$1(4, 17)), new ECBlocks$1(24, new ECB$1(4, 12), new ECB$1(4, 13))),
      new Version$1(10, Int32Array.from([6, 28, 50]), new ECBlocks$1(18, new ECB$1(2, 68), new ECB$1(2, 69)), new ECBlocks$1(26, new ECB$1(4, 43), new ECB$1(1, 44)), new ECBlocks$1(24, new ECB$1(6, 19), new ECB$1(2, 20)), new ECBlocks$1(28, new ECB$1(6, 15), new ECB$1(2, 16))),
      new Version$1(11, Int32Array.from([6, 30, 54]), new ECBlocks$1(20, new ECB$1(4, 81)), new ECBlocks$1(30, new ECB$1(1, 50), new ECB$1(4, 51)), new ECBlocks$1(28, new ECB$1(4, 22), new ECB$1(4, 23)), new ECBlocks$1(24, new ECB$1(3, 12), new ECB$1(8, 13))),
      new Version$1(12, Int32Array.from([6, 32, 58]), new ECBlocks$1(24, new ECB$1(2, 92), new ECB$1(2, 93)), new ECBlocks$1(22, new ECB$1(6, 36), new ECB$1(2, 37)), new ECBlocks$1(26, new ECB$1(4, 20), new ECB$1(6, 21)), new ECBlocks$1(28, new ECB$1(7, 14), new ECB$1(4, 15))),
      new Version$1(13, Int32Array.from([6, 34, 62]), new ECBlocks$1(26, new ECB$1(4, 107)), new ECBlocks$1(22, new ECB$1(8, 37), new ECB$1(1, 38)), new ECBlocks$1(24, new ECB$1(8, 20), new ECB$1(4, 21)), new ECBlocks$1(22, new ECB$1(12, 11), new ECB$1(4, 12))),
      new Version$1(14, Int32Array.from([6, 26, 46, 66]), new ECBlocks$1(30, new ECB$1(3, 115), new ECB$1(1, 116)), new ECBlocks$1(24, new ECB$1(4, 40), new ECB$1(5, 41)), new ECBlocks$1(20, new ECB$1(11, 16), new ECB$1(5, 17)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(5, 13))),
      new Version$1(15, Int32Array.from([6, 26, 48, 70]), new ECBlocks$1(22, new ECB$1(5, 87), new ECB$1(1, 88)), new ECBlocks$1(24, new ECB$1(5, 41), new ECB$1(5, 42)), new ECBlocks$1(30, new ECB$1(5, 24), new ECB$1(7, 25)), new ECBlocks$1(24, new ECB$1(11, 12), new ECB$1(7, 13))),
      new Version$1(16, Int32Array.from([6, 26, 50, 74]), new ECBlocks$1(24, new ECB$1(5, 98), new ECB$1(1, 99)), new ECBlocks$1(28, new ECB$1(7, 45), new ECB$1(3, 46)), new ECBlocks$1(24, new ECB$1(15, 19), new ECB$1(2, 20)), new ECBlocks$1(30, new ECB$1(3, 15), new ECB$1(13, 16))),
      new Version$1(17, Int32Array.from([6, 30, 54, 78]), new ECBlocks$1(28, new ECB$1(1, 107), new ECB$1(5, 108)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(1, 47)), new ECBlocks$1(28, new ECB$1(1, 22), new ECB$1(15, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(17, 15))),
      new Version$1(18, Int32Array.from([6, 30, 56, 82]), new ECBlocks$1(30, new ECB$1(5, 120), new ECB$1(1, 121)), new ECBlocks$1(26, new ECB$1(9, 43), new ECB$1(4, 44)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(1, 23)), new ECBlocks$1(28, new ECB$1(2, 14), new ECB$1(19, 15))),
      new Version$1(19, Int32Array.from([6, 30, 58, 86]), new ECBlocks$1(28, new ECB$1(3, 113), new ECB$1(4, 114)), new ECBlocks$1(26, new ECB$1(3, 44), new ECB$1(11, 45)), new ECBlocks$1(26, new ECB$1(17, 21), new ECB$1(4, 22)), new ECBlocks$1(26, new ECB$1(9, 13), new ECB$1(16, 14))),
      new Version$1(20, Int32Array.from([6, 34, 62, 90]), new ECBlocks$1(28, new ECB$1(3, 107), new ECB$1(5, 108)), new ECBlocks$1(26, new ECB$1(3, 41), new ECB$1(13, 42)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(5, 25)), new ECBlocks$1(28, new ECB$1(15, 15), new ECB$1(10, 16))),
      new Version$1(21, Int32Array.from([6, 28, 50, 72, 94]), new ECBlocks$1(28, new ECB$1(4, 116), new ECB$1(4, 117)), new ECBlocks$1(26, new ECB$1(17, 42)), new ECBlocks$1(28, new ECB$1(17, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(19, 16), new ECB$1(6, 17))),
      new Version$1(22, Int32Array.from([6, 26, 50, 74, 98]), new ECBlocks$1(28, new ECB$1(2, 111), new ECB$1(7, 112)), new ECBlocks$1(28, new ECB$1(17, 46)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(16, 25)), new ECBlocks$1(24, new ECB$1(34, 13))),
      new Version$1(23, Int32Array.from([6, 30, 54, 78, 102]), new ECBlocks$1(30, new ECB$1(4, 121), new ECB$1(5, 122)), new ECBlocks$1(28, new ECB$1(4, 47), new ECB$1(14, 48)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(16, 15), new ECB$1(14, 16))),
      new Version$1(24, Int32Array.from([6, 28, 54, 80, 106]), new ECBlocks$1(30, new ECB$1(6, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(6, 45), new ECB$1(14, 46)), new ECBlocks$1(30, new ECB$1(11, 24), new ECB$1(16, 25)), new ECBlocks$1(30, new ECB$1(30, 16), new ECB$1(2, 17))),
      new Version$1(25, Int32Array.from([6, 32, 58, 84, 110]), new ECBlocks$1(26, new ECB$1(8, 106), new ECB$1(4, 107)), new ECBlocks$1(28, new ECB$1(8, 47), new ECB$1(13, 48)), new ECBlocks$1(30, new ECB$1(7, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(13, 16))),
      new Version$1(26, Int32Array.from([6, 30, 58, 86, 114]), new ECBlocks$1(28, new ECB$1(10, 114), new ECB$1(2, 115)), new ECBlocks$1(28, new ECB$1(19, 46), new ECB$1(4, 47)), new ECBlocks$1(28, new ECB$1(28, 22), new ECB$1(6, 23)), new ECBlocks$1(30, new ECB$1(33, 16), new ECB$1(4, 17))),
      new Version$1(27, Int32Array.from([6, 34, 62, 90, 118]), new ECBlocks$1(30, new ECB$1(8, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(22, 45), new ECB$1(3, 46)), new ECBlocks$1(30, new ECB$1(8, 23), new ECB$1(26, 24)), new ECBlocks$1(30, new ECB$1(12, 15), new ECB$1(28, 16))),
      new Version$1(28, Int32Array.from([6, 26, 50, 74, 98, 122]), new ECBlocks$1(30, new ECB$1(3, 117), new ECB$1(10, 118)), new ECBlocks$1(28, new ECB$1(3, 45), new ECB$1(23, 46)), new ECBlocks$1(30, new ECB$1(4, 24), new ECB$1(31, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(31, 16))),
      new Version$1(29, Int32Array.from([6, 30, 54, 78, 102, 126]), new ECBlocks$1(30, new ECB$1(7, 116), new ECB$1(7, 117)), new ECBlocks$1(28, new ECB$1(21, 45), new ECB$1(7, 46)), new ECBlocks$1(30, new ECB$1(1, 23), new ECB$1(37, 24)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(26, 16))),
      new Version$1(30, Int32Array.from([6, 26, 52, 78, 104, 130]), new ECBlocks$1(30, new ECB$1(5, 115), new ECB$1(10, 116)), new ECBlocks$1(28, new ECB$1(19, 47), new ECB$1(10, 48)), new ECBlocks$1(30, new ECB$1(15, 24), new ECB$1(25, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(25, 16))),
      new Version$1(31, Int32Array.from([6, 30, 56, 82, 108, 134]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(3, 116)), new ECBlocks$1(28, new ECB$1(2, 46), new ECB$1(29, 47)), new ECBlocks$1(30, new ECB$1(42, 24), new ECB$1(1, 25)), new ECBlocks$1(30, new ECB$1(23, 15), new ECB$1(28, 16))),
      new Version$1(32, Int32Array.from([6, 34, 60, 86, 112, 138]), new ECBlocks$1(30, new ECB$1(17, 115)), new ECBlocks$1(28, new ECB$1(10, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(10, 24), new ECB$1(35, 25)), new ECBlocks$1(30, new ECB$1(19, 15), new ECB$1(35, 16))),
      new Version$1(33, Int32Array.from([6, 30, 58, 86, 114, 142]), new ECBlocks$1(30, new ECB$1(17, 115), new ECB$1(1, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(21, 47)), new ECBlocks$1(30, new ECB$1(29, 24), new ECB$1(19, 25)), new ECBlocks$1(30, new ECB$1(11, 15), new ECB$1(46, 16))),
      new Version$1(34, Int32Array.from([6, 34, 62, 90, 118, 146]), new ECBlocks$1(30, new ECB$1(13, 115), new ECB$1(6, 116)), new ECBlocks$1(28, new ECB$1(14, 46), new ECB$1(23, 47)), new ECBlocks$1(30, new ECB$1(44, 24), new ECB$1(7, 25)), new ECBlocks$1(30, new ECB$1(59, 16), new ECB$1(1, 17))),
      new Version$1(35, Int32Array.from([6, 30, 54, 78, 102, 126, 150]), new ECBlocks$1(30, new ECB$1(12, 121), new ECB$1(7, 122)), new ECBlocks$1(28, new ECB$1(12, 47), new ECB$1(26, 48)), new ECBlocks$1(30, new ECB$1(39, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(22, 15), new ECB$1(41, 16))),
      new Version$1(36, Int32Array.from([6, 24, 50, 76, 102, 128, 154]), new ECBlocks$1(30, new ECB$1(6, 121), new ECB$1(14, 122)), new ECBlocks$1(28, new ECB$1(6, 47), new ECB$1(34, 48)), new ECBlocks$1(30, new ECB$1(46, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(2, 15), new ECB$1(64, 16))),
      new Version$1(37, Int32Array.from([6, 28, 54, 80, 106, 132, 158]), new ECBlocks$1(30, new ECB$1(17, 122), new ECB$1(4, 123)), new ECBlocks$1(28, new ECB$1(29, 46), new ECB$1(14, 47)), new ECBlocks$1(30, new ECB$1(49, 24), new ECB$1(10, 25)), new ECBlocks$1(30, new ECB$1(24, 15), new ECB$1(46, 16))),
      new Version$1(38, Int32Array.from([6, 32, 58, 84, 110, 136, 162]), new ECBlocks$1(30, new ECB$1(4, 122), new ECB$1(18, 123)), new ECBlocks$1(28, new ECB$1(13, 46), new ECB$1(32, 47)), new ECBlocks$1(30, new ECB$1(48, 24), new ECB$1(14, 25)), new ECBlocks$1(30, new ECB$1(42, 15), new ECB$1(32, 16))),
      new Version$1(39, Int32Array.from([6, 26, 54, 82, 110, 138, 166]), new ECBlocks$1(30, new ECB$1(20, 117), new ECB$1(4, 118)), new ECBlocks$1(28, new ECB$1(40, 47), new ECB$1(7, 48)), new ECBlocks$1(30, new ECB$1(43, 24), new ECB$1(22, 25)), new ECBlocks$1(30, new ECB$1(10, 15), new ECB$1(67, 16))),
      new Version$1(40, Int32Array.from([6, 30, 58, 86, 114, 142, 170]), new ECBlocks$1(30, new ECB$1(19, 118), new ECB$1(6, 119)), new ECBlocks$1(28, new ECB$1(18, 47), new ECB$1(31, 48)), new ECBlocks$1(30, new ECB$1(34, 24), new ECB$1(34, 25)), new ECBlocks$1(30, new ECB$1(20, 15), new ECB$1(61, 16)))
    ];
    var DataMaskValues;
    (function(DataMaskValues2) {
      DataMaskValues2[DataMaskValues2["DATA_MASK_000"] = 0] = "DATA_MASK_000";
      DataMaskValues2[DataMaskValues2["DATA_MASK_001"] = 1] = "DATA_MASK_001";
      DataMaskValues2[DataMaskValues2["DATA_MASK_010"] = 2] = "DATA_MASK_010";
      DataMaskValues2[DataMaskValues2["DATA_MASK_011"] = 3] = "DATA_MASK_011";
      DataMaskValues2[DataMaskValues2["DATA_MASK_100"] = 4] = "DATA_MASK_100";
      DataMaskValues2[DataMaskValues2["DATA_MASK_101"] = 5] = "DATA_MASK_101";
      DataMaskValues2[DataMaskValues2["DATA_MASK_110"] = 6] = "DATA_MASK_110";
      DataMaskValues2[DataMaskValues2["DATA_MASK_111"] = 7] = "DATA_MASK_111";
    })(DataMaskValues || (DataMaskValues = {}));
    class DataMask {
      // See ISO 18004:2006 6.8.1
      constructor(value, isMasked) {
        this.value = value;
        this.isMasked = isMasked;
      }
      // End of enum constants.
      /**
       * <p>Implementations of this method reverse the data masking process applied to a QR Code and
       * make its bits ready to read.</p>
       *
       * @param bits representation of QR Code bits
       * @param dimension dimension of QR Code, represented by bits, being unmasked
       */
      unmaskBitMatrix(bits, dimension) {
        for (let i3 = 0; i3 < dimension; i3++) {
          for (let j2 = 0; j2 < dimension; j2++) {
            if (this.isMasked(i3, j2)) {
              bits.flip(j2, i3);
            }
          }
        }
      }
    }
    DataMask.values = /* @__PURE__ */ new Map([
      /**
       * 000: mask bits for which (x + y) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_000, new DataMask(DataMaskValues.DATA_MASK_000, (i3, j2) => {
        return (i3 + j2 & 1) === 0;
      })],
      /**
       * 001: mask bits for which x mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_001, new DataMask(DataMaskValues.DATA_MASK_001, (i3, j2) => {
        return (i3 & 1) === 0;
      })],
      /**
       * 010: mask bits for which y mod 3 == 0
       */
      [DataMaskValues.DATA_MASK_010, new DataMask(DataMaskValues.DATA_MASK_010, (i3, j2) => {
        return j2 % 3 === 0;
      })],
      /**
       * 011: mask bits for which (x + y) mod 3 == 0
       */
      [DataMaskValues.DATA_MASK_011, new DataMask(DataMaskValues.DATA_MASK_011, (i3, j2) => {
        return (i3 + j2) % 3 === 0;
      })],
      /**
       * 100: mask bits for which (x/2 + y/3) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_100, new DataMask(DataMaskValues.DATA_MASK_100, (i3, j2) => {
        return (Math.floor(i3 / 2) + Math.floor(j2 / 3) & 1) === 0;
      })],
      /**
       * 101: mask bits for which xy mod 2 + xy mod 3 == 0
       * equivalently, such that xy mod 6 == 0
       */
      [DataMaskValues.DATA_MASK_101, new DataMask(DataMaskValues.DATA_MASK_101, (i3, j2) => {
        return i3 * j2 % 6 === 0;
      })],
      /**
       * 110: mask bits for which (xy mod 2 + xy mod 3) mod 2 == 0
       * equivalently, such that xy mod 6 < 3
       */
      [DataMaskValues.DATA_MASK_110, new DataMask(DataMaskValues.DATA_MASK_110, (i3, j2) => {
        return i3 * j2 % 6 < 3;
      })],
      /**
       * 111: mask bits for which ((x+y)mod 2 + xy mod 3) mod 2 == 0
       * equivalently, such that (x + y + xy mod 3) mod 2 == 0
       */
      [DataMaskValues.DATA_MASK_111, new DataMask(DataMaskValues.DATA_MASK_111, (i3, j2) => {
        return (i3 + j2 + i3 * j2 % 3 & 1) === 0;
      })]
    ]);
    class BitMatrixParser$1 {
      /**
       * @param bitMatrix {@link BitMatrix} to parse
       * @throws FormatException if dimension is not >= 21 and 1 mod 4
       */
      constructor(bitMatrix) {
        const dimension = bitMatrix.getHeight();
        if (dimension < 21 || (dimension & 3) !== 1) {
          throw new FormatException();
        }
        this.bitMatrix = bitMatrix;
      }
      /**
       * <p>Reads format information from one of its two locations within the QR Code.</p>
       *
       * @return {@link FormatInformation} encapsulating the QR Code's format info
       * @throws FormatException if both format information locations cannot be parsed as
       * the valid encoding of format information
       */
      readFormatInformation() {
        if (this.parsedFormatInfo !== null && this.parsedFormatInfo !== void 0) {
          return this.parsedFormatInfo;
        }
        let formatInfoBits1 = 0;
        for (let i3 = 0; i3 < 6; i3++) {
          formatInfoBits1 = this.copyBit(i3, 8, formatInfoBits1);
        }
        formatInfoBits1 = this.copyBit(7, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 8, formatInfoBits1);
        formatInfoBits1 = this.copyBit(8, 7, formatInfoBits1);
        for (let j2 = 5; j2 >= 0; j2--) {
          formatInfoBits1 = this.copyBit(8, j2, formatInfoBits1);
        }
        const dimension = this.bitMatrix.getHeight();
        let formatInfoBits2 = 0;
        const jMin = dimension - 7;
        for (let j2 = dimension - 1; j2 >= jMin; j2--) {
          formatInfoBits2 = this.copyBit(8, j2, formatInfoBits2);
        }
        for (let i3 = dimension - 8; i3 < dimension; i3++) {
          formatInfoBits2 = this.copyBit(i3, 8, formatInfoBits2);
        }
        this.parsedFormatInfo = FormatInformation.decodeFormatInformation(formatInfoBits1, formatInfoBits2);
        if (this.parsedFormatInfo !== null) {
          return this.parsedFormatInfo;
        }
        throw new FormatException();
      }
      /**
       * <p>Reads version information from one of its two locations within the QR Code.</p>
       *
       * @return {@link Version} encapsulating the QR Code's version
       * @throws FormatException if both version information locations cannot be parsed as
       * the valid encoding of version information
       */
      readVersion() {
        if (this.parsedVersion !== null && this.parsedVersion !== void 0) {
          return this.parsedVersion;
        }
        const dimension = this.bitMatrix.getHeight();
        const provisionalVersion = Math.floor((dimension - 17) / 4);
        if (provisionalVersion <= 6) {
          return Version$1.getVersionForNumber(provisionalVersion);
        }
        let versionBits = 0;
        const ijMin = dimension - 11;
        for (let j2 = 5; j2 >= 0; j2--) {
          for (let i3 = dimension - 9; i3 >= ijMin; i3--) {
            versionBits = this.copyBit(i3, j2, versionBits);
          }
        }
        let theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        versionBits = 0;
        for (let i3 = 5; i3 >= 0; i3--) {
          for (let j2 = dimension - 9; j2 >= ijMin; j2--) {
            versionBits = this.copyBit(i3, j2, versionBits);
          }
        }
        theParsedVersion = Version$1.decodeVersionInformation(versionBits);
        if (theParsedVersion !== null && theParsedVersion.getDimensionForVersion() === dimension) {
          this.parsedVersion = theParsedVersion;
          return theParsedVersion;
        }
        throw new FormatException();
      }
      copyBit(i3, j2, versionBits) {
        const bit = this.isMirror ? this.bitMatrix.get(j2, i3) : this.bitMatrix.get(i3, j2);
        return bit ? versionBits << 1 | 1 : versionBits << 1;
      }
      /**
       * <p>Reads the bits in the {@link BitMatrix} representing the finder pattern in the
       * correct order in order to reconstruct the codewords bytes contained within the
       * QR Code.</p>
       *
       * @return bytes encoded within the QR Code
       * @throws FormatException if the exact number of bytes expected is not read
       */
      readCodewords() {
        const formatInfo = this.readFormatInformation();
        const version = this.readVersion();
        const dataMask = DataMask.values.get(formatInfo.getDataMask());
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
        const functionPattern = version.buildFunctionPattern();
        let readingUp = true;
        const result = new Uint8Array(version.getTotalCodewords());
        let resultOffset = 0;
        let currentByte = 0;
        let bitsRead = 0;
        for (let j2 = dimension - 1; j2 > 0; j2 -= 2) {
          if (j2 === 6) {
            j2--;
          }
          for (let count2 = 0; count2 < dimension; count2++) {
            const i3 = readingUp ? dimension - 1 - count2 : count2;
            for (let col = 0; col < 2; col++) {
              if (!functionPattern.get(j2 - col, i3)) {
                bitsRead++;
                currentByte <<= 1;
                if (this.bitMatrix.get(j2 - col, i3)) {
                  currentByte |= 1;
                }
                if (bitsRead === 8) {
                  result[resultOffset++] = /*(byte) */
                  currentByte;
                  bitsRead = 0;
                  currentByte = 0;
                }
              }
            }
          }
          readingUp = !readingUp;
        }
        if (resultOffset !== version.getTotalCodewords()) {
          throw new FormatException();
        }
        return result;
      }
      /**
       * Revert the mask removal done while reading the code words. The bit matrix should revert to its original state.
       */
      remask() {
        if (this.parsedFormatInfo === null) {
          return;
        }
        const dataMask = DataMask.values[this.parsedFormatInfo.getDataMask()];
        const dimension = this.bitMatrix.getHeight();
        dataMask.unmaskBitMatrix(this.bitMatrix, dimension);
      }
      /**
       * Prepare the parser for a mirrored operation.
       * This flag has effect only on the {@link #readFormatInformation()} and the
       * {@link #readVersion()}. Before proceeding with {@link #readCodewords()} the
       * {@link #mirror()} method should be called.
       *
       * @param mirror Whether to read version and format information mirrored.
       */
      setMirror(isMirror) {
        this.parsedVersion = null;
        this.parsedFormatInfo = null;
        this.isMirror = isMirror;
      }
      /** Mirror the bit matrix in order to attempt a second reading. */
      mirror() {
        const bitMatrix = this.bitMatrix;
        for (let x3 = 0, width = bitMatrix.getWidth(); x3 < width; x3++) {
          for (let y4 = x3 + 1, height = bitMatrix.getHeight(); y4 < height; y4++) {
            if (bitMatrix.get(x3, y4) !== bitMatrix.get(y4, x3)) {
              bitMatrix.flip(y4, x3);
              bitMatrix.flip(x3, y4);
            }
          }
        }
      }
    }
    class DataBlock$1 {
      constructor(numDataCodewords, codewords) {
        this.numDataCodewords = numDataCodewords;
        this.codewords = codewords;
      }
      /**
       * <p>When QR Codes use multiple data blocks, they are actually interleaved.
       * That is, the first byte of data block 1 to n is written, then the second bytes, and so on. This
       * method will separate the data into original blocks.</p>
       *
       * @param rawCodewords bytes as read directly from the QR Code
       * @param version version of the QR Code
       * @param ecLevel error-correction level of the QR Code
       * @return DataBlocks containing original bytes, "de-interleaved" from representation in the
       *         QR Code
       */
      static getDataBlocks(rawCodewords, version, ecLevel) {
        if (rawCodewords.length !== version.getTotalCodewords()) {
          throw new IllegalArgumentException();
        }
        const ecBlocks = version.getECBlocksForLevel(ecLevel);
        let totalBlocks = 0;
        const ecBlockArray = ecBlocks.getECBlocks();
        for (const ecBlock of ecBlockArray) {
          totalBlocks += ecBlock.getCount();
        }
        const result = new Array(totalBlocks);
        let numResultBlocks = 0;
        for (const ecBlock of ecBlockArray) {
          for (let i3 = 0; i3 < ecBlock.getCount(); i3++) {
            const numDataCodewords = ecBlock.getDataCodewords();
            const numBlockCodewords = ecBlocks.getECCodewordsPerBlock() + numDataCodewords;
            result[numResultBlocks++] = new DataBlock$1(numDataCodewords, new Uint8Array(numBlockCodewords));
          }
        }
        const shorterBlocksTotalCodewords = result[0].codewords.length;
        let longerBlocksStartAt = result.length - 1;
        while (longerBlocksStartAt >= 0) {
          const numCodewords = result[longerBlocksStartAt].codewords.length;
          if (numCodewords === shorterBlocksTotalCodewords) {
            break;
          }
          longerBlocksStartAt--;
        }
        longerBlocksStartAt++;
        const shorterBlocksNumDataCodewords = shorterBlocksTotalCodewords - ecBlocks.getECCodewordsPerBlock();
        let rawCodewordsOffset = 0;
        for (let i3 = 0; i3 < shorterBlocksNumDataCodewords; i3++) {
          for (let j2 = 0; j2 < numResultBlocks; j2++) {
            result[j2].codewords[i3] = rawCodewords[rawCodewordsOffset++];
          }
        }
        for (let j2 = longerBlocksStartAt; j2 < numResultBlocks; j2++) {
          result[j2].codewords[shorterBlocksNumDataCodewords] = rawCodewords[rawCodewordsOffset++];
        }
        const max2 = result[0].codewords.length;
        for (let i3 = shorterBlocksNumDataCodewords; i3 < max2; i3++) {
          for (let j2 = 0; j2 < numResultBlocks; j2++) {
            const iOffset = j2 < longerBlocksStartAt ? i3 : i3 + 1;
            result[j2].codewords[iOffset] = rawCodewords[rawCodewordsOffset++];
          }
        }
        return result;
      }
      getNumDataCodewords() {
        return this.numDataCodewords;
      }
      getCodewords() {
        return this.codewords;
      }
    }
    var ModeValues;
    (function(ModeValues2) {
      ModeValues2[ModeValues2["TERMINATOR"] = 0] = "TERMINATOR";
      ModeValues2[ModeValues2["NUMERIC"] = 1] = "NUMERIC";
      ModeValues2[ModeValues2["ALPHANUMERIC"] = 2] = "ALPHANUMERIC";
      ModeValues2[ModeValues2["STRUCTURED_APPEND"] = 3] = "STRUCTURED_APPEND";
      ModeValues2[ModeValues2["BYTE"] = 4] = "BYTE";
      ModeValues2[ModeValues2["ECI"] = 5] = "ECI";
      ModeValues2[ModeValues2["KANJI"] = 6] = "KANJI";
      ModeValues2[ModeValues2["FNC1_FIRST_POSITION"] = 7] = "FNC1_FIRST_POSITION";
      ModeValues2[ModeValues2["FNC1_SECOND_POSITION"] = 8] = "FNC1_SECOND_POSITION";
      ModeValues2[ModeValues2["HANZI"] = 9] = "HANZI";
    })(ModeValues || (ModeValues = {}));
    class Mode$1 {
      constructor(value, stringValue, characterCountBitsForVersions, bits) {
        this.value = value;
        this.stringValue = stringValue;
        this.characterCountBitsForVersions = characterCountBitsForVersions;
        this.bits = bits;
        Mode$1.FOR_BITS.set(bits, this);
        Mode$1.FOR_VALUE.set(value, this);
      }
      /**
       * @param bits four bits encoding a QR Code data mode
       * @return Mode encoded by these bits
       * @throws IllegalArgumentException if bits do not correspond to a known mode
       */
      static forBits(bits) {
        const mode = Mode$1.FOR_BITS.get(bits);
        if (void 0 === mode) {
          throw new IllegalArgumentException();
        }
        return mode;
      }
      /**
       * @param version version in question
       * @return number of bits used, in this QR Code symbol {@link Version}, to encode the
       *         count of characters that will follow encoded in this Mode
       */
      getCharacterCountBits(version) {
        const versionNumber = version.getVersionNumber();
        let offset2;
        if (versionNumber <= 9) {
          offset2 = 0;
        } else if (versionNumber <= 26) {
          offset2 = 1;
        } else {
          offset2 = 2;
        }
        return this.characterCountBitsForVersions[offset2];
      }
      getValue() {
        return this.value;
      }
      getBits() {
        return this.bits;
      }
      equals(o2) {
        if (!(o2 instanceof Mode$1)) {
          return false;
        }
        const other = o2;
        return this.value === other.value;
      }
      toString() {
        return this.stringValue;
      }
    }
    Mode$1.FOR_BITS = /* @__PURE__ */ new Map();
    Mode$1.FOR_VALUE = /* @__PURE__ */ new Map();
    Mode$1.TERMINATOR = new Mode$1(ModeValues.TERMINATOR, "TERMINATOR", Int32Array.from([0, 0, 0]), 0);
    Mode$1.NUMERIC = new Mode$1(ModeValues.NUMERIC, "NUMERIC", Int32Array.from([10, 12, 14]), 1);
    Mode$1.ALPHANUMERIC = new Mode$1(ModeValues.ALPHANUMERIC, "ALPHANUMERIC", Int32Array.from([9, 11, 13]), 2);
    Mode$1.STRUCTURED_APPEND = new Mode$1(ModeValues.STRUCTURED_APPEND, "STRUCTURED_APPEND", Int32Array.from([0, 0, 0]), 3);
    Mode$1.BYTE = new Mode$1(ModeValues.BYTE, "BYTE", Int32Array.from([8, 16, 16]), 4);
    Mode$1.ECI = new Mode$1(ModeValues.ECI, "ECI", Int32Array.from([0, 0, 0]), 7);
    Mode$1.KANJI = new Mode$1(ModeValues.KANJI, "KANJI", Int32Array.from([8, 10, 12]), 8);
    Mode$1.FNC1_FIRST_POSITION = new Mode$1(ModeValues.FNC1_FIRST_POSITION, "FNC1_FIRST_POSITION", Int32Array.from([0, 0, 0]), 5);
    Mode$1.FNC1_SECOND_POSITION = new Mode$1(ModeValues.FNC1_SECOND_POSITION, "FNC1_SECOND_POSITION", Int32Array.from([0, 0, 0]), 9);
    Mode$1.HANZI = new Mode$1(ModeValues.HANZI, "HANZI", Int32Array.from([8, 10, 12]), 13);
    class DecodedBitStreamParser$1 {
      static decode(bytes, version, ecLevel, hints) {
        const bits = new BitSource(bytes);
        let result = new StringBuilder();
        const byteSegments = new Array();
        let symbolSequence = -1;
        let parityData = -1;
        try {
          let currentCharacterSetECI = null;
          let fc1InEffect = false;
          let mode;
          do {
            if (bits.available() < 4) {
              mode = Mode$1.TERMINATOR;
            } else {
              const modeBits = bits.readBits(4);
              mode = Mode$1.forBits(modeBits);
            }
            switch (mode) {
              case Mode$1.TERMINATOR:
                break;
              case Mode$1.FNC1_FIRST_POSITION:
              case Mode$1.FNC1_SECOND_POSITION:
                fc1InEffect = true;
                break;
              case Mode$1.STRUCTURED_APPEND:
                if (bits.available() < 16) {
                  throw new FormatException();
                }
                symbolSequence = bits.readBits(8);
                parityData = bits.readBits(8);
                break;
              case Mode$1.ECI:
                const value = DecodedBitStreamParser$1.parseECIValue(bits);
                currentCharacterSetECI = CharacterSetECI.getCharacterSetECIByValue(value);
                if (currentCharacterSetECI === null) {
                  throw new FormatException();
                }
                break;
              case Mode$1.HANZI:
                const subset = bits.readBits(4);
                const countHanzi = bits.readBits(mode.getCharacterCountBits(version));
                if (subset === DecodedBitStreamParser$1.GB2312_SUBSET) {
                  DecodedBitStreamParser$1.decodeHanziSegment(bits, result, countHanzi);
                }
                break;
              default:
                const count2 = bits.readBits(mode.getCharacterCountBits(version));
                switch (mode) {
                  case Mode$1.NUMERIC:
                    DecodedBitStreamParser$1.decodeNumericSegment(bits, result, count2);
                    break;
                  case Mode$1.ALPHANUMERIC:
                    DecodedBitStreamParser$1.decodeAlphanumericSegment(bits, result, count2, fc1InEffect);
                    break;
                  case Mode$1.BYTE:
                    DecodedBitStreamParser$1.decodeByteSegment(bits, result, count2, currentCharacterSetECI, byteSegments, hints);
                    break;
                  case Mode$1.KANJI:
                    DecodedBitStreamParser$1.decodeKanjiSegment(bits, result, count2);
                    break;
                  default:
                    throw new FormatException();
                }
                break;
            }
          } while (mode !== Mode$1.TERMINATOR);
        } catch (iae) {
          throw new FormatException();
        }
        return new DecoderResult(bytes, result.toString(), byteSegments.length === 0 ? null : byteSegments, ecLevel === null ? null : ecLevel.toString(), symbolSequence, parityData);
      }
      /**
       * See specification GBT 18284-2000
       */
      static decodeHanziSegment(bits, result, count2) {
        if (count2 * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count2);
        let offset2 = 0;
        while (count2 > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 96 << 8 & 4294967295 | twoBytes % 96;
          if (assembledTwoBytes < 959) {
            assembledTwoBytes += 41377;
          } else {
            assembledTwoBytes += 42657;
          }
          buffer[offset2] = /*(byte) */
          assembledTwoBytes >> 8 & 255;
          buffer[offset2 + 1] = /*(byte) */
          assembledTwoBytes & 255;
          offset2 += 2;
          count2--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.GB2312));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeKanjiSegment(bits, result, count2) {
        if (count2 * 13 > bits.available()) {
          throw new FormatException();
        }
        const buffer = new Uint8Array(2 * count2);
        let offset2 = 0;
        while (count2 > 0) {
          const twoBytes = bits.readBits(13);
          let assembledTwoBytes = twoBytes / 192 << 8 & 4294967295 | twoBytes % 192;
          if (assembledTwoBytes < 7936) {
            assembledTwoBytes += 33088;
          } else {
            assembledTwoBytes += 49472;
          }
          buffer[offset2] = /*(byte) */
          assembledTwoBytes >> 8;
          buffer[offset2 + 1] = /*(byte) */
          assembledTwoBytes;
          offset2 += 2;
          count2--;
        }
        try {
          result.append(StringEncoding.decode(buffer, StringUtils.SHIFT_JIS));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
      }
      static decodeByteSegment(bits, result, count2, currentCharacterSetECI, byteSegments, hints) {
        if (8 * count2 > bits.available()) {
          throw new FormatException();
        }
        const readBytes = new Uint8Array(count2);
        for (let i3 = 0; i3 < count2; i3++) {
          readBytes[i3] = /*(byte) */
          bits.readBits(8);
        }
        let encoding;
        if (currentCharacterSetECI === null) {
          encoding = StringUtils.guessEncoding(readBytes, hints);
        } else {
          encoding = currentCharacterSetECI.getName();
        }
        try {
          result.append(StringEncoding.decode(readBytes, encoding));
        } catch (ignored) {
          throw new FormatException(ignored);
        }
        byteSegments.push(readBytes);
      }
      static toAlphaNumericChar(value) {
        if (value >= DecodedBitStreamParser$1.ALPHANUMERIC_CHARS.length) {
          throw new FormatException();
        }
        return DecodedBitStreamParser$1.ALPHANUMERIC_CHARS[value];
      }
      static decodeAlphanumericSegment(bits, result, count2, fc1InEffect) {
        const start = result.length();
        while (count2 > 1) {
          if (bits.available() < 11) {
            throw new FormatException();
          }
          const nextTwoCharsBits = bits.readBits(11);
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(nextTwoCharsBits / 45)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(nextTwoCharsBits % 45));
          count2 -= 2;
        }
        if (count2 === 1) {
          if (bits.available() < 6) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(bits.readBits(6)));
        }
        if (fc1InEffect) {
          for (let i3 = start; i3 < result.length(); i3++) {
            if (result.charAt(i3) === "%") {
              if (i3 < result.length() - 1 && result.charAt(i3 + 1) === "%") {
                result.deleteCharAt(i3 + 1);
              } else {
                result.setCharAt(i3, String.fromCharCode(29));
              }
            }
          }
        }
      }
      static decodeNumericSegment(bits, result, count2) {
        while (count2 >= 3) {
          if (bits.available() < 10) {
            throw new FormatException();
          }
          const threeDigitsBits = bits.readBits(10);
          if (threeDigitsBits >= 1e3) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 100)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(threeDigitsBits / 10) % 10));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(threeDigitsBits % 10));
          count2 -= 3;
        }
        if (count2 === 2) {
          if (bits.available() < 7) {
            throw new FormatException();
          }
          const twoDigitsBits = bits.readBits(7);
          if (twoDigitsBits >= 100) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(Math.floor(twoDigitsBits / 10)));
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(twoDigitsBits % 10));
        } else if (count2 === 1) {
          if (bits.available() < 4) {
            throw new FormatException();
          }
          const digitBits = bits.readBits(4);
          if (digitBits >= 10) {
            throw new FormatException();
          }
          result.append(DecodedBitStreamParser$1.toAlphaNumericChar(digitBits));
        }
      }
      static parseECIValue(bits) {
        const firstByte = bits.readBits(8);
        if ((firstByte & 128) === 0) {
          return firstByte & 127;
        }
        if ((firstByte & 192) === 128) {
          const secondByte = bits.readBits(8);
          return (firstByte & 63) << 8 & 4294967295 | secondByte;
        }
        if ((firstByte & 224) === 192) {
          const secondThirdBytes = bits.readBits(16);
          return (firstByte & 31) << 16 & 4294967295 | secondThirdBytes;
        }
        throw new FormatException();
      }
    }
    DecodedBitStreamParser$1.ALPHANUMERIC_CHARS = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
    DecodedBitStreamParser$1.GB2312_SUBSET = 1;
    class QRCodeDecoderMetaData {
      constructor(mirrored) {
        this.mirrored = mirrored;
      }
      /**
       * @return true if the QR Code was mirrored.
       */
      isMirrored() {
        return this.mirrored;
      }
      /**
       * Apply the result points' order correction due to mirroring.
       *
       * @param points Array of points to apply mirror correction to.
       */
      applyMirroredCorrection(points) {
        if (!this.mirrored || points === null || points.length < 3) {
          return;
        }
        const bottomLeft = points[0];
        points[0] = points[2];
        points[2] = bottomLeft;
      }
    }
    class Decoder$2 {
      constructor() {
        this.rsDecoder = new ReedSolomonDecoder(GenericGF.QR_CODE_FIELD_256);
      }
      // public decode(image: boolean[][]): DecoderResult /*throws ChecksumException, FormatException*/ {
      //   return decode(image, null)
      // }
      /**
       * <p>Convenience method that can decode a QR Code represented as a 2D array of booleans.
       * "true" is taken to mean a black module.</p>
       *
       * @param image booleans representing white/black QR Code modules
       * @param hints decoding hints that should be used to influence decoding
       * @return text and bytes encoded within the QR Code
       * @throws FormatException if the QR Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decodeBooleanArray(image, hints) {
        return this.decodeBitMatrix(BitMatrix.parseFromBooleanArray(image), hints);
      }
      // public decodeBitMatrix(bits: BitMatrix): DecoderResult /*throws ChecksumException, FormatException*/ {
      //   return decode(bits, null)
      // }
      /**
       * <p>Decodes a QR Code represented as a {@link BitMatrix}. A 1 or "true" is taken to mean a black module.</p>
       *
       * @param bits booleans representing white/black QR Code modules
       * @param hints decoding hints that should be used to influence decoding
       * @return text and bytes encoded within the QR Code
       * @throws FormatException if the QR Code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      decodeBitMatrix(bits, hints) {
        const parser = new BitMatrixParser$1(bits);
        let ex = null;
        try {
          return this.decodeBitMatrixParser(parser, hints);
        } catch (e3) {
          ex = e3;
        }
        try {
          parser.remask();
          parser.setMirror(true);
          parser.readVersion();
          parser.readFormatInformation();
          parser.mirror();
          const result = this.decodeBitMatrixParser(parser, hints);
          result.setOther(new QRCodeDecoderMetaData(true));
          return result;
        } catch (e3) {
          if (ex !== null) {
            throw ex;
          }
          throw e3;
        }
      }
      decodeBitMatrixParser(parser, hints) {
        const version = parser.readVersion();
        const ecLevel = parser.readFormatInformation().getErrorCorrectionLevel();
        const codewords = parser.readCodewords();
        const dataBlocks = DataBlock$1.getDataBlocks(codewords, version, ecLevel);
        let totalBytes = 0;
        for (const dataBlock of dataBlocks) {
          totalBytes += dataBlock.getNumDataCodewords();
        }
        const resultBytes = new Uint8Array(totalBytes);
        let resultOffset = 0;
        for (const dataBlock of dataBlocks) {
          const codewordBytes = dataBlock.getCodewords();
          const numDataCodewords = dataBlock.getNumDataCodewords();
          this.correctErrors(codewordBytes, numDataCodewords);
          for (let i3 = 0; i3 < numDataCodewords; i3++) {
            resultBytes[resultOffset++] = codewordBytes[i3];
          }
        }
        return DecodedBitStreamParser$1.decode(resultBytes, version, ecLevel, hints);
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place using Reed-Solomon error correction.</p>
       *
       * @param codewordBytes data and error correction codewords
       * @param numDataCodewords number of codewords that are data bytes
       * @throws ChecksumException if error correction fails
       */
      correctErrors(codewordBytes, numDataCodewords) {
        const codewordsInts = new Int32Array(codewordBytes);
        try {
          this.rsDecoder.decode(codewordsInts, codewordBytes.length - numDataCodewords);
        } catch (ignored) {
          throw new ChecksumException();
        }
        for (let i3 = 0; i3 < numDataCodewords; i3++) {
          codewordBytes[i3] = /*(byte) */
          codewordsInts[i3];
        }
      }
    }
    class AlignmentPattern extends ResultPoint {
      constructor(posX, posY, estimatedModuleSize) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
      }
      /**
       * <p>Determines if this alignment pattern "about equals" an alignment pattern at the stated
       * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
       */
      aboutEquals(moduleSize, i3, j2) {
        if (Math.abs(i3 - this.getY()) <= moduleSize && Math.abs(j2 - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      /**
       * Combines this object's current estimate of a finder pattern position and module size
       * with a new estimate. It returns a new {@code FinderPattern} containing an average of the two.
       */
      combineEstimate(i3, j2, newModuleSize) {
        const combinedX = (this.getX() + j2) / 2;
        const combinedY = (this.getY() + i3) / 2;
        const combinedModuleSize = (this.estimatedModuleSize + newModuleSize) / 2;
        return new AlignmentPattern(combinedX, combinedY, combinedModuleSize);
      }
    }
    class AlignmentPatternFinder {
      /**
       * <p>Creates a finder that will look in a portion of the whole image.</p>
       *
       * @param image image to search
       * @param startX left column from which to start searching
       * @param startY top row from which to start searching
       * @param width width of region to search
       * @param height height of region to search
       * @param moduleSize estimated module size so far
       */
      constructor(image, startX, startY, width, height, moduleSize, resultPointCallback) {
        this.image = image;
        this.startX = startX;
        this.startY = startY;
        this.width = width;
        this.height = height;
        this.moduleSize = moduleSize;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(3);
      }
      /**
       * <p>This method attempts to find the bottom-right alignment pattern in the image. It is a bit messy since
       * it's pretty performance-critical and so is written to be fast foremost.</p>
       *
       * @return {@link AlignmentPattern} if found
       * @throws NotFoundException if not found
       */
      find() {
        const startX = this.startX;
        const height = this.height;
        const width = this.width;
        const maxJ = startX + width;
        const middleI = this.startY + height / 2;
        const stateCount = new Int32Array(3);
        const image = this.image;
        for (let iGen = 0; iGen < height; iGen++) {
          const i3 = middleI + ((iGen & 1) === 0 ? Math.floor((iGen + 1) / 2) : -Math.floor((iGen + 1) / 2));
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          let j2 = startX;
          while (j2 < maxJ && !image.get(j2, i3)) {
            j2++;
          }
          let currentState = 0;
          while (j2 < maxJ) {
            if (image.get(j2, i3)) {
              if (currentState === 1) {
                stateCount[1]++;
              } else {
                if (currentState === 2) {
                  if (this.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i3, j2);
                    if (confirmed !== null) {
                      return confirmed;
                    }
                  }
                  stateCount[0] = stateCount[2];
                  stateCount[1] = 1;
                  stateCount[2] = 0;
                  currentState = 1;
                } else {
                  stateCount[++currentState]++;
                }
              }
            } else {
              if (currentState === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            }
            j2++;
          }
          if (this.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i3, maxJ);
            if (confirmed !== null) {
              return confirmed;
            }
          }
        }
        if (this.possibleCenters.length !== 0) {
          return this.possibleCenters[0];
        }
        throw new NotFoundException();
      }
      /**
       * Given a count of black/white/black pixels just seen and an end position,
       * figures the location of the center of this black/white/black run.
       */
      static centerFromEnd(stateCount, end) {
        return end - stateCount[2] - stateCount[1] / 2;
      }
      /**
       * @param stateCount count of black/white/black pixels just read
       * @return true iff the proportions of the counts is close enough to the 1/1/1 ratios
       *         used by alignment patterns to be considered a match
       */
      foundPatternCross(stateCount) {
        const moduleSize = this.moduleSize;
        const maxVariance = moduleSize / 2;
        for (let i3 = 0; i3 < 3; i3++) {
          if (Math.abs(moduleSize - stateCount[i3]) >= maxVariance) {
            return false;
          }
        }
        return true;
      }
      /**
       * <p>After a horizontal scan finds a potential alignment pattern, this method
       * "cross-checks" by scanning down vertically through the center of the possible
       * alignment pattern to see if the same proportion is detected.</p>
       *
       * @param startI row where an alignment pattern was detected
       * @param centerJ center of the section that appears to cross an alignment pattern
       * @param maxCount maximum reasonable number of modules that should be
       * observed in any reading state, based on the results of the horizontal scan
       * @return vertical center of alignment pattern, or {@link Float#NaN} if not found
       */
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.crossCheckStateCount;
        stateCount[0] = 0;
        stateCount[1] = 0;
        stateCount[2] = 0;
        let i3 = startI;
        while (i3 >= 0 && image.get(centerJ, i3) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i3--;
        }
        if (i3 < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i3 >= 0 && !image.get(centerJ, i3) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i3--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i3 = startI + 1;
        while (i3 < maxI && image.get(centerJ, i3) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i3++;
        }
        if (i3 === maxI || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i3 < maxI && !image.get(centerJ, i3) && stateCount[2] <= maxCount) {
          stateCount[2]++;
          i3++;
        }
        if (stateCount[2] > maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return this.foundPatternCross(stateCount) ? AlignmentPatternFinder.centerFromEnd(stateCount, i3) : NaN;
      }
      /**
       * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
       * cross check with a vertical scan, and if successful, will see if this pattern had been
       * found on a previous horizontal scan. If so, we consider it confirmed and conclude we have
       * found the alignment pattern.</p>
       *
       * @param stateCount reading state module counts from horizontal scan
       * @param i row where alignment pattern may be found
       * @param j end of possible alignment pattern in row
       * @return {@link AlignmentPattern} if we have found the same pattern twice, or null if not
       */
      handlePossibleCenter(stateCount, i3, j2) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2];
        const centerJ = AlignmentPatternFinder.centerFromEnd(stateCount, j2);
        const centerI = this.crossCheckVertical(
          i3,
          /*(int) */
          centerJ,
          2 * stateCount[1],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          const estimatedModuleSize = (stateCount[0] + stateCount[1] + stateCount[2]) / 3;
          for (const center of this.possibleCenters) {
            if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
              return center.combineEstimate(centerI, centerJ, estimatedModuleSize);
            }
          }
          const point = new AlignmentPattern(centerJ, centerI, estimatedModuleSize);
          this.possibleCenters.push(point);
          if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
            this.resultPointCallback.foundPossibleResultPoint(point);
          }
        }
        return null;
      }
    }
    class FinderPattern$1 extends ResultPoint {
      // FinderPattern(posX: number/*float*/, posY: number/*float*/, estimatedModuleSize: number/*float*/) {
      //   this(posX, posY, estimatedModuleSize, 1)
      // }
      constructor(posX, posY, estimatedModuleSize, count2) {
        super(posX, posY);
        this.estimatedModuleSize = estimatedModuleSize;
        this.count = count2;
        if (void 0 === count2) {
          this.count = 1;
        }
      }
      getEstimatedModuleSize() {
        return this.estimatedModuleSize;
      }
      getCount() {
        return this.count;
      }
      /*
      void incrementCount() {
        this.count++
      }
       */
      /**
       * <p>Determines if this finder pattern "about equals" a finder pattern at the stated
       * position and size -- meaning, it is at nearly the same center with nearly the same size.</p>
       */
      aboutEquals(moduleSize, i3, j2) {
        if (Math.abs(i3 - this.getY()) <= moduleSize && Math.abs(j2 - this.getX()) <= moduleSize) {
          const moduleSizeDiff = Math.abs(moduleSize - this.estimatedModuleSize);
          return moduleSizeDiff <= 1 || moduleSizeDiff <= this.estimatedModuleSize;
        }
        return false;
      }
      /**
       * Combines this object's current estimate of a finder pattern position and module size
       * with a new estimate. It returns a new {@code FinderPattern} containing a weighted average
       * based on count.
       */
      combineEstimate(i3, j2, newModuleSize) {
        const combinedCount = this.count + 1;
        const combinedX = (this.count * this.getX() + j2) / combinedCount;
        const combinedY = (this.count * this.getY() + i3) / combinedCount;
        const combinedModuleSize = (this.count * this.estimatedModuleSize + newModuleSize) / combinedCount;
        return new FinderPattern$1(combinedX, combinedY, combinedModuleSize, combinedCount);
      }
    }
    class FinderPatternInfo {
      constructor(patternCenters) {
        this.bottomLeft = patternCenters[0];
        this.topLeft = patternCenters[1];
        this.topRight = patternCenters[2];
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
    }
    class FinderPatternFinder {
      /**
       * <p>Creates a finder that will search the image for three finder patterns.</p>
       *
       * @param image image to search
       */
      // public constructor(image: BitMatrix) {
      //   this(image, null)
      // }
      constructor(image, resultPointCallback) {
        this.image = image;
        this.resultPointCallback = resultPointCallback;
        this.possibleCenters = [];
        this.crossCheckStateCount = new Int32Array(5);
        this.resultPointCallback = resultPointCallback;
      }
      getImage() {
        return this.image;
      }
      getPossibleCenters() {
        return this.possibleCenters;
      }
      find(hints) {
        const tryHarder = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.TRY_HARDER);
        const pureBarcode = hints !== null && hints !== void 0 && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE);
        const image = this.image;
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        let iSkip = Math.floor(3 * maxI / (4 * FinderPatternFinder.MAX_MODULES));
        if (iSkip < FinderPatternFinder.MIN_SKIP || tryHarder) {
          iSkip = FinderPatternFinder.MIN_SKIP;
        }
        let done = false;
        const stateCount = new Int32Array(5);
        for (let i3 = iSkip - 1; i3 < maxI && !done; i3 += iSkip) {
          stateCount[0] = 0;
          stateCount[1] = 0;
          stateCount[2] = 0;
          stateCount[3] = 0;
          stateCount[4] = 0;
          let currentState = 0;
          for (let j2 = 0; j2 < maxJ; j2++) {
            if (image.get(j2, i3)) {
              if ((currentState & 1) === 1) {
                currentState++;
              }
              stateCount[currentState]++;
            } else {
              if ((currentState & 1) === 0) {
                if (currentState === 4) {
                  if (FinderPatternFinder.foundPatternCross(stateCount)) {
                    const confirmed = this.handlePossibleCenter(stateCount, i3, j2, pureBarcode);
                    if (confirmed === true) {
                      iSkip = 2;
                      if (this.hasSkipped === true) {
                        done = this.haveMultiplyConfirmedCenters();
                      } else {
                        const rowSkip = this.findRowSkip();
                        if (rowSkip > stateCount[2]) {
                          i3 += rowSkip - stateCount[2] - iSkip;
                          j2 = maxJ - 1;
                        }
                      }
                    } else {
                      stateCount[0] = stateCount[2];
                      stateCount[1] = stateCount[3];
                      stateCount[2] = stateCount[4];
                      stateCount[3] = 1;
                      stateCount[4] = 0;
                      currentState = 3;
                      continue;
                    }
                    currentState = 0;
                    stateCount[0] = 0;
                    stateCount[1] = 0;
                    stateCount[2] = 0;
                    stateCount[3] = 0;
                    stateCount[4] = 0;
                  } else {
                    stateCount[0] = stateCount[2];
                    stateCount[1] = stateCount[3];
                    stateCount[2] = stateCount[4];
                    stateCount[3] = 1;
                    stateCount[4] = 0;
                    currentState = 3;
                  }
                } else {
                  stateCount[++currentState]++;
                }
              } else {
                stateCount[currentState]++;
              }
            }
          }
          if (FinderPatternFinder.foundPatternCross(stateCount)) {
            const confirmed = this.handlePossibleCenter(stateCount, i3, maxJ, pureBarcode);
            if (confirmed === true) {
              iSkip = stateCount[0];
              if (this.hasSkipped) {
                done = this.haveMultiplyConfirmedCenters();
              }
            }
          }
        }
        const patternInfo = this.selectBestPatterns();
        ResultPoint.orderBestPatterns(patternInfo);
        return new FinderPatternInfo(patternInfo);
      }
      /**
       * Given a count of black/white/black/white/black pixels just seen and an end position,
       * figures the location of the center of this run.
       */
      static centerFromEnd(stateCount, end) {
        return end - stateCount[4] - stateCount[3] - stateCount[2] / 2;
      }
      /**
       * @param stateCount count of black/white/black/white/black pixels just read
       * @return true iff the proportions of the counts is close enough to the 1/1/3/1/1 ratios
       *         used by finder patterns to be considered a match
       */
      static foundPatternCross(stateCount) {
        let totalModuleSize = 0;
        for (let i3 = 0; i3 < 5; i3++) {
          const count2 = stateCount[i3];
          if (count2 === 0) {
            return false;
          }
          totalModuleSize += count2;
        }
        if (totalModuleSize < 7) {
          return false;
        }
        const moduleSize = totalModuleSize / 7;
        const maxVariance = moduleSize / 2;
        return Math.abs(moduleSize - stateCount[0]) < maxVariance && Math.abs(moduleSize - stateCount[1]) < maxVariance && Math.abs(3 * moduleSize - stateCount[2]) < 3 * maxVariance && Math.abs(moduleSize - stateCount[3]) < maxVariance && Math.abs(moduleSize - stateCount[4]) < maxVariance;
      }
      getCrossCheckStateCount() {
        const crossCheckStateCount = this.crossCheckStateCount;
        crossCheckStateCount[0] = 0;
        crossCheckStateCount[1] = 0;
        crossCheckStateCount[2] = 0;
        crossCheckStateCount[3] = 0;
        crossCheckStateCount[4] = 0;
        return crossCheckStateCount;
      }
      /**
       * After a vertical and horizontal scan finds a potential finder pattern, this method
       * "cross-cross-cross-checks" by scanning down diagonally through the center of the possible
       * finder pattern to see if the same proportion is detected.
       *
       * @param startI row where a finder pattern was detected
       * @param centerJ center of the section that appears to cross a finder pattern
       * @param maxCount maximum reasonable number of modules that should be
       *  observed in any reading state, based on the results of the horizontal scan
       * @param originalStateCountTotal The original state count total.
       * @return true if proportions are withing expected limits
       */
      crossCheckDiagonal(startI, centerJ, maxCount, originalStateCountTotal) {
        const stateCount = this.getCrossCheckStateCount();
        let i3 = 0;
        const image = this.image;
        while (startI >= i3 && centerJ >= i3 && image.get(centerJ - i3, startI - i3)) {
          stateCount[2]++;
          i3++;
        }
        if (startI < i3 || centerJ < i3) {
          return false;
        }
        while (startI >= i3 && centerJ >= i3 && !image.get(centerJ - i3, startI - i3) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i3++;
        }
        if (startI < i3 || centerJ < i3 || stateCount[1] > maxCount) {
          return false;
        }
        while (startI >= i3 && centerJ >= i3 && image.get(centerJ - i3, startI - i3) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i3++;
        }
        if (stateCount[0] > maxCount) {
          return false;
        }
        const maxI = image.getHeight();
        const maxJ = image.getWidth();
        i3 = 1;
        while (startI + i3 < maxI && centerJ + i3 < maxJ && image.get(centerJ + i3, startI + i3)) {
          stateCount[2]++;
          i3++;
        }
        if (startI + i3 >= maxI || centerJ + i3 >= maxJ) {
          return false;
        }
        while (startI + i3 < maxI && centerJ + i3 < maxJ && !image.get(centerJ + i3, startI + i3) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i3++;
        }
        if (startI + i3 >= maxI || centerJ + i3 >= maxJ || stateCount[3] >= maxCount) {
          return false;
        }
        while (startI + i3 < maxI && centerJ + i3 < maxJ && image.get(centerJ + i3, startI + i3) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i3++;
        }
        if (stateCount[4] >= maxCount) {
          return false;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        return Math.abs(stateCountTotal - originalStateCountTotal) < 2 * originalStateCountTotal && FinderPatternFinder.foundPatternCross(stateCount);
      }
      /**
       * <p>After a horizontal scan finds a potential finder pattern, this method
       * "cross-checks" by scanning down vertically through the center of the possible
       * finder pattern to see if the same proportion is detected.</p>
       *
       * @param startI row where a finder pattern was detected
       * @param centerJ center of the section that appears to cross a finder pattern
       * @param maxCount maximum reasonable number of modules that should be
       * observed in any reading state, based on the results of the horizontal scan
       * @return vertical center of finder pattern, or {@link Float#NaN} if not found
       */
      crossCheckVertical(startI, centerJ, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxI = image.getHeight();
        const stateCount = this.getCrossCheckStateCount();
        let i3 = startI;
        while (i3 >= 0 && image.get(centerJ, i3)) {
          stateCount[2]++;
          i3--;
        }
        if (i3 < 0) {
          return NaN;
        }
        while (i3 >= 0 && !image.get(centerJ, i3) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          i3--;
        }
        if (i3 < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (i3 >= 0 && image.get(centerJ, i3) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          i3--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        i3 = startI + 1;
        while (i3 < maxI && image.get(centerJ, i3)) {
          stateCount[2]++;
          i3++;
        }
        if (i3 === maxI) {
          return NaN;
        }
        while (i3 < maxI && !image.get(centerJ, i3) && stateCount[3] < maxCount) {
          stateCount[3]++;
          i3++;
        }
        if (i3 === maxI || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (i3 < maxI && image.get(centerJ, i3) && stateCount[4] < maxCount) {
          stateCount[4]++;
          i3++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= 2 * originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, i3) : NaN;
      }
      /**
       * <p>Like {@link #crossCheckVertical(int, int, int, int)}, and in fact is basically identical,
       * except it reads horizontally instead of vertically. This is used to cross-cross
       * check a vertical cross check and locate the real center of the alignment pattern.</p>
       */
      crossCheckHorizontal(startJ, centerI, maxCount, originalStateCountTotal) {
        const image = this.image;
        const maxJ = image.getWidth();
        const stateCount = this.getCrossCheckStateCount();
        let j2 = startJ;
        while (j2 >= 0 && image.get(j2, centerI)) {
          stateCount[2]++;
          j2--;
        }
        if (j2 < 0) {
          return NaN;
        }
        while (j2 >= 0 && !image.get(j2, centerI) && stateCount[1] <= maxCount) {
          stateCount[1]++;
          j2--;
        }
        if (j2 < 0 || stateCount[1] > maxCount) {
          return NaN;
        }
        while (j2 >= 0 && image.get(j2, centerI) && stateCount[0] <= maxCount) {
          stateCount[0]++;
          j2--;
        }
        if (stateCount[0] > maxCount) {
          return NaN;
        }
        j2 = startJ + 1;
        while (j2 < maxJ && image.get(j2, centerI)) {
          stateCount[2]++;
          j2++;
        }
        if (j2 === maxJ) {
          return NaN;
        }
        while (j2 < maxJ && !image.get(j2, centerI) && stateCount[3] < maxCount) {
          stateCount[3]++;
          j2++;
        }
        if (j2 === maxJ || stateCount[3] >= maxCount) {
          return NaN;
        }
        while (j2 < maxJ && image.get(j2, centerI) && stateCount[4] < maxCount) {
          stateCount[4]++;
          j2++;
        }
        if (stateCount[4] >= maxCount) {
          return NaN;
        }
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        if (5 * Math.abs(stateCountTotal - originalStateCountTotal) >= originalStateCountTotal) {
          return NaN;
        }
        return FinderPatternFinder.foundPatternCross(stateCount) ? FinderPatternFinder.centerFromEnd(stateCount, j2) : NaN;
      }
      /**
       * <p>This is called when a horizontal scan finds a possible alignment pattern. It will
       * cross check with a vertical scan, and if successful, will, ah, cross-cross-check
       * with another horizontal scan. This is needed primarily to locate the real horizontal
       * center of the pattern in cases of extreme skew.
       * And then we cross-cross-cross check with another diagonal scan.</p>
       *
       * <p>If that succeeds the finder pattern location is added to a list that tracks
       * the number of times each location has been nearly-matched as a finder pattern.
       * Each additional find is more evidence that the location is in fact a finder
       * pattern center
       *
       * @param stateCount reading state module counts from horizontal scan
       * @param i row where finder pattern may be found
       * @param j end of possible finder pattern in row
       * @param pureBarcode true if in "pure barcode" mode
       * @return true if a finder pattern candidate was found this time
       */
      handlePossibleCenter(stateCount, i3, j2, pureBarcode) {
        const stateCountTotal = stateCount[0] + stateCount[1] + stateCount[2] + stateCount[3] + stateCount[4];
        let centerJ = FinderPatternFinder.centerFromEnd(stateCount, j2);
        let centerI = this.crossCheckVertical(
          i3,
          /*(int) */
          Math.floor(centerJ),
          stateCount[2],
          stateCountTotal
        );
        if (!isNaN(centerI)) {
          centerJ = this.crossCheckHorizontal(
            /*(int) */
            Math.floor(centerJ),
            /*(int) */
            Math.floor(centerI),
            stateCount[2],
            stateCountTotal
          );
          if (!isNaN(centerJ) && (!pureBarcode || this.crossCheckDiagonal(
            /*(int) */
            Math.floor(centerI),
            /*(int) */
            Math.floor(centerJ),
            stateCount[2],
            stateCountTotal
          ))) {
            const estimatedModuleSize = stateCountTotal / 7;
            let found = false;
            const possibleCenters = this.possibleCenters;
            for (let index2 = 0, length = possibleCenters.length; index2 < length; index2++) {
              const center = possibleCenters[index2];
              if (center.aboutEquals(estimatedModuleSize, centerI, centerJ)) {
                possibleCenters[index2] = center.combineEstimate(centerI, centerJ, estimatedModuleSize);
                found = true;
                break;
              }
            }
            if (!found) {
              const point = new FinderPattern$1(centerJ, centerI, estimatedModuleSize);
              possibleCenters.push(point);
              if (this.resultPointCallback !== null && this.resultPointCallback !== void 0) {
                this.resultPointCallback.foundPossibleResultPoint(point);
              }
            }
            return true;
          }
        }
        return false;
      }
      /**
       * @return number of rows we could safely skip during scanning, based on the first
       *         two finder patterns that have been located. In some cases their position will
       *         allow us to infer that the third pattern must lie below a certain point farther
       *         down in the image.
       */
      findRowSkip() {
        const max2 = this.possibleCenters.length;
        if (max2 <= 1) {
          return 0;
        }
        let firstConfirmedCenter = null;
        for (const center of this.possibleCenters) {
          if (center.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            if (firstConfirmedCenter == null) {
              firstConfirmedCenter = center;
            } else {
              this.hasSkipped = true;
              return (
                /*(int) */
                Math.floor((Math.abs(firstConfirmedCenter.getX() - center.getX()) - Math.abs(firstConfirmedCenter.getY() - center.getY())) / 2)
              );
            }
          }
        }
        return 0;
      }
      /**
       * @return true iff we have found at least 3 finder patterns that have been detected
       *         at least {@link #CENTER_QUORUM} times each, and, the estimated module size of the
       *         candidates is "pretty similar"
       */
      haveMultiplyConfirmedCenters() {
        let confirmedCount = 0;
        let totalModuleSize = 0;
        const max2 = this.possibleCenters.length;
        for (const pattern of this.possibleCenters) {
          if (pattern.getCount() >= FinderPatternFinder.CENTER_QUORUM) {
            confirmedCount++;
            totalModuleSize += pattern.getEstimatedModuleSize();
          }
        }
        if (confirmedCount < 3) {
          return false;
        }
        const average = totalModuleSize / max2;
        let totalDeviation = 0;
        for (const pattern of this.possibleCenters) {
          totalDeviation += Math.abs(pattern.getEstimatedModuleSize() - average);
        }
        return totalDeviation <= 0.05 * totalModuleSize;
      }
      /**
       * @return the 3 best {@link FinderPattern}s from our list of candidates. The "best" are
       *         those that have been detected at least {@link #CENTER_QUORUM} times, and whose module
       *         size differs from the average among those patterns the least
       * @throws NotFoundException if 3 such finder patterns do not exist
       */
      selectBestPatterns() {
        const startSize = this.possibleCenters.length;
        if (startSize < 3) {
          throw new NotFoundException();
        }
        const possibleCenters = this.possibleCenters;
        let average;
        if (startSize > 3) {
          let totalModuleSize = 0;
          let square = 0;
          for (const center of this.possibleCenters) {
            const size2 = center.getEstimatedModuleSize();
            totalModuleSize += size2;
            square += size2 * size2;
          }
          average = totalModuleSize / startSize;
          let stdDev = Math.sqrt(square / startSize - average * average);
          possibleCenters.sort(
            /**
             * <p>Orders by furthest from average</p>
             */
            // FurthestFromAverageComparator implements Comparator<FinderPattern>
            (center1, center2) => {
              const dA = Math.abs(center2.getEstimatedModuleSize() - average);
              const dB = Math.abs(center1.getEstimatedModuleSize() - average);
              return dA < dB ? -1 : dA > dB ? 1 : 0;
            }
          );
          const limit = Math.max(0.2 * average, stdDev);
          for (let i3 = 0; i3 < possibleCenters.length && possibleCenters.length > 3; i3++) {
            const pattern = possibleCenters[i3];
            if (Math.abs(pattern.getEstimatedModuleSize() - average) > limit) {
              possibleCenters.splice(i3, 1);
              i3--;
            }
          }
        }
        if (possibleCenters.length > 3) {
          let totalModuleSize = 0;
          for (const possibleCenter of possibleCenters) {
            totalModuleSize += possibleCenter.getEstimatedModuleSize();
          }
          average = totalModuleSize / possibleCenters.length;
          possibleCenters.sort(
            /**
             * <p>Orders by {@link FinderPattern#getCount()}, descending.</p>
             */
            // CenterComparator implements Comparator<FinderPattern>
            (center1, center2) => {
              if (center2.getCount() === center1.getCount()) {
                const dA = Math.abs(center2.getEstimatedModuleSize() - average);
                const dB = Math.abs(center1.getEstimatedModuleSize() - average);
                return dA < dB ? 1 : dA > dB ? -1 : 0;
              } else {
                return center2.getCount() - center1.getCount();
              }
            }
          );
          possibleCenters.splice(3);
        }
        return [
          possibleCenters[0],
          possibleCenters[1],
          possibleCenters[2]
        ];
      }
    }
    FinderPatternFinder.CENTER_QUORUM = 2;
    FinderPatternFinder.MIN_SKIP = 3;
    FinderPatternFinder.MAX_MODULES = 57;
    class Detector$2 {
      constructor(image) {
        this.image = image;
      }
      getImage() {
        return this.image;
      }
      getResultPointCallback() {
        return this.resultPointCallback;
      }
      /**
       * <p>Detects a QR Code in an image.</p>
       *
       * @return {@link DetectorResult} encapsulating results of detecting a QR Code
       * @throws NotFoundException if QR Code cannot be found
       * @throws FormatException if a QR Code cannot be decoded
       */
      // public detect(): DetectorResult /*throws NotFoundException, FormatException*/ {
      //   return detect(null)
      // }
      /**
       * <p>Detects a QR Code in an image.</p>
       *
       * @param hints optional hints to detector
       * @return {@link DetectorResult} encapsulating results of detecting a QR Code
       * @throws NotFoundException if QR Code cannot be found
       * @throws FormatException if a QR Code cannot be decoded
       */
      detect(hints) {
        this.resultPointCallback = hints === null || hints === void 0 ? null : (
          /*(ResultPointCallback) */
          hints.get(DecodeHintType$1.NEED_RESULT_POINT_CALLBACK)
        );
        const finder = new FinderPatternFinder(this.image, this.resultPointCallback);
        const info = finder.find(hints);
        return this.processFinderPatternInfo(info);
      }
      processFinderPatternInfo(info) {
        const topLeft = info.getTopLeft();
        const topRight = info.getTopRight();
        const bottomLeft = info.getBottomLeft();
        const moduleSize = this.calculateModuleSize(topLeft, topRight, bottomLeft);
        if (moduleSize < 1) {
          throw new NotFoundException("No pattern found in proccess finder.");
        }
        const dimension = Detector$2.computeDimension(topLeft, topRight, bottomLeft, moduleSize);
        const provisionalVersion = Version$1.getProvisionalVersionForDimension(dimension);
        const modulesBetweenFPCenters = provisionalVersion.getDimensionForVersion() - 7;
        let alignmentPattern = null;
        if (provisionalVersion.getAlignmentPatternCenters().length > 0) {
          const bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          const bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          const correctionToTopLeft = 1 - 3 / modulesBetweenFPCenters;
          const estAlignmentX = (
            /*(int) */
            Math.floor(topLeft.getX() + correctionToTopLeft * (bottomRightX - topLeft.getX()))
          );
          const estAlignmentY = (
            /*(int) */
            Math.floor(topLeft.getY() + correctionToTopLeft * (bottomRightY - topLeft.getY()))
          );
          for (let i3 = 4; i3 <= 16; i3 <<= 1) {
            try {
              alignmentPattern = this.findAlignmentInRegion(moduleSize, estAlignmentX, estAlignmentY, i3);
              break;
            } catch (re2) {
              if (!(re2 instanceof NotFoundException)) {
                throw re2;
              }
            }
          }
        }
        const transform = Detector$2.createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension);
        const bits = Detector$2.sampleGrid(this.image, transform, dimension);
        let points;
        if (alignmentPattern === null) {
          points = [bottomLeft, topLeft, topRight];
        } else {
          points = [bottomLeft, topLeft, topRight, alignmentPattern];
        }
        return new DetectorResult(bits, points);
      }
      static createTransform(topLeft, topRight, bottomLeft, alignmentPattern, dimension) {
        const dimMinusThree = dimension - 3.5;
        let bottomRightX;
        let bottomRightY;
        let sourceBottomRightX;
        let sourceBottomRightY;
        if (alignmentPattern !== null) {
          bottomRightX = alignmentPattern.getX();
          bottomRightY = alignmentPattern.getY();
          sourceBottomRightX = dimMinusThree - 3;
          sourceBottomRightY = sourceBottomRightX;
        } else {
          bottomRightX = topRight.getX() - topLeft.getX() + bottomLeft.getX();
          bottomRightY = topRight.getY() - topLeft.getY() + bottomLeft.getY();
          sourceBottomRightX = dimMinusThree;
          sourceBottomRightY = dimMinusThree;
        }
        return PerspectiveTransform.quadrilateralToQuadrilateral(3.5, 3.5, dimMinusThree, 3.5, sourceBottomRightX, sourceBottomRightY, 3.5, dimMinusThree, topLeft.getX(), topLeft.getY(), topRight.getX(), topRight.getY(), bottomRightX, bottomRightY, bottomLeft.getX(), bottomLeft.getY());
      }
      static sampleGrid(image, transform, dimension) {
        const sampler = GridSamplerInstance.getInstance();
        return sampler.sampleGridWithTransform(image, dimension, dimension, transform);
      }
      /**
       * <p>Computes the dimension (number of modules on a size) of the QR Code based on the position
       * of the finder patterns and estimated module size.</p>
       */
      static computeDimension(topLeft, topRight, bottomLeft, moduleSize) {
        const tltrCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, topRight) / moduleSize);
        const tlblCentersDimension = MathUtils.round(ResultPoint.distance(topLeft, bottomLeft) / moduleSize);
        let dimension = Math.floor((tltrCentersDimension + tlblCentersDimension) / 2) + 7;
        switch (dimension & 3) {
          case 0:
            dimension++;
            break;
          case 2:
            dimension--;
            break;
          case 3:
            throw new NotFoundException("Dimensions could be not found.");
        }
        return dimension;
      }
      /**
       * <p>Computes an average estimated module size based on estimated derived from the positions
       * of the three finder patterns.</p>
       *
       * @param topLeft detected top-left finder pattern center
       * @param topRight detected top-right finder pattern center
       * @param bottomLeft detected bottom-left finder pattern center
       * @return estimated module size
       */
      calculateModuleSize(topLeft, topRight, bottomLeft) {
        return (this.calculateModuleSizeOneWay(topLeft, topRight) + this.calculateModuleSizeOneWay(topLeft, bottomLeft)) / 2;
      }
      /**
       * <p>Estimates module size based on two finder patterns -- it uses
       * {@link #sizeOfBlackWhiteBlackRunBothWays(int, int, int, int)} to figure the
       * width of each, measuring along the axis between their centers.</p>
       */
      calculateModuleSizeOneWay(pattern, otherPattern) {
        const moduleSizeEst1 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY()),
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY())
        );
        const moduleSizeEst2 = this.sizeOfBlackWhiteBlackRunBothWays(
          /*(int) */
          Math.floor(otherPattern.getX()),
          /*(int) */
          Math.floor(otherPattern.getY()),
          /*(int) */
          Math.floor(pattern.getX()),
          /*(int) */
          Math.floor(pattern.getY())
        );
        if (isNaN(moduleSizeEst1)) {
          return moduleSizeEst2 / 7;
        }
        if (isNaN(moduleSizeEst2)) {
          return moduleSizeEst1 / 7;
        }
        return (moduleSizeEst1 + moduleSizeEst2) / 14;
      }
      /**
       * See {@link #sizeOfBlackWhiteBlackRun(int, int, int, int)}; computes the total width of
       * a finder pattern by looking for a black-white-black run from the center in the direction
       * of another point (another finder pattern center), and in the opposite direction too.
       */
      sizeOfBlackWhiteBlackRunBothWays(fromX, fromY, toX, toY) {
        let result = this.sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY);
        let scale = 1;
        let otherToX = fromX - (toX - fromX);
        if (otherToX < 0) {
          scale = fromX / /*(float) */
          (fromX - otherToX);
          otherToX = 0;
        } else if (otherToX >= this.image.getWidth()) {
          scale = (this.image.getWidth() - 1 - fromX) / /*(float) */
          (otherToX - fromX);
          otherToX = this.image.getWidth() - 1;
        }
        let otherToY = (
          /*(int) */
          Math.floor(fromY - (toY - fromY) * scale)
        );
        scale = 1;
        if (otherToY < 0) {
          scale = fromY / /*(float) */
          (fromY - otherToY);
          otherToY = 0;
        } else if (otherToY >= this.image.getHeight()) {
          scale = (this.image.getHeight() - 1 - fromY) / /*(float) */
          (otherToY - fromY);
          otherToY = this.image.getHeight() - 1;
        }
        otherToX = /*(int) */
        Math.floor(fromX + (otherToX - fromX) * scale);
        result += this.sizeOfBlackWhiteBlackRun(fromX, fromY, otherToX, otherToY);
        return result - 1;
      }
      /**
       * <p>This method traces a line from a point in the image, in the direction towards another point.
       * It begins in a black region, and keeps going until it finds white, then black, then white again.
       * It reports the distance from the start to this point.</p>
       *
       * <p>This is used when figuring out how wide a finder pattern is, when the finder pattern
       * may be skewed or rotated.</p>
       */
      sizeOfBlackWhiteBlackRun(fromX, fromY, toX, toY) {
        const steep = Math.abs(toY - fromY) > Math.abs(toX - fromX);
        if (steep) {
          let temp = fromX;
          fromX = fromY;
          fromY = temp;
          temp = toX;
          toX = toY;
          toY = temp;
        }
        const dx = Math.abs(toX - fromX);
        const dy = Math.abs(toY - fromY);
        let error = -dx / 2;
        const xstep = fromX < toX ? 1 : -1;
        const ystep = fromY < toY ? 1 : -1;
        let state = 0;
        const xLimit = toX + xstep;
        for (let x3 = fromX, y4 = fromY; x3 !== xLimit; x3 += xstep) {
          const realX = steep ? y4 : x3;
          const realY = steep ? x3 : y4;
          if (state === 1 === this.image.get(realX, realY)) {
            if (state === 2) {
              return MathUtils.distance(x3, y4, fromX, fromY);
            }
            state++;
          }
          error += dy;
          if (error > 0) {
            if (y4 === toY) {
              break;
            }
            y4 += ystep;
            error -= dx;
          }
        }
        if (state === 2) {
          return MathUtils.distance(toX + xstep, toY, fromX, fromY);
        }
        return NaN;
      }
      /**
       * <p>Attempts to locate an alignment pattern in a limited region of the image, which is
       * guessed to contain it. This method uses {@link AlignmentPattern}.</p>
       *
       * @param overallEstModuleSize estimated module size so far
       * @param estAlignmentX x coordinate of center of area probably containing alignment pattern
       * @param estAlignmentY y coordinate of above
       * @param allowanceFactor number of pixels in all directions to search from the center
       * @return {@link AlignmentPattern} if found, or null otherwise
       * @throws NotFoundException if an unexpected error occurs during detection
       */
      findAlignmentInRegion(overallEstModuleSize, estAlignmentX, estAlignmentY, allowanceFactor) {
        const allowance = (
          /*(int) */
          Math.floor(allowanceFactor * overallEstModuleSize)
        );
        const alignmentAreaLeftX = Math.max(0, estAlignmentX - allowance);
        const alignmentAreaRightX = Math.min(this.image.getWidth() - 1, estAlignmentX + allowance);
        if (alignmentAreaRightX - alignmentAreaLeftX < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment top exceeds estimated module size.");
        }
        const alignmentAreaTopY = Math.max(0, estAlignmentY - allowance);
        const alignmentAreaBottomY = Math.min(this.image.getHeight() - 1, estAlignmentY + allowance);
        if (alignmentAreaBottomY - alignmentAreaTopY < overallEstModuleSize * 3) {
          throw new NotFoundException("Alignment bottom exceeds estimated module size.");
        }
        const alignmentFinder = new AlignmentPatternFinder(this.image, alignmentAreaLeftX, alignmentAreaTopY, alignmentAreaRightX - alignmentAreaLeftX, alignmentAreaBottomY - alignmentAreaTopY, overallEstModuleSize, this.resultPointCallback);
        return alignmentFinder.find();
      }
    }
    class QRCodeReader {
      constructor() {
        this.decoder = new Decoder$2();
      }
      getDecoder() {
        return this.decoder;
      }
      /**
       * Locates and decodes a QR code in an image.
       *
       * @return a representing: string the content encoded by the QR code
       * @throws NotFoundException if a QR code cannot be found
       * @throws FormatException if a QR code cannot be decoded
       * @throws ChecksumException if error correction fails
       */
      /*@Override*/
      // public decode(image: BinaryBitmap): Result /*throws NotFoundException, ChecksumException, FormatException */ {
      //   return this.decode(image, null)
      // }
      /*@Override*/
      decode(image, hints) {
        let decoderResult;
        let points;
        if (hints !== void 0 && hints !== null && void 0 !== hints.get(DecodeHintType$1.PURE_BARCODE)) {
          const bits = QRCodeReader.extractPureBits(image.getBlackMatrix());
          decoderResult = this.decoder.decodeBitMatrix(bits, hints);
          points = QRCodeReader.NO_POINTS;
        } else {
          const detectorResult = new Detector$2(image.getBlackMatrix()).detect(hints);
          decoderResult = this.decoder.decodeBitMatrix(detectorResult.getBits(), hints);
          points = detectorResult.getPoints();
        }
        if (decoderResult.getOther() instanceof QRCodeDecoderMetaData) {
          decoderResult.getOther().applyMirroredCorrection(points);
        }
        const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.QR_CODE, void 0);
        const byteSegments = decoderResult.getByteSegments();
        if (byteSegments !== null) {
          result.putMetadata(ResultMetadataType$1.BYTE_SEGMENTS, byteSegments);
        }
        const ecLevel = decoderResult.getECLevel();
        if (ecLevel !== null) {
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, ecLevel);
        }
        if (decoderResult.hasStructuredAppend()) {
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_SEQUENCE, decoderResult.getStructuredAppendSequenceNumber());
          result.putMetadata(ResultMetadataType$1.STRUCTURED_APPEND_PARITY, decoderResult.getStructuredAppendParity());
        }
        return result;
      }
      /*@Override*/
      reset() {
      }
      /**
       * This method detects a code in a "pure" image -- that is, pure monochrome image
       * which contains only an unrotated, unskewed, image of a code, with some white border
       * around it. This is a specialized method that works exceptionally fast in this special
       * case.
       *
       * @see com.google.zxing.datamatrix.DataMatrixReader#extractPureBits(BitMatrix)
       */
      static extractPureBits(image) {
        const leftTopBlack = image.getTopLeftOnBit();
        const rightBottomBlack = image.getBottomRightOnBit();
        if (leftTopBlack === null || rightBottomBlack === null) {
          throw new NotFoundException();
        }
        const moduleSize = this.moduleSize(leftTopBlack, image);
        let top = leftTopBlack[1];
        let bottom = rightBottomBlack[1];
        let left = leftTopBlack[0];
        let right = rightBottomBlack[0];
        if (left >= right || top >= bottom) {
          throw new NotFoundException();
        }
        if (bottom - top !== right - left) {
          right = left + (bottom - top);
          if (right >= image.getWidth()) {
            throw new NotFoundException();
          }
        }
        const matrixWidth = Math.round((right - left + 1) / moduleSize);
        const matrixHeight = Math.round((bottom - top + 1) / moduleSize);
        if (matrixWidth <= 0 || matrixHeight <= 0) {
          throw new NotFoundException();
        }
        if (matrixHeight !== matrixWidth) {
          throw new NotFoundException();
        }
        const nudge = (
          /*(int) */
          Math.floor(moduleSize / 2)
        );
        top += nudge;
        left += nudge;
        const nudgedTooFarRight = left + /*(int) */
        Math.floor((matrixWidth - 1) * moduleSize) - right;
        if (nudgedTooFarRight > 0) {
          if (nudgedTooFarRight > nudge) {
            throw new NotFoundException();
          }
          left -= nudgedTooFarRight;
        }
        const nudgedTooFarDown = top + /*(int) */
        Math.floor((matrixHeight - 1) * moduleSize) - bottom;
        if (nudgedTooFarDown > 0) {
          if (nudgedTooFarDown > nudge) {
            throw new NotFoundException();
          }
          top -= nudgedTooFarDown;
        }
        const bits = new BitMatrix(matrixWidth, matrixHeight);
        for (let y4 = 0; y4 < matrixHeight; y4++) {
          const iOffset = top + /*(int) */
          Math.floor(y4 * moduleSize);
          for (let x3 = 0; x3 < matrixWidth; x3++) {
            if (image.get(left + /*(int) */
            Math.floor(x3 * moduleSize), iOffset)) {
              bits.set(x3, y4);
            }
          }
        }
        return bits;
      }
      static moduleSize(leftTopBlack, image) {
        const height = image.getHeight();
        const width = image.getWidth();
        let x3 = leftTopBlack[0];
        let y4 = leftTopBlack[1];
        let inBlack = true;
        let transitions = 0;
        while (x3 < width && y4 < height) {
          if (inBlack !== image.get(x3, y4)) {
            if (++transitions === 5) {
              break;
            }
            inBlack = !inBlack;
          }
          x3++;
          y4++;
        }
        if (x3 === width || y4 === height) {
          throw new NotFoundException();
        }
        return (x3 - leftTopBlack[0]) / 7;
      }
    }
    QRCodeReader.NO_POINTS = new Array();
    class PDF417Common {
      PDF417Common() {
      }
      /**
       * @param moduleBitCount values to sum
       * @return sum of values
       * @deprecated call {@link MathUtils#sum(int[])}
       */
      // @Deprecated
      static getBitCountSum(moduleBitCount) {
        return MathUtils.sum(moduleBitCount);
      }
      static toIntArray(list) {
        if (list == null || !list.length) {
          return PDF417Common.EMPTY_INT_ARRAY;
        }
        const result = new Int32Array(list.length);
        let i3 = 0;
        for (const integer of list) {
          result[i3++] = integer;
        }
        return result;
      }
      /**
       * @param symbol encoded symbol to translate to a codeword
       * @return the codeword corresponding to the symbol.
       */
      static getCodeword(symbol) {
        const i3 = Arrays.binarySearch(PDF417Common.SYMBOL_TABLE, symbol & 262143);
        if (i3 < 0) {
          return -1;
        }
        return (PDF417Common.CODEWORD_TABLE[i3] - 1) % PDF417Common.NUMBER_OF_CODEWORDS;
      }
    }
    PDF417Common.NUMBER_OF_CODEWORDS = 929;
    PDF417Common.MAX_CODEWORDS_IN_BARCODE = PDF417Common.NUMBER_OF_CODEWORDS - 1;
    PDF417Common.MIN_ROWS_IN_BARCODE = 3;
    PDF417Common.MAX_ROWS_IN_BARCODE = 90;
    PDF417Common.MODULES_IN_CODEWORD = 17;
    PDF417Common.MODULES_IN_STOP_PATTERN = 18;
    PDF417Common.BARS_IN_MODULE = 8;
    PDF417Common.EMPTY_INT_ARRAY = new Int32Array([]);
    PDF417Common.SYMBOL_TABLE = Int32Array.from([
      66142,
      66170,
      66206,
      66236,
      66290,
      66292,
      66350,
      66382,
      66396,
      66454,
      66470,
      66476,
      66594,
      66600,
      66614,
      66626,
      66628,
      66632,
      66640,
      66654,
      66662,
      66668,
      66682,
      66690,
      66718,
      66720,
      66748,
      66758,
      66776,
      66798,
      66802,
      66804,
      66820,
      66824,
      66832,
      66846,
      66848,
      66876,
      66880,
      66936,
      66950,
      66956,
      66968,
      66992,
      67006,
      67022,
      67036,
      67042,
      67044,
      67048,
      67062,
      67118,
      67150,
      67164,
      67214,
      67228,
      67256,
      67294,
      67322,
      67350,
      67366,
      67372,
      67398,
      67404,
      67416,
      67438,
      67474,
      67476,
      67490,
      67492,
      67496,
      67510,
      67618,
      67624,
      67650,
      67656,
      67664,
      67678,
      67686,
      67692,
      67706,
      67714,
      67716,
      67728,
      67742,
      67744,
      67772,
      67782,
      67788,
      67800,
      67822,
      67826,
      67828,
      67842,
      67848,
      67870,
      67872,
      67900,
      67904,
      67960,
      67974,
      67992,
      68016,
      68030,
      68046,
      68060,
      68066,
      68068,
      68072,
      68086,
      68104,
      68112,
      68126,
      68128,
      68156,
      68160,
      68216,
      68336,
      68358,
      68364,
      68376,
      68400,
      68414,
      68448,
      68476,
      68494,
      68508,
      68536,
      68546,
      68548,
      68552,
      68560,
      68574,
      68582,
      68588,
      68654,
      68686,
      68700,
      68706,
      68708,
      68712,
      68726,
      68750,
      68764,
      68792,
      68802,
      68804,
      68808,
      68816,
      68830,
      68838,
      68844,
      68858,
      68878,
      68892,
      68920,
      68976,
      68990,
      68994,
      68996,
      69e3,
      69008,
      69022,
      69024,
      69052,
      69062,
      69068,
      69080,
      69102,
      69106,
      69108,
      69142,
      69158,
      69164,
      69190,
      69208,
      69230,
      69254,
      69260,
      69272,
      69296,
      69310,
      69326,
      69340,
      69386,
      69394,
      69396,
      69410,
      69416,
      69430,
      69442,
      69444,
      69448,
      69456,
      69470,
      69478,
      69484,
      69554,
      69556,
      69666,
      69672,
      69698,
      69704,
      69712,
      69726,
      69754,
      69762,
      69764,
      69776,
      69790,
      69792,
      69820,
      69830,
      69836,
      69848,
      69870,
      69874,
      69876,
      69890,
      69918,
      69920,
      69948,
      69952,
      70008,
      70022,
      70040,
      70064,
      70078,
      70094,
      70108,
      70114,
      70116,
      70120,
      70134,
      70152,
      70174,
      70176,
      70264,
      70384,
      70412,
      70448,
      70462,
      70496,
      70524,
      70542,
      70556,
      70584,
      70594,
      70600,
      70608,
      70622,
      70630,
      70636,
      70664,
      70672,
      70686,
      70688,
      70716,
      70720,
      70776,
      70896,
      71136,
      71180,
      71192,
      71216,
      71230,
      71264,
      71292,
      71360,
      71416,
      71452,
      71480,
      71536,
      71550,
      71554,
      71556,
      71560,
      71568,
      71582,
      71584,
      71612,
      71622,
      71628,
      71640,
      71662,
      71726,
      71732,
      71758,
      71772,
      71778,
      71780,
      71784,
      71798,
      71822,
      71836,
      71864,
      71874,
      71880,
      71888,
      71902,
      71910,
      71916,
      71930,
      71950,
      71964,
      71992,
      72048,
      72062,
      72066,
      72068,
      72080,
      72094,
      72096,
      72124,
      72134,
      72140,
      72152,
      72174,
      72178,
      72180,
      72206,
      72220,
      72248,
      72304,
      72318,
      72416,
      72444,
      72456,
      72464,
      72478,
      72480,
      72508,
      72512,
      72568,
      72588,
      72600,
      72624,
      72638,
      72654,
      72668,
      72674,
      72676,
      72680,
      72694,
      72726,
      72742,
      72748,
      72774,
      72780,
      72792,
      72814,
      72838,
      72856,
      72880,
      72894,
      72910,
      72924,
      72930,
      72932,
      72936,
      72950,
      72966,
      72972,
      72984,
      73008,
      73022,
      73056,
      73084,
      73102,
      73116,
      73144,
      73156,
      73160,
      73168,
      73182,
      73190,
      73196,
      73210,
      73226,
      73234,
      73236,
      73250,
      73252,
      73256,
      73270,
      73282,
      73284,
      73296,
      73310,
      73318,
      73324,
      73346,
      73348,
      73352,
      73360,
      73374,
      73376,
      73404,
      73414,
      73420,
      73432,
      73454,
      73498,
      73518,
      73522,
      73524,
      73550,
      73564,
      73570,
      73572,
      73576,
      73590,
      73800,
      73822,
      73858,
      73860,
      73872,
      73886,
      73888,
      73916,
      73944,
      73970,
      73972,
      73992,
      74014,
      74016,
      74044,
      74048,
      74104,
      74118,
      74136,
      74160,
      74174,
      74210,
      74212,
      74216,
      74230,
      74244,
      74256,
      74270,
      74272,
      74360,
      74480,
      74502,
      74508,
      74544,
      74558,
      74592,
      74620,
      74638,
      74652,
      74680,
      74690,
      74696,
      74704,
      74726,
      74732,
      74782,
      74784,
      74812,
      74992,
      75232,
      75288,
      75326,
      75360,
      75388,
      75456,
      75512,
      75576,
      75632,
      75646,
      75650,
      75652,
      75664,
      75678,
      75680,
      75708,
      75718,
      75724,
      75736,
      75758,
      75808,
      75836,
      75840,
      75896,
      76016,
      76256,
      76736,
      76824,
      76848,
      76862,
      76896,
      76924,
      76992,
      77048,
      77296,
      77340,
      77368,
      77424,
      77438,
      77536,
      77564,
      77572,
      77576,
      77584,
      77600,
      77628,
      77632,
      77688,
      77702,
      77708,
      77720,
      77744,
      77758,
      77774,
      77788,
      77870,
      77902,
      77916,
      77922,
      77928,
      77966,
      77980,
      78008,
      78018,
      78024,
      78032,
      78046,
      78060,
      78074,
      78094,
      78136,
      78192,
      78206,
      78210,
      78212,
      78224,
      78238,
      78240,
      78268,
      78278,
      78284,
      78296,
      78322,
      78324,
      78350,
      78364,
      78448,
      78462,
      78560,
      78588,
      78600,
      78622,
      78624,
      78652,
      78656,
      78712,
      78726,
      78744,
      78768,
      78782,
      78798,
      78812,
      78818,
      78820,
      78824,
      78838,
      78862,
      78876,
      78904,
      78960,
      78974,
      79072,
      79100,
      79296,
      79352,
      79368,
      79376,
      79390,
      79392,
      79420,
      79424,
      79480,
      79600,
      79628,
      79640,
      79664,
      79678,
      79712,
      79740,
      79772,
      79800,
      79810,
      79812,
      79816,
      79824,
      79838,
      79846,
      79852,
      79894,
      79910,
      79916,
      79942,
      79948,
      79960,
      79982,
      79988,
      80006,
      80024,
      80048,
      80062,
      80078,
      80092,
      80098,
      80100,
      80104,
      80134,
      80140,
      80176,
      80190,
      80224,
      80252,
      80270,
      80284,
      80312,
      80328,
      80336,
      80350,
      80358,
      80364,
      80378,
      80390,
      80396,
      80408,
      80432,
      80446,
      80480,
      80508,
      80576,
      80632,
      80654,
      80668,
      80696,
      80752,
      80766,
      80776,
      80784,
      80798,
      80800,
      80828,
      80844,
      80856,
      80878,
      80882,
      80884,
      80914,
      80916,
      80930,
      80932,
      80936,
      80950,
      80962,
      80968,
      80976,
      80990,
      80998,
      81004,
      81026,
      81028,
      81040,
      81054,
      81056,
      81084,
      81094,
      81100,
      81112,
      81134,
      81154,
      81156,
      81160,
      81168,
      81182,
      81184,
      81212,
      81216,
      81272,
      81286,
      81292,
      81304,
      81328,
      81342,
      81358,
      81372,
      81380,
      81384,
      81398,
      81434,
      81454,
      81458,
      81460,
      81486,
      81500,
      81506,
      81508,
      81512,
      81526,
      81550,
      81564,
      81592,
      81602,
      81604,
      81608,
      81616,
      81630,
      81638,
      81644,
      81702,
      81708,
      81722,
      81734,
      81740,
      81752,
      81774,
      81778,
      81780,
      82050,
      82078,
      82080,
      82108,
      82180,
      82184,
      82192,
      82206,
      82208,
      82236,
      82240,
      82296,
      82316,
      82328,
      82352,
      82366,
      82402,
      82404,
      82408,
      82440,
      82448,
      82462,
      82464,
      82492,
      82496,
      82552,
      82672,
      82694,
      82700,
      82712,
      82736,
      82750,
      82784,
      82812,
      82830,
      82882,
      82884,
      82888,
      82896,
      82918,
      82924,
      82952,
      82960,
      82974,
      82976,
      83004,
      83008,
      83064,
      83184,
      83424,
      83468,
      83480,
      83504,
      83518,
      83552,
      83580,
      83648,
      83704,
      83740,
      83768,
      83824,
      83838,
      83842,
      83844,
      83848,
      83856,
      83872,
      83900,
      83910,
      83916,
      83928,
      83950,
      83984,
      84e3,
      84028,
      84032,
      84088,
      84208,
      84448,
      84928,
      85040,
      85054,
      85088,
      85116,
      85184,
      85240,
      85488,
      85560,
      85616,
      85630,
      85728,
      85756,
      85764,
      85768,
      85776,
      85790,
      85792,
      85820,
      85824,
      85880,
      85894,
      85900,
      85912,
      85936,
      85966,
      85980,
      86048,
      86080,
      86136,
      86256,
      86496,
      86976,
      88160,
      88188,
      88256,
      88312,
      88560,
      89056,
      89200,
      89214,
      89312,
      89340,
      89536,
      89592,
      89608,
      89616,
      89632,
      89664,
      89720,
      89840,
      89868,
      89880,
      89904,
      89952,
      89980,
      89998,
      90012,
      90040,
      90190,
      90204,
      90254,
      90268,
      90296,
      90306,
      90308,
      90312,
      90334,
      90382,
      90396,
      90424,
      90480,
      90494,
      90500,
      90504,
      90512,
      90526,
      90528,
      90556,
      90566,
      90572,
      90584,
      90610,
      90612,
      90638,
      90652,
      90680,
      90736,
      90750,
      90848,
      90876,
      90884,
      90888,
      90896,
      90910,
      90912,
      90940,
      90944,
      91e3,
      91014,
      91020,
      91032,
      91056,
      91070,
      91086,
      91100,
      91106,
      91108,
      91112,
      91126,
      91150,
      91164,
      91192,
      91248,
      91262,
      91360,
      91388,
      91584,
      91640,
      91664,
      91678,
      91680,
      91708,
      91712,
      91768,
      91888,
      91928,
      91952,
      91966,
      92e3,
      92028,
      92046,
      92060,
      92088,
      92098,
      92100,
      92104,
      92112,
      92126,
      92134,
      92140,
      92188,
      92216,
      92272,
      92384,
      92412,
      92608,
      92664,
      93168,
      93200,
      93214,
      93216,
      93244,
      93248,
      93304,
      93424,
      93664,
      93720,
      93744,
      93758,
      93792,
      93820,
      93888,
      93944,
      93980,
      94008,
      94064,
      94078,
      94084,
      94088,
      94096,
      94110,
      94112,
      94140,
      94150,
      94156,
      94168,
      94246,
      94252,
      94278,
      94284,
      94296,
      94318,
      94342,
      94348,
      94360,
      94384,
      94398,
      94414,
      94428,
      94440,
      94470,
      94476,
      94488,
      94512,
      94526,
      94560,
      94588,
      94606,
      94620,
      94648,
      94658,
      94660,
      94664,
      94672,
      94686,
      94694,
      94700,
      94714,
      94726,
      94732,
      94744,
      94768,
      94782,
      94816,
      94844,
      94912,
      94968,
      94990,
      95004,
      95032,
      95088,
      95102,
      95112,
      95120,
      95134,
      95136,
      95164,
      95180,
      95192,
      95214,
      95218,
      95220,
      95244,
      95256,
      95280,
      95294,
      95328,
      95356,
      95424,
      95480,
      95728,
      95758,
      95772,
      95800,
      95856,
      95870,
      95968,
      95996,
      96008,
      96016,
      96030,
      96032,
      96060,
      96064,
      96120,
      96152,
      96176,
      96190,
      96220,
      96226,
      96228,
      96232,
      96290,
      96292,
      96296,
      96310,
      96322,
      96324,
      96328,
      96336,
      96350,
      96358,
      96364,
      96386,
      96388,
      96392,
      96400,
      96414,
      96416,
      96444,
      96454,
      96460,
      96472,
      96494,
      96498,
      96500,
      96514,
      96516,
      96520,
      96528,
      96542,
      96544,
      96572,
      96576,
      96632,
      96646,
      96652,
      96664,
      96688,
      96702,
      96718,
      96732,
      96738,
      96740,
      96744,
      96758,
      96772,
      96776,
      96784,
      96798,
      96800,
      96828,
      96832,
      96888,
      97008,
      97030,
      97036,
      97048,
      97072,
      97086,
      97120,
      97148,
      97166,
      97180,
      97208,
      97220,
      97224,
      97232,
      97246,
      97254,
      97260,
      97326,
      97330,
      97332,
      97358,
      97372,
      97378,
      97380,
      97384,
      97398,
      97422,
      97436,
      97464,
      97474,
      97476,
      97480,
      97488,
      97502,
      97510,
      97516,
      97550,
      97564,
      97592,
      97648,
      97666,
      97668,
      97672,
      97680,
      97694,
      97696,
      97724,
      97734,
      97740,
      97752,
      97774,
      97830,
      97836,
      97850,
      97862,
      97868,
      97880,
      97902,
      97906,
      97908,
      97926,
      97932,
      97944,
      97968,
      97998,
      98012,
      98018,
      98020,
      98024,
      98038,
      98618,
      98674,
      98676,
      98838,
      98854,
      98874,
      98892,
      98904,
      98926,
      98930,
      98932,
      98968,
      99006,
      99042,
      99044,
      99048,
      99062,
      99166,
      99194,
      99246,
      99286,
      99350,
      99366,
      99372,
      99386,
      99398,
      99416,
      99438,
      99442,
      99444,
      99462,
      99504,
      99518,
      99534,
      99548,
      99554,
      99556,
      99560,
      99574,
      99590,
      99596,
      99608,
      99632,
      99646,
      99680,
      99708,
      99726,
      99740,
      99768,
      99778,
      99780,
      99784,
      99792,
      99806,
      99814,
      99820,
      99834,
      99858,
      99860,
      99874,
      99880,
      99894,
      99906,
      99920,
      99934,
      99962,
      99970,
      99972,
      99976,
      99984,
      99998,
      1e5,
      100028,
      100038,
      100044,
      100056,
      100078,
      100082,
      100084,
      100142,
      100174,
      100188,
      100246,
      100262,
      100268,
      100306,
      100308,
      100390,
      100396,
      100410,
      100422,
      100428,
      100440,
      100462,
      100466,
      100468,
      100486,
      100504,
      100528,
      100542,
      100558,
      100572,
      100578,
      100580,
      100584,
      100598,
      100620,
      100656,
      100670,
      100704,
      100732,
      100750,
      100792,
      100802,
      100808,
      100816,
      100830,
      100838,
      100844,
      100858,
      100888,
      100912,
      100926,
      100960,
      100988,
      101056,
      101112,
      101148,
      101176,
      101232,
      101246,
      101250,
      101252,
      101256,
      101264,
      101278,
      101280,
      101308,
      101318,
      101324,
      101336,
      101358,
      101362,
      101364,
      101410,
      101412,
      101416,
      101430,
      101442,
      101448,
      101456,
      101470,
      101478,
      101498,
      101506,
      101508,
      101520,
      101534,
      101536,
      101564,
      101580,
      101618,
      101620,
      101636,
      101640,
      101648,
      101662,
      101664,
      101692,
      101696,
      101752,
      101766,
      101784,
      101838,
      101858,
      101860,
      101864,
      101934,
      101938,
      101940,
      101966,
      101980,
      101986,
      101988,
      101992,
      102030,
      102044,
      102072,
      102082,
      102084,
      102088,
      102096,
      102138,
      102166,
      102182,
      102188,
      102214,
      102220,
      102232,
      102254,
      102282,
      102290,
      102292,
      102306,
      102308,
      102312,
      102326,
      102444,
      102458,
      102470,
      102476,
      102488,
      102514,
      102516,
      102534,
      102552,
      102576,
      102590,
      102606,
      102620,
      102626,
      102632,
      102646,
      102662,
      102668,
      102704,
      102718,
      102752,
      102780,
      102798,
      102812,
      102840,
      102850,
      102856,
      102864,
      102878,
      102886,
      102892,
      102906,
      102936,
      102974,
      103008,
      103036,
      103104,
      103160,
      103224,
      103280,
      103294,
      103298,
      103300,
      103312,
      103326,
      103328,
      103356,
      103366,
      103372,
      103384,
      103406,
      103410,
      103412,
      103472,
      103486,
      103520,
      103548,
      103616,
      103672,
      103920,
      103992,
      104048,
      104062,
      104160,
      104188,
      104194,
      104196,
      104200,
      104208,
      104224,
      104252,
      104256,
      104312,
      104326,
      104332,
      104344,
      104368,
      104382,
      104398,
      104412,
      104418,
      104420,
      104424,
      104482,
      104484,
      104514,
      104520,
      104528,
      104542,
      104550,
      104570,
      104578,
      104580,
      104592,
      104606,
      104608,
      104636,
      104652,
      104690,
      104692,
      104706,
      104712,
      104734,
      104736,
      104764,
      104768,
      104824,
      104838,
      104856,
      104910,
      104930,
      104932,
      104936,
      104968,
      104976,
      104990,
      104992,
      105020,
      105024,
      105080,
      105200,
      105240,
      105278,
      105312,
      105372,
      105410,
      105412,
      105416,
      105424,
      105446,
      105518,
      105524,
      105550,
      105564,
      105570,
      105572,
      105576,
      105614,
      105628,
      105656,
      105666,
      105672,
      105680,
      105702,
      105722,
      105742,
      105756,
      105784,
      105840,
      105854,
      105858,
      105860,
      105864,
      105872,
      105888,
      105932,
      105970,
      105972,
      106006,
      106022,
      106028,
      106054,
      106060,
      106072,
      106100,
      106118,
      106124,
      106136,
      106160,
      106174,
      106190,
      106210,
      106212,
      106216,
      106250,
      106258,
      106260,
      106274,
      106276,
      106280,
      106306,
      106308,
      106312,
      106320,
      106334,
      106348,
      106394,
      106414,
      106418,
      106420,
      106566,
      106572,
      106610,
      106612,
      106630,
      106636,
      106648,
      106672,
      106686,
      106722,
      106724,
      106728,
      106742,
      106758,
      106764,
      106776,
      106800,
      106814,
      106848,
      106876,
      106894,
      106908,
      106936,
      106946,
      106948,
      106952,
      106960,
      106974,
      106982,
      106988,
      107032,
      107056,
      107070,
      107104,
      107132,
      107200,
      107256,
      107292,
      107320,
      107376,
      107390,
      107394,
      107396,
      107400,
      107408,
      107422,
      107424,
      107452,
      107462,
      107468,
      107480,
      107502,
      107506,
      107508,
      107544,
      107568,
      107582,
      107616,
      107644,
      107712,
      107768,
      108016,
      108060,
      108088,
      108144,
      108158,
      108256,
      108284,
      108290,
      108292,
      108296,
      108304,
      108318,
      108320,
      108348,
      108352,
      108408,
      108422,
      108428,
      108440,
      108464,
      108478,
      108494,
      108508,
      108514,
      108516,
      108520,
      108592,
      108640,
      108668,
      108736,
      108792,
      109040,
      109536,
      109680,
      109694,
      109792,
      109820,
      110016,
      110072,
      110084,
      110088,
      110096,
      110112,
      110140,
      110144,
      110200,
      110320,
      110342,
      110348,
      110360,
      110384,
      110398,
      110432,
      110460,
      110478,
      110492,
      110520,
      110532,
      110536,
      110544,
      110558,
      110658,
      110686,
      110714,
      110722,
      110724,
      110728,
      110736,
      110750,
      110752,
      110780,
      110796,
      110834,
      110836,
      110850,
      110852,
      110856,
      110864,
      110878,
      110880,
      110908,
      110912,
      110968,
      110982,
      111e3,
      111054,
      111074,
      111076,
      111080,
      111108,
      111112,
      111120,
      111134,
      111136,
      111164,
      111168,
      111224,
      111344,
      111372,
      111422,
      111456,
      111516,
      111554,
      111556,
      111560,
      111568,
      111590,
      111632,
      111646,
      111648,
      111676,
      111680,
      111736,
      111856,
      112096,
      112152,
      112224,
      112252,
      112320,
      112440,
      112514,
      112516,
      112520,
      112528,
      112542,
      112544,
      112588,
      112686,
      112718,
      112732,
      112782,
      112796,
      112824,
      112834,
      112836,
      112840,
      112848,
      112870,
      112890,
      112910,
      112924,
      112952,
      113008,
      113022,
      113026,
      113028,
      113032,
      113040,
      113054,
      113056,
      113100,
      113138,
      113140,
      113166,
      113180,
      113208,
      113264,
      113278,
      113376,
      113404,
      113416,
      113424,
      113440,
      113468,
      113472,
      113560,
      113614,
      113634,
      113636,
      113640,
      113686,
      113702,
      113708,
      113734,
      113740,
      113752,
      113778,
      113780,
      113798,
      113804,
      113816,
      113840,
      113854,
      113870,
      113890,
      113892,
      113896,
      113926,
      113932,
      113944,
      113968,
      113982,
      114016,
      114044,
      114076,
      114114,
      114116,
      114120,
      114128,
      114150,
      114170,
      114194,
      114196,
      114210,
      114212,
      114216,
      114242,
      114244,
      114248,
      114256,
      114270,
      114278,
      114306,
      114308,
      114312,
      114320,
      114334,
      114336,
      114364,
      114380,
      114420,
      114458,
      114478,
      114482,
      114484,
      114510,
      114524,
      114530,
      114532,
      114536,
      114842,
      114866,
      114868,
      114970,
      114994,
      114996,
      115042,
      115044,
      115048,
      115062,
      115130,
      115226,
      115250,
      115252,
      115278,
      115292,
      115298,
      115300,
      115304,
      115318,
      115342,
      115394,
      115396,
      115400,
      115408,
      115422,
      115430,
      115436,
      115450,
      115478,
      115494,
      115514,
      115526,
      115532,
      115570,
      115572,
      115738,
      115758,
      115762,
      115764,
      115790,
      115804,
      115810,
      115812,
      115816,
      115830,
      115854,
      115868,
      115896,
      115906,
      115912,
      115920,
      115934,
      115942,
      115948,
      115962,
      115996,
      116024,
      116080,
      116094,
      116098,
      116100,
      116104,
      116112,
      116126,
      116128,
      116156,
      116166,
      116172,
      116184,
      116206,
      116210,
      116212,
      116246,
      116262,
      116268,
      116282,
      116294,
      116300,
      116312,
      116334,
      116338,
      116340,
      116358,
      116364,
      116376,
      116400,
      116414,
      116430,
      116444,
      116450,
      116452,
      116456,
      116498,
      116500,
      116514,
      116520,
      116534,
      116546,
      116548,
      116552,
      116560,
      116574,
      116582,
      116588,
      116602,
      116654,
      116694,
      116714,
      116762,
      116782,
      116786,
      116788,
      116814,
      116828,
      116834,
      116836,
      116840,
      116854,
      116878,
      116892,
      116920,
      116930,
      116936,
      116944,
      116958,
      116966,
      116972,
      116986,
      117006,
      117048,
      117104,
      117118,
      117122,
      117124,
      117136,
      117150,
      117152,
      117180,
      117190,
      117196,
      117208,
      117230,
      117234,
      117236,
      117304,
      117360,
      117374,
      117472,
      117500,
      117506,
      117508,
      117512,
      117520,
      117536,
      117564,
      117568,
      117624,
      117638,
      117644,
      117656,
      117680,
      117694,
      117710,
      117724,
      117730,
      117732,
      117736,
      117750,
      117782,
      117798,
      117804,
      117818,
      117830,
      117848,
      117874,
      117876,
      117894,
      117936,
      117950,
      117966,
      117986,
      117988,
      117992,
      118022,
      118028,
      118040,
      118064,
      118078,
      118112,
      118140,
      118172,
      118210,
      118212,
      118216,
      118224,
      118238,
      118246,
      118266,
      118306,
      118312,
      118338,
      118352,
      118366,
      118374,
      118394,
      118402,
      118404,
      118408,
      118416,
      118430,
      118432,
      118460,
      118476,
      118514,
      118516,
      118574,
      118578,
      118580,
      118606,
      118620,
      118626,
      118628,
      118632,
      118678,
      118694,
      118700,
      118730,
      118738,
      118740,
      118830,
      118834,
      118836,
      118862,
      118876,
      118882,
      118884,
      118888,
      118902,
      118926,
      118940,
      118968,
      118978,
      118980,
      118984,
      118992,
      119006,
      119014,
      119020,
      119034,
      119068,
      119096,
      119152,
      119166,
      119170,
      119172,
      119176,
      119184,
      119198,
      119200,
      119228,
      119238,
      119244,
      119256,
      119278,
      119282,
      119284,
      119324,
      119352,
      119408,
      119422,
      119520,
      119548,
      119554,
      119556,
      119560,
      119568,
      119582,
      119584,
      119612,
      119616,
      119672,
      119686,
      119692,
      119704,
      119728,
      119742,
      119758,
      119772,
      119778,
      119780,
      119784,
      119798,
      119920,
      119934,
      120032,
      120060,
      120256,
      120312,
      120324,
      120328,
      120336,
      120352,
      120384,
      120440,
      120560,
      120582,
      120588,
      120600,
      120624,
      120638,
      120672,
      120700,
      120718,
      120732,
      120760,
      120770,
      120772,
      120776,
      120784,
      120798,
      120806,
      120812,
      120870,
      120876,
      120890,
      120902,
      120908,
      120920,
      120946,
      120948,
      120966,
      120972,
      120984,
      121008,
      121022,
      121038,
      121058,
      121060,
      121064,
      121078,
      121100,
      121112,
      121136,
      121150,
      121184,
      121212,
      121244,
      121282,
      121284,
      121288,
      121296,
      121318,
      121338,
      121356,
      121368,
      121392,
      121406,
      121440,
      121468,
      121536,
      121592,
      121656,
      121730,
      121732,
      121736,
      121744,
      121758,
      121760,
      121804,
      121842,
      121844,
      121890,
      121922,
      121924,
      121928,
      121936,
      121950,
      121958,
      121978,
      121986,
      121988,
      121992,
      122e3,
      122014,
      122016,
      122044,
      122060,
      122098,
      122100,
      122116,
      122120,
      122128,
      122142,
      122144,
      122172,
      122176,
      122232,
      122246,
      122264,
      122318,
      122338,
      122340,
      122344,
      122414,
      122418,
      122420,
      122446,
      122460,
      122466,
      122468,
      122472,
      122510,
      122524,
      122552,
      122562,
      122564,
      122568,
      122576,
      122598,
      122618,
      122646,
      122662,
      122668,
      122694,
      122700,
      122712,
      122738,
      122740,
      122762,
      122770,
      122772,
      122786,
      122788,
      122792,
      123018,
      123026,
      123028,
      123042,
      123044,
      123048,
      123062,
      123098,
      123146,
      123154,
      123156,
      123170,
      123172,
      123176,
      123190,
      123202,
      123204,
      123208,
      123216,
      123238,
      123244,
      123258,
      123290,
      123314,
      123316,
      123402,
      123410,
      123412,
      123426,
      123428,
      123432,
      123446,
      123458,
      123464,
      123472,
      123486,
      123494,
      123500,
      123514,
      123522,
      123524,
      123528,
      123536,
      123552,
      123580,
      123590,
      123596,
      123608,
      123630,
      123634,
      123636,
      123674,
      123698,
      123700,
      123740,
      123746,
      123748,
      123752,
      123834,
      123914,
      123922,
      123924,
      123938,
      123944,
      123958,
      123970,
      123976,
      123984,
      123998,
      124006,
      124012,
      124026,
      124034,
      124036,
      124048,
      124062,
      124064,
      124092,
      124102,
      124108,
      124120,
      124142,
      124146,
      124148,
      124162,
      124164,
      124168,
      124176,
      124190,
      124192,
      124220,
      124224,
      124280,
      124294,
      124300,
      124312,
      124336,
      124350,
      124366,
      124380,
      124386,
      124388,
      124392,
      124406,
      124442,
      124462,
      124466,
      124468,
      124494,
      124508,
      124514,
      124520,
      124558,
      124572,
      124600,
      124610,
      124612,
      124616,
      124624,
      124646,
      124666,
      124694,
      124710,
      124716,
      124730,
      124742,
      124748,
      124760,
      124786,
      124788,
      124818,
      124820,
      124834,
      124836,
      124840,
      124854,
      124946,
      124948,
      124962,
      124964,
      124968,
      124982,
      124994,
      124996,
      125e3,
      125008,
      125022,
      125030,
      125036,
      125050,
      125058,
      125060,
      125064,
      125072,
      125086,
      125088,
      125116,
      125126,
      125132,
      125144,
      125166,
      125170,
      125172,
      125186,
      125188,
      125192,
      125200,
      125216,
      125244,
      125248,
      125304,
      125318,
      125324,
      125336,
      125360,
      125374,
      125390,
      125404,
      125410,
      125412,
      125416,
      125430,
      125444,
      125448,
      125456,
      125472,
      125504,
      125560,
      125680,
      125702,
      125708,
      125720,
      125744,
      125758,
      125792,
      125820,
      125838,
      125852,
      125880,
      125890,
      125892,
      125896,
      125904,
      125918,
      125926,
      125932,
      125978,
      125998,
      126002,
      126004,
      126030,
      126044,
      126050,
      126052,
      126056,
      126094,
      126108,
      126136,
      126146,
      126148,
      126152,
      126160,
      126182,
      126202,
      126222,
      126236,
      126264,
      126320,
      126334,
      126338,
      126340,
      126344,
      126352,
      126366,
      126368,
      126412,
      126450,
      126452,
      126486,
      126502,
      126508,
      126522,
      126534,
      126540,
      126552,
      126574,
      126578,
      126580,
      126598,
      126604,
      126616,
      126640,
      126654,
      126670,
      126684,
      126690,
      126692,
      126696,
      126738,
      126754,
      126756,
      126760,
      126774,
      126786,
      126788,
      126792,
      126800,
      126814,
      126822,
      126828,
      126842,
      126894,
      126898,
      126900,
      126934,
      127126,
      127142,
      127148,
      127162,
      127178,
      127186,
      127188,
      127254,
      127270,
      127276,
      127290,
      127302,
      127308,
      127320,
      127342,
      127346,
      127348,
      127370,
      127378,
      127380,
      127394,
      127396,
      127400,
      127450,
      127510,
      127526,
      127532,
      127546,
      127558,
      127576,
      127598,
      127602,
      127604,
      127622,
      127628,
      127640,
      127664,
      127678,
      127694,
      127708,
      127714,
      127716,
      127720,
      127734,
      127754,
      127762,
      127764,
      127778,
      127784,
      127810,
      127812,
      127816,
      127824,
      127838,
      127846,
      127866,
      127898,
      127918,
      127922,
      127924,
      128022,
      128038,
      128044,
      128058,
      128070,
      128076,
      128088,
      128110,
      128114,
      128116,
      128134,
      128140,
      128152,
      128176,
      128190,
      128206,
      128220,
      128226,
      128228,
      128232,
      128246,
      128262,
      128268,
      128280,
      128304,
      128318,
      128352,
      128380,
      128398,
      128412,
      128440,
      128450,
      128452,
      128456,
      128464,
      128478,
      128486,
      128492,
      128506,
      128522,
      128530,
      128532,
      128546,
      128548,
      128552,
      128566,
      128578,
      128580,
      128584,
      128592,
      128606,
      128614,
      128634,
      128642,
      128644,
      128648,
      128656,
      128670,
      128672,
      128700,
      128716,
      128754,
      128756,
      128794,
      128814,
      128818,
      128820,
      128846,
      128860,
      128866,
      128868,
      128872,
      128886,
      128918,
      128934,
      128940,
      128954,
      128978,
      128980,
      129178,
      129198,
      129202,
      129204,
      129238,
      129258,
      129306,
      129326,
      129330,
      129332,
      129358,
      129372,
      129378,
      129380,
      129384,
      129398,
      129430,
      129446,
      129452,
      129466,
      129482,
      129490,
      129492,
      129562,
      129582,
      129586,
      129588,
      129614,
      129628,
      129634,
      129636,
      129640,
      129654,
      129678,
      129692,
      129720,
      129730,
      129732,
      129736,
      129744,
      129758,
      129766,
      129772,
      129814,
      129830,
      129836,
      129850,
      129862,
      129868,
      129880,
      129902,
      129906,
      129908,
      129930,
      129938,
      129940,
      129954,
      129956,
      129960,
      129974,
      130010
    ]);
    PDF417Common.CODEWORD_TABLE = Int32Array.from([
      2627,
      1819,
      2622,
      2621,
      1813,
      1812,
      2729,
      2724,
      2723,
      2779,
      2774,
      2773,
      902,
      896,
      908,
      868,
      865,
      861,
      859,
      2511,
      873,
      871,
      1780,
      835,
      2493,
      825,
      2491,
      842,
      837,
      844,
      1764,
      1762,
      811,
      810,
      809,
      2483,
      807,
      2482,
      806,
      2480,
      815,
      814,
      813,
      812,
      2484,
      817,
      816,
      1745,
      1744,
      1742,
      1746,
      2655,
      2637,
      2635,
      2626,
      2625,
      2623,
      2628,
      1820,
      2752,
      2739,
      2737,
      2728,
      2727,
      2725,
      2730,
      2785,
      2783,
      2778,
      2777,
      2775,
      2780,
      787,
      781,
      747,
      739,
      736,
      2413,
      754,
      752,
      1719,
      692,
      689,
      681,
      2371,
      678,
      2369,
      700,
      697,
      694,
      703,
      1688,
      1686,
      642,
      638,
      2343,
      631,
      2341,
      627,
      2338,
      651,
      646,
      643,
      2345,
      654,
      652,
      1652,
      1650,
      1647,
      1654,
      601,
      599,
      2322,
      596,
      2321,
      594,
      2319,
      2317,
      611,
      610,
      608,
      606,
      2324,
      603,
      2323,
      615,
      614,
      612,
      1617,
      1616,
      1614,
      1612,
      616,
      1619,
      1618,
      2575,
      2538,
      2536,
      905,
      901,
      898,
      909,
      2509,
      2507,
      2504,
      870,
      867,
      864,
      860,
      2512,
      875,
      872,
      1781,
      2490,
      2489,
      2487,
      2485,
      1748,
      836,
      834,
      832,
      830,
      2494,
      827,
      2492,
      843,
      841,
      839,
      845,
      1765,
      1763,
      2701,
      2676,
      2674,
      2653,
      2648,
      2656,
      2634,
      2633,
      2631,
      2629,
      1821,
      2638,
      2636,
      2770,
      2763,
      2761,
      2750,
      2745,
      2753,
      2736,
      2735,
      2733,
      2731,
      1848,
      2740,
      2738,
      2786,
      2784,
      591,
      588,
      576,
      569,
      566,
      2296,
      1590,
      537,
      534,
      526,
      2276,
      522,
      2274,
      545,
      542,
      539,
      548,
      1572,
      1570,
      481,
      2245,
      466,
      2242,
      462,
      2239,
      492,
      485,
      482,
      2249,
      496,
      494,
      1534,
      1531,
      1528,
      1538,
      413,
      2196,
      406,
      2191,
      2188,
      425,
      419,
      2202,
      415,
      2199,
      432,
      430,
      427,
      1472,
      1467,
      1464,
      433,
      1476,
      1474,
      368,
      367,
      2160,
      365,
      2159,
      362,
      2157,
      2155,
      2152,
      378,
      377,
      375,
      2166,
      372,
      2165,
      369,
      2162,
      383,
      381,
      379,
      2168,
      1419,
      1418,
      1416,
      1414,
      385,
      1411,
      384,
      1423,
      1422,
      1420,
      1424,
      2461,
      802,
      2441,
      2439,
      790,
      786,
      783,
      794,
      2409,
      2406,
      2403,
      750,
      742,
      738,
      2414,
      756,
      753,
      1720,
      2367,
      2365,
      2362,
      2359,
      1663,
      693,
      691,
      684,
      2373,
      680,
      2370,
      702,
      699,
      696,
      704,
      1690,
      1687,
      2337,
      2336,
      2334,
      2332,
      1624,
      2329,
      1622,
      640,
      637,
      2344,
      634,
      2342,
      630,
      2340,
      650,
      648,
      645,
      2346,
      655,
      653,
      1653,
      1651,
      1649,
      1655,
      2612,
      2597,
      2595,
      2571,
      2568,
      2565,
      2576,
      2534,
      2529,
      2526,
      1787,
      2540,
      2537,
      907,
      904,
      900,
      910,
      2503,
      2502,
      2500,
      2498,
      1768,
      2495,
      1767,
      2510,
      2508,
      2506,
      869,
      866,
      863,
      2513,
      876,
      874,
      1782,
      2720,
      2713,
      2711,
      2697,
      2694,
      2691,
      2702,
      2672,
      2670,
      2664,
      1828,
      2678,
      2675,
      2647,
      2646,
      2644,
      2642,
      1823,
      2639,
      1822,
      2654,
      2652,
      2650,
      2657,
      2771,
      1855,
      2765,
      2762,
      1850,
      1849,
      2751,
      2749,
      2747,
      2754,
      353,
      2148,
      344,
      342,
      336,
      2142,
      332,
      2140,
      345,
      1375,
      1373,
      306,
      2130,
      299,
      2128,
      295,
      2125,
      319,
      314,
      311,
      2132,
      1354,
      1352,
      1349,
      1356,
      262,
      257,
      2101,
      253,
      2096,
      2093,
      274,
      273,
      267,
      2107,
      263,
      2104,
      280,
      278,
      275,
      1316,
      1311,
      1308,
      1320,
      1318,
      2052,
      202,
      2050,
      2044,
      2040,
      219,
      2063,
      212,
      2060,
      208,
      2055,
      224,
      221,
      2066,
      1260,
      1258,
      1252,
      231,
      1248,
      229,
      1266,
      1264,
      1261,
      1268,
      155,
      1998,
      153,
      1996,
      1994,
      1991,
      1988,
      165,
      164,
      2007,
      162,
      2006,
      159,
      2003,
      2e3,
      172,
      171,
      169,
      2012,
      166,
      2010,
      1186,
      1184,
      1182,
      1179,
      175,
      1176,
      173,
      1192,
      1191,
      1189,
      1187,
      176,
      1194,
      1193,
      2313,
      2307,
      2305,
      592,
      589,
      2294,
      2292,
      2289,
      578,
      572,
      568,
      2297,
      580,
      1591,
      2272,
      2267,
      2264,
      1547,
      538,
      536,
      529,
      2278,
      525,
      2275,
      547,
      544,
      541,
      1574,
      1571,
      2237,
      2235,
      2229,
      1493,
      2225,
      1489,
      478,
      2247,
      470,
      2244,
      465,
      2241,
      493,
      488,
      484,
      2250,
      498,
      495,
      1536,
      1533,
      1530,
      1539,
      2187,
      2186,
      2184,
      2182,
      1432,
      2179,
      1430,
      2176,
      1427,
      414,
      412,
      2197,
      409,
      2195,
      405,
      2193,
      2190,
      426,
      424,
      421,
      2203,
      418,
      2201,
      431,
      429,
      1473,
      1471,
      1469,
      1466,
      434,
      1477,
      1475,
      2478,
      2472,
      2470,
      2459,
      2457,
      2454,
      2462,
      803,
      2437,
      2432,
      2429,
      1726,
      2443,
      2440,
      792,
      789,
      785,
      2401,
      2399,
      2393,
      1702,
      2389,
      1699,
      2411,
      2408,
      2405,
      745,
      741,
      2415,
      758,
      755,
      1721,
      2358,
      2357,
      2355,
      2353,
      1661,
      2350,
      1660,
      2347,
      1657,
      2368,
      2366,
      2364,
      2361,
      1666,
      690,
      687,
      2374,
      683,
      2372,
      701,
      698,
      705,
      1691,
      1689,
      2619,
      2617,
      2610,
      2608,
      2605,
      2613,
      2593,
      2588,
      2585,
      1803,
      2599,
      2596,
      2563,
      2561,
      2555,
      1797,
      2551,
      1795,
      2573,
      2570,
      2567,
      2577,
      2525,
      2524,
      2522,
      2520,
      1786,
      2517,
      1785,
      2514,
      1783,
      2535,
      2533,
      2531,
      2528,
      1788,
      2541,
      2539,
      906,
      903,
      911,
      2721,
      1844,
      2715,
      2712,
      1838,
      1836,
      2699,
      2696,
      2693,
      2703,
      1827,
      1826,
      1824,
      2673,
      2671,
      2669,
      2666,
      1829,
      2679,
      2677,
      1858,
      1857,
      2772,
      1854,
      1853,
      1851,
      1856,
      2766,
      2764,
      143,
      1987,
      139,
      1986,
      135,
      133,
      131,
      1984,
      128,
      1983,
      125,
      1981,
      138,
      137,
      136,
      1985,
      1133,
      1132,
      1130,
      112,
      110,
      1974,
      107,
      1973,
      104,
      1971,
      1969,
      122,
      121,
      119,
      117,
      1977,
      114,
      1976,
      124,
      1115,
      1114,
      1112,
      1110,
      1117,
      1116,
      84,
      83,
      1953,
      81,
      1952,
      78,
      1950,
      1948,
      1945,
      94,
      93,
      91,
      1959,
      88,
      1958,
      85,
      1955,
      99,
      97,
      95,
      1961,
      1086,
      1085,
      1083,
      1081,
      1078,
      100,
      1090,
      1089,
      1087,
      1091,
      49,
      47,
      1917,
      44,
      1915,
      1913,
      1910,
      1907,
      59,
      1926,
      56,
      1925,
      53,
      1922,
      1919,
      66,
      64,
      1931,
      61,
      1929,
      1042,
      1040,
      1038,
      71,
      1035,
      70,
      1032,
      68,
      1048,
      1047,
      1045,
      1043,
      1050,
      1049,
      12,
      10,
      1869,
      1867,
      1864,
      1861,
      21,
      1880,
      19,
      1877,
      1874,
      1871,
      28,
      1888,
      25,
      1886,
      22,
      1883,
      982,
      980,
      977,
      974,
      32,
      30,
      991,
      989,
      987,
      984,
      34,
      995,
      994,
      992,
      2151,
      2150,
      2147,
      2146,
      2144,
      356,
      355,
      354,
      2149,
      2139,
      2138,
      2136,
      2134,
      1359,
      343,
      341,
      338,
      2143,
      335,
      2141,
      348,
      347,
      346,
      1376,
      1374,
      2124,
      2123,
      2121,
      2119,
      1326,
      2116,
      1324,
      310,
      308,
      305,
      2131,
      302,
      2129,
      298,
      2127,
      320,
      318,
      316,
      313,
      2133,
      322,
      321,
      1355,
      1353,
      1351,
      1357,
      2092,
      2091,
      2089,
      2087,
      1276,
      2084,
      1274,
      2081,
      1271,
      259,
      2102,
      256,
      2100,
      252,
      2098,
      2095,
      272,
      269,
      2108,
      266,
      2106,
      281,
      279,
      277,
      1317,
      1315,
      1313,
      1310,
      282,
      1321,
      1319,
      2039,
      2037,
      2035,
      2032,
      1203,
      2029,
      1200,
      1197,
      207,
      2053,
      205,
      2051,
      201,
      2049,
      2046,
      2043,
      220,
      218,
      2064,
      215,
      2062,
      211,
      2059,
      228,
      226,
      223,
      2069,
      1259,
      1257,
      1254,
      232,
      1251,
      230,
      1267,
      1265,
      1263,
      2316,
      2315,
      2312,
      2311,
      2309,
      2314,
      2304,
      2303,
      2301,
      2299,
      1593,
      2308,
      2306,
      590,
      2288,
      2287,
      2285,
      2283,
      1578,
      2280,
      1577,
      2295,
      2293,
      2291,
      579,
      577,
      574,
      571,
      2298,
      582,
      581,
      1592,
      2263,
      2262,
      2260,
      2258,
      1545,
      2255,
      1544,
      2252,
      1541,
      2273,
      2271,
      2269,
      2266,
      1550,
      535,
      532,
      2279,
      528,
      2277,
      546,
      543,
      549,
      1575,
      1573,
      2224,
      2222,
      2220,
      1486,
      2217,
      1485,
      2214,
      1482,
      1479,
      2238,
      2236,
      2234,
      2231,
      1496,
      2228,
      1492,
      480,
      477,
      2248,
      473,
      2246,
      469,
      2243,
      490,
      487,
      2251,
      497,
      1537,
      1535,
      1532,
      2477,
      2476,
      2474,
      2479,
      2469,
      2468,
      2466,
      2464,
      1730,
      2473,
      2471,
      2453,
      2452,
      2450,
      2448,
      1729,
      2445,
      1728,
      2460,
      2458,
      2456,
      2463,
      805,
      804,
      2428,
      2427,
      2425,
      2423,
      1725,
      2420,
      1724,
      2417,
      1722,
      2438,
      2436,
      2434,
      2431,
      1727,
      2444,
      2442,
      793,
      791,
      788,
      795,
      2388,
      2386,
      2384,
      1697,
      2381,
      1696,
      2378,
      1694,
      1692,
      2402,
      2400,
      2398,
      2395,
      1703,
      2392,
      1701,
      2412,
      2410,
      2407,
      751,
      748,
      744,
      2416,
      759,
      757,
      1807,
      2620,
      2618,
      1806,
      1805,
      2611,
      2609,
      2607,
      2614,
      1802,
      1801,
      1799,
      2594,
      2592,
      2590,
      2587,
      1804,
      2600,
      2598,
      1794,
      1793,
      1791,
      1789,
      2564,
      2562,
      2560,
      2557,
      1798,
      2554,
      1796,
      2574,
      2572,
      2569,
      2578,
      1847,
      1846,
      2722,
      1843,
      1842,
      1840,
      1845,
      2716,
      2714,
      1835,
      1834,
      1832,
      1830,
      1839,
      1837,
      2700,
      2698,
      2695,
      2704,
      1817,
      1811,
      1810,
      897,
      862,
      1777,
      829,
      826,
      838,
      1760,
      1758,
      808,
      2481,
      1741,
      1740,
      1738,
      1743,
      2624,
      1818,
      2726,
      2776,
      782,
      740,
      737,
      1715,
      686,
      679,
      695,
      1682,
      1680,
      639,
      628,
      2339,
      647,
      644,
      1645,
      1643,
      1640,
      1648,
      602,
      600,
      597,
      595,
      2320,
      593,
      2318,
      609,
      607,
      604,
      1611,
      1610,
      1608,
      1606,
      613,
      1615,
      1613,
      2328,
      926,
      924,
      892,
      886,
      899,
      857,
      850,
      2505,
      1778,
      824,
      823,
      821,
      819,
      2488,
      818,
      2486,
      833,
      831,
      828,
      840,
      1761,
      1759,
      2649,
      2632,
      2630,
      2746,
      2734,
      2732,
      2782,
      2781,
      570,
      567,
      1587,
      531,
      527,
      523,
      540,
      1566,
      1564,
      476,
      467,
      463,
      2240,
      486,
      483,
      1524,
      1521,
      1518,
      1529,
      411,
      403,
      2192,
      399,
      2189,
      423,
      416,
      1462,
      1457,
      1454,
      428,
      1468,
      1465,
      2210,
      366,
      363,
      2158,
      360,
      2156,
      357,
      2153,
      376,
      373,
      370,
      2163,
      1410,
      1409,
      1407,
      1405,
      382,
      1402,
      380,
      1417,
      1415,
      1412,
      1421,
      2175,
      2174,
      777,
      774,
      771,
      784,
      732,
      725,
      722,
      2404,
      743,
      1716,
      676,
      674,
      668,
      2363,
      665,
      2360,
      685,
      1684,
      1681,
      626,
      624,
      622,
      2335,
      620,
      2333,
      617,
      2330,
      641,
      635,
      649,
      1646,
      1644,
      1642,
      2566,
      928,
      925,
      2530,
      2527,
      894,
      891,
      888,
      2501,
      2499,
      2496,
      858,
      856,
      854,
      851,
      1779,
      2692,
      2668,
      2665,
      2645,
      2643,
      2640,
      2651,
      2768,
      2759,
      2757,
      2744,
      2743,
      2741,
      2748,
      352,
      1382,
      340,
      337,
      333,
      1371,
      1369,
      307,
      300,
      296,
      2126,
      315,
      312,
      1347,
      1342,
      1350,
      261,
      258,
      250,
      2097,
      246,
      2094,
      271,
      268,
      264,
      1306,
      1301,
      1298,
      276,
      1312,
      1309,
      2115,
      203,
      2048,
      195,
      2045,
      191,
      2041,
      213,
      209,
      2056,
      1246,
      1244,
      1238,
      225,
      1234,
      222,
      1256,
      1253,
      1249,
      1262,
      2080,
      2079,
      154,
      1997,
      150,
      1995,
      147,
      1992,
      1989,
      163,
      160,
      2004,
      156,
      2001,
      1175,
      1174,
      1172,
      1170,
      1167,
      170,
      1164,
      167,
      1185,
      1183,
      1180,
      1177,
      174,
      1190,
      1188,
      2025,
      2024,
      2022,
      587,
      586,
      564,
      559,
      556,
      2290,
      573,
      1588,
      520,
      518,
      512,
      2268,
      508,
      2265,
      530,
      1568,
      1565,
      461,
      457,
      2233,
      450,
      2230,
      446,
      2226,
      479,
      471,
      489,
      1526,
      1523,
      1520,
      397,
      395,
      2185,
      392,
      2183,
      389,
      2180,
      2177,
      410,
      2194,
      402,
      422,
      1463,
      1461,
      1459,
      1456,
      1470,
      2455,
      799,
      2433,
      2430,
      779,
      776,
      773,
      2397,
      2394,
      2390,
      734,
      728,
      724,
      746,
      1717,
      2356,
      2354,
      2351,
      2348,
      1658,
      677,
      675,
      673,
      670,
      667,
      688,
      1685,
      1683,
      2606,
      2589,
      2586,
      2559,
      2556,
      2552,
      927,
      2523,
      2521,
      2518,
      2515,
      1784,
      2532,
      895,
      893,
      890,
      2718,
      2709,
      2707,
      2689,
      2687,
      2684,
      2663,
      2662,
      2660,
      2658,
      1825,
      2667,
      2769,
      1852,
      2760,
      2758,
      142,
      141,
      1139,
      1138,
      134,
      132,
      129,
      126,
      1982,
      1129,
      1128,
      1126,
      1131,
      113,
      111,
      108,
      105,
      1972,
      101,
      1970,
      120,
      118,
      115,
      1109,
      1108,
      1106,
      1104,
      123,
      1113,
      1111,
      82,
      79,
      1951,
      75,
      1949,
      72,
      1946,
      92,
      89,
      86,
      1956,
      1077,
      1076,
      1074,
      1072,
      98,
      1069,
      96,
      1084,
      1082,
      1079,
      1088,
      1968,
      1967,
      48,
      45,
      1916,
      42,
      1914,
      39,
      1911,
      1908,
      60,
      57,
      54,
      1923,
      50,
      1920,
      1031,
      1030,
      1028,
      1026,
      67,
      1023,
      65,
      1020,
      62,
      1041,
      1039,
      1036,
      1033,
      69,
      1046,
      1044,
      1944,
      1943,
      1941,
      11,
      9,
      1868,
      7,
      1865,
      1862,
      1859,
      20,
      1878,
      16,
      1875,
      13,
      1872,
      970,
      968,
      966,
      963,
      29,
      960,
      26,
      23,
      983,
      981,
      978,
      975,
      33,
      971,
      31,
      990,
      988,
      985,
      1906,
      1904,
      1902,
      993,
      351,
      2145,
      1383,
      331,
      330,
      328,
      326,
      2137,
      323,
      2135,
      339,
      1372,
      1370,
      294,
      293,
      291,
      289,
      2122,
      286,
      2120,
      283,
      2117,
      309,
      303,
      317,
      1348,
      1346,
      1344,
      245,
      244,
      242,
      2090,
      239,
      2088,
      236,
      2085,
      2082,
      260,
      2099,
      249,
      270,
      1307,
      1305,
      1303,
      1300,
      1314,
      189,
      2038,
      186,
      2036,
      183,
      2033,
      2030,
      2026,
      206,
      198,
      2047,
      194,
      216,
      1247,
      1245,
      1243,
      1240,
      227,
      1237,
      1255,
      2310,
      2302,
      2300,
      2286,
      2284,
      2281,
      565,
      563,
      561,
      558,
      575,
      1589,
      2261,
      2259,
      2256,
      2253,
      1542,
      521,
      519,
      517,
      514,
      2270,
      511,
      533,
      1569,
      1567,
      2223,
      2221,
      2218,
      2215,
      1483,
      2211,
      1480,
      459,
      456,
      453,
      2232,
      449,
      474,
      491,
      1527,
      1525,
      1522,
      2475,
      2467,
      2465,
      2451,
      2449,
      2446,
      801,
      800,
      2426,
      2424,
      2421,
      2418,
      1723,
      2435,
      780,
      778,
      775,
      2387,
      2385,
      2382,
      2379,
      1695,
      2375,
      1693,
      2396,
      735,
      733,
      730,
      727,
      749,
      1718,
      2616,
      2615,
      2604,
      2603,
      2601,
      2584,
      2583,
      2581,
      2579,
      1800,
      2591,
      2550,
      2549,
      2547,
      2545,
      1792,
      2542,
      1790,
      2558,
      929,
      2719,
      1841,
      2710,
      2708,
      1833,
      1831,
      2690,
      2688,
      2686,
      1815,
      1809,
      1808,
      1774,
      1756,
      1754,
      1737,
      1736,
      1734,
      1739,
      1816,
      1711,
      1676,
      1674,
      633,
      629,
      1638,
      1636,
      1633,
      1641,
      598,
      1605,
      1604,
      1602,
      1600,
      605,
      1609,
      1607,
      2327,
      887,
      853,
      1775,
      822,
      820,
      1757,
      1755,
      1584,
      524,
      1560,
      1558,
      468,
      464,
      1514,
      1511,
      1508,
      1519,
      408,
      404,
      400,
      1452,
      1447,
      1444,
      417,
      1458,
      1455,
      2208,
      364,
      361,
      358,
      2154,
      1401,
      1400,
      1398,
      1396,
      374,
      1393,
      371,
      1408,
      1406,
      1403,
      1413,
      2173,
      2172,
      772,
      726,
      723,
      1712,
      672,
      669,
      666,
      682,
      1678,
      1675,
      625,
      623,
      621,
      618,
      2331,
      636,
      632,
      1639,
      1637,
      1635,
      920,
      918,
      884,
      880,
      889,
      849,
      848,
      847,
      846,
      2497,
      855,
      852,
      1776,
      2641,
      2742,
      2787,
      1380,
      334,
      1367,
      1365,
      301,
      297,
      1340,
      1338,
      1335,
      1343,
      255,
      251,
      247,
      1296,
      1291,
      1288,
      265,
      1302,
      1299,
      2113,
      204,
      196,
      192,
      2042,
      1232,
      1230,
      1224,
      214,
      1220,
      210,
      1242,
      1239,
      1235,
      1250,
      2077,
      2075,
      151,
      148,
      1993,
      144,
      1990,
      1163,
      1162,
      1160,
      1158,
      1155,
      161,
      1152,
      157,
      1173,
      1171,
      1168,
      1165,
      168,
      1181,
      1178,
      2021,
      2020,
      2018,
      2023,
      585,
      560,
      557,
      1585,
      516,
      509,
      1562,
      1559,
      458,
      447,
      2227,
      472,
      1516,
      1513,
      1510,
      398,
      396,
      393,
      390,
      2181,
      386,
      2178,
      407,
      1453,
      1451,
      1449,
      1446,
      420,
      1460,
      2209,
      769,
      764,
      720,
      712,
      2391,
      729,
      1713,
      664,
      663,
      661,
      659,
      2352,
      656,
      2349,
      671,
      1679,
      1677,
      2553,
      922,
      919,
      2519,
      2516,
      885,
      883,
      881,
      2685,
      2661,
      2659,
      2767,
      2756,
      2755,
      140,
      1137,
      1136,
      130,
      127,
      1125,
      1124,
      1122,
      1127,
      109,
      106,
      102,
      1103,
      1102,
      1100,
      1098,
      116,
      1107,
      1105,
      1980,
      80,
      76,
      73,
      1947,
      1068,
      1067,
      1065,
      1063,
      90,
      1060,
      87,
      1075,
      1073,
      1070,
      1080,
      1966,
      1965,
      46,
      43,
      40,
      1912,
      36,
      1909,
      1019,
      1018,
      1016,
      1014,
      58,
      1011,
      55,
      1008,
      51,
      1029,
      1027,
      1024,
      1021,
      63,
      1037,
      1034,
      1940,
      1939,
      1937,
      1942,
      8,
      1866,
      4,
      1863,
      1,
      1860,
      956,
      954,
      952,
      949,
      946,
      17,
      14,
      969,
      967,
      964,
      961,
      27,
      957,
      24,
      979,
      976,
      972,
      1901,
      1900,
      1898,
      1896,
      986,
      1905,
      1903,
      350,
      349,
      1381,
      329,
      327,
      324,
      1368,
      1366,
      292,
      290,
      287,
      284,
      2118,
      304,
      1341,
      1339,
      1337,
      1345,
      243,
      240,
      237,
      2086,
      233,
      2083,
      254,
      1297,
      1295,
      1293,
      1290,
      1304,
      2114,
      190,
      187,
      184,
      2034,
      180,
      2031,
      177,
      2027,
      199,
      1233,
      1231,
      1229,
      1226,
      217,
      1223,
      1241,
      2078,
      2076,
      584,
      555,
      554,
      552,
      550,
      2282,
      562,
      1586,
      507,
      506,
      504,
      502,
      2257,
      499,
      2254,
      515,
      1563,
      1561,
      445,
      443,
      441,
      2219,
      438,
      2216,
      435,
      2212,
      460,
      454,
      475,
      1517,
      1515,
      1512,
      2447,
      798,
      797,
      2422,
      2419,
      770,
      768,
      766,
      2383,
      2380,
      2376,
      721,
      719,
      717,
      714,
      731,
      1714,
      2602,
      2582,
      2580,
      2548,
      2546,
      2543,
      923,
      921,
      2717,
      2706,
      2705,
      2683,
      2682,
      2680,
      1771,
      1752,
      1750,
      1733,
      1732,
      1731,
      1735,
      1814,
      1707,
      1670,
      1668,
      1631,
      1629,
      1626,
      1634,
      1599,
      1598,
      1596,
      1594,
      1603,
      1601,
      2326,
      1772,
      1753,
      1751,
      1581,
      1554,
      1552,
      1504,
      1501,
      1498,
      1509,
      1442,
      1437,
      1434,
      401,
      1448,
      1445,
      2206,
      1392,
      1391,
      1389,
      1387,
      1384,
      359,
      1399,
      1397,
      1394,
      1404,
      2171,
      2170,
      1708,
      1672,
      1669,
      619,
      1632,
      1630,
      1628,
      1773,
      1378,
      1363,
      1361,
      1333,
      1328,
      1336,
      1286,
      1281,
      1278,
      248,
      1292,
      1289,
      2111,
      1218,
      1216,
      1210,
      197,
      1206,
      193,
      1228,
      1225,
      1221,
      1236,
      2073,
      2071,
      1151,
      1150,
      1148,
      1146,
      152,
      1143,
      149,
      1140,
      145,
      1161,
      1159,
      1156,
      1153,
      158,
      1169,
      1166,
      2017,
      2016,
      2014,
      2019,
      1582,
      510,
      1556,
      1553,
      452,
      448,
      1506,
      1500,
      394,
      391,
      387,
      1443,
      1441,
      1439,
      1436,
      1450,
      2207,
      765,
      716,
      713,
      1709,
      662,
      660,
      657,
      1673,
      1671,
      916,
      914,
      879,
      878,
      877,
      882,
      1135,
      1134,
      1121,
      1120,
      1118,
      1123,
      1097,
      1096,
      1094,
      1092,
      103,
      1101,
      1099,
      1979,
      1059,
      1058,
      1056,
      1054,
      77,
      1051,
      74,
      1066,
      1064,
      1061,
      1071,
      1964,
      1963,
      1007,
      1006,
      1004,
      1002,
      999,
      41,
      996,
      37,
      1017,
      1015,
      1012,
      1009,
      52,
      1025,
      1022,
      1936,
      1935,
      1933,
      1938,
      942,
      940,
      938,
      935,
      932,
      5,
      2,
      955,
      953,
      950,
      947,
      18,
      943,
      15,
      965,
      962,
      958,
      1895,
      1894,
      1892,
      1890,
      973,
      1899,
      1897,
      1379,
      325,
      1364,
      1362,
      288,
      285,
      1334,
      1332,
      1330,
      241,
      238,
      234,
      1287,
      1285,
      1283,
      1280,
      1294,
      2112,
      188,
      185,
      181,
      178,
      2028,
      1219,
      1217,
      1215,
      1212,
      200,
      1209,
      1227,
      2074,
      2072,
      583,
      553,
      551,
      1583,
      505,
      503,
      500,
      513,
      1557,
      1555,
      444,
      442,
      439,
      436,
      2213,
      455,
      451,
      1507,
      1505,
      1502,
      796,
      763,
      762,
      760,
      767,
      711,
      710,
      708,
      706,
      2377,
      718,
      715,
      1710,
      2544,
      917,
      915,
      2681,
      1627,
      1597,
      1595,
      2325,
      1769,
      1749,
      1747,
      1499,
      1438,
      1435,
      2204,
      1390,
      1388,
      1385,
      1395,
      2169,
      2167,
      1704,
      1665,
      1662,
      1625,
      1623,
      1620,
      1770,
      1329,
      1282,
      1279,
      2109,
      1214,
      1207,
      1222,
      2068,
      2065,
      1149,
      1147,
      1144,
      1141,
      146,
      1157,
      1154,
      2013,
      2011,
      2008,
      2015,
      1579,
      1549,
      1546,
      1495,
      1487,
      1433,
      1431,
      1428,
      1425,
      388,
      1440,
      2205,
      1705,
      658,
      1667,
      1664,
      1119,
      1095,
      1093,
      1978,
      1057,
      1055,
      1052,
      1062,
      1962,
      1960,
      1005,
      1003,
      1e3,
      997,
      38,
      1013,
      1010,
      1932,
      1930,
      1927,
      1934,
      941,
      939,
      936,
      933,
      6,
      930,
      3,
      951,
      948,
      944,
      1889,
      1887,
      1884,
      1881,
      959,
      1893,
      1891,
      35,
      1377,
      1360,
      1358,
      1327,
      1325,
      1322,
      1331,
      1277,
      1275,
      1272,
      1269,
      235,
      1284,
      2110,
      1205,
      1204,
      1201,
      1198,
      182,
      1195,
      179,
      1213,
      2070,
      2067,
      1580,
      501,
      1551,
      1548,
      440,
      437,
      1497,
      1494,
      1490,
      1503,
      761,
      709,
      707,
      1706,
      913,
      912,
      2198,
      1386,
      2164,
      2161,
      1621,
      1766,
      2103,
      1208,
      2058,
      2054,
      1145,
      1142,
      2005,
      2002,
      1999,
      2009,
      1488,
      1429,
      1426,
      2200,
      1698,
      1659,
      1656,
      1975,
      1053,
      1957,
      1954,
      1001,
      998,
      1924,
      1921,
      1918,
      1928,
      937,
      934,
      931,
      1879,
      1876,
      1873,
      1870,
      945,
      1885,
      1882,
      1323,
      1273,
      1270,
      2105,
      1202,
      1199,
      1196,
      1211,
      2061,
      2057,
      1576,
      1543,
      1540,
      1484,
      1481,
      1478,
      1491,
      1700
    ]);
    class PDF417DetectorResult {
      constructor(bits, points) {
        this.bits = bits;
        this.points = points;
      }
      getBits() {
        return this.bits;
      }
      getPoints() {
        return this.points;
      }
    }
    class Detector$3 {
      /**
       * <p>Detects a PDF417 Code in an image. Only checks 0 and 180 degree rotations.</p>
       *
       * @param image barcode image to decode
       * @param hints optional hints to detector
       * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
       * be found and returned
       * @return {@link PDF417DetectorResult} encapsulating results of detecting a PDF417 code
       * @throws NotFoundException if no PDF417 Code can be found
       */
      static detectMultiple(image, hints, multiple) {
        let bitMatrix = image.getBlackMatrix();
        let barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        if (!barcodeCoordinates.length) {
          bitMatrix = bitMatrix.clone();
          bitMatrix.rotate180();
          barcodeCoordinates = Detector$3.detect(multiple, bitMatrix);
        }
        return new PDF417DetectorResult(bitMatrix, barcodeCoordinates);
      }
      /**
       * Detects PDF417 codes in an image. Only checks 0 degree rotation
       * @param multiple if true, then the image is searched for multiple codes. If false, then at most one code will
       * be found and returned
       * @param bitMatrix bit matrix to detect barcodes in
       * @return List of ResultPoint arrays containing the coordinates of found barcodes
       */
      static detect(multiple, bitMatrix) {
        const barcodeCoordinates = new Array();
        let row = 0;
        let column = 0;
        let foundBarcodeInRow = false;
        while (row < bitMatrix.getHeight()) {
          const vertices = Detector$3.findVertices(bitMatrix, row, column);
          if (vertices[0] == null && vertices[3] == null) {
            if (!foundBarcodeInRow) {
              break;
            }
            foundBarcodeInRow = false;
            column = 0;
            for (const barcodeCoordinate of barcodeCoordinates) {
              if (barcodeCoordinate[1] != null) {
                row = Math.trunc(Math.max(row, barcodeCoordinate[1].getY()));
              }
              if (barcodeCoordinate[3] != null) {
                row = Math.max(row, Math.trunc(barcodeCoordinate[3].getY()));
              }
            }
            row += Detector$3.ROW_STEP;
            continue;
          }
          foundBarcodeInRow = true;
          barcodeCoordinates.push(vertices);
          if (!multiple) {
            break;
          }
          if (vertices[2] != null) {
            column = Math.trunc(vertices[2].getX());
            row = Math.trunc(vertices[2].getY());
          } else {
            column = Math.trunc(vertices[4].getX());
            row = Math.trunc(vertices[4].getY());
          }
        }
        return barcodeCoordinates;
      }
      /**
       * Locate the vertices and the codewords area of a black blob using the Start
       * and Stop patterns as locators.
       *
       * @param matrix the scanned barcode image.
       * @return an array containing the vertices:
       *           vertices[0] x, y top left barcode
       *           vertices[1] x, y bottom left barcode
       *           vertices[2] x, y top right barcode
       *           vertices[3] x, y bottom right barcode
       *           vertices[4] x, y top left codeword area
       *           vertices[5] x, y bottom left codeword area
       *           vertices[6] x, y top right codeword area
       *           vertices[7] x, y bottom right codeword area
       */
      static findVertices(matrix, startRow, startColumn) {
        const height = matrix.getHeight();
        const width = matrix.getWidth();
        const result = new Array(8);
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.START_PATTERN), Detector$3.INDEXES_START_PATTERN);
        if (result[4] != null) {
          startColumn = Math.trunc(result[4].getX());
          startRow = Math.trunc(result[4].getY());
        }
        Detector$3.copyToResult(result, Detector$3.findRowsWithPattern(matrix, height, width, startRow, startColumn, Detector$3.STOP_PATTERN), Detector$3.INDEXES_STOP_PATTERN);
        return result;
      }
      static copyToResult(result, tmpResult, destinationIndexes) {
        for (let i3 = 0; i3 < destinationIndexes.length; i3++) {
          result[destinationIndexes[i3]] = tmpResult[i3];
        }
      }
      static findRowsWithPattern(matrix, height, width, startRow, startColumn, pattern) {
        const result = new Array(4);
        let found = false;
        const counters = new Int32Array(pattern.length);
        for (; startRow < height; startRow += Detector$3.ROW_STEP) {
          let loc = Detector$3.findGuardPattern(matrix, startColumn, startRow, width, false, pattern, counters);
          if (loc != null) {
            while (startRow > 0) {
              const previousRowLoc = Detector$3.findGuardPattern(matrix, startColumn, --startRow, width, false, pattern, counters);
              if (previousRowLoc != null) {
                loc = previousRowLoc;
              } else {
                startRow++;
                break;
              }
            }
            result[0] = new ResultPoint(loc[0], startRow);
            result[1] = new ResultPoint(loc[1], startRow);
            found = true;
            break;
          }
        }
        let stopRow = startRow + 1;
        if (found) {
          let skippedRowCount = 0;
          let previousRowLoc = Int32Array.from([Math.trunc(result[0].getX()), Math.trunc(result[1].getX())]);
          for (; stopRow < height; stopRow++) {
            const loc = Detector$3.findGuardPattern(matrix, previousRowLoc[0], stopRow, width, false, pattern, counters);
            if (loc != null && Math.abs(previousRowLoc[0] - loc[0]) < Detector$3.MAX_PATTERN_DRIFT && Math.abs(previousRowLoc[1] - loc[1]) < Detector$3.MAX_PATTERN_DRIFT) {
              previousRowLoc = loc;
              skippedRowCount = 0;
            } else {
              if (skippedRowCount > Detector$3.SKIPPED_ROW_COUNT_MAX) {
                break;
              } else {
                skippedRowCount++;
              }
            }
          }
          stopRow -= skippedRowCount + 1;
          result[2] = new ResultPoint(previousRowLoc[0], stopRow);
          result[3] = new ResultPoint(previousRowLoc[1], stopRow);
        }
        if (stopRow - startRow < Detector$3.BARCODE_MIN_HEIGHT) {
          Arrays.fill(result, null);
        }
        return result;
      }
      /**
       * @param matrix row of black/white values to search
       * @param column x position to start search
       * @param row y position to start search
       * @param width the number of pixels to search on this row
       * @param pattern pattern of counts of number of black and white pixels that are
       *                 being searched for as a pattern
       * @param counters array of counters, as long as pattern, to re-use
       * @return start/end horizontal offset of guard pattern, as an array of two ints.
       */
      static findGuardPattern(matrix, column, row, width, whiteFirst, pattern, counters) {
        Arrays.fillWithin(counters, 0, counters.length, 0);
        let patternStart = column;
        let pixelDrift = 0;
        while (matrix.get(patternStart, row) && patternStart > 0 && pixelDrift++ < Detector$3.MAX_PIXEL_DRIFT) {
          patternStart--;
        }
        let x3 = patternStart;
        let counterPosition = 0;
        let patternLength = pattern.length;
        for (let isWhite = whiteFirst; x3 < width; x3++) {
          let pixel = matrix.get(x3, row);
          if (pixel !== isWhite) {
            counters[counterPosition]++;
          } else {
            if (counterPosition === patternLength - 1) {
              if (Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
                return new Int32Array([patternStart, x3]);
              }
              patternStart += counters[0] + counters[1];
              System.arraycopy(counters, 2, counters, 0, counterPosition - 1);
              counters[counterPosition - 1] = 0;
              counters[counterPosition] = 0;
              counterPosition--;
            } else {
              counterPosition++;
            }
            counters[counterPosition] = 1;
            isWhite = !isWhite;
          }
        }
        if (counterPosition === patternLength - 1 && Detector$3.patternMatchVariance(counters, pattern, Detector$3.MAX_INDIVIDUAL_VARIANCE) < Detector$3.MAX_AVG_VARIANCE) {
          return new Int32Array([patternStart, x3 - 1]);
        }
        return null;
      }
      /**
       * Determines how closely a set of observed counts of runs of black/white
       * values matches a given target pattern. This is reported as the ratio of
       * the total variance from the expected pattern proportions across all
       * pattern elements, to the length of the pattern.
       *
       * @param counters observed counters
       * @param pattern expected pattern
       * @param maxIndividualVariance The most any counter can differ before we give up
       * @return ratio of total variance between counters and pattern compared to total pattern size
       */
      static patternMatchVariance(counters, pattern, maxIndividualVariance) {
        let numCounters = counters.length;
        let total = 0;
        let patternLength = 0;
        for (let i3 = 0; i3 < numCounters; i3++) {
          total += counters[i3];
          patternLength += pattern[i3];
        }
        if (total < patternLength) {
          return (
            /*Float.POSITIVE_INFINITY*/
            Infinity
          );
        }
        let unitBarWidth = total / patternLength;
        maxIndividualVariance *= unitBarWidth;
        let totalVariance = 0;
        for (let x3 = 0; x3 < numCounters; x3++) {
          let counter = counters[x3];
          let scaledPattern = pattern[x3] * unitBarWidth;
          let variance = counter > scaledPattern ? counter - scaledPattern : scaledPattern - counter;
          if (variance > maxIndividualVariance) {
            return (
              /*Float.POSITIVE_INFINITY*/
              Infinity
            );
          }
          totalVariance += variance;
        }
        return totalVariance / total;
      }
    }
    Detector$3.INDEXES_START_PATTERN = Int32Array.from([0, 4, 1, 5]);
    Detector$3.INDEXES_STOP_PATTERN = Int32Array.from([6, 2, 7, 3]);
    Detector$3.MAX_AVG_VARIANCE = 0.42;
    Detector$3.MAX_INDIVIDUAL_VARIANCE = 0.8;
    Detector$3.START_PATTERN = Int32Array.from([8, 1, 1, 1, 1, 1, 1, 3]);
    Detector$3.STOP_PATTERN = Int32Array.from([7, 1, 1, 3, 1, 1, 1, 2, 1]);
    Detector$3.MAX_PIXEL_DRIFT = 3;
    Detector$3.MAX_PATTERN_DRIFT = 5;
    Detector$3.SKIPPED_ROW_COUNT_MAX = 25;
    Detector$3.ROW_STEP = 5;
    Detector$3.BARCODE_MIN_HEIGHT = 10;
    class ModulusPoly {
      constructor(field, coefficients) {
        if (coefficients.length === 0) {
          throw new IllegalArgumentException();
        }
        this.field = field;
        let coefficientsLength = (
          /*int*/
          coefficients.length
        );
        if (coefficientsLength > 1 && coefficients[0] === 0) {
          let firstNonZero = (
            /*int*/
            1
          );
          while (firstNonZero < coefficientsLength && coefficients[firstNonZero] === 0) {
            firstNonZero++;
          }
          if (firstNonZero === coefficientsLength) {
            this.coefficients = new Int32Array([0]);
          } else {
            this.coefficients = new Int32Array(coefficientsLength - firstNonZero);
            System.arraycopy(coefficients, firstNonZero, this.coefficients, 0, this.coefficients.length);
          }
        } else {
          this.coefficients = coefficients;
        }
      }
      getCoefficients() {
        return this.coefficients;
      }
      /**
       * @return degree of this polynomial
       */
      getDegree() {
        return this.coefficients.length - 1;
      }
      /**
       * @return true iff this polynomial is the monomial "0"
       */
      isZero() {
        return this.coefficients[0] === 0;
      }
      /**
       * @return coefficient of x^degree term in this polynomial
       */
      getCoefficient(degree) {
        return this.coefficients[this.coefficients.length - 1 - degree];
      }
      /**
       * @return evaluation of this polynomial at a given point
       */
      evaluateAt(a4) {
        if (a4 === 0) {
          return this.getCoefficient(0);
        }
        if (a4 === 1) {
          let sum = (
            /*int*/
            0
          );
          for (let coefficient of this.coefficients) {
            sum = this.field.add(sum, coefficient);
          }
          return sum;
        }
        let result = (
          /*int*/
          this.coefficients[0]
        );
        let size2 = (
          /*int*/
          this.coefficients.length
        );
        for (let i3 = 1; i3 < size2; i3++) {
          result = this.field.add(this.field.multiply(a4, result), this.coefficients[i3]);
        }
        return result;
      }
      add(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero()) {
          return other;
        }
        if (other.isZero()) {
          return this;
        }
        let smallerCoefficients = this.coefficients;
        let largerCoefficients = other.coefficients;
        if (smallerCoefficients.length > largerCoefficients.length) {
          let temp = smallerCoefficients;
          smallerCoefficients = largerCoefficients;
          largerCoefficients = temp;
        }
        let sumDiff = new Int32Array(largerCoefficients.length);
        let lengthDiff = (
          /*int*/
          largerCoefficients.length - smallerCoefficients.length
        );
        System.arraycopy(largerCoefficients, 0, sumDiff, 0, lengthDiff);
        for (let i3 = lengthDiff; i3 < largerCoefficients.length; i3++) {
          sumDiff[i3] = this.field.add(smallerCoefficients[i3 - lengthDiff], largerCoefficients[i3]);
        }
        return new ModulusPoly(this.field, sumDiff);
      }
      subtract(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (other.isZero()) {
          return this;
        }
        return this.add(other.negative());
      }
      multiply(other) {
        if (other instanceof ModulusPoly) {
          return this.multiplyOther(other);
        }
        return this.multiplyScalar(other);
      }
      multiplyOther(other) {
        if (!this.field.equals(other.field)) {
          throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
        }
        if (this.isZero() || other.isZero()) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let aCoefficients = this.coefficients;
        let aLength = (
          /*int*/
          aCoefficients.length
        );
        let bCoefficients = other.coefficients;
        let bLength = (
          /*int*/
          bCoefficients.length
        );
        let product = new Int32Array(aLength + bLength - 1);
        for (let i3 = 0; i3 < aLength; i3++) {
          let aCoeff = (
            /*int*/
            aCoefficients[i3]
          );
          for (let j2 = 0; j2 < bLength; j2++) {
            product[i3 + j2] = this.field.add(product[i3 + j2], this.field.multiply(aCoeff, bCoefficients[j2]));
          }
        }
        return new ModulusPoly(this.field, product);
      }
      negative() {
        let size2 = (
          /*int*/
          this.coefficients.length
        );
        let negativeCoefficients = new Int32Array(size2);
        for (let i3 = 0; i3 < size2; i3++) {
          negativeCoefficients[i3] = this.field.subtract(0, this.coefficients[i3]);
        }
        return new ModulusPoly(this.field, negativeCoefficients);
      }
      multiplyScalar(scalar) {
        if (scalar === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        if (scalar === 1) {
          return this;
        }
        let size2 = (
          /*int*/
          this.coefficients.length
        );
        let product = new Int32Array(size2);
        for (let i3 = 0; i3 < size2; i3++) {
          product[i3] = this.field.multiply(this.coefficients[i3], scalar);
        }
        return new ModulusPoly(this.field, product);
      }
      multiplyByMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return new ModulusPoly(this.field, new Int32Array([0]));
        }
        let size2 = (
          /*int*/
          this.coefficients.length
        );
        let product = new Int32Array(size2 + degree);
        for (let i3 = 0; i3 < size2; i3++) {
          product[i3] = this.field.multiply(this.coefficients[i3], coefficient);
        }
        return new ModulusPoly(this.field, product);
      }
      /*
        ModulusPoly[] divide(other: ModulusPoly) {
          if (!field.equals(other.field)) {
            throw new IllegalArgumentException("ModulusPolys do not have same ModulusGF field");
          }
          if (other.isZero()) {
            throw new IllegalArgumentException("Divide by 0");
          }
      
          let quotient: ModulusPoly = field.getZero();
          let remainder: ModulusPoly = this;
      
          let denominatorLeadingTerm: /*int/ number = other.getCoefficient(other.getDegree());
          let inverseDenominatorLeadingTerm: /*int/ number = field.inverse(denominatorLeadingTerm);
      
          while (remainder.getDegree() >= other.getDegree() && !remainder.isZero()) {
            let degreeDifference: /*int/ number = remainder.getDegree() - other.getDegree();
            let scale: /*int/ number = field.multiply(remainder.getCoefficient(remainder.getDegree()), inverseDenominatorLeadingTerm);
            let term: ModulusPoly = other.multiplyByMonomial(degreeDifference, scale);
            let iterationQuotient: ModulusPoly = field.buildMonomial(degreeDifference, scale);
            quotient = quotient.add(iterationQuotient);
            remainder = remainder.subtract(term);
          }
      
          return new ModulusPoly[] { quotient, remainder };
        }
        */
      // @Override
      toString() {
        let result = new StringBuilder(
          /*8 * this.getDegree()*/
        );
        for (let degree = this.getDegree(); degree >= 0; degree--) {
          let coefficient = (
            /*int*/
            this.getCoefficient(degree)
          );
          if (coefficient !== 0) {
            if (coefficient < 0) {
              result.append(" - ");
              coefficient = -coefficient;
            } else {
              if (result.length() > 0) {
                result.append(" + ");
              }
            }
            if (degree === 0 || coefficient !== 1) {
              result.append(coefficient);
            }
            if (degree !== 0) {
              if (degree === 1) {
                result.append("x");
              } else {
                result.append("x^");
                result.append(degree);
              }
            }
          }
        }
        return result.toString();
      }
    }
    class ModulusBase {
      add(a4, b2) {
        return (a4 + b2) % this.modulus;
      }
      subtract(a4, b2) {
        return (this.modulus + a4 - b2) % this.modulus;
      }
      exp(a4) {
        return this.expTable[a4];
      }
      log(a4) {
        if (a4 === 0) {
          throw new IllegalArgumentException();
        }
        return this.logTable[a4];
      }
      inverse(a4) {
        if (a4 === 0) {
          throw new ArithmeticException();
        }
        return this.expTable[this.modulus - this.logTable[a4] - 1];
      }
      multiply(a4, b2) {
        if (a4 === 0 || b2 === 0) {
          return 0;
        }
        return this.expTable[(this.logTable[a4] + this.logTable[b2]) % (this.modulus - 1)];
      }
      getSize() {
        return this.modulus;
      }
      equals(o2) {
        return o2 === this;
      }
    }
    class ModulusGF extends ModulusBase {
      // private /*final*/ modulus: /*int*/ number;
      constructor(modulus, generator) {
        super();
        this.modulus = modulus;
        this.expTable = new Int32Array(modulus);
        this.logTable = new Int32Array(modulus);
        let x3 = (
          /*int*/
          1
        );
        for (let i3 = 0; i3 < modulus; i3++) {
          this.expTable[i3] = x3;
          x3 = x3 * generator % modulus;
        }
        for (let i3 = 0; i3 < modulus - 1; i3++) {
          this.logTable[this.expTable[i3]] = i3;
        }
        this.zero = new ModulusPoly(this, new Int32Array([0]));
        this.one = new ModulusPoly(this, new Int32Array([1]));
      }
      getZero() {
        return this.zero;
      }
      getOne() {
        return this.one;
      }
      buildMonomial(degree, coefficient) {
        if (degree < 0) {
          throw new IllegalArgumentException();
        }
        if (coefficient === 0) {
          return this.zero;
        }
        let coefficients = new Int32Array(degree + 1);
        coefficients[0] = coefficient;
        return new ModulusPoly(this, coefficients);
      }
    }
    ModulusGF.PDF417_GF = new ModulusGF(PDF417Common.NUMBER_OF_CODEWORDS, 3);
    class ErrorCorrection {
      constructor() {
        this.field = ModulusGF.PDF417_GF;
      }
      /**
       * @param received received codewords
       * @param numECCodewords number of those codewords used for EC
       * @param erasures location of erasures
       * @return number of errors
       * @throws ChecksumException if errors cannot be corrected, maybe because of too many errors
       */
      decode(received, numECCodewords, erasures) {
        let poly = new ModulusPoly(this.field, received);
        let S4 = new Int32Array(numECCodewords);
        let error = false;
        for (let i3 = numECCodewords; i3 > 0; i3--) {
          let evaluation = poly.evaluateAt(this.field.exp(i3));
          S4[numECCodewords - i3] = evaluation;
          if (evaluation !== 0) {
            error = true;
          }
        }
        if (!error) {
          return 0;
        }
        let knownErrors = this.field.getOne();
        if (erasures != null) {
          for (const erasure of erasures) {
            let b2 = this.field.exp(received.length - 1 - erasure);
            let term = new ModulusPoly(this.field, new Int32Array([this.field.subtract(0, b2), 1]));
            knownErrors = knownErrors.multiply(term);
          }
        }
        let syndrome = new ModulusPoly(this.field, S4);
        let sigmaOmega = this.runEuclideanAlgorithm(this.field.buildMonomial(numECCodewords, 1), syndrome, numECCodewords);
        let sigma = sigmaOmega[0];
        let omega = sigmaOmega[1];
        let errorLocations = this.findErrorLocations(sigma);
        let errorMagnitudes = this.findErrorMagnitudes(omega, sigma, errorLocations);
        for (let i3 = 0; i3 < errorLocations.length; i3++) {
          let position = received.length - 1 - this.field.log(errorLocations[i3]);
          if (position < 0) {
            throw ChecksumException.getChecksumInstance();
          }
          received[position] = this.field.subtract(received[position], errorMagnitudes[i3]);
        }
        return errorLocations.length;
      }
      /**
       *
       * @param ModulusPoly
       * @param a
       * @param ModulusPoly
       * @param b
       * @param int
       * @param R
       * @throws ChecksumException
       */
      runEuclideanAlgorithm(a4, b2, R3) {
        if (a4.getDegree() < b2.getDegree()) {
          let temp = a4;
          a4 = b2;
          b2 = temp;
        }
        let rLast = a4;
        let r2 = b2;
        let tLast = this.field.getZero();
        let t3 = this.field.getOne();
        while (r2.getDegree() >= Math.round(R3 / 2)) {
          let rLastLast = rLast;
          let tLastLast = tLast;
          rLast = r2;
          tLast = t3;
          if (rLast.isZero()) {
            throw ChecksumException.getChecksumInstance();
          }
          r2 = rLastLast;
          let q3 = this.field.getZero();
          let denominatorLeadingTerm = rLast.getCoefficient(rLast.getDegree());
          let dltInverse = this.field.inverse(denominatorLeadingTerm);
          while (r2.getDegree() >= rLast.getDegree() && !r2.isZero()) {
            let degreeDiff = r2.getDegree() - rLast.getDegree();
            let scale = this.field.multiply(r2.getCoefficient(r2.getDegree()), dltInverse);
            q3 = q3.add(this.field.buildMonomial(degreeDiff, scale));
            r2 = r2.subtract(rLast.multiplyByMonomial(degreeDiff, scale));
          }
          t3 = q3.multiply(tLast).subtract(tLastLast).negative();
        }
        let sigmaTildeAtZero = t3.getCoefficient(0);
        if (sigmaTildeAtZero === 0) {
          throw ChecksumException.getChecksumInstance();
        }
        let inverse = this.field.inverse(sigmaTildeAtZero);
        let sigma = t3.multiply(inverse);
        let omega = r2.multiply(inverse);
        return [sigma, omega];
      }
      /**
       *
       * @param errorLocator
       * @throws ChecksumException
       */
      findErrorLocations(errorLocator) {
        let numErrors = errorLocator.getDegree();
        let result = new Int32Array(numErrors);
        let e3 = 0;
        for (let i3 = 1; i3 < this.field.getSize() && e3 < numErrors; i3++) {
          if (errorLocator.evaluateAt(i3) === 0) {
            result[e3] = this.field.inverse(i3);
            e3++;
          }
        }
        if (e3 !== numErrors) {
          throw ChecksumException.getChecksumInstance();
        }
        return result;
      }
      findErrorMagnitudes(errorEvaluator, errorLocator, errorLocations) {
        let errorLocatorDegree = errorLocator.getDegree();
        let formalDerivativeCoefficients = new Int32Array(errorLocatorDegree);
        for (let i3 = 1; i3 <= errorLocatorDegree; i3++) {
          formalDerivativeCoefficients[errorLocatorDegree - i3] = this.field.multiply(i3, errorLocator.getCoefficient(i3));
        }
        let formalDerivative = new ModulusPoly(this.field, formalDerivativeCoefficients);
        let s4 = errorLocations.length;
        let result = new Int32Array(s4);
        for (let i3 = 0; i3 < s4; i3++) {
          let xiInverse = this.field.inverse(errorLocations[i3]);
          let numerator = this.field.subtract(0, errorEvaluator.evaluateAt(xiInverse));
          let denominator = this.field.inverse(formalDerivative.evaluateAt(xiInverse));
          result[i3] = this.field.multiply(numerator, denominator);
        }
        return result;
      }
    }
    class BoundingBox {
      constructor(image, topLeft, bottomLeft, topRight, bottomRight) {
        if (image instanceof BoundingBox) {
          this.constructor_2(image);
        } else {
          this.constructor_1(image, topLeft, bottomLeft, topRight, bottomRight);
        }
      }
      /**
       *
       * @param image
       * @param topLeft
       * @param bottomLeft
       * @param topRight
       * @param bottomRight
       *
       * @throws NotFoundException
       */
      constructor_1(image, topLeft, bottomLeft, topRight, bottomRight) {
        const leftUnspecified = topLeft == null || bottomLeft == null;
        const rightUnspecified = topRight == null || bottomRight == null;
        if (leftUnspecified && rightUnspecified) {
          throw new NotFoundException();
        }
        if (leftUnspecified) {
          topLeft = new ResultPoint(0, topRight.getY());
          bottomLeft = new ResultPoint(0, bottomRight.getY());
        } else if (rightUnspecified) {
          topRight = new ResultPoint(image.getWidth() - 1, topLeft.getY());
          bottomRight = new ResultPoint(image.getWidth() - 1, bottomLeft.getY());
        }
        this.image = image;
        this.topLeft = topLeft;
        this.bottomLeft = bottomLeft;
        this.topRight = topRight;
        this.bottomRight = bottomRight;
        this.minX = Math.trunc(Math.min(topLeft.getX(), bottomLeft.getX()));
        this.maxX = Math.trunc(Math.max(topRight.getX(), bottomRight.getX()));
        this.minY = Math.trunc(Math.min(topLeft.getY(), topRight.getY()));
        this.maxY = Math.trunc(Math.max(bottomLeft.getY(), bottomRight.getY()));
      }
      constructor_2(boundingBox) {
        this.image = boundingBox.image;
        this.topLeft = boundingBox.getTopLeft();
        this.bottomLeft = boundingBox.getBottomLeft();
        this.topRight = boundingBox.getTopRight();
        this.bottomRight = boundingBox.getBottomRight();
        this.minX = boundingBox.getMinX();
        this.maxX = boundingBox.getMaxX();
        this.minY = boundingBox.getMinY();
        this.maxY = boundingBox.getMaxY();
      }
      /**
       * @throws NotFoundException
       */
      static merge(leftBox, rightBox) {
        if (leftBox == null) {
          return rightBox;
        }
        if (rightBox == null) {
          return leftBox;
        }
        return new BoundingBox(leftBox.image, leftBox.topLeft, leftBox.bottomLeft, rightBox.topRight, rightBox.bottomRight);
      }
      /**
       * @throws NotFoundException
       */
      addMissingRows(missingStartRows, missingEndRows, isLeft) {
        let newTopLeft = this.topLeft;
        let newBottomLeft = this.bottomLeft;
        let newTopRight = this.topRight;
        let newBottomRight = this.bottomRight;
        if (missingStartRows > 0) {
          let top = isLeft ? this.topLeft : this.topRight;
          let newMinY = Math.trunc(top.getY() - missingStartRows);
          if (newMinY < 0) {
            newMinY = 0;
          }
          let newTop = new ResultPoint(top.getX(), newMinY);
          if (isLeft) {
            newTopLeft = newTop;
          } else {
            newTopRight = newTop;
          }
        }
        if (missingEndRows > 0) {
          let bottom = isLeft ? this.bottomLeft : this.bottomRight;
          let newMaxY = Math.trunc(bottom.getY() + missingEndRows);
          if (newMaxY >= this.image.getHeight()) {
            newMaxY = this.image.getHeight() - 1;
          }
          let newBottom = new ResultPoint(bottom.getX(), newMaxY);
          if (isLeft) {
            newBottomLeft = newBottom;
          } else {
            newBottomRight = newBottom;
          }
        }
        return new BoundingBox(this.image, newTopLeft, newBottomLeft, newTopRight, newBottomRight);
      }
      getMinX() {
        return this.minX;
      }
      getMaxX() {
        return this.maxX;
      }
      getMinY() {
        return this.minY;
      }
      getMaxY() {
        return this.maxY;
      }
      getTopLeft() {
        return this.topLeft;
      }
      getTopRight() {
        return this.topRight;
      }
      getBottomLeft() {
        return this.bottomLeft;
      }
      getBottomRight() {
        return this.bottomRight;
      }
    }
    class BarcodeMetadata {
      constructor(columnCount, rowCountUpperPart, rowCountLowerPart, errorCorrectionLevel) {
        this.columnCount = columnCount;
        this.errorCorrectionLevel = errorCorrectionLevel;
        this.rowCountUpperPart = rowCountUpperPart;
        this.rowCountLowerPart = rowCountLowerPart;
        this.rowCount = rowCountUpperPart + rowCountLowerPart;
      }
      getColumnCount() {
        return this.columnCount;
      }
      getErrorCorrectionLevel() {
        return this.errorCorrectionLevel;
      }
      getRowCount() {
        return this.rowCount;
      }
      getRowCountUpperPart() {
        return this.rowCountUpperPart;
      }
      getRowCountLowerPart() {
        return this.rowCountLowerPart;
      }
    }
    class Formatter {
      constructor() {
        this.buffer = "";
      }
      /**
       *
       * @see https://stackoverflow.com/a/13439711/4367683
       *
       * @param str
       * @param arr
       */
      static form(str, arr) {
        let i3 = -1;
        function callback(exp, p0, p1, p2, p3, p4) {
          if (exp === "%%")
            return "%";
          if (arr[++i3] === void 0)
            return void 0;
          exp = p2 ? parseInt(p2.substr(1)) : void 0;
          let base = p3 ? parseInt(p3.substr(1)) : void 0;
          let val;
          switch (p4) {
            case "s":
              val = arr[i3];
              break;
            case "c":
              val = arr[i3][0];
              break;
            case "f":
              val = parseFloat(arr[i3]).toFixed(exp);
              break;
            case "p":
              val = parseFloat(arr[i3]).toPrecision(exp);
              break;
            case "e":
              val = parseFloat(arr[i3]).toExponential(exp);
              break;
            case "x":
              val = parseInt(arr[i3]).toString(base ? base : 16);
              break;
            case "d":
              val = parseFloat(parseInt(arr[i3], base ? base : 10).toPrecision(exp)).toFixed(0);
              break;
          }
          val = typeof val === "object" ? JSON.stringify(val) : (+val).toString(base);
          let size2 = parseInt(p1);
          let ch2 = p1 && p1[0] + "" === "0" ? "0" : " ";
          while (val.length < size2)
            val = p0 !== void 0 ? val + ch2 : ch2 + val;
          return val;
        }
        let regex = /%(-)?(0?[0-9]+)?([.][0-9]+)?([#][0-9]+)?([scfpexd%])/g;
        return str.replace(regex, callback);
      }
      /**
       *
       * @param append The new string to append.
       * @param args Argumets values to be formated.
       */
      format(append, ...args) {
        this.buffer += Formatter.form(append, args);
      }
      /**
       * Returns the Formatter string value.
       */
      toString() {
        return this.buffer;
      }
    }
    class DetectionResultColumn {
      constructor(boundingBox) {
        this.boundingBox = new BoundingBox(boundingBox);
        this.codewords = new Array(boundingBox.getMaxY() - boundingBox.getMinY() + 1);
      }
      /*final*/
      getCodewordNearby(imageRow) {
        let codeword = this.getCodeword(imageRow);
        if (codeword != null) {
          return codeword;
        }
        for (let i3 = 1; i3 < DetectionResultColumn.MAX_NEARBY_DISTANCE; i3++) {
          let nearImageRow = this.imageRowToCodewordIndex(imageRow) - i3;
          if (nearImageRow >= 0) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
          nearImageRow = this.imageRowToCodewordIndex(imageRow) + i3;
          if (nearImageRow < this.codewords.length) {
            codeword = this.codewords[nearImageRow];
            if (codeword != null) {
              return codeword;
            }
          }
        }
        return null;
      }
      /*final int*/
      imageRowToCodewordIndex(imageRow) {
        return imageRow - this.boundingBox.getMinY();
      }
      /*final void*/
      setCodeword(imageRow, codeword) {
        this.codewords[this.imageRowToCodewordIndex(imageRow)] = codeword;
      }
      /*final*/
      getCodeword(imageRow) {
        return this.codewords[this.imageRowToCodewordIndex(imageRow)];
      }
      /*final*/
      getBoundingBox() {
        return this.boundingBox;
      }
      /*final*/
      getCodewords() {
        return this.codewords;
      }
      // @Override
      toString() {
        const formatter = new Formatter();
        let row = 0;
        for (const codeword of this.codewords) {
          if (codeword == null) {
            formatter.format("%3d:    |   %n", row++);
            continue;
          }
          formatter.format("%3d: %3d|%3d%n", row++, codeword.getRowNumber(), codeword.getValue());
        }
        return formatter.toString();
      }
    }
    DetectionResultColumn.MAX_NEARBY_DISTANCE = 5;
    class BarcodeValue {
      constructor() {
        this.values = /* @__PURE__ */ new Map();
      }
      /**
       * Add an occurrence of a value
       */
      setValue(value) {
        value = Math.trunc(value);
        let confidence = this.values.get(value);
        if (confidence == null) {
          confidence = 0;
        }
        confidence++;
        this.values.set(value, confidence);
      }
      /**
       * Determines the maximum occurrence of a set value and returns all values which were set with this occurrence.
       * @return an array of int, containing the values with the highest occurrence, or null, if no value was set
       */
      getValue() {
        let maxConfidence = -1;
        let result = new Array();
        for (const [key, value] of this.values.entries()) {
          const entry = {
            getKey: () => key,
            getValue: () => value
          };
          if (entry.getValue() > maxConfidence) {
            maxConfidence = entry.getValue();
            result = [];
            result.push(entry.getKey());
          } else if (entry.getValue() === maxConfidence) {
            result.push(entry.getKey());
          }
        }
        return PDF417Common.toIntArray(result);
      }
      getConfidence(value) {
        return this.values.get(value);
      }
    }
    class DetectionResultRowIndicatorColumn extends DetectionResultColumn {
      constructor(boundingBox, isLeft) {
        super(boundingBox);
        this._isLeft = isLeft;
      }
      setRowNumbers() {
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            codeword.setRowNumberAsRowIndicatorColumn();
          }
        }
      }
      // TODO implement properly
      // TODO maybe we should add missing codewords to store the correct row number to make
      // finding row numbers for other columns easier
      // use row height count to make detection of invalid row numbers more reliable
      adjustCompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let codewords = this.getCodewords();
        this.setRowNumbers();
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let barcodeRow = -1;
        let maxRowHeight = 1;
        let currentRowHeight = 0;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) {
            currentRowHeight++;
          } else if (rowDifference === 1) {
            maxRowHeight = Math.max(maxRowHeight, currentRowHeight);
            currentRowHeight = 1;
            barcodeRow = codeword.getRowNumber();
          } else if (rowDifference < 0 || codeword.getRowNumber() >= barcodeMetadata.getRowCount() || rowDifference > codewordsRow) {
            codewords[codewordsRow] = null;
          } else {
            let checkedRows;
            if (maxRowHeight > 2) {
              checkedRows = (maxRowHeight - 2) * rowDifference;
            } else {
              checkedRows = rowDifference;
            }
            let closePreviousCodewordFound = checkedRows >= codewordsRow;
            for (let i3 = 1; i3 <= checkedRows && !closePreviousCodewordFound; i3++) {
              closePreviousCodewordFound = codewords[codewordsRow - i3] != null;
            }
            if (closePreviousCodewordFound) {
              codewords[codewordsRow] = null;
            } else {
              barcodeRow = codeword.getRowNumber();
              currentRowHeight = 1;
            }
          }
        }
      }
      getRowHeights() {
        let barcodeMetadata = this.getBarcodeMetadata();
        if (barcodeMetadata == null) {
          return null;
        }
        this.adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata);
        let result = new Int32Array(barcodeMetadata.getRowCount());
        for (let codeword of this.getCodewords()) {
          if (codeword != null) {
            let rowNumber = codeword.getRowNumber();
            if (rowNumber >= result.length) {
              continue;
            }
            result[rowNumber]++;
          }
        }
        return result;
      }
      // TODO maybe we should add missing codewords to store the correct row number to make
      // finding row numbers for other columns easier
      // use row height count to make detection of invalid row numbers more reliable
      adjustIncompleteIndicatorColumnRowNumbers(barcodeMetadata) {
        let boundingBox = this.getBoundingBox();
        let top = this._isLeft ? boundingBox.getTopLeft() : boundingBox.getTopRight();
        let bottom = this._isLeft ? boundingBox.getBottomLeft() : boundingBox.getBottomRight();
        let firstRow = this.imageRowToCodewordIndex(Math.trunc(top.getY()));
        let lastRow = this.imageRowToCodewordIndex(Math.trunc(bottom.getY()));
        let codewords = this.getCodewords();
        let barcodeRow = -1;
        for (let codewordsRow = firstRow; codewordsRow < lastRow; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let codeword = codewords[codewordsRow];
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowDifference = codeword.getRowNumber() - barcodeRow;
          if (rowDifference === 0) ;
          else if (rowDifference === 1) {
            barcodeRow = codeword.getRowNumber();
          } else if (codeword.getRowNumber() >= barcodeMetadata.getRowCount()) {
            codewords[codewordsRow] = null;
          } else {
            barcodeRow = codeword.getRowNumber();
          }
        }
      }
      getBarcodeMetadata() {
        let codewords = this.getCodewords();
        let barcodeColumnCount = new BarcodeValue();
        let barcodeRowCountUpperPart = new BarcodeValue();
        let barcodeRowCountLowerPart = new BarcodeValue();
        let barcodeECLevel = new BarcodeValue();
        for (let codeword of codewords) {
          if (codeword == null) {
            continue;
          }
          codeword.setRowNumberAsRowIndicatorColumn();
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              barcodeRowCountUpperPart.setValue(rowIndicatorValue * 3 + 1);
              break;
            case 1:
              barcodeECLevel.setValue(rowIndicatorValue / 3);
              barcodeRowCountLowerPart.setValue(rowIndicatorValue % 3);
              break;
            case 2:
              barcodeColumnCount.setValue(rowIndicatorValue + 1);
              break;
          }
        }
        if (barcodeColumnCount.getValue().length === 0 || barcodeRowCountUpperPart.getValue().length === 0 || barcodeRowCountLowerPart.getValue().length === 0 || barcodeECLevel.getValue().length === 0 || barcodeColumnCount.getValue()[0] < 1 || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] < PDF417Common.MIN_ROWS_IN_BARCODE || barcodeRowCountUpperPart.getValue()[0] + barcodeRowCountLowerPart.getValue()[0] > PDF417Common.MAX_ROWS_IN_BARCODE) {
          return null;
        }
        let barcodeMetadata = new BarcodeMetadata(barcodeColumnCount.getValue()[0], barcodeRowCountUpperPart.getValue()[0], barcodeRowCountLowerPart.getValue()[0], barcodeECLevel.getValue()[0]);
        this.removeIncorrectCodewords(codewords, barcodeMetadata);
        return barcodeMetadata;
      }
      removeIncorrectCodewords(codewords, barcodeMetadata) {
        for (let codewordRow = 0; codewordRow < codewords.length; codewordRow++) {
          let codeword = codewords[codewordRow];
          if (codewords[codewordRow] == null) {
            continue;
          }
          let rowIndicatorValue = codeword.getValue() % 30;
          let codewordRowNumber = codeword.getRowNumber();
          if (codewordRowNumber > barcodeMetadata.getRowCount()) {
            codewords[codewordRow] = null;
            continue;
          }
          if (!this._isLeft) {
            codewordRowNumber += 2;
          }
          switch (codewordRowNumber % 3) {
            case 0:
              if (rowIndicatorValue * 3 + 1 !== barcodeMetadata.getRowCountUpperPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 1:
              if (Math.trunc(rowIndicatorValue / 3) !== barcodeMetadata.getErrorCorrectionLevel() || rowIndicatorValue % 3 !== barcodeMetadata.getRowCountLowerPart()) {
                codewords[codewordRow] = null;
              }
              break;
            case 2:
              if (rowIndicatorValue + 1 !== barcodeMetadata.getColumnCount()) {
                codewords[codewordRow] = null;
              }
              break;
          }
        }
      }
      isLeft() {
        return this._isLeft;
      }
      // @Override
      toString() {
        return "IsLeft: " + this._isLeft + "\n" + super.toString();
      }
    }
    class DetectionResult {
      constructor(barcodeMetadata, boundingBox) {
        this.ADJUST_ROW_NUMBER_SKIP = 2;
        this.barcodeMetadata = barcodeMetadata;
        this.barcodeColumnCount = barcodeMetadata.getColumnCount();
        this.boundingBox = boundingBox;
        this.detectionResultColumns = new Array(this.barcodeColumnCount + 2);
      }
      getDetectionResultColumns() {
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[0]);
        this.adjustIndicatorColumnRowNumbers(this.detectionResultColumns[this.barcodeColumnCount + 1]);
        let unadjustedCodewordCount = PDF417Common.MAX_CODEWORDS_IN_BARCODE;
        let previousUnadjustedCount;
        do {
          previousUnadjustedCount = unadjustedCodewordCount;
          unadjustedCodewordCount = this.adjustRowNumbersAndGetCount();
        } while (unadjustedCodewordCount > 0 && unadjustedCodewordCount < previousUnadjustedCount);
        return this.detectionResultColumns;
      }
      adjustIndicatorColumnRowNumbers(detectionResultColumn) {
        if (detectionResultColumn != null) {
          detectionResultColumn.adjustCompleteIndicatorColumnRowNumbers(this.barcodeMetadata);
        }
      }
      // TODO ensure that no detected codewords with unknown row number are left
      // we should be able to estimate the row height and use it as a hint for the row number
      // we should also fill the rows top to bottom and bottom to top
      /**
       * @return number of codewords which don't have a valid row number. Note that the count is not accurate as codewords
       * will be counted several times. It just serves as an indicator to see when we can stop adjusting row numbers
       */
      adjustRowNumbersAndGetCount() {
        let unadjustedCount = this.adjustRowNumbersByRow();
        if (unadjustedCount === 0) {
          return 0;
        }
        for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1; barcodeColumn++) {
          let codewords = this.detectionResultColumns[barcodeColumn].getCodewords();
          for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
            if (codewords[codewordsRow] == null) {
              continue;
            }
            if (!codewords[codewordsRow].hasValidRowNumber()) {
              this.adjustRowNumbers(barcodeColumn, codewordsRow, codewords);
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersByRow() {
        this.adjustRowNumbersFromBothRI();
        let unadjustedCount = this.adjustRowNumbersFromLRI();
        return unadjustedCount + this.adjustRowNumbersFromRRI();
      }
      adjustRowNumbersFromBothRI() {
        if (this.detectionResultColumns[0] == null || this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return;
        }
        let LRIcodewords = this.detectionResultColumns[0].getCodewords();
        let RRIcodewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < LRIcodewords.length; codewordsRow++) {
          if (LRIcodewords[codewordsRow] != null && RRIcodewords[codewordsRow] != null && LRIcodewords[codewordsRow].getRowNumber() === RRIcodewords[codewordsRow].getRowNumber()) {
            for (let barcodeColumn = 1; barcodeColumn <= this.barcodeColumnCount; barcodeColumn++) {
              let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
              if (codeword == null) {
                continue;
              }
              codeword.setRowNumber(LRIcodewords[codewordsRow].getRowNumber());
              if (!codeword.hasValidRowNumber()) {
                this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow] = null;
              }
            }
          }
        }
      }
      adjustRowNumbersFromRRI() {
        if (this.detectionResultColumns[this.barcodeColumnCount + 1] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[this.barcodeColumnCount + 1].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = this.barcodeColumnCount + 1; barcodeColumn > 0 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn--) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      adjustRowNumbersFromLRI() {
        if (this.detectionResultColumns[0] == null) {
          return 0;
        }
        let unadjustedCount = 0;
        let codewords = this.detectionResultColumns[0].getCodewords();
        for (let codewordsRow = 0; codewordsRow < codewords.length; codewordsRow++) {
          if (codewords[codewordsRow] == null) {
            continue;
          }
          let rowIndicatorRowNumber = codewords[codewordsRow].getRowNumber();
          let invalidRowCounts = 0;
          for (let barcodeColumn = 1; barcodeColumn < this.barcodeColumnCount + 1 && invalidRowCounts < this.ADJUST_ROW_NUMBER_SKIP; barcodeColumn++) {
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword != null) {
              invalidRowCounts = DetectionResult.adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword);
              if (!codeword.hasValidRowNumber()) {
                unadjustedCount++;
              }
            }
          }
        }
        return unadjustedCount;
      }
      static adjustRowNumberIfValid(rowIndicatorRowNumber, invalidRowCounts, codeword) {
        if (codeword == null) {
          return invalidRowCounts;
        }
        if (!codeword.hasValidRowNumber()) {
          if (codeword.isValidRowNumber(rowIndicatorRowNumber)) {
            codeword.setRowNumber(rowIndicatorRowNumber);
            invalidRowCounts = 0;
          } else {
            ++invalidRowCounts;
          }
        }
        return invalidRowCounts;
      }
      adjustRowNumbers(barcodeColumn, codewordsRow, codewords) {
        if (!this.detectionResultColumns[barcodeColumn - 1]) {
          return;
        }
        let codeword = codewords[codewordsRow];
        let previousColumnCodewords = this.detectionResultColumns[barcodeColumn - 1].getCodewords();
        let nextColumnCodewords = previousColumnCodewords;
        if (this.detectionResultColumns[barcodeColumn + 1] != null) {
          nextColumnCodewords = this.detectionResultColumns[barcodeColumn + 1].getCodewords();
        }
        let otherCodewords = new Array(14);
        otherCodewords[2] = previousColumnCodewords[codewordsRow];
        otherCodewords[3] = nextColumnCodewords[codewordsRow];
        if (codewordsRow > 0) {
          otherCodewords[0] = codewords[codewordsRow - 1];
          otherCodewords[4] = previousColumnCodewords[codewordsRow - 1];
          otherCodewords[5] = nextColumnCodewords[codewordsRow - 1];
        }
        if (codewordsRow > 1) {
          otherCodewords[8] = codewords[codewordsRow - 2];
          otherCodewords[10] = previousColumnCodewords[codewordsRow - 2];
          otherCodewords[11] = nextColumnCodewords[codewordsRow - 2];
        }
        if (codewordsRow < codewords.length - 1) {
          otherCodewords[1] = codewords[codewordsRow + 1];
          otherCodewords[6] = previousColumnCodewords[codewordsRow + 1];
          otherCodewords[7] = nextColumnCodewords[codewordsRow + 1];
        }
        if (codewordsRow < codewords.length - 2) {
          otherCodewords[9] = codewords[codewordsRow + 2];
          otherCodewords[12] = previousColumnCodewords[codewordsRow + 2];
          otherCodewords[13] = nextColumnCodewords[codewordsRow + 2];
        }
        for (let otherCodeword of otherCodewords) {
          if (DetectionResult.adjustRowNumber(codeword, otherCodeword)) {
            return;
          }
        }
      }
      /**
       * @return true, if row number was adjusted, false otherwise
       */
      static adjustRowNumber(codeword, otherCodeword) {
        if (otherCodeword == null) {
          return false;
        }
        if (otherCodeword.hasValidRowNumber() && otherCodeword.getBucket() === codeword.getBucket()) {
          codeword.setRowNumber(otherCodeword.getRowNumber());
          return true;
        }
        return false;
      }
      getBarcodeColumnCount() {
        return this.barcodeColumnCount;
      }
      getBarcodeRowCount() {
        return this.barcodeMetadata.getRowCount();
      }
      getBarcodeECLevel() {
        return this.barcodeMetadata.getErrorCorrectionLevel();
      }
      setBoundingBox(boundingBox) {
        this.boundingBox = boundingBox;
      }
      getBoundingBox() {
        return this.boundingBox;
      }
      setDetectionResultColumn(barcodeColumn, detectionResultColumn) {
        this.detectionResultColumns[barcodeColumn] = detectionResultColumn;
      }
      getDetectionResultColumn(barcodeColumn) {
        return this.detectionResultColumns[barcodeColumn];
      }
      // @Override
      toString() {
        let rowIndicatorColumn = this.detectionResultColumns[0];
        if (rowIndicatorColumn == null) {
          rowIndicatorColumn = this.detectionResultColumns[this.barcodeColumnCount + 1];
        }
        let formatter = new Formatter();
        for (let codewordsRow = 0; codewordsRow < rowIndicatorColumn.getCodewords().length; codewordsRow++) {
          formatter.format("CW %3d:", codewordsRow);
          for (let barcodeColumn = 0; barcodeColumn < this.barcodeColumnCount + 2; barcodeColumn++) {
            if (this.detectionResultColumns[barcodeColumn] == null) {
              formatter.format("    |   ");
              continue;
            }
            let codeword = this.detectionResultColumns[barcodeColumn].getCodewords()[codewordsRow];
            if (codeword == null) {
              formatter.format("    |   ");
              continue;
            }
            formatter.format(" %3d|%3d", codeword.getRowNumber(), codeword.getValue());
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    class Codeword {
      constructor(startX, endX, bucket, value) {
        this.rowNumber = Codeword.BARCODE_ROW_UNKNOWN;
        this.startX = Math.trunc(startX);
        this.endX = Math.trunc(endX);
        this.bucket = Math.trunc(bucket);
        this.value = Math.trunc(value);
      }
      hasValidRowNumber() {
        return this.isValidRowNumber(this.rowNumber);
      }
      isValidRowNumber(rowNumber) {
        return rowNumber !== Codeword.BARCODE_ROW_UNKNOWN && this.bucket === rowNumber % 3 * 3;
      }
      setRowNumberAsRowIndicatorColumn() {
        this.rowNumber = Math.trunc(Math.trunc(this.value / 30) * 3 + Math.trunc(this.bucket / 3));
      }
      getWidth() {
        return this.endX - this.startX;
      }
      getStartX() {
        return this.startX;
      }
      getEndX() {
        return this.endX;
      }
      getBucket() {
        return this.bucket;
      }
      getValue() {
        return this.value;
      }
      getRowNumber() {
        return this.rowNumber;
      }
      setRowNumber(rowNumber) {
        this.rowNumber = rowNumber;
      }
      //   @Override
      toString() {
        return this.rowNumber + "|" + this.value;
      }
    }
    Codeword.BARCODE_ROW_UNKNOWN = -1;
    class PDF417CodewordDecoder {
      /* @note
       * this action have to be performed before first use of class
       * - static constructor
       * working with 32bit float (based from Java logic)
      */
      static initialize() {
        for (let i3 = 0; i3 < PDF417Common.SYMBOL_TABLE.length; i3++) {
          let currentSymbol = PDF417Common.SYMBOL_TABLE[i3];
          let currentBit = currentSymbol & 1;
          for (let j2 = 0; j2 < PDF417Common.BARS_IN_MODULE; j2++) {
            let size2 = 0;
            while ((currentSymbol & 1) === currentBit) {
              size2 += 1;
              currentSymbol >>= 1;
            }
            currentBit = currentSymbol & 1;
            if (!PDF417CodewordDecoder.RATIOS_TABLE[i3]) {
              PDF417CodewordDecoder.RATIOS_TABLE[i3] = new Array(PDF417Common.BARS_IN_MODULE);
            }
            PDF417CodewordDecoder.RATIOS_TABLE[i3][PDF417Common.BARS_IN_MODULE - j2 - 1] = Math.fround(size2 / PDF417Common.MODULES_IN_CODEWORD);
          }
        }
        this.bSymbolTableReady = true;
      }
      static getDecodedValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getDecodedCodewordValue(PDF417CodewordDecoder.sampleBitCounts(moduleBitCount));
        if (decodedValue !== -1) {
          return decodedValue;
        }
        return PDF417CodewordDecoder.getClosestDecodedValue(moduleBitCount);
      }
      static sampleBitCounts(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let result = new Int32Array(PDF417Common.BARS_IN_MODULE);
        let bitCountIndex = 0;
        let sumPreviousBits = 0;
        for (let i3 = 0; i3 < PDF417Common.MODULES_IN_CODEWORD; i3++) {
          let sampleIndex = bitCountSum / (2 * PDF417Common.MODULES_IN_CODEWORD) + i3 * bitCountSum / PDF417Common.MODULES_IN_CODEWORD;
          if (sumPreviousBits + moduleBitCount[bitCountIndex] <= sampleIndex) {
            sumPreviousBits += moduleBitCount[bitCountIndex];
            bitCountIndex++;
          }
          result[bitCountIndex]++;
        }
        return result;
      }
      static getDecodedCodewordValue(moduleBitCount) {
        let decodedValue = PDF417CodewordDecoder.getBitValue(moduleBitCount);
        return PDF417Common.getCodeword(decodedValue) === -1 ? -1 : decodedValue;
      }
      static getBitValue(moduleBitCount) {
        let result = (
          /*long*/
          0
        );
        for (let i3 = 0; i3 < moduleBitCount.length; i3++) {
          for (let bit = 0; bit < moduleBitCount[i3]; bit++) {
            result = result << 1 | (i3 % 2 === 0 ? 1 : 0);
          }
        }
        return Math.trunc(result);
      }
      // working with 32bit float (as in Java)
      static getClosestDecodedValue(moduleBitCount) {
        let bitCountSum = MathUtils.sum(moduleBitCount);
        let bitCountRatios = new Array(PDF417Common.BARS_IN_MODULE);
        if (bitCountSum > 1) {
          for (let i3 = 0; i3 < bitCountRatios.length; i3++) {
            bitCountRatios[i3] = Math.fround(moduleBitCount[i3] / bitCountSum);
          }
        }
        let bestMatchError = Float.MAX_VALUE;
        let bestMatch = -1;
        if (!this.bSymbolTableReady) {
          PDF417CodewordDecoder.initialize();
        }
        for (let j2 = 0; j2 < PDF417CodewordDecoder.RATIOS_TABLE.length; j2++) {
          let error = 0;
          let ratioTableRow = PDF417CodewordDecoder.RATIOS_TABLE[j2];
          for (let k3 = 0; k3 < PDF417Common.BARS_IN_MODULE; k3++) {
            let diff = Math.fround(ratioTableRow[k3] - bitCountRatios[k3]);
            error += Math.fround(diff * diff);
            if (error >= bestMatchError) {
              break;
            }
          }
          if (error < bestMatchError) {
            bestMatchError = error;
            bestMatch = PDF417Common.SYMBOL_TABLE[j2];
          }
        }
        return bestMatch;
      }
    }
    PDF417CodewordDecoder.bSymbolTableReady = false;
    PDF417CodewordDecoder.RATIOS_TABLE = new Array(PDF417Common.SYMBOL_TABLE.length).map((x3) => new Array(PDF417Common.BARS_IN_MODULE));
    class PDF417ResultMetadata {
      constructor() {
        this.segmentCount = -1;
        this.fileSize = -1;
        this.timestamp = -1;
        this.checksum = -1;
      }
      /**
       * The Segment ID represents the segment of the whole file distributed over different symbols.
       *
       * @return File segment index
       */
      getSegmentIndex() {
        return this.segmentIndex;
      }
      setSegmentIndex(segmentIndex) {
        this.segmentIndex = segmentIndex;
      }
      /**
       * Is the same for each related PDF417 symbol
       *
       * @return File ID
       */
      getFileId() {
        return this.fileId;
      }
      setFileId(fileId) {
        this.fileId = fileId;
      }
      /**
       * @return always null
       * @deprecated use dedicated already parsed fields
       */
      //   @Deprecated
      getOptionalData() {
        return this.optionalData;
      }
      /**
       * @param optionalData old optional data format as int array
       * @deprecated parse and use new fields
       */
      //   @Deprecated
      setOptionalData(optionalData) {
        this.optionalData = optionalData;
      }
      /**
       * @return true if it is the last segment
       */
      isLastSegment() {
        return this.lastSegment;
      }
      setLastSegment(lastSegment) {
        this.lastSegment = lastSegment;
      }
      /**
       * @return count of segments, -1 if not set
       */
      getSegmentCount() {
        return this.segmentCount;
      }
      setSegmentCount(segmentCount) {
        this.segmentCount = segmentCount;
      }
      getSender() {
        return this.sender || null;
      }
      setSender(sender) {
        this.sender = sender;
      }
      getAddressee() {
        return this.addressee || null;
      }
      setAddressee(addressee) {
        this.addressee = addressee;
      }
      /**
       * Filename of the encoded file
       *
       * @return filename
       */
      getFileName() {
        return this.fileName;
      }
      setFileName(fileName) {
        this.fileName = fileName;
      }
      /**
       * filesize in bytes of the encoded file
       *
       * @return filesize in bytes, -1 if not set
       */
      getFileSize() {
        return this.fileSize;
      }
      setFileSize(fileSize) {
        this.fileSize = fileSize;
      }
      /**
       * 16-bit CRC checksum using CCITT-16
       *
       * @return crc checksum, -1 if not set
       */
      getChecksum() {
        return this.checksum;
      }
      setChecksum(checksum) {
        this.checksum = checksum;
      }
      /**
       * unix epock timestamp, elapsed seconds since 1970-01-01
       *
       * @return elapsed seconds, -1 if not set
       */
      getTimestamp() {
        return this.timestamp;
      }
      setTimestamp(timestamp) {
        this.timestamp = timestamp;
      }
    }
    class Long {
      /**
       * Parses a string to a number, since JS has no really Int64.
       *
       * @param num Numeric string.
       * @param radix Destination radix.
       */
      static parseLong(num, radix = void 0) {
        return parseInt(num, radix);
      }
    }
    class NullPointerException extends Exception {
    }
    NullPointerException.kind = "NullPointerException";
    class OutputStream {
      /**
       * Writes <code>b.length</code> bytes from the specified byte array
       * to this output stream. The general contract for <code>write(b)</code>
       * is that it should have exactly the same effect as the call
       * <code>write(b, 0, b.length)</code>.
       *
       * @param      b   the data.
       * @exception  IOException  if an I/O error occurs.
       * @see        java.io.OutputStream#write(byte[], int, int)
       */
      writeBytes(b2) {
        this.writeBytesOffset(b2, 0, b2.length);
      }
      /**
       * Writes <code>len</code> bytes from the specified byte array
       * starting at offset <code>off</code> to this output stream.
       * The general contract for <code>write(b, off, len)</code> is that
       * some of the bytes in the array <code>b</code> are written to the
       * output stream in order; element <code>b[off]</code> is the first
       * byte written and <code>b[off+len-1]</code> is the last byte written
       * by this operation.
       * <p>
       * The <code>write</code> method of <code>OutputStream</code> calls
       * the write method of one argument on each of the bytes to be
       * written out. Subclasses are encouraged to override this method and
       * provide a more efficient implementation.
       * <p>
       * If <code>b</code> is <code>null</code>, a
       * <code>NullPointerException</code> is thrown.
       * <p>
       * If <code>off</code> is negative, or <code>len</code> is negative, or
       * <code>off+len</code> is greater than the length of the array
       * <code>b</code>, then an <tt>IndexOutOfBoundsException</tt> is thrown.
       *
       * @param      b     the data.
       * @param      off   the start offset in the data.
       * @param      len   the number of bytes to write.
       * @exception  IOException  if an I/O error occurs. In particular,
       *             an <code>IOException</code> is thrown if the output
       *             stream is closed.
       */
      writeBytesOffset(b2, off, len) {
        if (b2 == null) {
          throw new NullPointerException();
        } else if (off < 0 || off > b2.length || len < 0 || off + len > b2.length || off + len < 0) {
          throw new IndexOutOfBoundsException();
        } else if (len === 0) {
          return;
        }
        for (let i3 = 0; i3 < len; i3++) {
          this.write(b2[off + i3]);
        }
      }
      /**
       * Flushes this output stream and forces any buffered output bytes
       * to be written out. The general contract of <code>flush</code> is
       * that calling it is an indication that, if any bytes previously
       * written have been buffered by the implementation of the output
       * stream, such bytes should immediately be written to their
       * intended destination.
       * <p>
       * If the intended destination of this stream is an abstraction provided by
       * the underlying operating system, for example a file, then flushing the
       * stream guarantees only that bytes previously written to the stream are
       * passed to the operating system for writing; it does not guarantee that
       * they are actually written to a physical device such as a disk drive.
       * <p>
       * The <code>flush</code> method of <code>OutputStream</code> does nothing.
       *
       * @exception  IOException  if an I/O error occurs.
       */
      flush() {
      }
      /**
       * Closes this output stream and releases any system resources
       * associated with this stream. The general contract of <code>close</code>
       * is that it closes the output stream. A closed stream cannot perform
       * output operations and cannot be reopened.
       * <p>
       * The <code>close</code> method of <code>OutputStream</code> does nothing.
       *
       * @exception  IOException  if an I/O error occurs.
       */
      close() {
      }
    }
    class OutOfMemoryError extends Exception {
    }
    class ByteArrayOutputStream extends OutputStream {
      /**
       * Creates a new byte array output stream. The buffer capacity is
       * initially 32 bytes, though its size increases if necessary.
       */
      // public constructor() {
      //     this(32);
      // }
      /**
       * Creates a new byte array output stream, with a buffer capacity of
       * the specified size, in bytes.
       *
       * @param   size   the initial size.
       * @exception  IllegalArgumentException if size is negative.
       */
      constructor(size2 = 32) {
        super();
        this.count = 0;
        if (size2 < 0) {
          throw new IllegalArgumentException("Negative initial size: " + size2);
        }
        this.buf = new Uint8Array(size2);
      }
      /**
       * Increases the capacity if necessary to ensure that it can hold
       * at least the number of elements specified by the minimum
       * capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       * @throws OutOfMemoryError if {@code minCapacity < 0}.  This is
       * interpreted as a request for the unsatisfiably large capacity
       * {@code (long) Integer.MAX_VALUE + (minCapacity - Integer.MAX_VALUE)}.
       */
      ensureCapacity(minCapacity) {
        if (minCapacity - this.buf.length > 0)
          this.grow(minCapacity);
      }
      /**
       * Increases the capacity to ensure that it can hold at least the
       * number of elements specified by the minimum capacity argument.
       *
       * @param minCapacity the desired minimum capacity
       */
      grow(minCapacity) {
        let oldCapacity = this.buf.length;
        let newCapacity = oldCapacity << 1;
        if (newCapacity - minCapacity < 0)
          newCapacity = minCapacity;
        if (newCapacity < 0) {
          if (minCapacity < 0)
            throw new OutOfMemoryError();
          newCapacity = Integer.MAX_VALUE;
        }
        this.buf = Arrays.copyOfUint8Array(this.buf, newCapacity);
      }
      /**
       * Writes the specified byte to this byte array output stream.
       *
       * @param   b   the byte to be written.
       */
      write(b2) {
        this.ensureCapacity(this.count + 1);
        this.buf[this.count] = /*(byte)*/
        b2;
        this.count += 1;
      }
      /**
       * Writes <code>len</code> bytes from the specified byte array
       * starting at offset <code>off</code> to this byte array output stream.
       *
       * @param   b     the data.
       * @param   off   the start offset in the data.
       * @param   len   the number of bytes to write.
       */
      writeBytesOffset(b2, off, len) {
        if (off < 0 || off > b2.length || len < 0 || off + len - b2.length > 0) {
          throw new IndexOutOfBoundsException();
        }
        this.ensureCapacity(this.count + len);
        System.arraycopy(b2, off, this.buf, this.count, len);
        this.count += len;
      }
      /**
       * Writes the complete contents of this byte array output stream to
       * the specified output stream argument, as if by calling the output
       * stream's write method using <code>out.write(buf, 0, count)</code>.
       *
       * @param      out   the output stream to which to write the data.
       * @exception  IOException  if an I/O error occurs.
       */
      writeTo(out) {
        out.writeBytesOffset(this.buf, 0, this.count);
      }
      /**
       * Resets the <code>count</code> field of this byte array output
       * stream to zero, so that all currently accumulated output in the
       * output stream is discarded. The output stream can be used again,
       * reusing the already allocated buffer space.
       *
       * @see     java.io.ByteArrayInputStream#count
       */
      reset() {
        this.count = 0;
      }
      /**
       * Creates a newly allocated byte array. Its size is the current
       * size of this output stream and the valid contents of the buffer
       * have been copied into it.
       *
       * @return  the current contents of this output stream, as a byte array.
       * @see     java.io.ByteArrayOutputStream#size()
       */
      toByteArray() {
        return Arrays.copyOfUint8Array(this.buf, this.count);
      }
      /**
       * Returns the current size of the buffer.
       *
       * @return  the value of the <code>count</code> field, which is the number
       *          of valid bytes in this output stream.
       * @see     java.io.ByteArrayOutputStream#count
       */
      size() {
        return this.count;
      }
      toString(param) {
        if (!param) {
          return this.toString_void();
        }
        if (typeof param === "string") {
          return this.toString_string(param);
        }
        return this.toString_number(param);
      }
      /**
       * Converts the buffer's contents into a string decoding bytes using the
       * platform's default character set. The length of the new <tt>String</tt>
       * is a function of the character set, and hence may not be equal to the
       * size of the buffer.
       *
       * <p> This method always replaces malformed-input and unmappable-character
       * sequences with the default replacement string for the platform's
       * default character set. The {@linkplain java.nio.charset.CharsetDecoder}
       * class should be used when more control over the decoding process is
       * required.
       *
       * @return String decoded from the buffer's contents.
       * @since  JDK1.1
       */
      toString_void() {
        return new String(
          this.buf
          /*, 0, this.count*/
        ).toString();
      }
      /**
       * Converts the buffer's contents into a string by decoding the bytes using
       * the specified {@link java.nio.charset.Charset charsetName}. The length of
       * the new <tt>String</tt> is a function of the charset, and hence may not be
       * equal to the length of the byte array.
       *
       * <p> This method always replaces malformed-input and unmappable-character
       * sequences with this charset's default replacement string. The {@link
       * java.nio.charset.CharsetDecoder} class should be used when more control
       * over the decoding process is required.
       *
       * @param  charsetName  the name of a supported
       *              {@linkplain java.nio.charset.Charset </code>charset<code>}
       * @return String decoded from the buffer's contents.
       * @exception  UnsupportedEncodingException
       *             If the named charset is not supported
       * @since   JDK1.1
       */
      toString_string(charsetName) {
        return new String(
          this.buf
          /*, 0, this.count, charsetName*/
        ).toString();
      }
      /**
       * Creates a newly allocated string. Its size is the current size of
       * the output stream and the valid contents of the buffer have been
       * copied into it. Each character <i>c</i> in the resulting string is
       * constructed from the corresponding element <i>b</i> in the byte
       * array such that:
       * <blockquote><pre>
       *     c == (char)(((hibyte &amp; 0xff) &lt;&lt; 8) | (b &amp; 0xff))
       * </pre></blockquote>
       *
       * @deprecated This method does not properly convert bytes into characters.
       * As of JDK&nbsp;1.1, the preferred way to do this is via the
       * <code>toString(String enc)</code> method, which takes an encoding-name
       * argument, or the <code>toString()</code> method, which uses the
       * platform's default character encoding.
       *
       * @param      hibyte    the high byte of each resulting Unicode character.
       * @return     the current contents of the output stream, as a string.
       * @see        java.io.ByteArrayOutputStream#size()
       * @see        java.io.ByteArrayOutputStream#toString(String)
       * @see        java.io.ByteArrayOutputStream#toString()
       */
      // @Deprecated
      toString_number(hibyte) {
        return new String(
          this.buf
          /*, hibyte, 0, this.count*/
        ).toString();
      }
      /**
       * Closing a <tt>ByteArrayOutputStream</tt> has no effect. The methods in
       * this class can be called after the stream has been closed without
       * generating an <tt>IOException</tt>.
       * <p>
       *
       * @throws IOException
       */
      close() {
      }
    }
    var Mode$2;
    (function(Mode2) {
      Mode2[Mode2["ALPHA"] = 0] = "ALPHA";
      Mode2[Mode2["LOWER"] = 1] = "LOWER";
      Mode2[Mode2["MIXED"] = 2] = "MIXED";
      Mode2[Mode2["PUNCT"] = 3] = "PUNCT";
      Mode2[Mode2["ALPHA_SHIFT"] = 4] = "ALPHA_SHIFT";
      Mode2[Mode2["PUNCT_SHIFT"] = 5] = "PUNCT_SHIFT";
    })(Mode$2 || (Mode$2 = {}));
    function getBigIntConstructor() {
      if (typeof window !== "undefined") {
        return window["BigInt"] || null;
      }
      if (typeof commonjsGlobal !== "undefined") {
        return commonjsGlobal["BigInt"] || null;
      }
      if (typeof self !== "undefined") {
        return self["BigInt"] || null;
      }
      throw new Error("Can't search globals for BigInt!");
    }
    let BigInteger;
    function createBigInt(num) {
      if (typeof BigInteger === "undefined") {
        BigInteger = getBigIntConstructor();
      }
      if (BigInteger === null) {
        throw new Error("BigInt is not supported!");
      }
      return BigInteger(num);
    }
    function getEXP900() {
      let EXP900 = [];
      EXP900[0] = createBigInt(1);
      let nineHundred = createBigInt(900);
      EXP900[1] = nineHundred;
      for (let i3 = 2; i3 < 16; i3++) {
        EXP900[i3] = EXP900[i3 - 1] * nineHundred;
      }
      return EXP900;
    }
    class DecodedBitStreamParser$2 {
      //   private DecodedBitStreamParser() {
      // }
      /**
       *
       * @param codewords
       * @param ecLevel
       *
       * @throws FormatException
       */
      static decode(codewords, ecLevel) {
        let result = new StringBuilder("");
        let encoding = CharacterSetECI.ISO8859_1;
        result.enableDecoding(encoding);
        let codeIndex = 1;
        let code = codewords[codeIndex++];
        let resultMetadata = new PDF417ResultMetadata();
        while (codeIndex < codewords[0]) {
          switch (code) {
            case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              codeIndex = DecodedBitStreamParser$2.byteCompaction(code, codewords, encoding, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
              result.append(
                /*(char)*/
                codewords[codeIndex++]
              );
              break;
            case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex, result);
              break;
            case DecodedBitStreamParser$2.ECI_CHARSET:
              CharacterSetECI.getCharacterSetECIByValue(codewords[codeIndex++]);
              break;
            case DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE:
              codeIndex += 2;
              break;
            case DecodedBitStreamParser$2.ECI_USER_DEFINED:
              codeIndex++;
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              codeIndex = DecodedBitStreamParser$2.decodeMacroBlock(codewords, codeIndex, resultMetadata);
              break;
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              throw new FormatException();
            default:
              codeIndex--;
              codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, result);
              break;
          }
          if (codeIndex < codewords.length) {
            code = codewords[codeIndex++];
          } else {
            throw FormatException.getFormatInstance();
          }
        }
        if (result.length() === 0) {
          throw FormatException.getFormatInstance();
        }
        let decoderResult = new DecoderResult(null, result.toString(), null, ecLevel);
        decoderResult.setOther(resultMetadata);
        return decoderResult;
      }
      /**
       *
       * @param int
       * @param param1
       * @param codewords
       * @param int
       * @param codeIndex
       * @param PDF417ResultMetadata
       * @param resultMetadata
       *
       * @throws FormatException
       */
      // @SuppressWarnings("deprecation")
      static decodeMacroBlock(codewords, codeIndex, resultMetadata) {
        if (codeIndex + DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS > codewords[0]) {
          throw FormatException.getFormatInstance();
        }
        let segmentIndexArray = new Int32Array(DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS);
        for (let i3 = 0; i3 < DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS; i3++, codeIndex++) {
          segmentIndexArray[i3] = codewords[codeIndex];
        }
        resultMetadata.setSegmentIndex(Integer.parseInt(DecodedBitStreamParser$2.decodeBase900toBase10(segmentIndexArray, DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS)));
        let fileId = new StringBuilder();
        codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex, fileId);
        resultMetadata.setFileId(fileId.toString());
        let optionalFieldsStart = -1;
        if (codewords[codeIndex] === DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD) {
          optionalFieldsStart = codeIndex + 1;
        }
        while (codeIndex < codewords[0]) {
          switch (codewords[codeIndex]) {
            case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              codeIndex++;
              switch (codewords[codeIndex]) {
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME:
                  let fileName = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, fileName);
                  resultMetadata.setFileName(fileName.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER:
                  let sender = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, sender);
                  resultMetadata.setSender(sender.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE:
                  let addressee = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.textCompaction(codewords, codeIndex + 1, addressee);
                  resultMetadata.setAddressee(addressee.toString());
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT:
                  let segmentCount = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, segmentCount);
                  resultMetadata.setSegmentCount(Integer.parseInt(segmentCount.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP:
                  let timestamp = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, timestamp);
                  resultMetadata.setTimestamp(Long.parseLong(timestamp.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM:
                  let checksum = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, checksum);
                  resultMetadata.setChecksum(Integer.parseInt(checksum.toString()));
                  break;
                case DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE:
                  let fileSize = new StringBuilder();
                  codeIndex = DecodedBitStreamParser$2.numericCompaction(codewords, codeIndex + 1, fileSize);
                  resultMetadata.setFileSize(Long.parseLong(fileSize.toString()));
                  break;
                default:
                  throw FormatException.getFormatInstance();
              }
              break;
            case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
              codeIndex++;
              resultMetadata.setLastSegment(true);
              break;
            default:
              throw FormatException.getFormatInstance();
          }
        }
        if (optionalFieldsStart !== -1) {
          let optionalFieldsLength = codeIndex - optionalFieldsStart;
          if (resultMetadata.isLastSegment()) {
            optionalFieldsLength--;
          }
          resultMetadata.setOptionalData(Arrays.copyOfRange(codewords, optionalFieldsStart, optionalFieldsStart + optionalFieldsLength));
        }
        return codeIndex;
      }
      /**
       * Text Compaction mode (see 5.4.1.5) permits all printable ASCII characters to be
       * encoded, i.e. values 32 - 126 inclusive in accordance with ISO/IEC 646 (IRV), as
       * well as selected control characters.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      static textCompaction(codewords, codeIndex, result) {
        let textCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let byteCompactionData = new Int32Array((codewords[0] - codeIndex) * 2);
        let index2 = 0;
        let end = false;
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            textCompactionData[index2] = code / 30;
            textCompactionData[index2 + 1] = code % 30;
            index2 += 2;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                textCompactionData[index2++] = DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH;
                break;
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
              case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                textCompactionData[index2] = DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
                code = codewords[codeIndex++];
                byteCompactionData[index2] = code;
                index2++;
                break;
            }
          }
        }
        DecodedBitStreamParser$2.decodeTextCompaction(textCompactionData, byteCompactionData, index2, result);
        return codeIndex;
      }
      /**
       * The Text Compaction mode includes all the printable ASCII characters
       * (i.e. values from 32 to 126) and three ASCII control characters: HT or tab
       * (9: e), LF or line feed (10: e), and CR or carriage
       * return (13: e). The Text Compaction mode also includes various latch
       * and shift characters which are used exclusively within the mode. The Text
       * Compaction mode encodes up to 2 characters per codeword. The compaction rules
       * for converting data into PDF417 codewords are defined in 5.4.2.2. The sub-mode
       * switches are defined in 5.4.2.3.
       *
       * @param textCompactionData The text compaction data.
       * @param byteCompactionData The byte compaction data if there
       *                           was a mode shift.
       * @param length             The size of the text compaction and byte compaction data.
       * @param result             The decoded data is appended to the result.
       */
      static decodeTextCompaction(textCompactionData, byteCompactionData, length, result) {
        let subMode = Mode$2.ALPHA;
        let priorToShiftMode = Mode$2.ALPHA;
        let i3 = 0;
        while (i3 < length) {
          let subModeCh = textCompactionData[i3];
          let ch2 = (
            /*char*/
            ""
          );
          switch (subMode) {
            case Mode$2.ALPHA:
              if (subModeCh < 26) {
                ch2 = /*(char)('A' + subModeCh) */
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch2 = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i3]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.LOWER:
              if (subModeCh < 26) {
                ch2 = /*(char)('a' + subModeCh)*/
                String.fromCharCode(97 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch2 = " ";
                    break;
                  case DecodedBitStreamParser$2.AS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.ALPHA_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.ML:
                    subMode = Mode$2.MIXED;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i3]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.MIXED:
              if (subModeCh < DecodedBitStreamParser$2.PL) {
                ch2 = DecodedBitStreamParser$2.MIXED_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PL:
                    subMode = Mode$2.PUNCT;
                    break;
                  case 26:
                    ch2 = " ";
                    break;
                  case DecodedBitStreamParser$2.LL:
                    subMode = Mode$2.LOWER;
                    break;
                  case DecodedBitStreamParser$2.AL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.PS:
                    priorToShiftMode = subMode;
                    subMode = Mode$2.PUNCT_SHIFT;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i3]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT:
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch2 = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i3]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.ALPHA_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < 26) {
                ch2 = /*(char)('A' + subModeCh)*/
                String.fromCharCode(65 + subModeCh);
              } else {
                switch (subModeCh) {
                  case 26:
                    ch2 = " ";
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
            case Mode$2.PUNCT_SHIFT:
              subMode = priorToShiftMode;
              if (subModeCh < DecodedBitStreamParser$2.PAL) {
                ch2 = DecodedBitStreamParser$2.PUNCT_CHARS[subModeCh];
              } else {
                switch (subModeCh) {
                  case DecodedBitStreamParser$2.PAL:
                    subMode = Mode$2.ALPHA;
                    break;
                  case DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE:
                    result.append(
                      /*(char)*/
                      byteCompactionData[i3]
                    );
                    break;
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                    subMode = Mode$2.ALPHA;
                    break;
                }
              }
              break;
          }
          if (ch2 !== "") {
            result.append(ch2);
          }
          i3++;
        }
      }
      /**
       * Byte Compaction mode (see 5.4.3) permits all 256 possible 8-bit byte values to be encoded.
       * This includes all ASCII characters value 0 to 127 inclusive and provides for international
       * character set support.
       *
       * @param mode      The byte compaction mode i.e. 901 or 924
       * @param codewords The array of codewords (data + error)
       * @param encoding  Currently active character encoding
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       */
      static byteCompaction(mode, codewords, encoding, codeIndex, result) {
        let decodedBytes = new ByteArrayOutputStream();
        let count2 = 0;
        let value = (
          /*long*/
          0
        );
        let end = false;
        switch (mode) {
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
            let byteCompactedCodewords = new Int32Array(6);
            let nextCode = codewords[codeIndex++];
            while (codeIndex < codewords[0] && !end) {
              byteCompactedCodewords[count2++] = nextCode;
              value = 900 * value + nextCode;
              nextCode = codewords[codeIndex++];
              switch (nextCode) {
                case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                  codeIndex--;
                  end = true;
                  break;
                default:
                  if (count2 % 5 === 0 && count2 > 0) {
                    for (let j2 = 0; j2 < 6; ++j2) {
                      decodedBytes.write(
                        /*(byte)*/
                        Number(createBigInt(value) >> createBigInt(8 * (5 - j2)))
                      );
                    }
                    value = 0;
                    count2 = 0;
                  }
                  break;
              }
            }
            if (codeIndex === codewords[0] && nextCode < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
              byteCompactedCodewords[count2++] = nextCode;
            }
            for (let i3 = 0; i3 < count2; i3++) {
              decodedBytes.write(
                /*(byte)*/
                byteCompactedCodewords[i3]
              );
            }
            break;
          case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
            while (codeIndex < codewords[0] && !end) {
              let code = codewords[codeIndex++];
              if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
                count2++;
                value = 900 * value + code;
              } else {
                switch (code) {
                  case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH:
                  case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
                  case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
                  case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                    codeIndex--;
                    end = true;
                    break;
                }
              }
              if (count2 % 5 === 0 && count2 > 0) {
                for (let j2 = 0; j2 < 6; ++j2) {
                  decodedBytes.write(
                    /*(byte)*/
                    Number(createBigInt(value) >> createBigInt(8 * (5 - j2)))
                  );
                }
                value = 0;
                count2 = 0;
              }
            }
            break;
        }
        result.append(StringEncoding.decode(decodedBytes.toByteArray(), encoding));
        return codeIndex;
      }
      /**
       * Numeric Compaction mode (see 5.4.4) permits efficient encoding of numeric data strings.
       *
       * @param codewords The array of codewords (data + error)
       * @param codeIndex The current index into the codeword array.
       * @param result    The decoded data is appended to the result.
       * @return The next index into the codeword array.
       *
       * @throws FormatException
       */
      static numericCompaction(codewords, codeIndex, result) {
        let count2 = 0;
        let end = false;
        let numericCodewords = new Int32Array(DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS);
        while (codeIndex < codewords[0] && !end) {
          let code = codewords[codeIndex++];
          if (codeIndex === codewords[0]) {
            end = true;
          }
          if (code < DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH) {
            numericCodewords[count2] = code;
            count2++;
          } else {
            switch (code) {
              case DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH:
              case DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK:
              case DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD:
              case DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR:
                codeIndex--;
                end = true;
                break;
            }
          }
          if ((count2 % DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS === 0 || code === DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH || end) && count2 > 0) {
            result.append(DecodedBitStreamParser$2.decodeBase900toBase10(numericCodewords, count2));
            count2 = 0;
          }
        }
        return codeIndex;
      }
      /**
       * Convert a list of Numeric Compacted codewords from Base 900 to Base 10.
       *
       * @param codewords The array of codewords
       * @param count     The number of codewords
       * @return The decoded string representing the Numeric data.
       *
       * EXAMPLE
       * Encode the fifteen digit numeric string 000213298174000
       * Prefix the numeric string with a 1 and set the initial value of
       * t = 1 000 213 298 174 000
       * Calculate codeword 0
       * d0 = 1 000 213 298 174 000 mod 900 = 200
       *
       * t = 1 000 213 298 174 000 div 900 = 1 111 348 109 082
       * Calculate codeword 1
       * d1 = 1 111 348 109 082 mod 900 = 282
       *
       * t = 1 111 348 109 082 div 900 = 1 234 831 232
       * Calculate codeword 2
       * d2 = 1 234 831 232 mod 900 = 632
       *
       * t = 1 234 831 232 div 900 = 1 372 034
       * Calculate codeword 3
       * d3 = 1 372 034 mod 900 = 434
       *
       * t = 1 372 034 div 900 = 1 524
       * Calculate codeword 4
       * d4 = 1 524 mod 900 = 624
       *
       * t = 1 524 div 900 = 1
       * Calculate codeword 5
       * d5 = 1 mod 900 = 1
       * t = 1 div 900 = 0
       * Codeword sequence is: 1, 624, 434, 632, 282, 200
       *
       * Decode the above codewords involves
       *   1 x 900 power of 5 + 624 x 900 power of 4 + 434 x 900 power of 3 +
       * 632 x 900 power of 2 + 282 x 900 power of 1 + 200 x 900 power of 0 = 1000213298174000
       *
       * Remove leading 1 =>  Result is 000213298174000
       *
       * @throws FormatException
       */
      static decodeBase900toBase10(codewords, count2) {
        let result = createBigInt(0);
        for (let i3 = 0; i3 < count2; i3++) {
          result += DecodedBitStreamParser$2.EXP900[count2 - i3 - 1] * createBigInt(codewords[i3]);
        }
        let resultString = result.toString();
        if (resultString.charAt(0) !== "1") {
          throw new FormatException();
        }
        return resultString.substring(1);
      }
    }
    DecodedBitStreamParser$2.TEXT_COMPACTION_MODE_LATCH = 900;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH = 901;
    DecodedBitStreamParser$2.NUMERIC_COMPACTION_MODE_LATCH = 902;
    DecodedBitStreamParser$2.BYTE_COMPACTION_MODE_LATCH_6 = 924;
    DecodedBitStreamParser$2.ECI_USER_DEFINED = 925;
    DecodedBitStreamParser$2.ECI_GENERAL_PURPOSE = 926;
    DecodedBitStreamParser$2.ECI_CHARSET = 927;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_CONTROL_BLOCK = 928;
    DecodedBitStreamParser$2.BEGIN_MACRO_PDF417_OPTIONAL_FIELD = 923;
    DecodedBitStreamParser$2.MACRO_PDF417_TERMINATOR = 922;
    DecodedBitStreamParser$2.MODE_SHIFT_TO_BYTE_COMPACTION_MODE = 913;
    DecodedBitStreamParser$2.MAX_NUMERIC_CODEWORDS = 15;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME = 0;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT = 1;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP = 2;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_SENDER = 3;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE = 4;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE = 5;
    DecodedBitStreamParser$2.MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM = 6;
    DecodedBitStreamParser$2.PL = 25;
    DecodedBitStreamParser$2.LL = 27;
    DecodedBitStreamParser$2.AS = 27;
    DecodedBitStreamParser$2.ML = 28;
    DecodedBitStreamParser$2.AL = 28;
    DecodedBitStreamParser$2.PS = 29;
    DecodedBitStreamParser$2.PAL = 29;
    DecodedBitStreamParser$2.PUNCT_CHARS = ";<>@[\\]_`~!\r	,:\n-.$/\"|*()?{}'";
    DecodedBitStreamParser$2.MIXED_CHARS = "0123456789&\r	,:#-.$/+%*=^";
    DecodedBitStreamParser$2.EXP900 = getBigIntConstructor() ? getEXP900() : [];
    DecodedBitStreamParser$2.NUMBER_OF_SEQUENCE_CODEWORDS = 2;
    class PDF417ScanningDecoder {
      constructor() {
      }
      /**
       * @TODO don't pass in minCodewordWidth and maxCodewordWidth, pass in barcode columns for start and stop pattern
       *
       * columns. That way width can be deducted from the pattern column.
       * This approach also allows to detect more details about the barcode, e.g. if a bar type (white or black) is wider
       * than it should be. This can happen if the scanner used a bad blackpoint.
       *
       * @param BitMatrix
       * @param image
       * @param ResultPoint
       * @param imageTopLeft
       * @param ResultPoint
       * @param imageBottomLeft
       * @param ResultPoint
       * @param imageTopRight
       * @param ResultPoint
       * @param imageBottomRight
       * @param int
       * @param minCodewordWidth
       * @param int
       * @param maxCodewordWidth
       *
       * @throws NotFoundException
       * @throws FormatException
       * @throws ChecksumException
       */
      static decode(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight, minCodewordWidth, maxCodewordWidth) {
        let boundingBox = new BoundingBox(image, imageTopLeft, imageBottomLeft, imageTopRight, imageBottomRight);
        let leftRowIndicatorColumn = null;
        let rightRowIndicatorColumn = null;
        let detectionResult;
        for (let firstPass = true; ; firstPass = false) {
          if (imageTopLeft != null) {
            leftRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopLeft, true, minCodewordWidth, maxCodewordWidth);
          }
          if (imageTopRight != null) {
            rightRowIndicatorColumn = PDF417ScanningDecoder.getRowIndicatorColumn(image, boundingBox, imageTopRight, false, minCodewordWidth, maxCodewordWidth);
          }
          detectionResult = PDF417ScanningDecoder.merge(leftRowIndicatorColumn, rightRowIndicatorColumn);
          if (detectionResult == null) {
            throw NotFoundException.getNotFoundInstance();
          }
          let resultBox = detectionResult.getBoundingBox();
          if (firstPass && resultBox != null && (resultBox.getMinY() < boundingBox.getMinY() || resultBox.getMaxY() > boundingBox.getMaxY())) {
            boundingBox = resultBox;
          } else {
            break;
          }
        }
        detectionResult.setBoundingBox(boundingBox);
        let maxBarcodeColumn = detectionResult.getBarcodeColumnCount() + 1;
        detectionResult.setDetectionResultColumn(0, leftRowIndicatorColumn);
        detectionResult.setDetectionResultColumn(maxBarcodeColumn, rightRowIndicatorColumn);
        let leftToRight = leftRowIndicatorColumn != null;
        for (let barcodeColumnCount = 1; barcodeColumnCount <= maxBarcodeColumn; barcodeColumnCount++) {
          let barcodeColumn = leftToRight ? barcodeColumnCount : maxBarcodeColumn - barcodeColumnCount;
          if (detectionResult.getDetectionResultColumn(barcodeColumn) !== /* null */
          void 0) {
            continue;
          }
          let detectionResultColumn;
          if (barcodeColumn === 0 || barcodeColumn === maxBarcodeColumn) {
            detectionResultColumn = new DetectionResultRowIndicatorColumn(boundingBox, barcodeColumn === 0);
          } else {
            detectionResultColumn = new DetectionResultColumn(boundingBox);
          }
          detectionResult.setDetectionResultColumn(barcodeColumn, detectionResultColumn);
          let startColumn = -1;
          let previousStartColumn = startColumn;
          for (let imageRow = boundingBox.getMinY(); imageRow <= boundingBox.getMaxY(); imageRow++) {
            startColumn = PDF417ScanningDecoder.getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight);
            if (startColumn < 0 || startColumn > boundingBox.getMaxX()) {
              if (previousStartColumn === -1) {
                continue;
              }
              startColumn = previousStartColumn;
            }
            let codeword = PDF417ScanningDecoder.detectCodeword(image, boundingBox.getMinX(), boundingBox.getMaxX(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              detectionResultColumn.setCodeword(imageRow, codeword);
              previousStartColumn = startColumn;
              minCodewordWidth = Math.min(minCodewordWidth, codeword.getWidth());
              maxCodewordWidth = Math.max(maxCodewordWidth, codeword.getWidth());
            }
          }
        }
        return PDF417ScanningDecoder.createDecoderResult(detectionResult);
      }
      /**
       *
       * @param leftRowIndicatorColumn
       * @param rightRowIndicatorColumn
       *
       * @throws NotFoundException
       */
      static merge(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        if (leftRowIndicatorColumn == null && rightRowIndicatorColumn == null) {
          return null;
        }
        let barcodeMetadata = PDF417ScanningDecoder.getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn);
        if (barcodeMetadata == null) {
          return null;
        }
        let boundingBox = BoundingBox.merge(PDF417ScanningDecoder.adjustBoundingBox(leftRowIndicatorColumn), PDF417ScanningDecoder.adjustBoundingBox(rightRowIndicatorColumn));
        return new DetectionResult(barcodeMetadata, boundingBox);
      }
      /**
       *
       * @param rowIndicatorColumn
       *
       * @throws NotFoundException
       */
      static adjustBoundingBox(rowIndicatorColumn) {
        if (rowIndicatorColumn == null) {
          return null;
        }
        let rowHeights = rowIndicatorColumn.getRowHeights();
        if (rowHeights == null) {
          return null;
        }
        let maxRowHeight = PDF417ScanningDecoder.getMax(rowHeights);
        let missingStartRows = 0;
        for (let rowHeight of rowHeights) {
          missingStartRows += maxRowHeight - rowHeight;
          if (rowHeight > 0) {
            break;
          }
        }
        let codewords = rowIndicatorColumn.getCodewords();
        for (let row = 0; missingStartRows > 0 && codewords[row] == null; row++) {
          missingStartRows--;
        }
        let missingEndRows = 0;
        for (let row = rowHeights.length - 1; row >= 0; row--) {
          missingEndRows += maxRowHeight - rowHeights[row];
          if (rowHeights[row] > 0) {
            break;
          }
        }
        for (let row = codewords.length - 1; missingEndRows > 0 && codewords[row] == null; row--) {
          missingEndRows--;
        }
        return rowIndicatorColumn.getBoundingBox().addMissingRows(missingStartRows, missingEndRows, rowIndicatorColumn.isLeft());
      }
      static getMax(values) {
        let maxValue = -1;
        for (let value of values) {
          maxValue = Math.max(maxValue, value);
        }
        return maxValue;
      }
      static getBarcodeMetadata(leftRowIndicatorColumn, rightRowIndicatorColumn) {
        let leftBarcodeMetadata;
        if (leftRowIndicatorColumn == null || (leftBarcodeMetadata = leftRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return rightRowIndicatorColumn == null ? null : rightRowIndicatorColumn.getBarcodeMetadata();
        }
        let rightBarcodeMetadata;
        if (rightRowIndicatorColumn == null || (rightBarcodeMetadata = rightRowIndicatorColumn.getBarcodeMetadata()) == null) {
          return leftBarcodeMetadata;
        }
        if (leftBarcodeMetadata.getColumnCount() !== rightBarcodeMetadata.getColumnCount() && leftBarcodeMetadata.getErrorCorrectionLevel() !== rightBarcodeMetadata.getErrorCorrectionLevel() && leftBarcodeMetadata.getRowCount() !== rightBarcodeMetadata.getRowCount()) {
          return null;
        }
        return leftBarcodeMetadata;
      }
      static getRowIndicatorColumn(image, boundingBox, startPoint, leftToRight, minCodewordWidth, maxCodewordWidth) {
        let rowIndicatorColumn = new DetectionResultRowIndicatorColumn(boundingBox, leftToRight);
        for (let i3 = 0; i3 < 2; i3++) {
          let increment = i3 === 0 ? 1 : -1;
          let startColumn = Math.trunc(Math.trunc(startPoint.getX()));
          for (let imageRow = Math.trunc(Math.trunc(startPoint.getY())); imageRow <= boundingBox.getMaxY() && imageRow >= boundingBox.getMinY(); imageRow += increment) {
            let codeword = PDF417ScanningDecoder.detectCodeword(image, 0, image.getWidth(), leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth);
            if (codeword != null) {
              rowIndicatorColumn.setCodeword(imageRow, codeword);
              if (leftToRight) {
                startColumn = codeword.getStartX();
              } else {
                startColumn = codeword.getEndX();
              }
            }
          }
        }
        return rowIndicatorColumn;
      }
      /**
       *
       * @param detectionResult
       * @param BarcodeValue
       * @param param2
       * @param param3
       * @param barcodeMatrix
       *
       * @throws NotFoundException
       */
      static adjustCodewordCount(detectionResult, barcodeMatrix) {
        let barcodeMatrix01 = barcodeMatrix[0][1];
        let numberOfCodewords = barcodeMatrix01.getValue();
        let calculatedNumberOfCodewords = detectionResult.getBarcodeColumnCount() * detectionResult.getBarcodeRowCount() - PDF417ScanningDecoder.getNumberOfECCodeWords(detectionResult.getBarcodeECLevel());
        if (numberOfCodewords.length === 0) {
          if (calculatedNumberOfCodewords < 1 || calculatedNumberOfCodewords > PDF417Common.MAX_CODEWORDS_IN_BARCODE) {
            throw NotFoundException.getNotFoundInstance();
          }
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        } else if (numberOfCodewords[0] !== calculatedNumberOfCodewords) {
          barcodeMatrix01.setValue(calculatedNumberOfCodewords);
        }
      }
      /**
       *
       * @param detectionResult
       *
       * @throws FormatException
       * @throws ChecksumException
       * @throws NotFoundException
       */
      static createDecoderResult(detectionResult) {
        let barcodeMatrix = PDF417ScanningDecoder.createBarcodeMatrix(detectionResult);
        PDF417ScanningDecoder.adjustCodewordCount(detectionResult, barcodeMatrix);
        let erasures = new Array();
        let codewords = new Int32Array(detectionResult.getBarcodeRowCount() * detectionResult.getBarcodeColumnCount());
        let ambiguousIndexValuesList = (
          /*List<int[]>*/
          []
        );
        let ambiguousIndexesList = (
          /*Collection<Integer>*/
          new Array()
        );
        for (let row = 0; row < detectionResult.getBarcodeRowCount(); row++) {
          for (let column = 0; column < detectionResult.getBarcodeColumnCount(); column++) {
            let values = barcodeMatrix[row][column + 1].getValue();
            let codewordIndex = row * detectionResult.getBarcodeColumnCount() + column;
            if (values.length === 0) {
              erasures.push(codewordIndex);
            } else if (values.length === 1) {
              codewords[codewordIndex] = values[0];
            } else {
              ambiguousIndexesList.push(codewordIndex);
              ambiguousIndexValuesList.push(values);
            }
          }
        }
        let ambiguousIndexValues = new Array(ambiguousIndexValuesList.length);
        for (let i3 = 0; i3 < ambiguousIndexValues.length; i3++) {
          ambiguousIndexValues[i3] = ambiguousIndexValuesList[i3];
        }
        return PDF417ScanningDecoder.createDecoderResultFromAmbiguousValues(detectionResult.getBarcodeECLevel(), codewords, PDF417Common.toIntArray(erasures), PDF417Common.toIntArray(ambiguousIndexesList), ambiguousIndexValues);
      }
      /**
       * This method deals with the fact, that the decoding process doesn't always yield a single most likely value. The
       * current error correction implementation doesn't deal with erasures very well, so it's better to provide a value
       * for these ambiguous codewords instead of treating it as an erasure. The problem is that we don't know which of
       * the ambiguous values to choose. We try decode using the first value, and if that fails, we use another of the
       * ambiguous values and try to decode again. This usually only happens on very hard to read and decode barcodes,
       * so decoding the normal barcodes is not affected by this.
       *
       * @param erasureArray contains the indexes of erasures
       * @param ambiguousIndexes array with the indexes that have more than one most likely value
       * @param ambiguousIndexValues two dimensional array that contains the ambiguous values. The first dimension must
       * be the same length as the ambiguousIndexes array
       *
       * @throws FormatException
       * @throws ChecksumException
       */
      static createDecoderResultFromAmbiguousValues(ecLevel, codewords, erasureArray, ambiguousIndexes, ambiguousIndexValues) {
        let ambiguousIndexCount = new Int32Array(ambiguousIndexes.length);
        let tries = 100;
        while (tries-- > 0) {
          for (let i3 = 0; i3 < ambiguousIndexCount.length; i3++) {
            codewords[ambiguousIndexes[i3]] = ambiguousIndexValues[i3][ambiguousIndexCount[i3]];
          }
          try {
            return PDF417ScanningDecoder.decodeCodewords(codewords, ecLevel, erasureArray);
          } catch (err) {
            let ignored = err instanceof ChecksumException;
            if (!ignored) {
              throw err;
            }
          }
          if (ambiguousIndexCount.length === 0) {
            throw ChecksumException.getChecksumInstance();
          }
          for (let i3 = 0; i3 < ambiguousIndexCount.length; i3++) {
            if (ambiguousIndexCount[i3] < ambiguousIndexValues[i3].length - 1) {
              ambiguousIndexCount[i3]++;
              break;
            } else {
              ambiguousIndexCount[i3] = 0;
              if (i3 === ambiguousIndexCount.length - 1) {
                throw ChecksumException.getChecksumInstance();
              }
            }
          }
        }
        throw ChecksumException.getChecksumInstance();
      }
      static createBarcodeMatrix(detectionResult) {
        let barcodeMatrix = Array.from({ length: detectionResult.getBarcodeRowCount() }, () => new Array(detectionResult.getBarcodeColumnCount() + 2));
        for (let row = 0; row < barcodeMatrix.length; row++) {
          for (let column2 = 0; column2 < barcodeMatrix[row].length; column2++) {
            barcodeMatrix[row][column2] = new BarcodeValue();
          }
        }
        let column = 0;
        for (let detectionResultColumn of detectionResult.getDetectionResultColumns()) {
          if (detectionResultColumn != null) {
            for (let codeword of detectionResultColumn.getCodewords()) {
              if (codeword != null) {
                let rowNumber = codeword.getRowNumber();
                if (rowNumber >= 0) {
                  if (rowNumber >= barcodeMatrix.length) {
                    continue;
                  }
                  barcodeMatrix[rowNumber][column].setValue(codeword.getValue());
                }
              }
            }
          }
          column++;
        }
        return barcodeMatrix;
      }
      static isValidBarcodeColumn(detectionResult, barcodeColumn) {
        return barcodeColumn >= 0 && barcodeColumn <= detectionResult.getBarcodeColumnCount() + 1;
      }
      static getStartColumn(detectionResult, barcodeColumn, imageRow, leftToRight) {
        let offset2 = leftToRight ? 1 : -1;
        let codeword = null;
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset2).getCodeword(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        codeword = detectionResult.getDetectionResultColumn(barcodeColumn).getCodewordNearby(imageRow);
        if (codeword != null) {
          return leftToRight ? codeword.getStartX() : codeword.getEndX();
        }
        if (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          codeword = detectionResult.getDetectionResultColumn(barcodeColumn - offset2).getCodewordNearby(imageRow);
        }
        if (codeword != null) {
          return leftToRight ? codeword.getEndX() : codeword.getStartX();
        }
        let skippedColumns = 0;
        while (PDF417ScanningDecoder.isValidBarcodeColumn(detectionResult, barcodeColumn - offset2)) {
          barcodeColumn -= offset2;
          for (let previousRowCodeword of detectionResult.getDetectionResultColumn(barcodeColumn).getCodewords()) {
            if (previousRowCodeword != null) {
              return (leftToRight ? previousRowCodeword.getEndX() : previousRowCodeword.getStartX()) + offset2 * skippedColumns * (previousRowCodeword.getEndX() - previousRowCodeword.getStartX());
            }
          }
          skippedColumns++;
        }
        return leftToRight ? detectionResult.getBoundingBox().getMinX() : detectionResult.getBoundingBox().getMaxX();
      }
      static detectCodeword(image, minColumn, maxColumn, leftToRight, startColumn, imageRow, minCodewordWidth, maxCodewordWidth) {
        startColumn = PDF417ScanningDecoder.adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        let moduleBitCount = PDF417ScanningDecoder.getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow);
        if (moduleBitCount == null) {
          return null;
        }
        let endColumn;
        let codewordBitCount = MathUtils.sum(moduleBitCount);
        if (leftToRight) {
          endColumn = startColumn + codewordBitCount;
        } else {
          for (let i3 = 0; i3 < moduleBitCount.length / 2; i3++) {
            let tmpCount = moduleBitCount[i3];
            moduleBitCount[i3] = moduleBitCount[moduleBitCount.length - 1 - i3];
            moduleBitCount[moduleBitCount.length - 1 - i3] = tmpCount;
          }
          endColumn = startColumn;
          startColumn = endColumn - codewordBitCount;
        }
        if (!PDF417ScanningDecoder.checkCodewordSkew(codewordBitCount, minCodewordWidth, maxCodewordWidth)) {
          return null;
        }
        let decodedValue = PDF417CodewordDecoder.getDecodedValue(moduleBitCount);
        let codeword = PDF417Common.getCodeword(decodedValue);
        if (codeword === -1) {
          return null;
        }
        return new Codeword(startColumn, endColumn, PDF417ScanningDecoder.getCodewordBucketNumber(decodedValue), codeword);
      }
      static getModuleBitCount(image, minColumn, maxColumn, leftToRight, startColumn, imageRow) {
        let imageColumn = startColumn;
        let moduleBitCount = new Int32Array(8);
        let moduleNumber = 0;
        let increment = leftToRight ? 1 : -1;
        let previousPixelValue = leftToRight;
        while ((leftToRight ? imageColumn < maxColumn : imageColumn >= minColumn) && moduleNumber < moduleBitCount.length) {
          if (image.get(imageColumn, imageRow) === previousPixelValue) {
            moduleBitCount[moduleNumber]++;
            imageColumn += increment;
          } else {
            moduleNumber++;
            previousPixelValue = !previousPixelValue;
          }
        }
        if (moduleNumber === moduleBitCount.length || imageColumn === (leftToRight ? maxColumn : minColumn) && moduleNumber === moduleBitCount.length - 1) {
          return moduleBitCount;
        }
        return null;
      }
      static getNumberOfECCodeWords(barcodeECLevel) {
        return 2 << barcodeECLevel;
      }
      static adjustCodewordStartColumn(image, minColumn, maxColumn, leftToRight, codewordStartColumn, imageRow) {
        let correctedStartColumn = codewordStartColumn;
        let increment = leftToRight ? -1 : 1;
        for (let i3 = 0; i3 < 2; i3++) {
          while ((leftToRight ? correctedStartColumn >= minColumn : correctedStartColumn < maxColumn) && leftToRight === image.get(correctedStartColumn, imageRow)) {
            if (Math.abs(codewordStartColumn - correctedStartColumn) > PDF417ScanningDecoder.CODEWORD_SKEW_SIZE) {
              return codewordStartColumn;
            }
            correctedStartColumn += increment;
          }
          increment = -increment;
          leftToRight = !leftToRight;
        }
        return correctedStartColumn;
      }
      static checkCodewordSkew(codewordSize, minCodewordWidth, maxCodewordWidth) {
        return minCodewordWidth - PDF417ScanningDecoder.CODEWORD_SKEW_SIZE <= codewordSize && codewordSize <= maxCodewordWidth + PDF417ScanningDecoder.CODEWORD_SKEW_SIZE;
      }
      /**
       * @throws FormatException,
       * @throws ChecksumException
       */
      static decodeCodewords(codewords, ecLevel, erasures) {
        if (codewords.length === 0) {
          throw FormatException.getFormatInstance();
        }
        let numECCodewords = 1 << ecLevel + 1;
        let correctedErrorsCount = PDF417ScanningDecoder.correctErrors(codewords, erasures, numECCodewords);
        PDF417ScanningDecoder.verifyCodewordCount(codewords, numECCodewords);
        let decoderResult = DecodedBitStreamParser$2.decode(codewords, "" + ecLevel);
        decoderResult.setErrorsCorrected(correctedErrorsCount);
        decoderResult.setErasures(erasures.length);
        return decoderResult;
      }
      /**
       * <p>Given data and error-correction codewords received, possibly corrupted by errors, attempts to
       * correct the errors in-place.</p>
       *
       * @param codewords   data and error correction codewords
       * @param erasures positions of any known erasures
       * @param numECCodewords number of error correction codewords that are available in codewords
       * @throws ChecksumException if error correction fails
       */
      static correctErrors(codewords, erasures, numECCodewords) {
        if (erasures != null && erasures.length > numECCodewords / 2 + PDF417ScanningDecoder.MAX_ERRORS || numECCodewords < 0 || numECCodewords > PDF417ScanningDecoder.MAX_EC_CODEWORDS) {
          throw ChecksumException.getChecksumInstance();
        }
        return PDF417ScanningDecoder.errorCorrection.decode(codewords, numECCodewords, erasures);
      }
      /**
       * Verify that all is OK with the codeword array.
       * @throws FormatException
       */
      static verifyCodewordCount(codewords, numECCodewords) {
        if (codewords.length < 4) {
          throw FormatException.getFormatInstance();
        }
        let numberOfCodewords = codewords[0];
        if (numberOfCodewords > codewords.length) {
          throw FormatException.getFormatInstance();
        }
        if (numberOfCodewords === 0) {
          if (numECCodewords < codewords.length) {
            codewords[0] = codewords.length - numECCodewords;
          } else {
            throw FormatException.getFormatInstance();
          }
        }
      }
      static getBitCountForCodeword(codeword) {
        let result = new Int32Array(8);
        let previousValue = 0;
        let i3 = result.length - 1;
        while (true) {
          if ((codeword & 1) !== previousValue) {
            previousValue = codeword & 1;
            i3--;
            if (i3 < 0) {
              break;
            }
          }
          result[i3]++;
          codeword >>= 1;
        }
        return result;
      }
      static getCodewordBucketNumber(codeword) {
        if (codeword instanceof Int32Array) {
          return this.getCodewordBucketNumber_Int32Array(codeword);
        }
        return this.getCodewordBucketNumber_number(codeword);
      }
      static getCodewordBucketNumber_number(codeword) {
        return PDF417ScanningDecoder.getCodewordBucketNumber(PDF417ScanningDecoder.getBitCountForCodeword(codeword));
      }
      static getCodewordBucketNumber_Int32Array(moduleBitCount) {
        return (moduleBitCount[0] - moduleBitCount[2] + moduleBitCount[4] - moduleBitCount[6] + 9) % 9;
      }
      static toString(barcodeMatrix) {
        let formatter = new Formatter();
        for (let row = 0; row < barcodeMatrix.length; row++) {
          formatter.format("Row %2d: ", row);
          for (let column = 0; column < barcodeMatrix[row].length; column++) {
            let barcodeValue = barcodeMatrix[row][column];
            if (barcodeValue.getValue().length === 0) {
              formatter.format("        ", null);
            } else {
              formatter.format("%4d(%2d)", barcodeValue.getValue()[0], barcodeValue.getConfidence(barcodeValue.getValue()[0]));
            }
          }
          formatter.format("%n");
        }
        return formatter.toString();
      }
    }
    PDF417ScanningDecoder.CODEWORD_SKEW_SIZE = 2;
    PDF417ScanningDecoder.MAX_ERRORS = 3;
    PDF417ScanningDecoder.MAX_EC_CODEWORDS = 512;
    PDF417ScanningDecoder.errorCorrection = new ErrorCorrection();
    class PDF417Reader {
      // private static /*final Result[]*/ EMPTY_RESULT_ARRAY: Result[] = new Result([0]);
      /**
       * Locates and decodes a PDF417 code in an image.
       *
       * @return a String representing the content encoded by the PDF417 code
       * @throws NotFoundException if a PDF417 code cannot be found,
       * @throws FormatException if a PDF417 cannot be decoded
       * @throws ChecksumException
       */
      // @Override
      decode(image, hints = null) {
        let result = PDF417Reader.decode(image, hints, false);
        if (result == null || result.length === 0 || result[0] == null) {
          throw NotFoundException.getNotFoundInstance();
        }
        return result[0];
      }
      /**
       *
       * @param BinaryBitmap
       * @param image
       * @throws NotFoundException
       */
      //   @Override
      decodeMultiple(image, hints = null) {
        try {
          return PDF417Reader.decode(image, hints, true);
        } catch (ignored) {
          if (ignored instanceof FormatException || ignored instanceof ChecksumException) {
            throw NotFoundException.getNotFoundInstance();
          }
          throw ignored;
        }
      }
      /**
       *
       * @param image
       * @param hints
       * @param multiple
       *
       * @throws NotFoundException
       * @throws FormatExceptionß
       * @throws ChecksumException
       */
      static decode(image, hints, multiple) {
        const results = new Array();
        const detectorResult = Detector$3.detectMultiple(image, hints, multiple);
        for (const points of detectorResult.getPoints()) {
          const decoderResult = PDF417ScanningDecoder.decode(detectorResult.getBits(), points[4], points[5], points[6], points[7], PDF417Reader.getMinCodewordWidth(points), PDF417Reader.getMaxCodewordWidth(points));
          const result = new Result(decoderResult.getText(), decoderResult.getRawBytes(), void 0, points, BarcodeFormat$1.PDF_417);
          result.putMetadata(ResultMetadataType$1.ERROR_CORRECTION_LEVEL, decoderResult.getECLevel());
          const pdf417ResultMetadata = decoderResult.getOther();
          if (pdf417ResultMetadata != null) {
            result.putMetadata(ResultMetadataType$1.PDF417_EXTRA_METADATA, pdf417ResultMetadata);
          }
          results.push(result);
        }
        return results.map((x3) => x3);
      }
      static getMaxWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return 0;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMinWidth(p1, p2) {
        if (p1 == null || p2 == null) {
          return Integer.MAX_VALUE;
        }
        return Math.trunc(Math.abs(p1.getX() - p2.getX()));
      }
      static getMaxCodewordWidth(p2) {
        return Math.floor(Math.max(Math.max(PDF417Reader.getMaxWidth(p2[0], p2[4]), PDF417Reader.getMaxWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.max(PDF417Reader.getMaxWidth(p2[1], p2[5]), PDF417Reader.getMaxWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      static getMinCodewordWidth(p2) {
        return Math.floor(Math.min(Math.min(PDF417Reader.getMinWidth(p2[0], p2[4]), PDF417Reader.getMinWidth(p2[6], p2[2]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN), Math.min(PDF417Reader.getMinWidth(p2[1], p2[5]), PDF417Reader.getMinWidth(p2[7], p2[3]) * PDF417Common.MODULES_IN_CODEWORD / PDF417Common.MODULES_IN_STOP_PATTERN)));
      }
      // @Override
      reset() {
      }
    }
    class ReaderException extends Exception {
    }
    ReaderException.kind = "ReaderException";
    class MultiFormatReader {
      /**
       * Creates an instance of this class
       * 
       * @param {Boolean} verbose if 'true' logs will be dumped to console, otherwise hidden.
       * @param hints The hints to use, clearing the previous state.
       */
      constructor(verbose, hints) {
        this.verbose = verbose === true;
        if (hints) {
          this.setHints(hints);
        }
      }
      /**
       * This version of decode honors the intent of Reader.decode(BinaryBitmap) in that it
       * passes null as a hint to the decoders. However, that makes it inefficient to call repeatedly.
       * Use setHints() followed by decodeWithState() for continuous scan applications.
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      // public decode(image: BinaryBitmap): Result {
      //   setHints(null)
      //   return decodeInternal(image)
      // }
      /**
       * Decode an image using the hints provided. Does not honor existing state.
       *
       * @param image The pixel data to decode
       * @param hints The hints to use, clearing the previous state.
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      /*@Override*/
      decode(image, hints) {
        if (hints) {
          this.setHints(hints);
        }
        return this.decodeInternal(image);
      }
      /**
       * Decode an image using the state set up by calling setHints() previously. Continuous scan
       * clients will get a <b>large</b> speed increase by using this instead of decode().
       *
       * @param image The pixel data to decode
       * @return The contents of the image
       *
       * @throws NotFoundException Any errors which occurred
       */
      decodeWithState(image) {
        if (this.readers === null || this.readers === void 0) {
          this.setHints(null);
        }
        return this.decodeInternal(image);
      }
      /**
       * This method adds state to the MultiFormatReader. By setting the hints once, subsequent calls
       * to decodeWithState(image) can reuse the same set of readers without reallocating memory. This
       * is important for performance in continuous scan clients.
       *
       * @param hints The set of hints to use for subsequent calls to decode(image)
       */
      setHints(hints) {
        this.hints = hints;
        const tryHarder = !isNullOrUndefined2(hints) && hints.get(DecodeHintType$1.TRY_HARDER) === true;
        const formats = isNullOrUndefined2(hints) ? null : hints.get(DecodeHintType$1.POSSIBLE_FORMATS);
        const readers = new Array();
        if (!isNullOrUndefined2(formats)) {
          const addOneDReader = formats.some((f2) => {
            return f2 === BarcodeFormat$1.UPC_A || f2 === BarcodeFormat$1.UPC_E || f2 === BarcodeFormat$1.EAN_13 || f2 === BarcodeFormat$1.EAN_8 || f2 === BarcodeFormat$1.CODABAR || f2 === BarcodeFormat$1.CODE_39 || f2 === BarcodeFormat$1.CODE_93 || f2 === BarcodeFormat$1.CODE_128 || f2 === BarcodeFormat$1.ITF || f2 === BarcodeFormat$1.RSS_14 || f2 === BarcodeFormat$1.RSS_EXPANDED;
          });
          if (addOneDReader && !tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          if (formats.includes(BarcodeFormat$1.QR_CODE)) {
            readers.push(new QRCodeReader());
          }
          if (formats.includes(BarcodeFormat$1.DATA_MATRIX)) {
            readers.push(new DataMatrixReader());
          }
          if (formats.includes(BarcodeFormat$1.AZTEC)) {
            readers.push(new AztecReader());
          }
          if (formats.includes(BarcodeFormat$1.PDF_417)) {
            readers.push(new PDF417Reader());
          }
          if (addOneDReader && tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        if (readers.length === 0) {
          if (!tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
          readers.push(new QRCodeReader());
          readers.push(new DataMatrixReader());
          readers.push(new AztecReader());
          readers.push(new PDF417Reader());
          if (tryHarder) {
            readers.push(new MultiFormatOneDReader(hints, this.verbose));
          }
        }
        this.readers = readers;
      }
      /*@Override*/
      reset() {
        if (this.readers !== null) {
          for (const reader of this.readers) {
            reader.reset();
          }
        }
      }
      /**
       * @throws NotFoundException
       */
      decodeInternal(image) {
        if (this.readers === null) {
          throw new ReaderException("No readers where selected, nothing can be read.");
        }
        for (const reader of this.readers) {
          try {
            return reader.decode(image, this.hints);
          } catch (ex) {
            if (ex instanceof ReaderException) {
              continue;
            }
          }
        }
        throw new NotFoundException("No MultiFormat Readers were able to detect the code.");
      }
    }
    class BrowserMultiFormatReader extends BrowserCodeReader {
      constructor(hints = null, timeBetweenScansMillis = 500) {
        const reader = new MultiFormatReader();
        reader.setHints(hints);
        super(reader, timeBetweenScansMillis);
      }
      /**
       * Overwrite decodeBitmap to call decodeWithState, which will pay
       * attention to the hints set in the constructor function
       */
      decodeBitmap(binaryBitmap) {
        return this.reader.decodeWithState(binaryBitmap);
      }
    }
    class BrowserPDF417Reader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserPDF417Reader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new PDF417Reader(), timeBetweenScansMillis);
      }
    }
    class BrowserQRCodeReader extends BrowserCodeReader {
      /**
       * Creates an instance of BrowserQRCodeReader.
       * @param {number} [timeBetweenScansMillis=500] the time delay between subsequent decode tries
       */
      constructor(timeBetweenScansMillis = 500) {
        super(new QRCodeReader(), timeBetweenScansMillis);
      }
    }
    var EncodeHintType;
    (function(EncodeHintType2) {
      EncodeHintType2[EncodeHintType2["ERROR_CORRECTION"] = 0] = "ERROR_CORRECTION";
      EncodeHintType2[EncodeHintType2["CHARACTER_SET"] = 1] = "CHARACTER_SET";
      EncodeHintType2[EncodeHintType2["DATA_MATRIX_SHAPE"] = 2] = "DATA_MATRIX_SHAPE";
      EncodeHintType2[EncodeHintType2["MIN_SIZE"] = 3] = "MIN_SIZE";
      EncodeHintType2[EncodeHintType2["MAX_SIZE"] = 4] = "MAX_SIZE";
      EncodeHintType2[EncodeHintType2["MARGIN"] = 5] = "MARGIN";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACT"] = 6] = "PDF417_COMPACT";
      EncodeHintType2[EncodeHintType2["PDF417_COMPACTION"] = 7] = "PDF417_COMPACTION";
      EncodeHintType2[EncodeHintType2["PDF417_DIMENSIONS"] = 8] = "PDF417_DIMENSIONS";
      EncodeHintType2[EncodeHintType2["AZTEC_LAYERS"] = 9] = "AZTEC_LAYERS";
      EncodeHintType2[EncodeHintType2["QR_VERSION"] = 10] = "QR_VERSION";
    })(EncodeHintType || (EncodeHintType = {}));
    var EncodeHintType$1 = EncodeHintType;
    class ReedSolomonEncoder {
      /**
       * A reed solomon error-correcting encoding constructor is created by
       * passing as Galois Field with of size equal to the number of code
       * words (symbols) in the alphabet (the number of values in each
       * element of arrays that are encoded/decoded).
       * @param field A galois field with a number of elements equal to the size
       * of the alphabet of symbols to encode.
       */
      constructor(field) {
        this.field = field;
        this.cachedGenerators = [];
        this.cachedGenerators.push(new GenericGFPoly(field, Int32Array.from([1])));
      }
      buildGenerator(degree) {
        const cachedGenerators = this.cachedGenerators;
        if (degree >= cachedGenerators.length) {
          let lastGenerator = cachedGenerators[cachedGenerators.length - 1];
          const field = this.field;
          for (let d4 = cachedGenerators.length; d4 <= degree; d4++) {
            const nextGenerator = lastGenerator.multiply(new GenericGFPoly(field, Int32Array.from([1, field.exp(d4 - 1 + field.getGeneratorBase())])));
            cachedGenerators.push(nextGenerator);
            lastGenerator = nextGenerator;
          }
        }
        return cachedGenerators[degree];
      }
      /**
       * <p>Encode a sequence of code words (symbols) using Reed-Solomon to allow decoders
       * to detect and correct errors that may have been introduced when the resulting
       * data is stored or transmitted.</p>
       *
       * @param toEncode array used for both and output. Caller initializes the array with
       * the code words (symbols) to be encoded followed by empty elements allocated to make
       * space for error-correction code words in the encoded output. The array contains
       * the encdoded output when encode returns. Code words are encoded as numbers from
       * 0 to n-1, where n is the number of possible code words (symbols), as determined
       * by the size of the Galois Field passed in the constructor of this object.
       * @param ecBytes the number of elements reserved in the array (first parameter)
       * to store error-correction code words. Thus, the number of code words (symbols)
       * to encode in the first parameter is thus toEncode.length - ecBytes.
       * Note, the use of "bytes" in the name of this parameter is misleading, as there may
       * be more or fewer than 256 symbols being encoded, as determined by the number of
       * elements in the Galois Field passed as a constructor to this object.
       * @throws IllegalArgumentException thrown in response to validation errros.
       */
      encode(toEncode, ecBytes) {
        if (ecBytes === 0) {
          throw new IllegalArgumentException("No error correction bytes");
        }
        const dataBytes = toEncode.length - ecBytes;
        if (dataBytes <= 0) {
          throw new IllegalArgumentException("No data bytes provided");
        }
        const generator = this.buildGenerator(ecBytes);
        const infoCoefficients = new Int32Array(dataBytes);
        System.arraycopy(toEncode, 0, infoCoefficients, 0, dataBytes);
        let info = new GenericGFPoly(this.field, infoCoefficients);
        info = info.multiplyByMonomial(ecBytes, 1);
        const remainder = info.divide(generator)[1];
        const coefficients = remainder.getCoefficients();
        const numZeroCoefficients = ecBytes - coefficients.length;
        for (let i3 = 0; i3 < numZeroCoefficients; i3++) {
          toEncode[dataBytes + i3] = 0;
        }
        System.arraycopy(coefficients, 0, toEncode, dataBytes + numZeroCoefficients, coefficients.length);
      }
    }
    class MaskUtil {
      constructor() {
      }
      /**
       * Apply mask penalty rule 1 and return the penalty. Find repetitive cells with the same color and
       * give penalty to them. Example: 00000 or 11111.
       */
      static applyMaskPenaltyRule1(matrix) {
        return MaskUtil.applyMaskPenaltyRule1Internal(matrix, true) + MaskUtil.applyMaskPenaltyRule1Internal(matrix, false);
      }
      /**
       * Apply mask penalty rule 2 and return the penalty. Find 2x2 blocks with the same color and give
       * penalty to them. This is actually equivalent to the spec's rule, which is to find MxN blocks and give a
       * penalty proportional to (M-1)x(N-1), because this is the number of 2x2 blocks inside such a block.
       */
      static applyMaskPenaltyRule2(matrix) {
        let penalty = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y4 = 0; y4 < height - 1; y4++) {
          const arrayY = array[y4];
          for (let x3 = 0; x3 < width - 1; x3++) {
            const value = arrayY[x3];
            if (value === arrayY[x3 + 1] && value === array[y4 + 1][x3] && value === array[y4 + 1][x3 + 1]) {
              penalty++;
            }
          }
        }
        return MaskUtil.N2 * penalty;
      }
      /**
       * Apply mask penalty rule 3 and return the penalty. Find consecutive runs of 1:1:3:1:1:4
       * starting with black, or 4:1:1:3:1:1 starting with white, and give penalty to them.  If we
       * find patterns like 000010111010000, we give penalty once.
       */
      static applyMaskPenaltyRule3(matrix) {
        let numPenalties = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y4 = 0; y4 < height; y4++) {
          for (let x3 = 0; x3 < width; x3++) {
            const arrayY = array[y4];
            if (x3 + 6 < width && arrayY[x3] === 1 && arrayY[x3 + 1] === 0 && arrayY[x3 + 2] === 1 && arrayY[x3 + 3] === 1 && arrayY[x3 + 4] === 1 && arrayY[x3 + 5] === 0 && arrayY[x3 + 6] === 1 && (MaskUtil.isWhiteHorizontal(arrayY, x3 - 4, x3) || MaskUtil.isWhiteHorizontal(arrayY, x3 + 7, x3 + 11))) {
              numPenalties++;
            }
            if (y4 + 6 < height && array[y4][x3] === 1 && array[y4 + 1][x3] === 0 && array[y4 + 2][x3] === 1 && array[y4 + 3][x3] === 1 && array[y4 + 4][x3] === 1 && array[y4 + 5][x3] === 0 && array[y4 + 6][x3] === 1 && (MaskUtil.isWhiteVertical(array, x3, y4 - 4, y4) || MaskUtil.isWhiteVertical(array, x3, y4 + 7, y4 + 11))) {
              numPenalties++;
            }
          }
        }
        return numPenalties * MaskUtil.N3;
      }
      static isWhiteHorizontal(rowArray, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, rowArray.length);
        for (let i3 = from; i3 < to; i3++) {
          if (rowArray[i3] === 1) {
            return false;
          }
        }
        return true;
      }
      static isWhiteVertical(array, col, from, to) {
        from = Math.max(from, 0);
        to = Math.min(to, array.length);
        for (let i3 = from; i3 < to; i3++) {
          if (array[i3][col] === 1) {
            return false;
          }
        }
        return true;
      }
      /**
       * Apply mask penalty rule 4 and return the penalty. Calculate the ratio of dark cells and give
       * penalty if the ratio is far from 50%. It gives 10 penalty for 5% distance.
       */
      static applyMaskPenaltyRule4(matrix) {
        let numDarkCells = 0;
        const array = matrix.getArray();
        const width = matrix.getWidth();
        const height = matrix.getHeight();
        for (let y4 = 0; y4 < height; y4++) {
          const arrayY = array[y4];
          for (let x3 = 0; x3 < width; x3++) {
            if (arrayY[x3] === 1) {
              numDarkCells++;
            }
          }
        }
        const numTotalCells = matrix.getHeight() * matrix.getWidth();
        const fivePercentVariances = Math.floor(Math.abs(numDarkCells * 2 - numTotalCells) * 10 / numTotalCells);
        return fivePercentVariances * MaskUtil.N4;
      }
      /**
       * Return the mask bit for "getMaskPattern" at "x" and "y". See 8.8 of JISX0510:2004 for mask
       * pattern conditions.
       */
      static getDataMaskBit(maskPattern, x3, y4) {
        let intermediate;
        let temp;
        switch (maskPattern) {
          case 0:
            intermediate = y4 + x3 & 1;
            break;
          case 1:
            intermediate = y4 & 1;
            break;
          case 2:
            intermediate = x3 % 3;
            break;
          case 3:
            intermediate = (y4 + x3) % 3;
            break;
          case 4:
            intermediate = Math.floor(y4 / 2) + Math.floor(x3 / 3) & 1;
            break;
          case 5:
            temp = y4 * x3;
            intermediate = (temp & 1) + temp % 3;
            break;
          case 6:
            temp = y4 * x3;
            intermediate = (temp & 1) + temp % 3 & 1;
            break;
          case 7:
            temp = y4 * x3;
            intermediate = temp % 3 + (y4 + x3 & 1) & 1;
            break;
          default:
            throw new IllegalArgumentException("Invalid mask pattern: " + maskPattern);
        }
        return intermediate === 0;
      }
      /**
       * Helper function for applyMaskPenaltyRule1. We need this for doing this calculation in both
       * vertical and horizontal orders respectively.
       */
      static applyMaskPenaltyRule1Internal(matrix, isHorizontal) {
        let penalty = 0;
        const iLimit = isHorizontal ? matrix.getHeight() : matrix.getWidth();
        const jLimit = isHorizontal ? matrix.getWidth() : matrix.getHeight();
        const array = matrix.getArray();
        for (let i3 = 0; i3 < iLimit; i3++) {
          let numSameBitCells = 0;
          let prevBit = -1;
          for (let j2 = 0; j2 < jLimit; j2++) {
            const bit = isHorizontal ? array[i3][j2] : array[j2][i3];
            if (bit === prevBit) {
              numSameBitCells++;
            } else {
              if (numSameBitCells >= 5) {
                penalty += MaskUtil.N1 + (numSameBitCells - 5);
              }
              numSameBitCells = 1;
              prevBit = bit;
            }
          }
          if (numSameBitCells >= 5) {
            penalty += MaskUtil.N1 + (numSameBitCells - 5);
          }
        }
        return penalty;
      }
    }
    MaskUtil.N1 = 3;
    MaskUtil.N2 = 3;
    MaskUtil.N3 = 40;
    MaskUtil.N4 = 10;
    class ByteMatrix {
      constructor(width, height) {
        this.width = width;
        this.height = height;
        const bytes = new Array(height);
        for (let i3 = 0; i3 !== height; i3++) {
          bytes[i3] = new Uint8Array(width);
        }
        this.bytes = bytes;
      }
      getHeight() {
        return this.height;
      }
      getWidth() {
        return this.width;
      }
      get(x3, y4) {
        return this.bytes[y4][x3];
      }
      /**
       * @return an internal representation as bytes, in row-major order. array[y][x] represents point (x,y)
       */
      getArray() {
        return this.bytes;
      }
      // TYPESCRIPTPORT: preffer to let two methods instead of override to avoid type comparison inside
      setNumber(x3, y4, value) {
        this.bytes[y4][x3] = value;
      }
      // public set(x: number /*int*/, y: number /*int*/, value: number /*int*/): void {
      //   bytes[y][x] = (byte) value
      // }
      setBoolean(x3, y4, value) {
        this.bytes[y4][x3] = /*(byte) */
        value ? 1 : 0;
      }
      clear(value) {
        for (const aByte of this.bytes) {
          Arrays.fill(aByte, value);
        }
      }
      equals(o2) {
        if (!(o2 instanceof ByteMatrix)) {
          return false;
        }
        const other = o2;
        if (this.width !== other.width) {
          return false;
        }
        if (this.height !== other.height) {
          return false;
        }
        for (let y4 = 0, height = this.height; y4 < height; ++y4) {
          const bytesY = this.bytes[y4];
          const otherBytesY = other.bytes[y4];
          for (let x3 = 0, width = this.width; x3 < width; ++x3) {
            if (bytesY[x3] !== otherBytesY[x3]) {
              return false;
            }
          }
        }
        return true;
      }
      /*@Override*/
      toString() {
        const result = new StringBuilder();
        for (let y4 = 0, height = this.height; y4 < height; ++y4) {
          const bytesY = this.bytes[y4];
          for (let x3 = 0, width = this.width; x3 < width; ++x3) {
            switch (bytesY[x3]) {
              case 0:
                result.append(" 0");
                break;
              case 1:
                result.append(" 1");
                break;
              default:
                result.append("  ");
                break;
            }
          }
          result.append("\n");
        }
        return result.toString();
      }
    }
    class QRCode {
      constructor() {
        this.maskPattern = -1;
      }
      getMode() {
        return this.mode;
      }
      getECLevel() {
        return this.ecLevel;
      }
      getVersion() {
        return this.version;
      }
      getMaskPattern() {
        return this.maskPattern;
      }
      getMatrix() {
        return this.matrix;
      }
      /*@Override*/
      toString() {
        const result = new StringBuilder();
        result.append("<<\n");
        result.append(" mode: ");
        result.append(this.mode ? this.mode.toString() : "null");
        result.append("\n ecLevel: ");
        result.append(this.ecLevel ? this.ecLevel.toString() : "null");
        result.append("\n version: ");
        result.append(this.version ? this.version.toString() : "null");
        result.append("\n maskPattern: ");
        result.append(this.maskPattern.toString());
        if (this.matrix) {
          result.append("\n matrix:\n");
          result.append(this.matrix.toString());
        } else {
          result.append("\n matrix: null\n");
        }
        result.append(">>\n");
        return result.toString();
      }
      setMode(value) {
        this.mode = value;
      }
      setECLevel(value) {
        this.ecLevel = value;
      }
      setVersion(version) {
        this.version = version;
      }
      setMaskPattern(value) {
        this.maskPattern = value;
      }
      setMatrix(value) {
        this.matrix = value;
      }
      // Check if "mask_pattern" is valid.
      static isValidMaskPattern(maskPattern) {
        return maskPattern >= 0 && maskPattern < QRCode.NUM_MASK_PATTERNS;
      }
    }
    QRCode.NUM_MASK_PATTERNS = 8;
    class WriterException extends Exception {
    }
    WriterException.kind = "WriterException";
    class MatrixUtil {
      constructor() {
      }
      // Set all cells to -1 (TYPESCRIPTPORT: 255).  -1 (TYPESCRIPTPORT: 255) means that the cell is empty (not set yet).
      //
      // JAVAPORT: We shouldn't need to do this at all. The code should be rewritten to begin encoding
      // with the ByteMatrix initialized all to zero.
      static clearMatrix(matrix) {
        matrix.clear(
          /*(byte) */
          /*-1*/
          255
        );
      }
      // Build 2D matrix of QR Code from "dataBits" with "ecLevel", "version" and "getMaskPattern". On
      // success, store the result in "matrix" and return true.
      static buildMatrix(dataBits, ecLevel, version, maskPattern, matrix) {
        MatrixUtil.clearMatrix(matrix);
        MatrixUtil.embedBasicPatterns(version, matrix);
        MatrixUtil.embedTypeInfo(ecLevel, maskPattern, matrix);
        MatrixUtil.maybeEmbedVersionInfo(version, matrix);
        MatrixUtil.embedDataBits(dataBits, maskPattern, matrix);
      }
      // Embed basic patterns. On success, modify the matrix and return true.
      // The basic patterns are:
      // - Position detection patterns
      // - Timing patterns
      // - Dark dot at the left bottom corner
      // - Position adjustment patterns, if need be
      static embedBasicPatterns(version, matrix) {
        MatrixUtil.embedPositionDetectionPatternsAndSeparators(matrix);
        MatrixUtil.embedDarkDotAtLeftBottomCorner(matrix);
        MatrixUtil.maybeEmbedPositionAdjustmentPatterns(version, matrix);
        MatrixUtil.embedTimingPatterns(matrix);
      }
      // Embed type information. On success, modify the matrix.
      static embedTypeInfo(ecLevel, maskPattern, matrix) {
        const typeInfoBits = new BitArray();
        MatrixUtil.makeTypeInfoBits(ecLevel, maskPattern, typeInfoBits);
        for (let i3 = 0, size2 = typeInfoBits.getSize(); i3 < size2; ++i3) {
          const bit = typeInfoBits.get(typeInfoBits.getSize() - 1 - i3);
          const coordinates = MatrixUtil.TYPE_INFO_COORDINATES[i3];
          const x1 = coordinates[0];
          const y1 = coordinates[1];
          matrix.setBoolean(x1, y1, bit);
          if (i3 < 8) {
            const x22 = matrix.getWidth() - i3 - 1;
            const y22 = 8;
            matrix.setBoolean(x22, y22, bit);
          } else {
            const x22 = 8;
            const y22 = matrix.getHeight() - 7 + (i3 - 8);
            matrix.setBoolean(x22, y22, bit);
          }
        }
      }
      // Embed version information if need be. On success, modify the matrix and return true.
      // See 8.10 of JISX0510:2004 (p.47) for how to embed version information.
      static maybeEmbedVersionInfo(version, matrix) {
        if (version.getVersionNumber() < 7) {
          return;
        }
        const versionInfoBits = new BitArray();
        MatrixUtil.makeVersionInfoBits(version, versionInfoBits);
        let bitIndex = 6 * 3 - 1;
        for (let i3 = 0; i3 < 6; ++i3) {
          for (let j2 = 0; j2 < 3; ++j2) {
            const bit = versionInfoBits.get(bitIndex);
            bitIndex--;
            matrix.setBoolean(i3, matrix.getHeight() - 11 + j2, bit);
            matrix.setBoolean(matrix.getHeight() - 11 + j2, i3, bit);
          }
        }
      }
      // Embed "dataBits" using "getMaskPattern". On success, modify the matrix and return true.
      // For debugging purposes, it skips masking process if "getMaskPattern" is -1(TYPESCRIPTPORT: 255).
      // See 8.7 of JISX0510:2004 (p.38) for how to embed data bits.
      static embedDataBits(dataBits, maskPattern, matrix) {
        let bitIndex = 0;
        let direction = -1;
        let x3 = matrix.getWidth() - 1;
        let y4 = matrix.getHeight() - 1;
        while (x3 > 0) {
          if (x3 === 6) {
            x3 -= 1;
          }
          while (y4 >= 0 && y4 < matrix.getHeight()) {
            for (let i3 = 0; i3 < 2; ++i3) {
              const xx = x3 - i3;
              if (!MatrixUtil.isEmpty(matrix.get(xx, y4))) {
                continue;
              }
              let bit;
              if (bitIndex < dataBits.getSize()) {
                bit = dataBits.get(bitIndex);
                ++bitIndex;
              } else {
                bit = false;
              }
              if (maskPattern !== 255 && MaskUtil.getDataMaskBit(maskPattern, xx, y4)) {
                bit = !bit;
              }
              matrix.setBoolean(xx, y4, bit);
            }
            y4 += direction;
          }
          direction = -direction;
          y4 += direction;
          x3 -= 2;
        }
        if (bitIndex !== dataBits.getSize()) {
          throw new WriterException("Not all bits consumed: " + bitIndex + "/" + dataBits.getSize());
        }
      }
      // Return the position of the most significant bit set (one: to) in the "value". The most
      // significant bit is position 32. If there is no bit set, return 0. Examples:
      // - findMSBSet(0) => 0
      // - findMSBSet(1) => 1
      // - findMSBSet(255) => 8
      static findMSBSet(value) {
        return 32 - Integer.numberOfLeadingZeros(value);
      }
      // Calculate BCH (Bose-Chaudhuri-Hocquenghem) code for "value" using polynomial "poly". The BCH
      // code is used for encoding type information and version information.
      // Example: Calculation of version information of 7.
      // f(x) is created from 7.
      //   - 7 = 000111 in 6 bits
      //   - f(x) = x^2 + x^1 + x^0
      // g(x) is given by the standard (p. 67)
      //   - g(x) = x^12 + x^11 + x^10 + x^9 + x^8 + x^5 + x^2 + 1
      // Multiply f(x) by x^(18 - 6)
      //   - f'(x) = f(x) * x^(18 - 6)
      //   - f'(x) = x^14 + x^13 + x^12
      // Calculate the remainder of f'(x) / g(x)
      //         x^2
      //         __________________________________________________
      //   g(x) )x^14 + x^13 + x^12
      //         x^14 + x^13 + x^12 + x^11 + x^10 + x^7 + x^4 + x^2
      //         --------------------------------------------------
      //                              x^11 + x^10 + x^7 + x^4 + x^2
      //
      // The remainder is x^11 + x^10 + x^7 + x^4 + x^2
      // Encode it in binary: 110010010100
      // The return value is 0xc94 (1100 1001 0100)
      //
      // Since all coefficients in the polynomials are 1 or 0, we can do the calculation by bit
      // operations. We don't care if coefficients are positive or negative.
      static calculateBCHCode(value, poly) {
        if (poly === 0) {
          throw new IllegalArgumentException("0 polynomial");
        }
        const msbSetInPoly = MatrixUtil.findMSBSet(poly);
        value <<= msbSetInPoly - 1;
        while (MatrixUtil.findMSBSet(value) >= msbSetInPoly) {
          value ^= poly << MatrixUtil.findMSBSet(value) - msbSetInPoly;
        }
        return value;
      }
      // Make bit vector of type information. On success, store the result in "bits" and return true.
      // Encode error correction level and mask pattern. See 8.9 of
      // JISX0510:2004 (p.45) for details.
      static makeTypeInfoBits(ecLevel, maskPattern, bits) {
        if (!QRCode.isValidMaskPattern(maskPattern)) {
          throw new WriterException("Invalid mask pattern");
        }
        const typeInfo = ecLevel.getBits() << 3 | maskPattern;
        bits.appendBits(typeInfo, 5);
        const bchCode = MatrixUtil.calculateBCHCode(typeInfo, MatrixUtil.TYPE_INFO_POLY);
        bits.appendBits(bchCode, 10);
        const maskBits = new BitArray();
        maskBits.appendBits(MatrixUtil.TYPE_INFO_MASK_PATTERN, 15);
        bits.xor(maskBits);
        if (bits.getSize() !== 15) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      // Make bit vector of version information. On success, store the result in "bits" and return true.
      // See 8.10 of JISX0510:2004 (p.45) for details.
      static makeVersionInfoBits(version, bits) {
        bits.appendBits(version.getVersionNumber(), 6);
        const bchCode = MatrixUtil.calculateBCHCode(version.getVersionNumber(), MatrixUtil.VERSION_INFO_POLY);
        bits.appendBits(bchCode, 12);
        if (bits.getSize() !== 18) {
          throw new WriterException("should not happen but we got: " + bits.getSize());
        }
      }
      // Check if "value" is empty.
      static isEmpty(value) {
        return value === 255;
      }
      static embedTimingPatterns(matrix) {
        for (let i3 = 8; i3 < matrix.getWidth() - 8; ++i3) {
          const bit = (i3 + 1) % 2;
          if (MatrixUtil.isEmpty(matrix.get(i3, 6))) {
            matrix.setNumber(i3, 6, bit);
          }
          if (MatrixUtil.isEmpty(matrix.get(6, i3))) {
            matrix.setNumber(6, i3, bit);
          }
        }
      }
      // Embed the lonely dark dot at left bottom corner. JISX0510:2004 (p.46)
      static embedDarkDotAtLeftBottomCorner(matrix) {
        if (matrix.get(8, matrix.getHeight() - 8) === 0) {
          throw new WriterException();
        }
        matrix.setNumber(8, matrix.getHeight() - 8, 1);
      }
      static embedHorizontalSeparationPattern(xStart, yStart, matrix) {
        for (let x3 = 0; x3 < 8; ++x3) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart + x3, yStart))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart + x3, yStart, 0);
        }
      }
      static embedVerticalSeparationPattern(xStart, yStart, matrix) {
        for (let y4 = 0; y4 < 7; ++y4) {
          if (!MatrixUtil.isEmpty(matrix.get(xStart, yStart + y4))) {
            throw new WriterException();
          }
          matrix.setNumber(xStart, yStart + y4, 0);
        }
      }
      static embedPositionAdjustmentPattern(xStart, yStart, matrix) {
        for (let y4 = 0; y4 < 5; ++y4) {
          const patternY = MatrixUtil.POSITION_ADJUSTMENT_PATTERN[y4];
          for (let x3 = 0; x3 < 5; ++x3) {
            matrix.setNumber(xStart + x3, yStart + y4, patternY[x3]);
          }
        }
      }
      static embedPositionDetectionPattern(xStart, yStart, matrix) {
        for (let y4 = 0; y4 < 7; ++y4) {
          const patternY = MatrixUtil.POSITION_DETECTION_PATTERN[y4];
          for (let x3 = 0; x3 < 7; ++x3) {
            matrix.setNumber(xStart + x3, yStart + y4, patternY[x3]);
          }
        }
      }
      // Embed position detection patterns and surrounding vertical/horizontal separators.
      static embedPositionDetectionPatternsAndSeparators(matrix) {
        const pdpWidth = MatrixUtil.POSITION_DETECTION_PATTERN[0].length;
        MatrixUtil.embedPositionDetectionPattern(0, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(matrix.getWidth() - pdpWidth, 0, matrix);
        MatrixUtil.embedPositionDetectionPattern(0, matrix.getWidth() - pdpWidth, matrix);
        const hspWidth = 8;
        MatrixUtil.embedHorizontalSeparationPattern(0, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(matrix.getWidth() - hspWidth, hspWidth - 1, matrix);
        MatrixUtil.embedHorizontalSeparationPattern(0, matrix.getWidth() - hspWidth, matrix);
        const vspSize = 7;
        MatrixUtil.embedVerticalSeparationPattern(vspSize, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(matrix.getHeight() - vspSize - 1, 0, matrix);
        MatrixUtil.embedVerticalSeparationPattern(vspSize, matrix.getHeight() - vspSize, matrix);
      }
      // Embed position adjustment patterns if need be.
      static maybeEmbedPositionAdjustmentPatterns(version, matrix) {
        if (version.getVersionNumber() < 2) {
          return;
        }
        const index2 = version.getVersionNumber() - 1;
        const coordinates = MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE[index2];
        for (let i3 = 0, length = coordinates.length; i3 !== length; i3++) {
          const y4 = coordinates[i3];
          if (y4 >= 0) {
            for (let j2 = 0; j2 !== length; j2++) {
              const x3 = coordinates[j2];
              if (x3 >= 0 && MatrixUtil.isEmpty(matrix.get(x3, y4))) {
                MatrixUtil.embedPositionAdjustmentPattern(x3 - 2, y4 - 2, matrix);
              }
            }
          }
        }
      }
    }
    MatrixUtil.POSITION_DETECTION_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 1, 1, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN = Array.from([
      Int32Array.from([1, 1, 1, 1, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 0, 1, 0, 1]),
      Int32Array.from([1, 0, 0, 0, 1]),
      Int32Array.from([1, 1, 1, 1, 1])
    ]);
    MatrixUtil.POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE = Array.from([
      Int32Array.from([-1, -1, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 18, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 26, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 30, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 34, -1, -1, -1, -1, -1]),
      Int32Array.from([6, 22, 38, -1, -1, -1, -1]),
      Int32Array.from([6, 24, 42, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, -1, -1, -1, -1]),
      Int32Array.from([6, 28, 50, -1, -1, -1, -1]),
      Int32Array.from([6, 30, 54, -1, -1, -1, -1]),
      Int32Array.from([6, 32, 58, -1, -1, -1, -1]),
      Int32Array.from([6, 34, 62, -1, -1, -1, -1]),
      Int32Array.from([6, 26, 46, 66, -1, -1, -1]),
      Int32Array.from([6, 26, 48, 70, -1, -1, -1]),
      Int32Array.from([6, 26, 50, 74, -1, -1, -1]),
      Int32Array.from([6, 30, 54, 78, -1, -1, -1]),
      Int32Array.from([6, 30, 56, 82, -1, -1, -1]),
      Int32Array.from([6, 30, 58, 86, -1, -1, -1]),
      Int32Array.from([6, 34, 62, 90, -1, -1, -1]),
      Int32Array.from([6, 28, 50, 72, 94, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, -1, -1]),
      Int32Array.from([6, 30, 54, 78, 102, -1, -1]),
      Int32Array.from([6, 28, 54, 80, 106, -1, -1]),
      Int32Array.from([6, 32, 58, 84, 110, -1, -1]),
      Int32Array.from([6, 30, 58, 86, 114, -1, -1]),
      Int32Array.from([6, 34, 62, 90, 118, -1, -1]),
      Int32Array.from([6, 26, 50, 74, 98, 122, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, -1]),
      Int32Array.from([6, 26, 52, 78, 104, 130, -1]),
      Int32Array.from([6, 30, 56, 82, 108, 134, -1]),
      Int32Array.from([6, 34, 60, 86, 112, 138, -1]),
      Int32Array.from([6, 30, 58, 86, 114, 142, -1]),
      Int32Array.from([6, 34, 62, 90, 118, 146, -1]),
      Int32Array.from([6, 30, 54, 78, 102, 126, 150]),
      Int32Array.from([6, 24, 50, 76, 102, 128, 154]),
      Int32Array.from([6, 28, 54, 80, 106, 132, 158]),
      Int32Array.from([6, 32, 58, 84, 110, 136, 162]),
      Int32Array.from([6, 26, 54, 82, 110, 138, 166]),
      Int32Array.from([6, 30, 58, 86, 114, 142, 170])
    ]);
    MatrixUtil.TYPE_INFO_COORDINATES = Array.from([
      Int32Array.from([8, 0]),
      Int32Array.from([8, 1]),
      Int32Array.from([8, 2]),
      Int32Array.from([8, 3]),
      Int32Array.from([8, 4]),
      Int32Array.from([8, 5]),
      Int32Array.from([8, 7]),
      Int32Array.from([8, 8]),
      Int32Array.from([7, 8]),
      Int32Array.from([5, 8]),
      Int32Array.from([4, 8]),
      Int32Array.from([3, 8]),
      Int32Array.from([2, 8]),
      Int32Array.from([1, 8]),
      Int32Array.from([0, 8])
    ]);
    MatrixUtil.VERSION_INFO_POLY = 7973;
    MatrixUtil.TYPE_INFO_POLY = 1335;
    MatrixUtil.TYPE_INFO_MASK_PATTERN = 21522;
    class BlockPair {
      constructor(dataBytes, errorCorrectionBytes) {
        this.dataBytes = dataBytes;
        this.errorCorrectionBytes = errorCorrectionBytes;
      }
      getDataBytes() {
        return this.dataBytes;
      }
      getErrorCorrectionBytes() {
        return this.errorCorrectionBytes;
      }
    }
    class Encoder {
      // TYPESCRIPTPORT: changed to UTF8, the default for js
      constructor() {
      }
      // The mask penalty calculation is complicated.  See Table 21 of JISX0510:2004 (p.45) for details.
      // Basically it applies four rules and summate all penalties.
      static calculateMaskPenalty(matrix) {
        return MaskUtil.applyMaskPenaltyRule1(matrix) + MaskUtil.applyMaskPenaltyRule2(matrix) + MaskUtil.applyMaskPenaltyRule3(matrix) + MaskUtil.applyMaskPenaltyRule4(matrix);
      }
      /**
       * @param content text to encode
       * @param ecLevel error correction level to use
       * @return {@link QRCode} representing the encoded QR code
       * @throws WriterException if encoding can't succeed, because of for example invalid content
       *   or configuration
       */
      // public static encode(content: string, ecLevel: ErrorCorrectionLevel): QRCode /*throws WriterException*/ {
      //   return encode(content, ecLevel, null)
      // }
      static encode(content, ecLevel, hints = null) {
        let encoding = Encoder.DEFAULT_BYTE_MODE_ENCODING;
        const hasEncodingHint = hints !== null && void 0 !== hints.get(EncodeHintType$1.CHARACTER_SET);
        if (hasEncodingHint) {
          encoding = hints.get(EncodeHintType$1.CHARACTER_SET).toString();
        }
        const mode = this.chooseMode(content, encoding);
        const headerBits = new BitArray();
        if (mode === Mode$1.BYTE && (hasEncodingHint || Encoder.DEFAULT_BYTE_MODE_ENCODING !== encoding)) {
          const eci = CharacterSetECI.getCharacterSetECIByName(encoding);
          if (eci !== void 0) {
            this.appendECI(eci, headerBits);
          }
        }
        this.appendModeInfo(mode, headerBits);
        const dataBits = new BitArray();
        this.appendBytes(content, mode, dataBits, encoding);
        let version;
        if (hints !== null && void 0 !== hints.get(EncodeHintType$1.QR_VERSION)) {
          const versionNumber = Number.parseInt(hints.get(EncodeHintType$1.QR_VERSION).toString(), 10);
          version = Version$1.getVersionForNumber(versionNumber);
          const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, version);
          if (!this.willFit(bitsNeeded, version, ecLevel)) {
            throw new WriterException("Data too big for requested version");
          }
        } else {
          version = this.recommendVersion(ecLevel, mode, headerBits, dataBits);
        }
        const headerAndDataBits = new BitArray();
        headerAndDataBits.appendBitArray(headerBits);
        const numLetters = mode === Mode$1.BYTE ? dataBits.getSizeInBytes() : content.length;
        this.appendLengthInfo(numLetters, version, mode, headerAndDataBits);
        headerAndDataBits.appendBitArray(dataBits);
        const ecBlocks = version.getECBlocksForLevel(ecLevel);
        const numDataBytes = version.getTotalCodewords() - ecBlocks.getTotalECCodewords();
        this.terminateBits(numDataBytes, headerAndDataBits);
        const finalBits = this.interleaveWithECBytes(headerAndDataBits, version.getTotalCodewords(), numDataBytes, ecBlocks.getNumBlocks());
        const qrCode = new QRCode();
        qrCode.setECLevel(ecLevel);
        qrCode.setMode(mode);
        qrCode.setVersion(version);
        const dimension = version.getDimensionForVersion();
        const matrix = new ByteMatrix(dimension, dimension);
        const maskPattern = this.chooseMaskPattern(finalBits, ecLevel, version, matrix);
        qrCode.setMaskPattern(maskPattern);
        MatrixUtil.buildMatrix(finalBits, ecLevel, version, maskPattern, matrix);
        qrCode.setMatrix(matrix);
        return qrCode;
      }
      /**
       * Decides the smallest version of QR code that will contain all of the provided data.
       *
       * @throws WriterException if the data cannot fit in any version
       */
      static recommendVersion(ecLevel, mode, headerBits, dataBits) {
        const provisionalBitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, Version$1.getVersionForNumber(1));
        const provisionalVersion = this.chooseVersion(provisionalBitsNeeded, ecLevel);
        const bitsNeeded = this.calculateBitsNeeded(mode, headerBits, dataBits, provisionalVersion);
        return this.chooseVersion(bitsNeeded, ecLevel);
      }
      static calculateBitsNeeded(mode, headerBits, dataBits, version) {
        return headerBits.getSize() + mode.getCharacterCountBits(version) + dataBits.getSize();
      }
      /**
       * @return the code point of the table used in alphanumeric mode or
       *  -1 if there is no corresponding code in the table.
       */
      static getAlphanumericCode(code) {
        if (code < Encoder.ALPHANUMERIC_TABLE.length) {
          return Encoder.ALPHANUMERIC_TABLE[code];
        }
        return -1;
      }
      // public static chooseMode(content: string): Mode {
      //   return chooseMode(content, null);
      // }
      /**
       * Choose the best mode by examining the content. Note that 'encoding' is used as a hint;
       * if it is Shift_JIS, and the input is only double-byte Kanji, then we return {@link Mode#KANJI}.
       */
      static chooseMode(content, encoding = null) {
        if (CharacterSetECI.SJIS.getName() === encoding && this.isOnlyDoubleByteKanji(content)) {
          return Mode$1.KANJI;
        }
        let hasNumeric = false;
        let hasAlphanumeric = false;
        for (let i3 = 0, length = content.length; i3 < length; ++i3) {
          const c3 = content.charAt(i3);
          if (Encoder.isDigit(c3)) {
            hasNumeric = true;
          } else if (this.getAlphanumericCode(c3.charCodeAt(0)) !== -1) {
            hasAlphanumeric = true;
          } else {
            return Mode$1.BYTE;
          }
        }
        if (hasAlphanumeric) {
          return Mode$1.ALPHANUMERIC;
        }
        if (hasNumeric) {
          return Mode$1.NUMERIC;
        }
        return Mode$1.BYTE;
      }
      static isOnlyDoubleByteKanji(content) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (ignored) {
          return false;
        }
        const length = bytes.length;
        if (length % 2 !== 0) {
          return false;
        }
        for (let i3 = 0; i3 < length; i3 += 2) {
          const byte1 = bytes[i3] & 255;
          if ((byte1 < 129 || byte1 > 159) && (byte1 < 224 || byte1 > 235)) {
            return false;
          }
        }
        return true;
      }
      static chooseMaskPattern(bits, ecLevel, version, matrix) {
        let minPenalty = Number.MAX_SAFE_INTEGER;
        let bestMaskPattern = -1;
        for (let maskPattern = 0; maskPattern < QRCode.NUM_MASK_PATTERNS; maskPattern++) {
          MatrixUtil.buildMatrix(bits, ecLevel, version, maskPattern, matrix);
          let penalty = this.calculateMaskPenalty(matrix);
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestMaskPattern = maskPattern;
          }
        }
        return bestMaskPattern;
      }
      static chooseVersion(numInputBits, ecLevel) {
        for (let versionNum = 1; versionNum <= 40; versionNum++) {
          const version = Version$1.getVersionForNumber(versionNum);
          if (Encoder.willFit(numInputBits, version, ecLevel)) {
            return version;
          }
        }
        throw new WriterException("Data too big");
      }
      /**
       * @return true if the number of input bits will fit in a code with the specified version and
       * error correction level.
       */
      static willFit(numInputBits, version, ecLevel) {
        const numBytes = version.getTotalCodewords();
        const ecBlocks = version.getECBlocksForLevel(ecLevel);
        const numEcBytes = ecBlocks.getTotalECCodewords();
        const numDataBytes = numBytes - numEcBytes;
        const totalInputBytes = (numInputBits + 7) / 8;
        return numDataBytes >= totalInputBytes;
      }
      /**
       * Terminate bits as described in 8.4.8 and 8.4.9 of JISX0510:2004 (p.24).
       */
      static terminateBits(numDataBytes, bits) {
        const capacity = numDataBytes * 8;
        if (bits.getSize() > capacity) {
          throw new WriterException("data bits cannot fit in the QR Code" + bits.getSize() + " > " + capacity);
        }
        for (let i3 = 0; i3 < 4 && bits.getSize() < capacity; ++i3) {
          bits.appendBit(false);
        }
        const numBitsInLastByte = bits.getSize() & 7;
        if (numBitsInLastByte > 0) {
          for (let i3 = numBitsInLastByte; i3 < 8; i3++) {
            bits.appendBit(false);
          }
        }
        const numPaddingBytes = numDataBytes - bits.getSizeInBytes();
        for (let i3 = 0; i3 < numPaddingBytes; ++i3) {
          bits.appendBits((i3 & 1) === 0 ? 236 : 17, 8);
        }
        if (bits.getSize() !== capacity) {
          throw new WriterException("Bits size does not equal capacity");
        }
      }
      /**
       * Get number of data bytes and number of error correction bytes for block id "blockID". Store
       * the result in "numDataBytesInBlock", and "numECBytesInBlock". See table 12 in 8.5.1 of
       * JISX0510:2004 (p.30)
       */
      static getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, blockID, numDataBytesInBlock, numECBytesInBlock) {
        if (blockID >= numRSBlocks) {
          throw new WriterException("Block ID too large");
        }
        const numRsBlocksInGroup2 = numTotalBytes % numRSBlocks;
        const numRsBlocksInGroup1 = numRSBlocks - numRsBlocksInGroup2;
        const numTotalBytesInGroup1 = Math.floor(numTotalBytes / numRSBlocks);
        const numTotalBytesInGroup2 = numTotalBytesInGroup1 + 1;
        const numDataBytesInGroup1 = Math.floor(numDataBytes / numRSBlocks);
        const numDataBytesInGroup2 = numDataBytesInGroup1 + 1;
        const numEcBytesInGroup1 = numTotalBytesInGroup1 - numDataBytesInGroup1;
        const numEcBytesInGroup2 = numTotalBytesInGroup2 - numDataBytesInGroup2;
        if (numEcBytesInGroup1 !== numEcBytesInGroup2) {
          throw new WriterException("EC bytes mismatch");
        }
        if (numRSBlocks !== numRsBlocksInGroup1 + numRsBlocksInGroup2) {
          throw new WriterException("RS blocks mismatch");
        }
        if (numTotalBytes !== (numDataBytesInGroup1 + numEcBytesInGroup1) * numRsBlocksInGroup1 + (numDataBytesInGroup2 + numEcBytesInGroup2) * numRsBlocksInGroup2) {
          throw new WriterException("Total bytes mismatch");
        }
        if (blockID < numRsBlocksInGroup1) {
          numDataBytesInBlock[0] = numDataBytesInGroup1;
          numECBytesInBlock[0] = numEcBytesInGroup1;
        } else {
          numDataBytesInBlock[0] = numDataBytesInGroup2;
          numECBytesInBlock[0] = numEcBytesInGroup2;
        }
      }
      /**
       * Interleave "bits" with corresponding error correction bytes. On success, store the result in
       * "result". The interleave rule is complicated. See 8.6 of JISX0510:2004 (p.37) for details.
       */
      static interleaveWithECBytes(bits, numTotalBytes, numDataBytes, numRSBlocks) {
        if (bits.getSizeInBytes() !== numDataBytes) {
          throw new WriterException("Number of bits and data bytes does not match");
        }
        let dataBytesOffset = 0;
        let maxNumDataBytes = 0;
        let maxNumEcBytes = 0;
        const blocks = new Array();
        for (let i3 = 0; i3 < numRSBlocks; ++i3) {
          const numDataBytesInBlock = new Int32Array(1);
          const numEcBytesInBlock = new Int32Array(1);
          Encoder.getNumDataBytesAndNumECBytesForBlockID(numTotalBytes, numDataBytes, numRSBlocks, i3, numDataBytesInBlock, numEcBytesInBlock);
          const size2 = numDataBytesInBlock[0];
          const dataBytes = new Uint8Array(size2);
          bits.toBytes(8 * dataBytesOffset, dataBytes, 0, size2);
          const ecBytes = Encoder.generateECBytes(dataBytes, numEcBytesInBlock[0]);
          blocks.push(new BlockPair(dataBytes, ecBytes));
          maxNumDataBytes = Math.max(maxNumDataBytes, size2);
          maxNumEcBytes = Math.max(maxNumEcBytes, ecBytes.length);
          dataBytesOffset += numDataBytesInBlock[0];
        }
        if (numDataBytes !== dataBytesOffset) {
          throw new WriterException("Data bytes does not match offset");
        }
        const result = new BitArray();
        for (let i3 = 0; i3 < maxNumDataBytes; ++i3) {
          for (const block of blocks) {
            const dataBytes = block.getDataBytes();
            if (i3 < dataBytes.length) {
              result.appendBits(dataBytes[i3], 8);
            }
          }
        }
        for (let i3 = 0; i3 < maxNumEcBytes; ++i3) {
          for (const block of blocks) {
            const ecBytes = block.getErrorCorrectionBytes();
            if (i3 < ecBytes.length) {
              result.appendBits(ecBytes[i3], 8);
            }
          }
        }
        if (numTotalBytes !== result.getSizeInBytes()) {
          throw new WriterException("Interleaving error: " + numTotalBytes + " and " + result.getSizeInBytes() + " differ.");
        }
        return result;
      }
      static generateECBytes(dataBytes, numEcBytesInBlock) {
        const numDataBytes = dataBytes.length;
        const toEncode = new Int32Array(numDataBytes + numEcBytesInBlock);
        for (let i3 = 0; i3 < numDataBytes; i3++) {
          toEncode[i3] = dataBytes[i3] & 255;
        }
        new ReedSolomonEncoder(GenericGF.QR_CODE_FIELD_256).encode(toEncode, numEcBytesInBlock);
        const ecBytes = new Uint8Array(numEcBytesInBlock);
        for (let i3 = 0; i3 < numEcBytesInBlock; i3++) {
          ecBytes[i3] = /*(byte) */
          toEncode[numDataBytes + i3];
        }
        return ecBytes;
      }
      /**
       * Append mode info. On success, store the result in "bits".
       */
      static appendModeInfo(mode, bits) {
        bits.appendBits(mode.getBits(), 4);
      }
      /**
       * Append length info. On success, store the result in "bits".
       */
      static appendLengthInfo(numLetters, version, mode, bits) {
        const numBits = mode.getCharacterCountBits(version);
        if (numLetters >= 1 << numBits) {
          throw new WriterException(numLetters + " is bigger than " + ((1 << numBits) - 1));
        }
        bits.appendBits(numLetters, numBits);
      }
      /**
       * Append "bytes" in "mode" mode (encoding) into "bits". On success, store the result in "bits".
       */
      static appendBytes(content, mode, bits, encoding) {
        switch (mode) {
          case Mode$1.NUMERIC:
            Encoder.appendNumericBytes(content, bits);
            break;
          case Mode$1.ALPHANUMERIC:
            Encoder.appendAlphanumericBytes(content, bits);
            break;
          case Mode$1.BYTE:
            Encoder.append8BitBytes(content, bits, encoding);
            break;
          case Mode$1.KANJI:
            Encoder.appendKanjiBytes(content, bits);
            break;
          default:
            throw new WriterException("Invalid mode: " + mode);
        }
      }
      static getDigit(singleCharacter) {
        return singleCharacter.charCodeAt(0) - 48;
      }
      static isDigit(singleCharacter) {
        const cn2 = Encoder.getDigit(singleCharacter);
        return cn2 >= 0 && cn2 <= 9;
      }
      static appendNumericBytes(content, bits) {
        const length = content.length;
        let i3 = 0;
        while (i3 < length) {
          const num1 = Encoder.getDigit(content.charAt(i3));
          if (i3 + 2 < length) {
            const num2 = Encoder.getDigit(content.charAt(i3 + 1));
            const num3 = Encoder.getDigit(content.charAt(i3 + 2));
            bits.appendBits(num1 * 100 + num2 * 10 + num3, 10);
            i3 += 3;
          } else if (i3 + 1 < length) {
            const num2 = Encoder.getDigit(content.charAt(i3 + 1));
            bits.appendBits(num1 * 10 + num2, 7);
            i3 += 2;
          } else {
            bits.appendBits(num1, 4);
            i3++;
          }
        }
      }
      static appendAlphanumericBytes(content, bits) {
        const length = content.length;
        let i3 = 0;
        while (i3 < length) {
          const code1 = Encoder.getAlphanumericCode(content.charCodeAt(i3));
          if (code1 === -1) {
            throw new WriterException();
          }
          if (i3 + 1 < length) {
            const code2 = Encoder.getAlphanumericCode(content.charCodeAt(i3 + 1));
            if (code2 === -1) {
              throw new WriterException();
            }
            bits.appendBits(code1 * 45 + code2, 11);
            i3 += 2;
          } else {
            bits.appendBits(code1, 6);
            i3++;
          }
        }
      }
      static append8BitBytes(content, bits, encoding) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, encoding);
        } catch (uee) {
          throw new WriterException(uee);
        }
        for (let i3 = 0, length = bytes.length; i3 !== length; i3++) {
          const b2 = bytes[i3];
          bits.appendBits(b2, 8);
        }
      }
      /**
       * @throws WriterException
       */
      static appendKanjiBytes(content, bits) {
        let bytes;
        try {
          bytes = StringEncoding.encode(content, CharacterSetECI.SJIS);
        } catch (uee) {
          throw new WriterException(uee);
        }
        const length = bytes.length;
        for (let i3 = 0; i3 < length; i3 += 2) {
          const byte1 = bytes[i3] & 255;
          const byte2 = bytes[i3 + 1] & 255;
          const code = byte1 << 8 & 4294967295 | byte2;
          let subtracted = -1;
          if (code >= 33088 && code <= 40956) {
            subtracted = code - 33088;
          } else if (code >= 57408 && code <= 60351) {
            subtracted = code - 49472;
          }
          if (subtracted === -1) {
            throw new WriterException("Invalid byte sequence");
          }
          const encoded = (subtracted >> 8) * 192 + (subtracted & 255);
          bits.appendBits(encoded, 13);
        }
      }
      static appendECI(eci, bits) {
        bits.appendBits(Mode$1.ECI.getBits(), 4);
        bits.appendBits(eci.getValue(), 8);
      }
    }
    Encoder.ALPHANUMERIC_TABLE = Int32Array.from([
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      36,
      -1,
      -1,
      -1,
      37,
      38,
      -1,
      -1,
      -1,
      -1,
      39,
      40,
      -1,
      41,
      42,
      43,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      44,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      -1,
      -1,
      -1,
      -1,
      -1
    ]);
    Encoder.DEFAULT_BYTE_MODE_ENCODING = CharacterSetECI.UTF8.getName();
    class BrowserQRCodeSvgWriter {
      /**
       * Writes and renders a QRCode SVG element.
       *
       * @param contents
       * @param width
       * @param height
       * @param hints
       */
      write(contents, width, height, hints = null) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException("Requested dimensions are too small: " + width + "x" + height);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return this.renderResult(code, width, height, quietZone);
      }
      /**
       * Renders the result and then appends it to the DOM.
       */
      writeToDom(containerElement, contents, width, height, hints = null) {
        if (typeof containerElement === "string") {
          containerElement = document.querySelector(containerElement);
        }
        const svgElement = this.write(contents, width, height, hints);
        if (containerElement)
          containerElement.appendChild(svgElement);
      }
      /**
       * Note that the input matrix uses 0 == white, 1 == black.
       * The output matrix uses 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
       */
      renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const svgElement = this.createSVGElement(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              const svgRectElement = this.createSvgRectElement(outputX, outputY, multiple, multiple);
              svgElement.appendChild(svgRectElement);
            }
          }
        }
        return svgElement;
      }
      /**
       * Creates a SVG element.
       *
       * @param w SVG's width attribute
       * @param h SVG's height attribute
       */
      createSVGElement(w3, h4) {
        const svgElement = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "svg");
        svgElement.setAttributeNS(null, "height", w3.toString());
        svgElement.setAttributeNS(null, "width", h4.toString());
        return svgElement;
      }
      /**
       * Creates a SVG rect element.
       *
       * @param x Element's x coordinate
       * @param y Element's y coordinate
       * @param w Element's width attribute
       * @param h Element's height attribute
       */
      createSvgRectElement(x3, y4, w3, h4) {
        const rect = document.createElementNS(BrowserQRCodeSvgWriter.SVG_NS, "rect");
        rect.setAttributeNS(null, "x", x3.toString());
        rect.setAttributeNS(null, "y", y4.toString());
        rect.setAttributeNS(null, "height", w3.toString());
        rect.setAttributeNS(null, "width", h4.toString());
        rect.setAttributeNS(null, "fill", "#000000");
        return rect;
      }
    }
    BrowserQRCodeSvgWriter.QUIET_ZONE_SIZE = 4;
    BrowserQRCodeSvgWriter.SVG_NS = "http://www.w3.org/2000/svg";
    class QRCodeWriter {
      /*@Override*/
      // public encode(contents: string, format: BarcodeFormat, width: number /*int*/, height: number /*int*/): BitMatrix
      //     /*throws WriterException */ {
      //   return encode(contents, format, width, height, null)
      // }
      /*@Override*/
      encode(contents, format2, width, height, hints) {
        if (contents.length === 0) {
          throw new IllegalArgumentException("Found empty contents");
        }
        if (format2 !== BarcodeFormat$1.QR_CODE) {
          throw new IllegalArgumentException("Can only encode QR_CODE, but got " + format2);
        }
        if (width < 0 || height < 0) {
          throw new IllegalArgumentException(`Requested dimensions are too small: ${width}x${height}`);
        }
        let errorCorrectionLevel = ErrorCorrectionLevel.L;
        let quietZone = QRCodeWriter.QUIET_ZONE_SIZE;
        if (hints !== null) {
          if (void 0 !== hints.get(EncodeHintType$1.ERROR_CORRECTION)) {
            errorCorrectionLevel = ErrorCorrectionLevel.fromString(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (void 0 !== hints.get(EncodeHintType$1.MARGIN)) {
            quietZone = Number.parseInt(hints.get(EncodeHintType$1.MARGIN).toString(), 10);
          }
        }
        const code = Encoder.encode(contents, errorCorrectionLevel, hints);
        return QRCodeWriter.renderResult(code, width, height, quietZone);
      }
      // Note that the input matrix uses 0 == white, 1 == black, while the output matrix uses
      // 0 == black, 255 == white (i.e. an 8 bit greyscale bitmap).
      static renderResult(code, width, height, quietZone) {
        const input = code.getMatrix();
        if (input === null) {
          throw new IllegalStateException();
        }
        const inputWidth = input.getWidth();
        const inputHeight = input.getHeight();
        const qrWidth = inputWidth + quietZone * 2;
        const qrHeight = inputHeight + quietZone * 2;
        const outputWidth = Math.max(width, qrWidth);
        const outputHeight = Math.max(height, qrHeight);
        const multiple = Math.min(Math.floor(outputWidth / qrWidth), Math.floor(outputHeight / qrHeight));
        const leftPadding = Math.floor((outputWidth - inputWidth * multiple) / 2);
        const topPadding = Math.floor((outputHeight - inputHeight * multiple) / 2);
        const output = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY) === 1) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      }
    }
    QRCodeWriter.QUIET_ZONE_SIZE = 4;
    class MultiFormatWriter {
      /*@Override*/
      // public encode(contents: string,
      //                         format: BarcodeFormat,
      //                         width: number /*int*/,
      //                         height: number /*int*/): BitMatrix /*throws WriterException */ {
      //   return encode(contents, format, width, height, null)
      // }
      /*@Override*/
      encode(contents, format2, width, height, hints) {
        let writer;
        switch (format2) {
          case BarcodeFormat$1.QR_CODE:
            writer = new QRCodeWriter();
            break;
          default:
            throw new IllegalArgumentException("No encoder available for format " + format2);
        }
        return writer.encode(contents, format2, width, height, hints);
      }
    }
    class PlanarYUVLuminanceSource extends LuminanceSource {
      constructor(yuvData, dataWidth, dataHeight, left, top, width, height, reverseHorizontal) {
        super(width, height);
        this.yuvData = yuvData;
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (left + width > dataWidth || top + height > dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
        if (reverseHorizontal) {
          this.reverseHorizontal(width, height);
        }
      }
      /*@Override*/
      getRow(y4, row) {
        if (y4 < 0 || y4 >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y4);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset2 = (y4 + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.yuvData, offset2, row, 0, width);
        return row;
      }
      /*@Override*/
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.yuvData;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.yuvData, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y4 = 0; y4 < height; y4++) {
          const outputOffset = y4 * width;
          System.arraycopy(this.yuvData, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      /*@Override*/
      isCropSupported() {
        return true;
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new PlanarYUVLuminanceSource(this.yuvData, this.dataWidth, this.dataHeight, this.left + left, this.top + top, width, height, false);
      }
      renderThumbnail() {
        const width = this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const height = this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        const pixels = new Int32Array(width * height);
        const yuv = this.yuvData;
        let inputOffset = this.top * this.dataWidth + this.left;
        for (let y4 = 0; y4 < height; y4++) {
          const outputOffset = y4 * width;
          for (let x3 = 0; x3 < width; x3++) {
            const grey = yuv[inputOffset + x3 * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR] & 255;
            pixels[outputOffset + x3] = 4278190080 | grey * 65793;
          }
          inputOffset += this.dataWidth * PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
        }
        return pixels;
      }
      /**
       * @return width of image from {@link #renderThumbnail()}
       */
      getThumbnailWidth() {
        return this.getWidth() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      /**
       * @return height of image from {@link #renderThumbnail()}
       */
      getThumbnailHeight() {
        return this.getHeight() / PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR;
      }
      reverseHorizontal(width, height) {
        const yuvData = this.yuvData;
        for (let y4 = 0, rowStart = this.top * this.dataWidth + this.left; y4 < height; y4++, rowStart += this.dataWidth) {
          const middle = rowStart + width / 2;
          for (let x1 = rowStart, x22 = rowStart + width - 1; x1 < middle; x1++, x22--) {
            const temp = yuvData[x1];
            yuvData[x1] = yuvData[x22];
            yuvData[x22] = temp;
          }
        }
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    PlanarYUVLuminanceSource.THUMBNAIL_SCALE_FACTOR = 2;
    class RGBLuminanceSource extends LuminanceSource {
      constructor(luminances, width, height, dataWidth, dataHeight, left, top) {
        super(width, height);
        this.dataWidth = dataWidth;
        this.dataHeight = dataHeight;
        this.left = left;
        this.top = top;
        if (luminances.BYTES_PER_ELEMENT === 4) {
          const size2 = width * height;
          const luminancesUint8Array = new Uint8ClampedArray(size2);
          for (let offset2 = 0; offset2 < size2; offset2++) {
            const pixel = luminances[offset2];
            const r2 = pixel >> 16 & 255;
            const g2 = pixel >> 7 & 510;
            const b2 = pixel & 255;
            luminancesUint8Array[offset2] = /*(byte) */
            (r2 + g2 + b2) / 4 & 255;
          }
          this.luminances = luminancesUint8Array;
        } else {
          this.luminances = luminances;
        }
        if (void 0 === dataWidth) {
          this.dataWidth = width;
        }
        if (void 0 === dataHeight) {
          this.dataHeight = height;
        }
        if (void 0 === left) {
          this.left = 0;
        }
        if (void 0 === top) {
          this.top = 0;
        }
        if (this.left + width > this.dataWidth || this.top + height > this.dataHeight) {
          throw new IllegalArgumentException("Crop rectangle does not fit within image data.");
        }
      }
      /*@Override*/
      getRow(y4, row) {
        if (y4 < 0 || y4 >= this.getHeight()) {
          throw new IllegalArgumentException("Requested row is outside the image: " + y4);
        }
        const width = this.getWidth();
        if (row === null || row === void 0 || row.length < width) {
          row = new Uint8ClampedArray(width);
        }
        const offset2 = (y4 + this.top) * this.dataWidth + this.left;
        System.arraycopy(this.luminances, offset2, row, 0, width);
        return row;
      }
      /*@Override*/
      getMatrix() {
        const width = this.getWidth();
        const height = this.getHeight();
        if (width === this.dataWidth && height === this.dataHeight) {
          return this.luminances;
        }
        const area = width * height;
        const matrix = new Uint8ClampedArray(area);
        let inputOffset = this.top * this.dataWidth + this.left;
        if (width === this.dataWidth) {
          System.arraycopy(this.luminances, inputOffset, matrix, 0, area);
          return matrix;
        }
        for (let y4 = 0; y4 < height; y4++) {
          const outputOffset = y4 * width;
          System.arraycopy(this.luminances, inputOffset, matrix, outputOffset, width);
          inputOffset += this.dataWidth;
        }
        return matrix;
      }
      /*@Override*/
      isCropSupported() {
        return true;
      }
      /*@Override*/
      crop(left, top, width, height) {
        return new RGBLuminanceSource(this.luminances, width, height, this.dataWidth, this.dataHeight, this.left + left, this.top + top);
      }
      invert() {
        return new InvertedLuminanceSource(this);
      }
    }
    class Charset extends CharacterSetECI {
      static forName(name) {
        return this.getCharacterSetECIByName(name);
      }
    }
    class StandardCharsets {
    }
    StandardCharsets.ISO_8859_1 = CharacterSetECI.ISO8859_1;
    class AztecCode {
      /**
       * @return {@code true} if compact instead of full mode
       */
      isCompact() {
        return this.compact;
      }
      setCompact(compact2) {
        this.compact = compact2;
      }
      /**
       * @return size in pixels (width and height)
       */
      getSize() {
        return this.size;
      }
      setSize(size2) {
        this.size = size2;
      }
      /**
       * @return number of levels
       */
      getLayers() {
        return this.layers;
      }
      setLayers(layers) {
        this.layers = layers;
      }
      /**
       * @return number of data codewords
       */
      getCodeWords() {
        return this.codeWords;
      }
      setCodeWords(codeWords) {
        this.codeWords = codeWords;
      }
      /**
       * @return the symbol image
       */
      getMatrix() {
        return this.matrix;
      }
      setMatrix(matrix) {
        this.matrix = matrix;
      }
    }
    class Collections {
      /**
       * The singletonList(T) method is used to return an immutable list containing only the specified object.
       */
      static singletonList(item) {
        return [item];
      }
      /**
       * The min(Collection<? extends T>, Comparator<? super T>) method is used to return the minimum element of the given collection, according to the order induced by the specified comparator.
       */
      static min(collection, comparator) {
        return collection.sort(comparator)[0];
      }
    }
    class Token {
      constructor(previous) {
        this.previous = previous;
      }
      getPrevious() {
        return this.previous;
      }
    }
    class SimpleToken extends Token {
      constructor(previous, value, bitCount) {
        super(previous);
        this.value = value;
        this.bitCount = bitCount;
      }
      /**
       * @Override
       */
      appendTo(bitArray, text) {
        bitArray.appendBits(this.value, this.bitCount);
      }
      add(value, bitCount) {
        return new SimpleToken(this, value, bitCount);
      }
      addBinaryShift(start, byteCount) {
        console.warn("addBinaryShift on SimpleToken, this simply returns a copy of this token");
        return new SimpleToken(this, start, byteCount);
      }
      /**
       * @Override
       */
      toString() {
        let value = this.value & (1 << this.bitCount) - 1;
        value |= 1 << this.bitCount;
        return "<" + Integer.toBinaryString(value | 1 << this.bitCount).substring(1) + ">";
      }
    }
    class BinaryShiftToken extends SimpleToken {
      constructor(previous, binaryShiftStart, binaryShiftByteCount) {
        super(previous, 0, 0);
        this.binaryShiftStart = binaryShiftStart;
        this.binaryShiftByteCount = binaryShiftByteCount;
      }
      /**
       * @Override
       */
      appendTo(bitArray, text) {
        for (let i3 = 0; i3 < this.binaryShiftByteCount; i3++) {
          if (i3 === 0 || i3 === 31 && this.binaryShiftByteCount <= 62) {
            bitArray.appendBits(31, 5);
            if (this.binaryShiftByteCount > 62) {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 16);
            } else if (i3 === 0) {
              bitArray.appendBits(Math.min(this.binaryShiftByteCount, 31), 5);
            } else {
              bitArray.appendBits(this.binaryShiftByteCount - 31, 5);
            }
          }
          bitArray.appendBits(text[this.binaryShiftStart + i3], 8);
        }
      }
      addBinaryShift(start, byteCount) {
        return new BinaryShiftToken(this, start, byteCount);
      }
      /**
       * @Override
       */
      toString() {
        return "<" + this.binaryShiftStart + "::" + (this.binaryShiftStart + this.binaryShiftByteCount - 1) + ">";
      }
    }
    function addBinaryShift(token, start, byteCount) {
      return new BinaryShiftToken(token, start, byteCount);
    }
    function add2(token, value, bitCount) {
      return new SimpleToken(token, value, bitCount);
    }
    const MODE_NAMES = [
      "UPPER",
      "LOWER",
      "DIGIT",
      "MIXED",
      "PUNCT"
    ];
    const MODE_UPPER = 0;
    const MODE_LOWER = 1;
    const MODE_DIGIT = 2;
    const MODE_MIXED = 3;
    const MODE_PUNCT = 4;
    const EMPTY_TOKEN = new SimpleToken(null, 0, 0);
    const LATCH_TABLE = [
      Int32Array.from([
        0,
        (5 << 16) + 28,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
        // UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (9 << 16) + (30 << 4) + 14,
        0,
        (5 << 16) + 30,
        (5 << 16) + 29,
        (10 << 16) + (29 << 5) + 30
        // LOWER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (4 << 16) + 14,
        (9 << 16) + (14 << 5) + 28,
        0,
        (9 << 16) + (14 << 5) + 29,
        (14 << 16) + (14 << 10) + (29 << 5) + 30
        // DIGIT -> UPPER -> MIXED -> PUNCT
      ]),
      Int32Array.from([
        (5 << 16) + 29,
        (5 << 16) + 28,
        (10 << 16) + (29 << 5) + 30,
        0,
        (5 << 16) + 30
        // MIXED -> PUNCT
      ]),
      Int32Array.from([
        (5 << 16) + 31,
        (10 << 16) + (31 << 5) + 28,
        (10 << 16) + (31 << 5) + 30,
        (10 << 16) + (31 << 5) + 29,
        0
      ])
    ];
    function static_SHIFT_TABLE(SHIFT_TABLE2) {
      for (let table of SHIFT_TABLE2) {
        Arrays.fill(table, -1);
      }
      SHIFT_TABLE2[MODE_UPPER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_LOWER][MODE_UPPER] = 28;
      SHIFT_TABLE2[MODE_MIXED][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_PUNCT] = 0;
      SHIFT_TABLE2[MODE_DIGIT][MODE_UPPER] = 15;
      return SHIFT_TABLE2;
    }
    const SHIFT_TABLE = static_SHIFT_TABLE(Arrays.createInt32Array(6, 6));
    class State {
      constructor(token, mode, binaryBytes, bitCount) {
        this.token = token;
        this.mode = mode;
        this.binaryShiftByteCount = binaryBytes;
        this.bitCount = bitCount;
      }
      getMode() {
        return this.mode;
      }
      getToken() {
        return this.token;
      }
      getBinaryShiftByteCount() {
        return this.binaryShiftByteCount;
      }
      getBitCount() {
        return this.bitCount;
      }
      // Create a new state representing this state with a latch to a (not
      // necessary different) mode, and then a code.
      latchAndAppend(mode, value) {
        let bitCount = this.bitCount;
        let token = this.token;
        if (mode !== this.mode) {
          let latch = LATCH_TABLE[this.mode][mode];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
        }
        let latchModeBitCount = mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, value, latchModeBitCount);
        return new State(token, mode, 0, bitCount + latchModeBitCount);
      }
      // Create a new state representing this state, with a temporary shift
      // to a different mode to output a single value.
      shiftAndAppend(mode, value) {
        let token = this.token;
        let thisModeBitCount = this.mode === MODE_DIGIT ? 4 : 5;
        token = add2(token, SHIFT_TABLE[this.mode][mode], thisModeBitCount);
        token = add2(token, value, 5);
        return new State(token, this.mode, 0, this.bitCount + thisModeBitCount + 5);
      }
      // Create a new state representing this state, but an additional character
      // output in Binary Shift mode.
      addBinaryShiftChar(index2) {
        let token = this.token;
        let mode = this.mode;
        let bitCount = this.bitCount;
        if (this.mode === MODE_PUNCT || this.mode === MODE_DIGIT) {
          let latch = LATCH_TABLE[mode][MODE_UPPER];
          token = add2(token, latch & 65535, latch >> 16);
          bitCount += latch >> 16;
          mode = MODE_UPPER;
        }
        let deltaBitCount = this.binaryShiftByteCount === 0 || this.binaryShiftByteCount === 31 ? 18 : this.binaryShiftByteCount === 62 ? 9 : 8;
        let result = new State(token, mode, this.binaryShiftByteCount + 1, bitCount + deltaBitCount);
        if (result.binaryShiftByteCount === 2047 + 31) {
          result = result.endBinaryShift(index2 + 1);
        }
        return result;
      }
      // Create the state identical to this one, but we are no longer in
      // Binary Shift mode.
      endBinaryShift(index2) {
        if (this.binaryShiftByteCount === 0) {
          return this;
        }
        let token = this.token;
        token = addBinaryShift(token, index2 - this.binaryShiftByteCount, this.binaryShiftByteCount);
        return new State(token, this.mode, 0, this.bitCount);
      }
      // Returns true if "this" state is better (equal: or) to be in than "that"
      // state under all possible circumstances.
      isBetterThanOrEqualTo(other) {
        let newModeBitCount = this.bitCount + (LATCH_TABLE[this.mode][other.mode] >> 16);
        if (this.binaryShiftByteCount < other.binaryShiftByteCount) {
          newModeBitCount += State.calculateBinaryShiftCost(other) - State.calculateBinaryShiftCost(this);
        } else if (this.binaryShiftByteCount > other.binaryShiftByteCount && other.binaryShiftByteCount > 0) {
          newModeBitCount += 10;
        }
        return newModeBitCount <= other.bitCount;
      }
      toBitArray(text) {
        let symbols = [];
        for (let token = this.endBinaryShift(text.length).token; token !== null; token = token.getPrevious()) {
          symbols.unshift(token);
        }
        let bitArray = new BitArray();
        for (const symbol of symbols) {
          symbol.appendTo(bitArray, text);
        }
        return bitArray;
      }
      /**
       * @Override
       */
      toString() {
        return StringUtils.format("%s bits=%d bytes=%d", MODE_NAMES[this.mode], this.bitCount, this.binaryShiftByteCount);
      }
      static calculateBinaryShiftCost(state) {
        if (state.binaryShiftByteCount > 62) {
          return 21;
        }
        if (state.binaryShiftByteCount > 31) {
          return 20;
        }
        if (state.binaryShiftByteCount > 0) {
          return 10;
        }
        return 0;
      }
    }
    State.INITIAL_STATE = new State(EMPTY_TOKEN, MODE_UPPER, 0, 0);
    function static_CHAR_MAP(CHAR_MAP2) {
      const spaceCharCode = StringUtils.getCharCode(" ");
      const pointCharCode = StringUtils.getCharCode(".");
      const commaCharCode = StringUtils.getCharCode(",");
      CHAR_MAP2[MODE_UPPER][spaceCharCode] = 1;
      const zUpperCharCode = StringUtils.getCharCode("Z");
      const aUpperCharCode = StringUtils.getCharCode("A");
      for (let c3 = aUpperCharCode; c3 <= zUpperCharCode; c3++) {
        CHAR_MAP2[MODE_UPPER][c3] = c3 - aUpperCharCode + 2;
      }
      CHAR_MAP2[MODE_LOWER][spaceCharCode] = 1;
      const zLowerCharCode = StringUtils.getCharCode("z");
      const aLowerCharCode = StringUtils.getCharCode("a");
      for (let c3 = aLowerCharCode; c3 <= zLowerCharCode; c3++) {
        CHAR_MAP2[MODE_LOWER][c3] = c3 - aLowerCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][spaceCharCode] = 1;
      const nineCharCode = StringUtils.getCharCode("9");
      const zeroCharCode = StringUtils.getCharCode("0");
      for (let c3 = zeroCharCode; c3 <= nineCharCode; c3++) {
        CHAR_MAP2[MODE_DIGIT][c3] = c3 - zeroCharCode + 2;
      }
      CHAR_MAP2[MODE_DIGIT][commaCharCode] = 12;
      CHAR_MAP2[MODE_DIGIT][pointCharCode] = 13;
      const mixedTable = [
        "\0",
        " ",
        "",
        "",
        "",
        "",
        "",
        "",
        "\x07",
        "\b",
        "	",
        "\n",
        "\v",
        "\f",
        "\r",
        "\x1B",
        "",
        "",
        "",
        "",
        "@",
        "\\",
        "^",
        "_",
        "`",
        "|",
        "~",
        ""
      ];
      for (let i3 = 0; i3 < mixedTable.length; i3++) {
        CHAR_MAP2[MODE_MIXED][StringUtils.getCharCode(mixedTable[i3])] = i3;
      }
      const punctTable = [
        "\0",
        "\r",
        "\0",
        "\0",
        "\0",
        "\0",
        "!",
        "'",
        "#",
        "$",
        "%",
        "&",
        "'",
        "(",
        ")",
        "*",
        "+",
        ",",
        "-",
        ".",
        "/",
        ":",
        ";",
        "<",
        "=",
        ">",
        "?",
        "[",
        "]",
        "{",
        "}"
      ];
      for (let i3 = 0; i3 < punctTable.length; i3++) {
        if (StringUtils.getCharCode(punctTable[i3]) > 0) {
          CHAR_MAP2[MODE_PUNCT][StringUtils.getCharCode(punctTable[i3])] = i3;
        }
      }
      return CHAR_MAP2;
    }
    const CHAR_MAP = static_CHAR_MAP(Arrays.createInt32Array(5, 256));
    class HighLevelEncoder {
      constructor(text) {
        this.text = text;
      }
      /**
       * @return text represented by this encoder encoded as a {@link BitArray}
       */
      encode() {
        const spaceCharCode = StringUtils.getCharCode(" ");
        const lineBreakCharCode = StringUtils.getCharCode("\n");
        let states = Collections.singletonList(State.INITIAL_STATE);
        for (let index2 = 0; index2 < this.text.length; index2++) {
          let pairCode;
          let nextChar = index2 + 1 < this.text.length ? this.text[index2 + 1] : 0;
          switch (this.text[index2]) {
            case StringUtils.getCharCode("\r"):
              pairCode = nextChar === lineBreakCharCode ? 2 : 0;
              break;
            case StringUtils.getCharCode("."):
              pairCode = nextChar === spaceCharCode ? 3 : 0;
              break;
            case StringUtils.getCharCode(","):
              pairCode = nextChar === spaceCharCode ? 4 : 0;
              break;
            case StringUtils.getCharCode(":"):
              pairCode = nextChar === spaceCharCode ? 5 : 0;
              break;
            default:
              pairCode = 0;
          }
          if (pairCode > 0) {
            states = HighLevelEncoder.updateStateListForPair(states, index2, pairCode);
            index2++;
          } else {
            states = this.updateStateListForChar(states, index2);
          }
        }
        const minState = Collections.min(states, (a4, b2) => {
          return a4.getBitCount() - b2.getBitCount();
        });
        return minState.toBitArray(this.text);
      }
      // We update a set of states for a new character by updating each state
      // for the new character, merging the results, and then removing the
      // non-optimal states.
      updateStateListForChar(states, index2) {
        const result = [];
        for (let state of states) {
          this.updateStateForChar(state, index2, result);
        }
        return HighLevelEncoder.simplifyStates(result);
      }
      // Return a set of states that represent the possible ways of updating this
      // state for the next character.  The resulting set of states are added to
      // the "result" list.
      updateStateForChar(state, index2, result) {
        let ch2 = this.text[index2] & 255;
        let charInCurrentTable = CHAR_MAP[state.getMode()][ch2] > 0;
        let stateNoBinary = null;
        for (let mode = 0; mode <= MODE_PUNCT; mode++) {
          let charInMode = CHAR_MAP[mode][ch2];
          if (charInMode > 0) {
            if (stateNoBinary == null) {
              stateNoBinary = state.endBinaryShift(index2);
            }
            if (!charInCurrentTable || mode === state.getMode() || mode === MODE_DIGIT) {
              const latchState = stateNoBinary.latchAndAppend(mode, charInMode);
              result.push(latchState);
            }
            if (!charInCurrentTable && SHIFT_TABLE[state.getMode()][mode] >= 0) {
              const shiftState = stateNoBinary.shiftAndAppend(mode, charInMode);
              result.push(shiftState);
            }
          }
        }
        if (state.getBinaryShiftByteCount() > 0 || CHAR_MAP[state.getMode()][ch2] === 0) {
          let binaryState = state.addBinaryShiftChar(index2);
          result.push(binaryState);
        }
      }
      static updateStateListForPair(states, index2, pairCode) {
        const result = [];
        for (let state of states) {
          this.updateStateForPair(state, index2, pairCode, result);
        }
        return this.simplifyStates(result);
      }
      static updateStateForPair(state, index2, pairCode, result) {
        let stateNoBinary = state.endBinaryShift(index2);
        result.push(stateNoBinary.latchAndAppend(MODE_PUNCT, pairCode));
        if (state.getMode() !== MODE_PUNCT) {
          result.push(stateNoBinary.shiftAndAppend(MODE_PUNCT, pairCode));
        }
        if (pairCode === 3 || pairCode === 4) {
          let digitState = stateNoBinary.latchAndAppend(MODE_DIGIT, 16 - pairCode).latchAndAppend(MODE_DIGIT, 1);
          result.push(digitState);
        }
        if (state.getBinaryShiftByteCount() > 0) {
          let binaryState = state.addBinaryShiftChar(index2).addBinaryShiftChar(index2 + 1);
          result.push(binaryState);
        }
      }
      static simplifyStates(states) {
        let result = [];
        for (const newState of states) {
          let add3 = true;
          for (const oldState of result) {
            if (oldState.isBetterThanOrEqualTo(newState)) {
              add3 = false;
              break;
            }
            if (newState.isBetterThanOrEqualTo(oldState)) {
              result = result.filter((x3) => x3 !== oldState);
            }
          }
          if (add3) {
            result.push(newState);
          }
        }
        return result;
      }
    }
    class Encoder$1 {
      constructor() {
      }
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @return Aztec symbol matrix with metadata
       */
      static encodeBytes(data) {
        return Encoder$1.encode(data, Encoder$1.DEFAULT_EC_PERCENT, Encoder$1.DEFAULT_AZTEC_LAYERS);
      }
      /**
       * Encodes the given binary content as an Aztec symbol
       *
       * @param data input data string
       * @param minECCPercent minimal percentage of error check words (According to ISO/IEC 24778:2008,
       *                      a minimum of 23% + 3 words is recommended)
       * @param userSpecifiedLayers if non-zero, a user-specified value for the number of layers
       * @return Aztec symbol matrix with metadata
       */
      static encode(data, minECCPercent, userSpecifiedLayers) {
        let bits = new HighLevelEncoder(data).encode();
        let eccBits = Integer.truncDivision(bits.getSize() * minECCPercent, 100) + 11;
        let totalSizeBits = bits.getSize() + eccBits;
        let compact2;
        let layers;
        let totalBitsInLayer;
        let wordSize;
        let stuffedBits;
        if (userSpecifiedLayers !== Encoder$1.DEFAULT_AZTEC_LAYERS) {
          compact2 = userSpecifiedLayers < 0;
          layers = Math.abs(userSpecifiedLayers);
          if (layers > (compact2 ? Encoder$1.MAX_NB_BITS_COMPACT : Encoder$1.MAX_NB_BITS)) {
            throw new IllegalArgumentException(StringUtils.format("Illegal value %s for layers", userSpecifiedLayers));
          }
          totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact2);
          wordSize = Encoder$1.WORD_SIZE[layers];
          let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
          stuffedBits = Encoder$1.stuffBits(bits, wordSize);
          if (stuffedBits.getSize() + eccBits > usableBitsInLayers) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
          if (compact2 && stuffedBits.getSize() > wordSize * 64) {
            throw new IllegalArgumentException("Data to large for user specified layer");
          }
        } else {
          wordSize = 0;
          stuffedBits = null;
          for (let i3 = 0; ; i3++) {
            if (i3 > Encoder$1.MAX_NB_BITS) {
              throw new IllegalArgumentException("Data too large for an Aztec code");
            }
            compact2 = i3 <= 3;
            layers = compact2 ? i3 + 1 : i3;
            totalBitsInLayer = Encoder$1.totalBitsInLayer(layers, compact2);
            if (totalSizeBits > totalBitsInLayer) {
              continue;
            }
            if (stuffedBits == null || wordSize !== Encoder$1.WORD_SIZE[layers]) {
              wordSize = Encoder$1.WORD_SIZE[layers];
              stuffedBits = Encoder$1.stuffBits(bits, wordSize);
            }
            let usableBitsInLayers = totalBitsInLayer - totalBitsInLayer % wordSize;
            if (compact2 && stuffedBits.getSize() > wordSize * 64) {
              continue;
            }
            if (stuffedBits.getSize() + eccBits <= usableBitsInLayers) {
              break;
            }
          }
        }
        let messageBits = Encoder$1.generateCheckWords(stuffedBits, totalBitsInLayer, wordSize);
        let messageSizeInWords = stuffedBits.getSize() / wordSize;
        let modeMessage = Encoder$1.generateModeMessage(compact2, layers, messageSizeInWords);
        let baseMatrixSize = (compact2 ? 11 : 14) + layers * 4;
        let alignmentMap = new Int32Array(baseMatrixSize);
        let matrixSize;
        if (compact2) {
          matrixSize = baseMatrixSize;
          for (let i3 = 0; i3 < alignmentMap.length; i3++) {
            alignmentMap[i3] = i3;
          }
        } else {
          matrixSize = baseMatrixSize + 1 + 2 * Integer.truncDivision(Integer.truncDivision(baseMatrixSize, 2) - 1, 15);
          let origCenter = Integer.truncDivision(baseMatrixSize, 2);
          let center = Integer.truncDivision(matrixSize, 2);
          for (let i3 = 0; i3 < origCenter; i3++) {
            let newOffset = i3 + Integer.truncDivision(i3, 15);
            alignmentMap[origCenter - i3 - 1] = center - newOffset - 1;
            alignmentMap[origCenter + i3] = center + newOffset + 1;
          }
        }
        let matrix = new BitMatrix(matrixSize);
        for (let i3 = 0, rowOffset = 0; i3 < layers; i3++) {
          let rowSize = (layers - i3) * 4 + (compact2 ? 9 : 12);
          for (let j2 = 0; j2 < rowSize; j2++) {
            let columnOffset = j2 * 2;
            for (let k3 = 0; k3 < 2; k3++) {
              if (messageBits.get(rowOffset + columnOffset + k3)) {
                matrix.set(alignmentMap[i3 * 2 + k3], alignmentMap[i3 * 2 + j2]);
              }
              if (messageBits.get(rowOffset + rowSize * 2 + columnOffset + k3)) {
                matrix.set(alignmentMap[i3 * 2 + j2], alignmentMap[baseMatrixSize - 1 - i3 * 2 - k3]);
              }
              if (messageBits.get(rowOffset + rowSize * 4 + columnOffset + k3)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i3 * 2 - k3], alignmentMap[baseMatrixSize - 1 - i3 * 2 - j2]);
              }
              if (messageBits.get(rowOffset + rowSize * 6 + columnOffset + k3)) {
                matrix.set(alignmentMap[baseMatrixSize - 1 - i3 * 2 - j2], alignmentMap[i3 * 2 + k3]);
              }
            }
          }
          rowOffset += rowSize * 8;
        }
        Encoder$1.drawModeMessage(matrix, compact2, matrixSize, modeMessage);
        if (compact2) {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 5);
        } else {
          Encoder$1.drawBullsEye(matrix, Integer.truncDivision(matrixSize, 2), 7);
          for (let i3 = 0, j2 = 0; i3 < Integer.truncDivision(baseMatrixSize, 2) - 1; i3 += 15, j2 += 16) {
            for (let k3 = Integer.truncDivision(matrixSize, 2) & 1; k3 < matrixSize; k3 += 2) {
              matrix.set(Integer.truncDivision(matrixSize, 2) - j2, k3);
              matrix.set(Integer.truncDivision(matrixSize, 2) + j2, k3);
              matrix.set(k3, Integer.truncDivision(matrixSize, 2) - j2);
              matrix.set(k3, Integer.truncDivision(matrixSize, 2) + j2);
            }
          }
        }
        let aztec = new AztecCode();
        aztec.setCompact(compact2);
        aztec.setSize(matrixSize);
        aztec.setLayers(layers);
        aztec.setCodeWords(messageSizeInWords);
        aztec.setMatrix(matrix);
        return aztec;
      }
      static drawBullsEye(matrix, center, size2) {
        for (let i3 = 0; i3 < size2; i3 += 2) {
          for (let j2 = center - i3; j2 <= center + i3; j2++) {
            matrix.set(j2, center - i3);
            matrix.set(j2, center + i3);
            matrix.set(center - i3, j2);
            matrix.set(center + i3, j2);
          }
        }
        matrix.set(center - size2, center - size2);
        matrix.set(center - size2 + 1, center - size2);
        matrix.set(center - size2, center - size2 + 1);
        matrix.set(center + size2, center - size2);
        matrix.set(center + size2, center - size2 + 1);
        matrix.set(center + size2, center + size2 - 1);
      }
      static generateModeMessage(compact2, layers, messageSizeInWords) {
        let modeMessage = new BitArray();
        if (compact2) {
          modeMessage.appendBits(layers - 1, 2);
          modeMessage.appendBits(messageSizeInWords - 1, 6);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 28, 4);
        } else {
          modeMessage.appendBits(layers - 1, 5);
          modeMessage.appendBits(messageSizeInWords - 1, 11);
          modeMessage = Encoder$1.generateCheckWords(modeMessage, 40, 4);
        }
        return modeMessage;
      }
      static drawModeMessage(matrix, compact2, matrixSize, modeMessage) {
        let center = Integer.truncDivision(matrixSize, 2);
        if (compact2) {
          for (let i3 = 0; i3 < 7; i3++) {
            let offset2 = center - 3 + i3;
            if (modeMessage.get(i3)) {
              matrix.set(offset2, center - 5);
            }
            if (modeMessage.get(i3 + 7)) {
              matrix.set(center + 5, offset2);
            }
            if (modeMessage.get(20 - i3)) {
              matrix.set(offset2, center + 5);
            }
            if (modeMessage.get(27 - i3)) {
              matrix.set(center - 5, offset2);
            }
          }
        } else {
          for (let i3 = 0; i3 < 10; i3++) {
            let offset2 = center - 5 + i3 + Integer.truncDivision(i3, 5);
            if (modeMessage.get(i3)) {
              matrix.set(offset2, center - 7);
            }
            if (modeMessage.get(i3 + 10)) {
              matrix.set(center + 7, offset2);
            }
            if (modeMessage.get(29 - i3)) {
              matrix.set(offset2, center + 7);
            }
            if (modeMessage.get(39 - i3)) {
              matrix.set(center - 7, offset2);
            }
          }
        }
      }
      static generateCheckWords(bitArray, totalBits, wordSize) {
        let messageSizeInWords = bitArray.getSize() / wordSize;
        let rs = new ReedSolomonEncoder(Encoder$1.getGF(wordSize));
        let totalWords = Integer.truncDivision(totalBits, wordSize);
        let messageWords = Encoder$1.bitsToWords(bitArray, wordSize, totalWords);
        rs.encode(messageWords, totalWords - messageSizeInWords);
        let startPad = totalBits % wordSize;
        let messageBits = new BitArray();
        messageBits.appendBits(0, startPad);
        for (const messageWord of Array.from(messageWords)) {
          messageBits.appendBits(messageWord, wordSize);
        }
        return messageBits;
      }
      static bitsToWords(stuffedBits, wordSize, totalWords) {
        let message = new Int32Array(totalWords);
        let i3;
        let n2;
        for (i3 = 0, n2 = stuffedBits.getSize() / wordSize; i3 < n2; i3++) {
          let value = 0;
          for (let j2 = 0; j2 < wordSize; j2++) {
            value |= stuffedBits.get(i3 * wordSize + j2) ? 1 << wordSize - j2 - 1 : 0;
          }
          message[i3] = value;
        }
        return message;
      }
      static getGF(wordSize) {
        switch (wordSize) {
          case 4:
            return GenericGF.AZTEC_PARAM;
          case 6:
            return GenericGF.AZTEC_DATA_6;
          case 8:
            return GenericGF.AZTEC_DATA_8;
          case 10:
            return GenericGF.AZTEC_DATA_10;
          case 12:
            return GenericGF.AZTEC_DATA_12;
          default:
            throw new IllegalArgumentException("Unsupported word size " + wordSize);
        }
      }
      static stuffBits(bits, wordSize) {
        let out = new BitArray();
        let n2 = bits.getSize();
        let mask = (1 << wordSize) - 2;
        for (let i3 = 0; i3 < n2; i3 += wordSize) {
          let word = 0;
          for (let j2 = 0; j2 < wordSize; j2++) {
            if (i3 + j2 >= n2 || bits.get(i3 + j2)) {
              word |= 1 << wordSize - 1 - j2;
            }
          }
          if ((word & mask) === mask) {
            out.appendBits(word & mask, wordSize);
            i3--;
          } else if ((word & mask) === 0) {
            out.appendBits(word | 1, wordSize);
            i3--;
          } else {
            out.appendBits(word, wordSize);
          }
        }
        return out;
      }
      static totalBitsInLayer(layers, compact2) {
        return ((compact2 ? 88 : 112) + 16 * layers) * layers;
      }
    }
    Encoder$1.DEFAULT_EC_PERCENT = 33;
    Encoder$1.DEFAULT_AZTEC_LAYERS = 0;
    Encoder$1.MAX_NB_BITS = 32;
    Encoder$1.MAX_NB_BITS_COMPACT = 4;
    Encoder$1.WORD_SIZE = Int32Array.from([
      4,
      6,
      6,
      8,
      8,
      8,
      8,
      8,
      8,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      10,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12,
      12
    ]);
    class AztecWriter {
      // @Override
      encode(contents, format2, width, height) {
        return this.encodeWithHints(contents, format2, width, height, null);
      }
      // @Override
      encodeWithHints(contents, format2, width, height, hints) {
        let charset = StandardCharsets.ISO_8859_1;
        let eccPercent = Encoder$1.DEFAULT_EC_PERCENT;
        let layers = Encoder$1.DEFAULT_AZTEC_LAYERS;
        if (hints != null) {
          if (hints.has(EncodeHintType$1.CHARACTER_SET)) {
            charset = Charset.forName(hints.get(EncodeHintType$1.CHARACTER_SET).toString());
          }
          if (hints.has(EncodeHintType$1.ERROR_CORRECTION)) {
            eccPercent = Integer.parseInt(hints.get(EncodeHintType$1.ERROR_CORRECTION).toString());
          }
          if (hints.has(EncodeHintType$1.AZTEC_LAYERS)) {
            layers = Integer.parseInt(hints.get(EncodeHintType$1.AZTEC_LAYERS).toString());
          }
        }
        return AztecWriter.encodeLayers(contents, format2, width, height, charset, eccPercent, layers);
      }
      static encodeLayers(contents, format2, width, height, charset, eccPercent, layers) {
        if (format2 !== BarcodeFormat$1.AZTEC) {
          throw new IllegalArgumentException("Can only encode AZTEC, but got " + format2);
        }
        let aztec = Encoder$1.encode(StringUtils.getBytes(contents, charset), eccPercent, layers);
        return AztecWriter.renderResult(aztec, width, height);
      }
      static renderResult(code, width, height) {
        let input = code.getMatrix();
        if (input == null) {
          throw new IllegalStateException();
        }
        let inputWidth = input.getWidth();
        let inputHeight = input.getHeight();
        let outputWidth = Math.max(width, inputWidth);
        let outputHeight = Math.max(height, inputHeight);
        let multiple = Math.min(outputWidth / inputWidth, outputHeight / inputHeight);
        let leftPadding = (outputWidth - inputWidth * multiple) / 2;
        let topPadding = (outputHeight - inputHeight * multiple) / 2;
        let output = new BitMatrix(outputWidth, outputHeight);
        for (let inputY = 0, outputY = topPadding; inputY < inputHeight; inputY++, outputY += multiple) {
          for (let inputX = 0, outputX = leftPadding; inputX < inputWidth; inputX++, outputX += multiple) {
            if (input.get(inputX, inputY)) {
              output.setRegion(outputX, outputY, multiple, multiple);
            }
          }
        }
        return output;
      }
    }
    exports2.AbstractExpandedDecoder = AbstractExpandedDecoder;
    exports2.ArgumentException = ArgumentException;
    exports2.ArithmeticException = ArithmeticException;
    exports2.AztecCode = AztecCode;
    exports2.AztecCodeReader = AztecReader;
    exports2.AztecCodeWriter = AztecWriter;
    exports2.AztecDecoder = Decoder;
    exports2.AztecDetector = Detector;
    exports2.AztecDetectorResult = AztecDetectorResult;
    exports2.AztecEncoder = Encoder$1;
    exports2.AztecHighLevelEncoder = HighLevelEncoder;
    exports2.AztecPoint = Point;
    exports2.BarcodeFormat = BarcodeFormat$1;
    exports2.Binarizer = Binarizer;
    exports2.BinaryBitmap = BinaryBitmap;
    exports2.BitArray = BitArray;
    exports2.BitMatrix = BitMatrix;
    exports2.BitSource = BitSource;
    exports2.BrowserAztecCodeReader = BrowserAztecCodeReader;
    exports2.BrowserBarcodeReader = BrowserBarcodeReader;
    exports2.BrowserCodeReader = BrowserCodeReader;
    exports2.BrowserDatamatrixCodeReader = BrowserDatamatrixCodeReader;
    exports2.BrowserMultiFormatReader = BrowserMultiFormatReader;
    exports2.BrowserPDF417Reader = BrowserPDF417Reader;
    exports2.BrowserQRCodeReader = BrowserQRCodeReader;
    exports2.BrowserQRCodeSvgWriter = BrowserQRCodeSvgWriter;
    exports2.CharacterSetECI = CharacterSetECI;
    exports2.ChecksumException = ChecksumException;
    exports2.Code128Reader = Code128Reader;
    exports2.Code39Reader = Code39Reader;
    exports2.DataMatrixDecodedBitStreamParser = DecodedBitStreamParser;
    exports2.DataMatrixReader = DataMatrixReader;
    exports2.DecodeHintType = DecodeHintType$1;
    exports2.DecoderResult = DecoderResult;
    exports2.DefaultGridSampler = DefaultGridSampler;
    exports2.DetectorResult = DetectorResult;
    exports2.EAN13Reader = EAN13Reader;
    exports2.EncodeHintType = EncodeHintType$1;
    exports2.Exception = Exception;
    exports2.FormatException = FormatException;
    exports2.GenericGF = GenericGF;
    exports2.GenericGFPoly = GenericGFPoly;
    exports2.GlobalHistogramBinarizer = GlobalHistogramBinarizer;
    exports2.GridSampler = GridSampler;
    exports2.GridSamplerInstance = GridSamplerInstance;
    exports2.HTMLCanvasElementLuminanceSource = HTMLCanvasElementLuminanceSource;
    exports2.HybridBinarizer = HybridBinarizer;
    exports2.ITFReader = ITFReader;
    exports2.IllegalArgumentException = IllegalArgumentException;
    exports2.IllegalStateException = IllegalStateException;
    exports2.InvertedLuminanceSource = InvertedLuminanceSource;
    exports2.LuminanceSource = LuminanceSource;
    exports2.MathUtils = MathUtils;
    exports2.MultiFormatOneDReader = MultiFormatOneDReader;
    exports2.MultiFormatReader = MultiFormatReader;
    exports2.MultiFormatWriter = MultiFormatWriter;
    exports2.NotFoundException = NotFoundException;
    exports2.OneDReader = OneDReader;
    exports2.PDF417DecodedBitStreamParser = DecodedBitStreamParser$2;
    exports2.PDF417DecoderErrorCorrection = ErrorCorrection;
    exports2.PDF417Reader = PDF417Reader;
    exports2.PDF417ResultMetadata = PDF417ResultMetadata;
    exports2.PerspectiveTransform = PerspectiveTransform;
    exports2.PlanarYUVLuminanceSource = PlanarYUVLuminanceSource;
    exports2.QRCodeByteMatrix = ByteMatrix;
    exports2.QRCodeDataMask = DataMask;
    exports2.QRCodeDecodedBitStreamParser = DecodedBitStreamParser$1;
    exports2.QRCodeDecoderErrorCorrectionLevel = ErrorCorrectionLevel;
    exports2.QRCodeDecoderFormatInformation = FormatInformation;
    exports2.QRCodeEncoder = Encoder;
    exports2.QRCodeEncoderQRCode = QRCode;
    exports2.QRCodeMaskUtil = MaskUtil;
    exports2.QRCodeMatrixUtil = MatrixUtil;
    exports2.QRCodeMode = Mode$1;
    exports2.QRCodeReader = QRCodeReader;
    exports2.QRCodeVersion = Version$1;
    exports2.QRCodeWriter = QRCodeWriter;
    exports2.RGBLuminanceSource = RGBLuminanceSource;
    exports2.RSS14Reader = RSS14Reader;
    exports2.RSSExpandedReader = RSSExpandedReader;
    exports2.ReaderException = ReaderException;
    exports2.ReedSolomonDecoder = ReedSolomonDecoder;
    exports2.ReedSolomonEncoder = ReedSolomonEncoder;
    exports2.ReedSolomonException = ReedSolomonException;
    exports2.Result = Result;
    exports2.ResultMetadataType = ResultMetadataType$1;
    exports2.ResultPoint = ResultPoint;
    exports2.StringUtils = StringUtils;
    exports2.UnsupportedOperationException = UnsupportedOperationException;
    exports2.VideoInputDevice = VideoInputDevice;
    exports2.WhiteRectangleDetector = WhiteRectangleDetector;
    exports2.WriterException = WriterException;
    exports2.ZXingArrays = Arrays;
    exports2.ZXingCharset = Charset;
    exports2.ZXingInteger = Integer;
    exports2.ZXingStandardCharsets = StandardCharsets;
    exports2.ZXingStringBuilder = StringBuilder;
    exports2.ZXingStringEncoding = StringEncoding;
    exports2.ZXingSystem = System;
    exports2.createAbstractExpandedDecoder = createDecoder;
    Object.defineProperty(exports2, "__esModule", { value: true });
  });
})(zxingJs_umd$1, zxingJs_umd$1.exports);
var zxingJs_umdExports = zxingJs_umd$1.exports;
const zxingJs_umd = /* @__PURE__ */ getDefaultExportFromCjs(zxingJs_umdExports);
const ZXing = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: zxingJs_umd
}, [zxingJs_umdExports]);
var ZXingHtml5QrcodeDecoder = function() {
  function ZXingHtml5QrcodeDecoder2(requestedFormats, verbose, logger2) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, zxingJs_umdExports.BarcodeFormat.QR_CODE],
      [Html5QrcodeSupportedFormats.AZTEC, zxingJs_umdExports.BarcodeFormat.AZTEC],
      [Html5QrcodeSupportedFormats.CODABAR, zxingJs_umdExports.BarcodeFormat.CODABAR],
      [Html5QrcodeSupportedFormats.CODE_39, zxingJs_umdExports.BarcodeFormat.CODE_39],
      [Html5QrcodeSupportedFormats.CODE_93, zxingJs_umdExports.BarcodeFormat.CODE_93],
      [
        Html5QrcodeSupportedFormats.CODE_128,
        zxingJs_umdExports.BarcodeFormat.CODE_128
      ],
      [
        Html5QrcodeSupportedFormats.DATA_MATRIX,
        zxingJs_umdExports.BarcodeFormat.DATA_MATRIX
      ],
      [
        Html5QrcodeSupportedFormats.MAXICODE,
        zxingJs_umdExports.BarcodeFormat.MAXICODE
      ],
      [Html5QrcodeSupportedFormats.ITF, zxingJs_umdExports.BarcodeFormat.ITF],
      [Html5QrcodeSupportedFormats.EAN_13, zxingJs_umdExports.BarcodeFormat.EAN_13],
      [Html5QrcodeSupportedFormats.EAN_8, zxingJs_umdExports.BarcodeFormat.EAN_8],
      [Html5QrcodeSupportedFormats.PDF_417, zxingJs_umdExports.BarcodeFormat.PDF_417],
      [Html5QrcodeSupportedFormats.RSS_14, zxingJs_umdExports.BarcodeFormat.RSS_14],
      [
        Html5QrcodeSupportedFormats.RSS_EXPANDED,
        zxingJs_umdExports.BarcodeFormat.RSS_EXPANDED
      ],
      [Html5QrcodeSupportedFormats.UPC_A, zxingJs_umdExports.BarcodeFormat.UPC_A],
      [Html5QrcodeSupportedFormats.UPC_E, zxingJs_umdExports.BarcodeFormat.UPC_E],
      [
        Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION,
        zxingJs_umdExports.BarcodeFormat.UPC_EAN_EXTENSION
      ]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!ZXing) {
      throw "Use html5qrcode.min.js without edit, ZXing not found.";
    }
    this.verbose = verbose;
    this.logger = logger2;
    var formats = this.createZXingFormats(requestedFormats);
    var hints = /* @__PURE__ */ new Map();
    hints.set(zxingJs_umdExports.DecodeHintType.POSSIBLE_FORMATS, formats);
    hints.set(zxingJs_umdExports.DecodeHintType.TRY_HARDER, false);
    this.hints = hints;
  }
  ZXingHtml5QrcodeDecoder2.prototype.decodeAsync = function(canvas) {
    var _this = this;
    return new Promise(function(resolve, reject) {
      try {
        resolve(_this.decode(canvas));
      } catch (error) {
        reject(error);
      }
    });
  };
  ZXingHtml5QrcodeDecoder2.prototype.decode = function(canvas) {
    var zxingDecoder = new zxingJs_umdExports.MultiFormatReader(this.verbose, this.hints);
    var luminanceSource = new zxingJs_umdExports.HTMLCanvasElementLuminanceSource(canvas);
    var binaryBitmap = new zxingJs_umdExports.BinaryBitmap(new zxingJs_umdExports.HybridBinarizer(luminanceSource));
    var result = zxingDecoder.decode(binaryBitmap);
    return {
      text: result.text,
      format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(result.format)),
      debugData: this.createDebugData()
    };
  };
  ZXingHtml5QrcodeDecoder2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key, _2) {
      result.set(value, key);
    });
    return result;
  };
  ZXingHtml5QrcodeDecoder2.prototype.toHtml5QrcodeSupportedFormats = function(zxingFormat) {
    if (!this.reverseFormatMap.has(zxingFormat)) {
      throw "reverseFormatMap doesn't have ".concat(zxingFormat);
    }
    return this.reverseFormatMap.get(zxingFormat);
  };
  ZXingHtml5QrcodeDecoder2.prototype.createZXingFormats = function(requestedFormats) {
    var zxingFormats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        zxingFormats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.logError("".concat(requestedFormat, " is not supported by") + "ZXingHtml5QrcodeShim");
      }
    }
    return zxingFormats;
  };
  ZXingHtml5QrcodeDecoder2.prototype.createDebugData = function() {
    return { decoderName: "zxing-js" };
  };
  return ZXingHtml5QrcodeDecoder2;
}();
var __awaiter$6 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$6 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var BarcodeDetectorDelegate = function() {
  function BarcodeDetectorDelegate2(requestedFormats, verbose, logger2) {
    this.formatMap = /* @__PURE__ */ new Map([
      [Html5QrcodeSupportedFormats.QR_CODE, "qr_code"],
      [Html5QrcodeSupportedFormats.AZTEC, "aztec"],
      [Html5QrcodeSupportedFormats.CODABAR, "codabar"],
      [Html5QrcodeSupportedFormats.CODE_39, "code_39"],
      [Html5QrcodeSupportedFormats.CODE_93, "code_93"],
      [Html5QrcodeSupportedFormats.CODE_128, "code_128"],
      [Html5QrcodeSupportedFormats.DATA_MATRIX, "data_matrix"],
      [Html5QrcodeSupportedFormats.ITF, "itf"],
      [Html5QrcodeSupportedFormats.EAN_13, "ean_13"],
      [Html5QrcodeSupportedFormats.EAN_8, "ean_8"],
      [Html5QrcodeSupportedFormats.PDF_417, "pdf417"],
      [Html5QrcodeSupportedFormats.UPC_A, "upc_a"],
      [Html5QrcodeSupportedFormats.UPC_E, "upc_e"]
    ]);
    this.reverseFormatMap = this.createReverseFormatMap();
    if (!BarcodeDetectorDelegate2.isSupported()) {
      throw "Use html5qrcode.min.js without edit, Use BarcodeDetectorDelegate only if it isSupported();";
    }
    this.verbose = verbose;
    this.logger = logger2;
    var formats = this.createBarcodeDetectorFormats(requestedFormats);
    this.detector = new BarcodeDetector(formats);
    if (!this.detector) {
      throw "BarcodeDetector detector not supported";
    }
  }
  BarcodeDetectorDelegate2.isSupported = function() {
    if (!("BarcodeDetector" in window)) {
      return false;
    }
    var dummyDetector = new BarcodeDetector({ formats: ["qr_code"] });
    return typeof dummyDetector !== "undefined";
  };
  BarcodeDetectorDelegate2.prototype.decodeAsync = function(canvas) {
    return __awaiter$6(this, void 0, void 0, function() {
      var barcodes, largestBarcode;
      return __generator$6(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, this.detector.detect(canvas)];
          case 1:
            barcodes = _a.sent();
            if (!barcodes || barcodes.length === 0) {
              throw "No barcode or QR code detected.";
            }
            largestBarcode = this.selectLargestBarcode(barcodes);
            return [2, {
              text: largestBarcode.rawValue,
              format: QrcodeResultFormat.create(this.toHtml5QrcodeSupportedFormats(largestBarcode.format)),
              debugData: this.createDebugData()
            }];
        }
      });
    });
  };
  BarcodeDetectorDelegate2.prototype.selectLargestBarcode = function(barcodes) {
    var largestBarcode = null;
    var maxArea = 0;
    for (var _i = 0, barcodes_1 = barcodes; _i < barcodes_1.length; _i++) {
      var barcode = barcodes_1[_i];
      var area = barcode.boundingBox.width * barcode.boundingBox.height;
      if (area > maxArea) {
        maxArea = area;
        largestBarcode = barcode;
      }
    }
    if (!largestBarcode) {
      throw "No largest barcode found";
    }
    return largestBarcode;
  };
  BarcodeDetectorDelegate2.prototype.createBarcodeDetectorFormats = function(requestedFormats) {
    var formats = [];
    for (var _i = 0, requestedFormats_1 = requestedFormats; _i < requestedFormats_1.length; _i++) {
      var requestedFormat = requestedFormats_1[_i];
      if (this.formatMap.has(requestedFormat)) {
        formats.push(this.formatMap.get(requestedFormat));
      } else {
        this.logger.warn("".concat(requestedFormat, " is not supported by") + "BarcodeDetectorDelegate");
      }
    }
    return { formats };
  };
  BarcodeDetectorDelegate2.prototype.toHtml5QrcodeSupportedFormats = function(barcodeDetectorFormat) {
    if (!this.reverseFormatMap.has(barcodeDetectorFormat)) {
      throw "reverseFormatMap doesn't have ".concat(barcodeDetectorFormat);
    }
    return this.reverseFormatMap.get(barcodeDetectorFormat);
  };
  BarcodeDetectorDelegate2.prototype.createReverseFormatMap = function() {
    var result = /* @__PURE__ */ new Map();
    this.formatMap.forEach(function(value, key, _2) {
      result.set(value, key);
    });
    return result;
  };
  BarcodeDetectorDelegate2.prototype.createDebugData = function() {
    return { decoderName: "BarcodeDetector" };
  };
  return BarcodeDetectorDelegate2;
}();
var __awaiter$5 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$5 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var Html5QrcodeShim = function() {
  function Html5QrcodeShim2(requestedFormats, useBarCodeDetectorIfSupported, verbose, logger2) {
    this.EXECUTIONS_TO_REPORT_PERFORMANCE = 100;
    this.executions = 0;
    this.executionResults = [];
    this.wasPrimaryDecoderUsedInLastDecode = false;
    this.verbose = verbose;
    if (useBarCodeDetectorIfSupported && BarcodeDetectorDelegate.isSupported()) {
      this.primaryDecoder = new BarcodeDetectorDelegate(requestedFormats, verbose, logger2);
      this.secondaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger2);
    } else {
      this.primaryDecoder = new ZXingHtml5QrcodeDecoder(requestedFormats, verbose, logger2);
    }
  }
  Html5QrcodeShim2.prototype.decodeAsync = function(canvas) {
    return __awaiter$5(this, void 0, void 0, function() {
      var startTime;
      return __generator$5(this, function(_a) {
        switch (_a.label) {
          case 0:
            startTime = performance.now();
            _a.label = 1;
          case 1:
            _a.trys.push([1, , 3, 4]);
            return [4, this.getDecoder().decodeAsync(canvas)];
          case 2:
            return [2, _a.sent()];
          case 3:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 4:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.decodeRobustlyAsync = function(canvas) {
    return __awaiter$5(this, void 0, void 0, function() {
      var startTime, error_1;
      return __generator$5(this, function(_a) {
        switch (_a.label) {
          case 0:
            startTime = performance.now();
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, 4, 5]);
            return [4, this.primaryDecoder.decodeAsync(canvas)];
          case 2:
            return [2, _a.sent()];
          case 3:
            error_1 = _a.sent();
            if (this.secondaryDecoder) {
              return [2, this.secondaryDecoder.decodeAsync(canvas)];
            }
            throw error_1;
          case 4:
            this.possiblyLogPerformance(startTime);
            return [7];
          case 5:
            return [2];
        }
      });
    });
  };
  Html5QrcodeShim2.prototype.getDecoder = function() {
    if (!this.secondaryDecoder) {
      return this.primaryDecoder;
    }
    if (this.wasPrimaryDecoderUsedInLastDecode === false) {
      this.wasPrimaryDecoderUsedInLastDecode = true;
      return this.primaryDecoder;
    }
    this.wasPrimaryDecoderUsedInLastDecode = false;
    return this.secondaryDecoder;
  };
  Html5QrcodeShim2.prototype.possiblyLogPerformance = function(startTime) {
    if (!this.verbose) {
      return;
    }
    var executionTime = performance.now() - startTime;
    this.executionResults.push(executionTime);
    this.executions++;
    this.possiblyFlushPerformanceReport();
  };
  Html5QrcodeShim2.prototype.possiblyFlushPerformanceReport = function() {
    if (this.executions < this.EXECUTIONS_TO_REPORT_PERFORMANCE) {
      return;
    }
    var sum = 0;
    for (var _i = 0, _a = this.executionResults; _i < _a.length; _i++) {
      var executionTime = _a[_i];
      sum += executionTime;
    }
    var mean = sum / this.executionResults.length;
    console.log("".concat(mean, " ms for ").concat(this.executionResults.length, " last runs."));
    this.executions = 0;
    this.executionResults = [];
  };
  return Html5QrcodeShim2;
}();
var __extends$1 = /* @__PURE__ */ function() {
  var extendStatics = function(d4, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
      d5.__proto__ = b3;
    } || function(d5, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d5[p2] = b3[p2];
    };
    return extendStatics(d4, b2);
  };
  return function(d4, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d4, b2);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __awaiter$4 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$4 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var AbstractCameraCapability = function() {
  function AbstractCameraCapability2(name, track) {
    this.name = name;
    this.track = track;
  }
  AbstractCameraCapability2.prototype.isSupported = function() {
    if (!this.track.getCapabilities) {
      return false;
    }
    return this.name in this.track.getCapabilities();
  };
  AbstractCameraCapability2.prototype.apply = function(value) {
    var constraint = {};
    constraint[this.name] = value;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractCameraCapability2.prototype.value = function() {
    var settings = this.track.getSettings();
    if (this.name in settings) {
      var settingValue = settings[this.name];
      return settingValue;
    }
    return null;
  };
  return AbstractCameraCapability2;
}();
var AbstractRangeCameraCapability = function(_super) {
  __extends$1(AbstractRangeCameraCapability2, _super);
  function AbstractRangeCameraCapability2(name, track) {
    return _super.call(this, name, track) || this;
  }
  AbstractRangeCameraCapability2.prototype.min = function() {
    return this.getCapabilities().min;
  };
  AbstractRangeCameraCapability2.prototype.max = function() {
    return this.getCapabilities().max;
  };
  AbstractRangeCameraCapability2.prototype.step = function() {
    return this.getCapabilities().step;
  };
  AbstractRangeCameraCapability2.prototype.apply = function(value) {
    var constraint = {};
    constraint[this.name] = value;
    var constraints = { advanced: [constraint] };
    return this.track.applyConstraints(constraints);
  };
  AbstractRangeCameraCapability2.prototype.getCapabilities = function() {
    this.failIfNotSupported();
    var capabilities = this.track.getCapabilities();
    var capability = capabilities[this.name];
    return {
      min: capability.min,
      max: capability.max,
      step: capability.step
    };
  };
  AbstractRangeCameraCapability2.prototype.failIfNotSupported = function() {
    if (!this.isSupported()) {
      throw new Error("".concat(this.name, " capability not supported"));
    }
  };
  return AbstractRangeCameraCapability2;
}(AbstractCameraCapability);
var ZoomFeatureImpl = function(_super) {
  __extends$1(ZoomFeatureImpl2, _super);
  function ZoomFeatureImpl2(track) {
    return _super.call(this, "zoom", track) || this;
  }
  return ZoomFeatureImpl2;
}(AbstractRangeCameraCapability);
var TorchFeatureImpl = function(_super) {
  __extends$1(TorchFeatureImpl2, _super);
  function TorchFeatureImpl2(track) {
    return _super.call(this, "torch", track) || this;
  }
  return TorchFeatureImpl2;
}(AbstractCameraCapability);
var CameraCapabilitiesImpl = function() {
  function CameraCapabilitiesImpl2(track) {
    this.track = track;
  }
  CameraCapabilitiesImpl2.prototype.zoomFeature = function() {
    return new ZoomFeatureImpl(this.track);
  };
  CameraCapabilitiesImpl2.prototype.torchFeature = function() {
    return new TorchFeatureImpl(this.track);
  };
  return CameraCapabilitiesImpl2;
}();
var RenderedCameraImpl = function() {
  function RenderedCameraImpl2(parentElement, mediaStream, callbacks) {
    this.isClosed = false;
    this.parentElement = parentElement;
    this.mediaStream = mediaStream;
    this.callbacks = callbacks;
    this.surface = this.createVideoElement(this.parentElement.clientWidth);
    parentElement.append(this.surface);
  }
  RenderedCameraImpl2.prototype.createVideoElement = function(width) {
    var videoElement = document.createElement("video");
    videoElement.style.width = "".concat(width, "px");
    videoElement.style.display = "block";
    videoElement.muted = true;
    videoElement.setAttribute("muted", "true");
    videoElement.playsInline = true;
    return videoElement;
  };
  RenderedCameraImpl2.prototype.setupSurface = function() {
    var _this = this;
    this.surface.onabort = function() {
      throw "RenderedCameraImpl video surface onabort() called";
    };
    this.surface.onerror = function() {
      throw "RenderedCameraImpl video surface onerror() called";
    };
    var onVideoStart = function() {
      var videoWidth = _this.surface.clientWidth;
      var videoHeight = _this.surface.clientHeight;
      _this.callbacks.onRenderSurfaceReady(videoWidth, videoHeight);
      _this.surface.removeEventListener("playing", onVideoStart);
    };
    this.surface.addEventListener("playing", onVideoStart);
    this.surface.srcObject = this.mediaStream;
    this.surface.play();
  };
  RenderedCameraImpl2.create = function(parentElement, mediaStream, options, callbacks) {
    return __awaiter$4(this, void 0, void 0, function() {
      var renderedCamera, aspectRatioConstraint;
      return __generator$4(this, function(_a) {
        switch (_a.label) {
          case 0:
            renderedCamera = new RenderedCameraImpl2(parentElement, mediaStream, callbacks);
            if (!options.aspectRatio) return [3, 2];
            aspectRatioConstraint = {
              aspectRatio: options.aspectRatio
            };
            return [4, renderedCamera.getFirstTrackOrFail().applyConstraints(aspectRatioConstraint)];
          case 1:
            _a.sent();
            _a.label = 2;
          case 2:
            renderedCamera.setupSurface();
            return [2, renderedCamera];
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.failIfClosed = function() {
    if (this.isClosed) {
      throw "The RenderedCamera has already been closed.";
    }
  };
  RenderedCameraImpl2.prototype.getFirstTrackOrFail = function() {
    this.failIfClosed();
    if (this.mediaStream.getVideoTracks().length === 0) {
      throw "No video tracks found";
    }
    return this.mediaStream.getVideoTracks()[0];
  };
  RenderedCameraImpl2.prototype.pause = function() {
    this.failIfClosed();
    this.surface.pause();
  };
  RenderedCameraImpl2.prototype.resume = function(onResumeCallback) {
    this.failIfClosed();
    var $this = this;
    var onVideoResume = function() {
      setTimeout(onResumeCallback, 200);
      $this.surface.removeEventListener("playing", onVideoResume);
    };
    this.surface.addEventListener("playing", onVideoResume);
    this.surface.play();
  };
  RenderedCameraImpl2.prototype.isPaused = function() {
    this.failIfClosed();
    return this.surface.paused;
  };
  RenderedCameraImpl2.prototype.getSurface = function() {
    this.failIfClosed();
    return this.surface;
  };
  RenderedCameraImpl2.prototype.getRunningTrackCapabilities = function() {
    return this.getFirstTrackOrFail().getCapabilities();
  };
  RenderedCameraImpl2.prototype.getRunningTrackSettings = function() {
    return this.getFirstTrackOrFail().getSettings();
  };
  RenderedCameraImpl2.prototype.applyVideoConstraints = function(constraints) {
    return __awaiter$4(this, void 0, void 0, function() {
      return __generator$4(this, function(_a) {
        if ("aspectRatio" in constraints) {
          throw "Changing 'aspectRatio' in run-time is not yet supported.";
        }
        return [2, this.getFirstTrackOrFail().applyConstraints(constraints)];
      });
    });
  };
  RenderedCameraImpl2.prototype.close = function() {
    if (this.isClosed) {
      return Promise.resolve();
    }
    var $this = this;
    return new Promise(function(resolve, _2) {
      var tracks = $this.mediaStream.getVideoTracks();
      var tracksToClose = tracks.length;
      var tracksClosed = 0;
      $this.mediaStream.getVideoTracks().forEach(function(videoTrack) {
        $this.mediaStream.removeTrack(videoTrack);
        videoTrack.stop();
        ++tracksClosed;
        if (tracksClosed >= tracksToClose) {
          $this.isClosed = true;
          $this.parentElement.removeChild($this.surface);
          resolve();
        }
      });
    });
  };
  RenderedCameraImpl2.prototype.getCapabilities = function() {
    return new CameraCapabilitiesImpl(this.getFirstTrackOrFail());
  };
  return RenderedCameraImpl2;
}();
var CameraImpl = function() {
  function CameraImpl2(mediaStream) {
    this.mediaStream = mediaStream;
  }
  CameraImpl2.prototype.render = function(parentElement, options, callbacks) {
    return __awaiter$4(this, void 0, void 0, function() {
      return __generator$4(this, function(_a) {
        return [2, RenderedCameraImpl.create(parentElement, this.mediaStream, options, callbacks)];
      });
    });
  };
  CameraImpl2.create = function(videoConstraints) {
    return __awaiter$4(this, void 0, void 0, function() {
      var constraints, mediaStream;
      return __generator$4(this, function(_a) {
        switch (_a.label) {
          case 0:
            if (!navigator.mediaDevices) {
              throw "navigator.mediaDevices not supported";
            }
            constraints = {
              audio: false,
              video: videoConstraints
            };
            return [4, navigator.mediaDevices.getUserMedia(constraints)];
          case 1:
            mediaStream = _a.sent();
            return [2, new CameraImpl2(mediaStream)];
        }
      });
    });
  };
  return CameraImpl2;
}();
var __awaiter$3 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$3 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraFactory = function() {
  function CameraFactory2() {
  }
  CameraFactory2.failIfNotSupported = function() {
    return __awaiter$3(this, void 0, void 0, function() {
      return __generator$3(this, function(_a) {
        if (!navigator.mediaDevices) {
          throw "navigator.mediaDevices not supported";
        }
        return [2, new CameraFactory2()];
      });
    });
  };
  CameraFactory2.prototype.create = function(videoConstraints) {
    return __awaiter$3(this, void 0, void 0, function() {
      return __generator$3(this, function(_a) {
        return [2, CameraImpl.create(videoConstraints)];
      });
    });
  };
  return CameraFactory2;
}();
var __awaiter$2 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$2 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraRetriever = function() {
  function CameraRetriever2() {
  }
  CameraRetriever2.retrieve = function() {
    if (navigator.mediaDevices) {
      return CameraRetriever2.getCamerasFromMediaDevices();
    }
    var mst = MediaStreamTrack;
    if (MediaStreamTrack && mst.getSources) {
      return CameraRetriever2.getCamerasFromMediaStreamTrack();
    }
    return CameraRetriever2.rejectWithError();
  };
  CameraRetriever2.rejectWithError = function() {
    var errorMessage = Html5QrcodeStrings.unableToQuerySupportedDevices();
    if (!CameraRetriever2.isHttpsOrLocalhost()) {
      errorMessage = Html5QrcodeStrings.insecureContextCameraQueryError();
    }
    return Promise.reject(errorMessage);
  };
  CameraRetriever2.isHttpsOrLocalhost = function() {
    if (location.protocol === "https:") {
      return true;
    }
    var host = location.host.split(":")[0];
    return host === "127.0.0.1" || host === "localhost";
  };
  CameraRetriever2.getCamerasFromMediaDevices = function() {
    return __awaiter$2(this, void 0, void 0, function() {
      var closeActiveStreams, mediaStream, devices, results, _i, devices_1, device;
      return __generator$2(this, function(_a) {
        switch (_a.label) {
          case 0:
            closeActiveStreams = function(stream) {
              var tracks = stream.getVideoTracks();
              for (var _i2 = 0, tracks_1 = tracks; _i2 < tracks_1.length; _i2++) {
                var track = tracks_1[_i2];
                track.enabled = false;
                track.stop();
                stream.removeTrack(track);
              }
            };
            return [4, navigator.mediaDevices.getUserMedia({ audio: false, video: true })];
          case 1:
            mediaStream = _a.sent();
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 2:
            devices = _a.sent();
            results = [];
            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
              device = devices_1[_i];
              if (device.kind === "videoinput") {
                results.push({
                  id: device.deviceId,
                  label: device.label
                });
              }
            }
            closeActiveStreams(mediaStream);
            return [2, results];
        }
      });
    });
  };
  CameraRetriever2.getCamerasFromMediaStreamTrack = function() {
    return new Promise(function(resolve, _2) {
      var callback = function(sourceInfos) {
        var results = [];
        for (var _i = 0, sourceInfos_1 = sourceInfos; _i < sourceInfos_1.length; _i++) {
          var sourceInfo = sourceInfos_1[_i];
          if (sourceInfo.kind === "video") {
            results.push({
              id: sourceInfo.id,
              label: sourceInfo.label
            });
          }
        }
        resolve(results);
      };
      var mst = MediaStreamTrack;
      mst.getSources(callback);
    });
  };
  return CameraRetriever2;
}();
var Html5QrcodeScannerState;
(function(Html5QrcodeScannerState2) {
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["UNKNOWN"] = 0] = "UNKNOWN";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["NOT_STARTED"] = 1] = "NOT_STARTED";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["SCANNING"] = 2] = "SCANNING";
  Html5QrcodeScannerState2[Html5QrcodeScannerState2["PAUSED"] = 3] = "PAUSED";
})(Html5QrcodeScannerState || (Html5QrcodeScannerState = {}));
var StateManagerImpl = function() {
  function StateManagerImpl2() {
    this.state = Html5QrcodeScannerState.NOT_STARTED;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  }
  StateManagerImpl2.prototype.directTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.state = newState;
  };
  StateManagerImpl2.prototype.startTransition = function(newState) {
    this.failIfTransitionOngoing();
    this.validateTransition(newState);
    this.onGoingTransactionNewState = newState;
    return this;
  };
  StateManagerImpl2.prototype.execute = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot execute().";
    }
    var tempNewState = this.onGoingTransactionNewState;
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
    this.directTransition(tempNewState);
  };
  StateManagerImpl2.prototype.cancel = function() {
    if (this.onGoingTransactionNewState === Html5QrcodeScannerState.UNKNOWN) {
      throw "Transaction is already cancelled, cannot cancel().";
    }
    this.onGoingTransactionNewState = Html5QrcodeScannerState.UNKNOWN;
  };
  StateManagerImpl2.prototype.getState = function() {
    return this.state;
  };
  StateManagerImpl2.prototype.failIfTransitionOngoing = function() {
    if (this.onGoingTransactionNewState !== Html5QrcodeScannerState.UNKNOWN) {
      throw "Cannot transition to a new state, already under transition";
    }
  };
  StateManagerImpl2.prototype.validateTransition = function(newState) {
    switch (this.state) {
      case Html5QrcodeScannerState.UNKNOWN:
        throw "Transition from unknown is not allowed";
      case Html5QrcodeScannerState.NOT_STARTED:
        this.failIfNewStateIs(newState, [Html5QrcodeScannerState.PAUSED]);
        break;
      case Html5QrcodeScannerState.SCANNING:
        break;
      case Html5QrcodeScannerState.PAUSED:
        break;
    }
  };
  StateManagerImpl2.prototype.failIfNewStateIs = function(newState, disallowedStatesToTransition) {
    for (var _i = 0, disallowedStatesToTransition_1 = disallowedStatesToTransition; _i < disallowedStatesToTransition_1.length; _i++) {
      var disallowedState = disallowedStatesToTransition_1[_i];
      if (newState === disallowedState) {
        throw "Cannot transition from ".concat(this.state, " to ").concat(newState);
      }
    }
  };
  return StateManagerImpl2;
}();
var StateManagerProxy = function() {
  function StateManagerProxy2(stateManager) {
    this.stateManager = stateManager;
  }
  StateManagerProxy2.prototype.startTransition = function(newState) {
    return this.stateManager.startTransition(newState);
  };
  StateManagerProxy2.prototype.directTransition = function(newState) {
    this.stateManager.directTransition(newState);
  };
  StateManagerProxy2.prototype.getState = function() {
    return this.stateManager.getState();
  };
  StateManagerProxy2.prototype.canScanFile = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isScanning = function() {
    return this.stateManager.getState() !== Html5QrcodeScannerState.NOT_STARTED;
  };
  StateManagerProxy2.prototype.isStrictlyScanning = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.SCANNING;
  };
  StateManagerProxy2.prototype.isPaused = function() {
    return this.stateManager.getState() === Html5QrcodeScannerState.PAUSED;
  };
  return StateManagerProxy2;
}();
var StateManagerFactory = function() {
  function StateManagerFactory2() {
  }
  StateManagerFactory2.create = function() {
    return new StateManagerProxy(new StateManagerImpl());
  };
  return StateManagerFactory2;
}();
var __extends = /* @__PURE__ */ function() {
  var extendStatics = function(d4, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d5, b3) {
      d5.__proto__ = b3;
    } || function(d5, b3) {
      for (var p2 in b3) if (Object.prototype.hasOwnProperty.call(b3, p2)) d5[p2] = b3[p2];
    };
    return extendStatics(d4, b2);
  };
  return function(d4, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d4, b2);
    function __() {
      this.constructor = d4;
    }
    d4.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var Constants = function(_super) {
  __extends(Constants2, _super);
  function Constants2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Constants2.DEFAULT_WIDTH = 300;
  Constants2.DEFAULT_WIDTH_OFFSET = 2;
  Constants2.FILE_SCAN_MIN_HEIGHT = 300;
  Constants2.FILE_SCAN_HIDDEN_CANVAS_PADDING = 100;
  Constants2.MIN_QR_BOX_SIZE = 50;
  Constants2.SHADED_LEFT = 1;
  Constants2.SHADED_RIGHT = 2;
  Constants2.SHADED_TOP = 3;
  Constants2.SHADED_BOTTOM = 4;
  Constants2.SHADED_REGION_ELEMENT_ID = "qr-shaded-region";
  Constants2.VERBOSE = false;
  Constants2.BORDER_SHADER_DEFAULT_COLOR = "#ffffff";
  Constants2.BORDER_SHADER_MATCH_COLOR = "rgb(90, 193, 56)";
  return Constants2;
}(Html5QrcodeConstants);
var InternalHtml5QrcodeConfig = function() {
  function InternalHtml5QrcodeConfig2(config, logger2) {
    this.logger = logger2;
    this.fps = Constants.SCAN_DEFAULT_FPS;
    if (!config) {
      this.disableFlip = Constants.DEFAULT_DISABLE_FLIP;
    } else {
      if (config.fps) {
        this.fps = config.fps;
      }
      this.disableFlip = config.disableFlip === true;
      this.qrbox = config.qrbox;
      this.aspectRatio = config.aspectRatio;
      this.videoConstraints = config.videoConstraints;
    }
  }
  InternalHtml5QrcodeConfig2.prototype.isMediaStreamConstraintsValid = function() {
    if (!this.videoConstraints) {
      this.logger.logError("Empty videoConstraints", true);
      return false;
    }
    return VideoConstraintsUtil.isMediaStreamConstraintsValid(this.videoConstraints, this.logger);
  };
  InternalHtml5QrcodeConfig2.prototype.isShadedBoxEnabled = function() {
    return !isNullOrUndefined(this.qrbox);
  };
  InternalHtml5QrcodeConfig2.create = function(config, logger2) {
    return new InternalHtml5QrcodeConfig2(config, logger2);
  };
  return InternalHtml5QrcodeConfig2;
}();
var Html5Qrcode = function() {
  function Html5Qrcode2(elementId, configOrVerbosityFlag) {
    this.element = null;
    this.canvasElement = null;
    this.scannerPausedUiElement = null;
    this.hasBorderShaders = null;
    this.borderShaders = null;
    this.qrMatch = null;
    this.renderedCamera = null;
    this.qrRegion = null;
    this.context = null;
    this.lastScanImageFile = null;
    this.isScanning = false;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=".concat(elementId, " not found");
    }
    this.elementId = elementId;
    this.verbose = false;
    var configObject;
    if (typeof configOrVerbosityFlag == "boolean") {
      this.verbose = configOrVerbosityFlag === true;
    } else if (configOrVerbosityFlag) {
      configObject = configOrVerbosityFlag;
      this.verbose = configObject.verbose === true;
      configObject.experimentalFeatures;
    }
    this.logger = new BaseLoggger(this.verbose);
    this.qrcode = new Html5QrcodeShim(this.getSupportedFormats(configOrVerbosityFlag), this.getUseBarCodeDetectorIfSupported(configObject), this.verbose, this.logger);
    this.foreverScanTimeout;
    this.shouldScan = true;
    this.stateManagerProxy = StateManagerFactory.create();
  }
  Html5Qrcode2.prototype.start = function(cameraIdOrConfig, configuration, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!cameraIdOrConfig) {
      throw "cameraIdOrConfig is required";
    }
    if (!qrCodeSuccessCallback || typeof qrCodeSuccessCallback != "function") {
      throw "qrCodeSuccessCallback is required and should be a function.";
    }
    var qrCodeErrorCallbackInternal;
    if (qrCodeErrorCallback) {
      qrCodeErrorCallbackInternal = qrCodeErrorCallback;
    } else {
      qrCodeErrorCallbackInternal = this.verbose ? this.logger.log : function() {
      };
    }
    var internalConfig = InternalHtml5QrcodeConfig.create(configuration, this.logger);
    this.clearElement();
    var videoConstraintsAvailableAndValid = false;
    if (internalConfig.videoConstraints) {
      if (!internalConfig.isMediaStreamConstraintsValid()) {
        this.logger.logError("'videoConstraints' is not valid 'MediaStreamConstraints, it will be ignored.'", true);
      } else {
        videoConstraintsAvailableAndValid = true;
      }
    }
    var areVideoConstraintsEnabled = videoConstraintsAvailableAndValid;
    var element = document.getElementById(this.elementId);
    element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
    element.style.position = "relative";
    this.shouldScan = true;
    this.element = element;
    var $this = this;
    var toScanningStateChangeTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.SCANNING);
    return new Promise(function(resolve, reject) {
      var videoConstraints = areVideoConstraintsEnabled ? internalConfig.videoConstraints : $this.createVideoConstraints(cameraIdOrConfig);
      if (!videoConstraints) {
        toScanningStateChangeTransaction.cancel();
        reject("videoConstraints should be defined");
        return;
      }
      var cameraRenderingOptions = {};
      if (!areVideoConstraintsEnabled || internalConfig.aspectRatio) {
        cameraRenderingOptions.aspectRatio = internalConfig.aspectRatio;
      }
      var renderingCallbacks = {
        onRenderSurfaceReady: function(viewfinderWidth, viewfinderHeight) {
          $this.setupUi(viewfinderWidth, viewfinderHeight, internalConfig);
          $this.isScanning = true;
          $this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallbackInternal);
        }
      };
      CameraFactory.failIfNotSupported().then(function(factory) {
        factory.create(videoConstraints).then(function(camera) {
          return camera.render(_this.element, cameraRenderingOptions, renderingCallbacks).then(function(renderedCamera) {
            $this.renderedCamera = renderedCamera;
            toScanningStateChangeTransaction.execute();
            resolve(null);
          }).catch(function(error) {
            toScanningStateChangeTransaction.cancel();
            reject(error);
          });
        }).catch(function(error) {
          toScanningStateChangeTransaction.cancel();
          reject(Html5QrcodeStrings.errorGettingUserMedia(error));
        });
      }).catch(function(_2) {
        toScanningStateChangeTransaction.cancel();
        reject(Html5QrcodeStrings.cameraStreamingNotSupported());
      });
    });
  };
  Html5Qrcode2.prototype.pause = function(shouldPauseVideo) {
    if (!this.stateManagerProxy.isStrictlyScanning()) {
      throw "Cannot pause, scanner is not scanning.";
    }
    this.stateManagerProxy.directTransition(Html5QrcodeScannerState.PAUSED);
    this.showPausedState();
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    if (shouldPauseVideo && this.renderedCamera) {
      this.renderedCamera.pause();
    }
  };
  Html5Qrcode2.prototype.resume = function() {
    if (!this.stateManagerProxy.isPaused()) {
      throw "Cannot result, scanner is not paused.";
    }
    if (!this.renderedCamera) {
      throw "renderedCamera doesn't exist while trying resume()";
    }
    var $this = this;
    var transitionToScanning = function() {
      $this.stateManagerProxy.directTransition(Html5QrcodeScannerState.SCANNING);
      $this.hidePausedState();
    };
    if (!this.renderedCamera.isPaused()) {
      transitionToScanning();
      return;
    }
    this.renderedCamera.resume(function() {
      transitionToScanning();
    });
  };
  Html5Qrcode2.prototype.getState = function() {
    return this.stateManagerProxy.getState();
  };
  Html5Qrcode2.prototype.stop = function() {
    var _this = this;
    if (!this.stateManagerProxy.isScanning()) {
      throw "Cannot stop, scanner is not running or paused.";
    }
    var toStoppedStateTransaction = this.stateManagerProxy.startTransition(Html5QrcodeScannerState.NOT_STARTED);
    this.shouldScan = false;
    if (this.foreverScanTimeout) {
      clearTimeout(this.foreverScanTimeout);
    }
    var removeQrRegion = function() {
      if (!_this.element) {
        return;
      }
      var childElement = document.getElementById(Constants.SHADED_REGION_ELEMENT_ID);
      if (childElement) {
        _this.element.removeChild(childElement);
      }
    };
    var $this = this;
    return this.renderedCamera.close().then(function() {
      $this.renderedCamera = null;
      if ($this.element) {
        $this.element.removeChild($this.canvasElement);
        $this.canvasElement = null;
      }
      removeQrRegion();
      if ($this.qrRegion) {
        $this.qrRegion = null;
      }
      if ($this.context) {
        $this.context = null;
      }
      toStoppedStateTransaction.execute();
      $this.hidePausedState();
      $this.isScanning = false;
      return Promise.resolve();
    });
  };
  Html5Qrcode2.prototype.scanFile = function(imageFile, showImage) {
    return this.scanFileV2(imageFile, showImage).then(function(html5qrcodeResult) {
      return html5qrcodeResult.decodedText;
    });
  };
  Html5Qrcode2.prototype.scanFileV2 = function(imageFile, showImage) {
    var _this = this;
    if (!imageFile || !(imageFile instanceof File)) {
      throw "imageFile argument is mandatory and should be instance of File. Use 'event.target.files[0]'.";
    }
    if (isNullOrUndefined(showImage)) {
      showImage = true;
    }
    if (!this.stateManagerProxy.canScanFile()) {
      throw "Cannot start file scan - ongoing camera scan";
    }
    return new Promise(function(resolve, reject) {
      _this.possiblyCloseLastScanImageFile();
      _this.clearElement();
      _this.lastScanImageFile = URL.createObjectURL(imageFile);
      var inputImage = new Image();
      inputImage.onload = function() {
        var imageWidth = inputImage.width;
        var imageHeight = inputImage.height;
        var element = document.getElementById(_this.elementId);
        var containerWidth = element.clientWidth ? element.clientWidth : Constants.DEFAULT_WIDTH;
        var containerHeight = Math.max(element.clientHeight ? element.clientHeight : imageHeight, Constants.FILE_SCAN_MIN_HEIGHT);
        var config = _this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
        if (showImage) {
          var visibleCanvas = _this.createCanvasElement(containerWidth, containerHeight, "qr-canvas-visible");
          visibleCanvas.style.display = "inline-block";
          element.appendChild(visibleCanvas);
          var context_1 = visibleCanvas.getContext("2d");
          if (!context_1) {
            throw "Unable to get 2d context from canvas";
          }
          context_1.canvas.width = containerWidth;
          context_1.canvas.height = containerHeight;
          context_1.drawImage(inputImage, 0, 0, imageWidth, imageHeight, config.x, config.y, config.width, config.height);
        }
        var padding = Constants.FILE_SCAN_HIDDEN_CANVAS_PADDING;
        var hiddenImageWidth = Math.max(inputImage.width, config.width);
        var hiddenImageHeight = Math.max(inputImage.height, config.height);
        var hiddenCanvasWidth = hiddenImageWidth + 2 * padding;
        var hiddenCanvasHeight = hiddenImageHeight + 2 * padding;
        var hiddenCanvas = _this.createCanvasElement(hiddenCanvasWidth, hiddenCanvasHeight);
        element.appendChild(hiddenCanvas);
        var context = hiddenCanvas.getContext("2d");
        if (!context) {
          throw "Unable to get 2d context from canvas";
        }
        context.canvas.width = hiddenCanvasWidth;
        context.canvas.height = hiddenCanvasHeight;
        context.drawImage(inputImage, 0, 0, imageWidth, imageHeight, padding, padding, hiddenImageWidth, hiddenImageHeight);
        try {
          _this.qrcode.decodeRobustlyAsync(hiddenCanvas).then(function(result) {
            resolve(Html5QrcodeResultFactory.createFromQrcodeResult(result));
          }).catch(reject);
        } catch (exception) {
          reject("QR code parse error, error = ".concat(exception));
        }
      };
      inputImage.onerror = reject;
      inputImage.onabort = reject;
      inputImage.onstalled = reject;
      inputImage.onsuspend = reject;
      inputImage.src = URL.createObjectURL(imageFile);
    });
  };
  Html5Qrcode2.prototype.clear = function() {
    this.clearElement();
  };
  Html5Qrcode2.getCameras = function() {
    return CameraRetriever.retrieve();
  };
  Html5Qrcode2.prototype.getRunningTrackCapabilities = function() {
    return this.getRenderedCameraOrFail().getRunningTrackCapabilities();
  };
  Html5Qrcode2.prototype.getRunningTrackSettings = function() {
    return this.getRenderedCameraOrFail().getRunningTrackSettings();
  };
  Html5Qrcode2.prototype.getRunningTrackCameraCapabilities = function() {
    return this.getRenderedCameraOrFail().getCapabilities();
  };
  Html5Qrcode2.prototype.applyVideoConstraints = function(videoConstaints) {
    if (!videoConstaints) {
      throw "videoConstaints is required argument.";
    } else if (!VideoConstraintsUtil.isMediaStreamConstraintsValid(videoConstaints, this.logger)) {
      throw "invalid videoConstaints passed, check logs for more details";
    }
    return this.getRenderedCameraOrFail().applyVideoConstraints(videoConstaints);
  };
  Html5Qrcode2.prototype.getRenderedCameraOrFail = function() {
    if (this.renderedCamera == null) {
      throw "Scanning is not in running state, call this API only when QR code scanning using camera is in running state.";
    }
    return this.renderedCamera;
  };
  Html5Qrcode2.prototype.getSupportedFormats = function(configOrVerbosityFlag) {
    var allFormats = [
      Html5QrcodeSupportedFormats.QR_CODE,
      Html5QrcodeSupportedFormats.AZTEC,
      Html5QrcodeSupportedFormats.CODABAR,
      Html5QrcodeSupportedFormats.CODE_39,
      Html5QrcodeSupportedFormats.CODE_93,
      Html5QrcodeSupportedFormats.CODE_128,
      Html5QrcodeSupportedFormats.DATA_MATRIX,
      Html5QrcodeSupportedFormats.MAXICODE,
      Html5QrcodeSupportedFormats.ITF,
      Html5QrcodeSupportedFormats.EAN_13,
      Html5QrcodeSupportedFormats.EAN_8,
      Html5QrcodeSupportedFormats.PDF_417,
      Html5QrcodeSupportedFormats.RSS_14,
      Html5QrcodeSupportedFormats.RSS_EXPANDED,
      Html5QrcodeSupportedFormats.UPC_A,
      Html5QrcodeSupportedFormats.UPC_E,
      Html5QrcodeSupportedFormats.UPC_EAN_EXTENSION
    ];
    if (!configOrVerbosityFlag || typeof configOrVerbosityFlag == "boolean") {
      return allFormats;
    }
    if (!configOrVerbosityFlag.formatsToSupport) {
      return allFormats;
    }
    if (!Array.isArray(configOrVerbosityFlag.formatsToSupport)) {
      throw "configOrVerbosityFlag.formatsToSupport should be undefined or an array.";
    }
    if (configOrVerbosityFlag.formatsToSupport.length === 0) {
      throw "Atleast 1 formatsToSupport is needed.";
    }
    var supportedFormats = [];
    for (var _i = 0, _a = configOrVerbosityFlag.formatsToSupport; _i < _a.length; _i++) {
      var format2 = _a[_i];
      if (isValidHtml5QrcodeSupportedFormats(format2)) {
        supportedFormats.push(format2);
      } else {
        this.logger.warn("Invalid format: ".concat(format2, " passed in config, ignoring."));
      }
    }
    if (supportedFormats.length === 0) {
      throw "None of formatsToSupport match supported values.";
    }
    return supportedFormats;
  };
  Html5Qrcode2.prototype.getUseBarCodeDetectorIfSupported = function(config) {
    if (isNullOrUndefined(config)) {
      return true;
    }
    if (!isNullOrUndefined(config.useBarCodeDetectorIfSupported)) {
      return config.useBarCodeDetectorIfSupported !== false;
    }
    if (isNullOrUndefined(config.experimentalFeatures)) {
      return true;
    }
    var experimentalFeatures = config.experimentalFeatures;
    if (isNullOrUndefined(experimentalFeatures.useBarCodeDetectorIfSupported)) {
      return true;
    }
    return experimentalFeatures.useBarCodeDetectorIfSupported !== false;
  };
  Html5Qrcode2.prototype.validateQrboxSize = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    var _this = this;
    var qrboxSize = internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    var validateMinSize = function(size2) {
      if (size2 < Constants.MIN_QR_BOX_SIZE) {
        throw "minimum size of 'config.qrbox' dimension value is" + " ".concat(Constants.MIN_QR_BOX_SIZE, "px.");
      }
    };
    var correctWidthBasedOnRootElementSize = function(configWidth) {
      if (configWidth > viewfinderWidth) {
        _this.logger.warn("`qrbox.width` or `qrbox` is larger than the width of the root element. The width will be truncated to the width of root element.");
        configWidth = viewfinderWidth;
      }
      return configWidth;
    };
    validateMinSize(qrDimensions.width);
    validateMinSize(qrDimensions.height);
    qrDimensions.width = correctWidthBasedOnRootElementSize(qrDimensions.width);
  };
  Html5Qrcode2.prototype.validateQrboxConfig = function(qrboxSize) {
    if (typeof qrboxSize === "number") {
      return;
    }
    if (typeof qrboxSize === "function") {
      return;
    }
    if (qrboxSize.width === void 0 || qrboxSize.height === void 0) {
      throw "Invalid instance of QrDimensions passed for 'config.qrbox'. Both 'width' and 'height' should be set.";
    }
  };
  Html5Qrcode2.prototype.toQrdimensions = function(viewfinderWidth, viewfinderHeight, qrboxSize) {
    if (typeof qrboxSize === "number") {
      return { width: qrboxSize, height: qrboxSize };
    } else if (typeof qrboxSize === "function") {
      try {
        return qrboxSize(viewfinderWidth, viewfinderHeight);
      } catch (error) {
        throw new Error("qrbox config was passed as a function but it failed with unknown error" + error);
      }
    }
    return qrboxSize;
  };
  Html5Qrcode2.prototype.setupUi = function(viewfinderWidth, viewfinderHeight, internalConfig) {
    if (internalConfig.isShadedBoxEnabled()) {
      this.validateQrboxSize(viewfinderWidth, viewfinderHeight, internalConfig);
    }
    var qrboxSize = isNullOrUndefined(internalConfig.qrbox) ? { width: viewfinderWidth, height: viewfinderHeight } : internalConfig.qrbox;
    this.validateQrboxConfig(qrboxSize);
    var qrDimensions = this.toQrdimensions(viewfinderWidth, viewfinderHeight, qrboxSize);
    if (qrDimensions.height > viewfinderHeight) {
      this.logger.warn("[Html5Qrcode] config.qrbox has height that isgreater than the height of the video stream. Shading will be ignored");
    }
    var shouldShadingBeApplied = internalConfig.isShadedBoxEnabled() && qrDimensions.height <= viewfinderHeight;
    var defaultQrRegion = {
      x: 0,
      y: 0,
      width: viewfinderWidth,
      height: viewfinderHeight
    };
    var qrRegion = shouldShadingBeApplied ? this.getShadedRegionBounds(viewfinderWidth, viewfinderHeight, qrDimensions) : defaultQrRegion;
    var canvasElement = this.createCanvasElement(qrRegion.width, qrRegion.height);
    var contextAttributes = { willReadFrequently: true };
    var context = canvasElement.getContext("2d", contextAttributes);
    context.canvas.width = qrRegion.width;
    context.canvas.height = qrRegion.height;
    this.element.append(canvasElement);
    if (shouldShadingBeApplied) {
      this.possiblyInsertShadingElement(this.element, viewfinderWidth, viewfinderHeight, qrDimensions);
    }
    this.createScannerPausedUiElement(this.element);
    this.qrRegion = qrRegion;
    this.context = context;
    this.canvasElement = canvasElement;
  };
  Html5Qrcode2.prototype.createScannerPausedUiElement = function(rootElement) {
    var scannerPausedUiElement = document.createElement("div");
    scannerPausedUiElement.innerText = Html5QrcodeStrings.scannerPaused();
    scannerPausedUiElement.style.display = "none";
    scannerPausedUiElement.style.position = "absolute";
    scannerPausedUiElement.style.top = "0px";
    scannerPausedUiElement.style.zIndex = "1";
    scannerPausedUiElement.style.background = "rgba(9, 9, 9, 0.46)";
    scannerPausedUiElement.style.color = "#FFECEC";
    scannerPausedUiElement.style.textAlign = "center";
    scannerPausedUiElement.style.width = "100%";
    rootElement.appendChild(scannerPausedUiElement);
    this.scannerPausedUiElement = scannerPausedUiElement;
  };
  Html5Qrcode2.prototype.scanContext = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (this.stateManagerProxy.isPaused()) {
      return Promise.resolve(false);
    }
    return this.qrcode.decodeAsync(this.canvasElement).then(function(result) {
      qrCodeSuccessCallback(result.text, Html5QrcodeResultFactory.createFromQrcodeResult(result));
      _this.possiblyUpdateShaders(true);
      return true;
    }).catch(function(error) {
      _this.possiblyUpdateShaders(false);
      var errorMessage = Html5QrcodeStrings.codeParseError(error);
      qrCodeErrorCallback(errorMessage, Html5QrcodeErrorFactory.createFrom(errorMessage));
      return false;
    });
  };
  Html5Qrcode2.prototype.foreverScan = function(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    if (!this.shouldScan) {
      return;
    }
    if (!this.renderedCamera) {
      return;
    }
    var videoElement = this.renderedCamera.getSurface();
    var widthRatio = videoElement.videoWidth / videoElement.clientWidth;
    var heightRatio = videoElement.videoHeight / videoElement.clientHeight;
    if (!this.qrRegion) {
      throw "qrRegion undefined when localMediaStream is ready.";
    }
    var sWidthOffset = this.qrRegion.width * widthRatio;
    var sHeightOffset = this.qrRegion.height * heightRatio;
    var sxOffset = this.qrRegion.x * widthRatio;
    var syOffset = this.qrRegion.y * heightRatio;
    this.context.drawImage(videoElement, sxOffset, syOffset, sWidthOffset, sHeightOffset, 0, 0, this.qrRegion.width, this.qrRegion.height);
    var triggerNextScan = function() {
      _this.foreverScanTimeout = setTimeout(function() {
        _this.foreverScan(internalConfig, qrCodeSuccessCallback, qrCodeErrorCallback);
      }, _this.getTimeoutFps(internalConfig.fps));
    };
    this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).then(function(isSuccessfull) {
      if (!isSuccessfull && internalConfig.disableFlip !== true) {
        _this.context.translate(_this.context.canvas.width, 0);
        _this.context.scale(-1, 1);
        _this.scanContext(qrCodeSuccessCallback, qrCodeErrorCallback).finally(function() {
          triggerNextScan();
        });
      } else {
        triggerNextScan();
      }
    }).catch(function(error) {
      _this.logger.logError("Error happend while scanning context", error);
      triggerNextScan();
    });
  };
  Html5Qrcode2.prototype.createVideoConstraints = function(cameraIdOrConfig) {
    if (typeof cameraIdOrConfig == "string") {
      return { deviceId: { exact: cameraIdOrConfig } };
    } else if (typeof cameraIdOrConfig == "object") {
      var facingModeKey = "facingMode";
      var deviceIdKey = "deviceId";
      var allowedFacingModeValues_1 = { "user": true, "environment": true };
      var exactKey = "exact";
      var isValidFacingModeValue = function(value) {
        if (value in allowedFacingModeValues_1) {
          return true;
        } else {
          throw "config has invalid 'facingMode' value = " + "'".concat(value, "'");
        }
      };
      var keys2 = Object.keys(cameraIdOrConfig);
      if (keys2.length !== 1) {
        throw "'cameraIdOrConfig' object should have exactly 1 key," + " if passed as an object, found ".concat(keys2.length, " keys");
      }
      var key = Object.keys(cameraIdOrConfig)[0];
      if (key !== facingModeKey && key !== deviceIdKey) {
        throw "Only '".concat(facingModeKey, "' and '").concat(deviceIdKey, "' ") + " are supported for 'cameraIdOrConfig'";
      }
      if (key === facingModeKey) {
        var facingMode = cameraIdOrConfig.facingMode;
        if (typeof facingMode == "string") {
          if (isValidFacingModeValue(facingMode)) {
            return { facingMode };
          }
        } else if (typeof facingMode == "object") {
          if (exactKey in facingMode) {
            if (isValidFacingModeValue(facingMode["".concat(exactKey)])) {
              return {
                facingMode: {
                  exact: facingMode["".concat(exactKey)]
                }
              };
            }
          } else {
            throw "'facingMode' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_1 = typeof facingMode;
          throw "Invalid type of 'facingMode' = ".concat(type_1);
        }
      } else {
        var deviceId = cameraIdOrConfig.deviceId;
        if (typeof deviceId == "string") {
          return { deviceId };
        } else if (typeof deviceId == "object") {
          if (exactKey in deviceId) {
            return {
              deviceId: { exact: deviceId["".concat(exactKey)] }
            };
          } else {
            throw "'deviceId' should be string or object with" + " ".concat(exactKey, " as key.");
          }
        } else {
          var type_2 = typeof deviceId;
          throw "Invalid type of 'deviceId' = ".concat(type_2);
        }
      }
    }
    var type = typeof cameraIdOrConfig;
    throw "Invalid type of 'cameraIdOrConfig' = ".concat(type);
  };
  Html5Qrcode2.prototype.computeCanvasDrawConfig = function(imageWidth, imageHeight, containerWidth, containerHeight) {
    if (imageWidth <= containerWidth && imageHeight <= containerHeight) {
      var xoffset = (containerWidth - imageWidth) / 2;
      var yoffset = (containerHeight - imageHeight) / 2;
      return {
        x: xoffset,
        y: yoffset,
        width: imageWidth,
        height: imageHeight
      };
    } else {
      var formerImageWidth = imageWidth;
      var formerImageHeight = imageHeight;
      if (imageWidth > containerWidth) {
        imageHeight = containerWidth / imageWidth * imageHeight;
        imageWidth = containerWidth;
      }
      if (imageHeight > containerHeight) {
        imageWidth = containerHeight / imageHeight * imageWidth;
        imageHeight = containerHeight;
      }
      this.logger.log("Image downsampled from " + "".concat(formerImageWidth, "X").concat(formerImageHeight) + " to ".concat(imageWidth, "X").concat(imageHeight, "."));
      return this.computeCanvasDrawConfig(imageWidth, imageHeight, containerWidth, containerHeight);
    }
  };
  Html5Qrcode2.prototype.clearElement = function() {
    if (this.stateManagerProxy.isScanning()) {
      throw "Cannot clear while scan is ongoing, close it first.";
    }
    var element = document.getElementById(this.elementId);
    if (element) {
      element.innerHTML = "";
    }
  };
  Html5Qrcode2.prototype.possiblyUpdateShaders = function(qrMatch) {
    if (this.qrMatch === qrMatch) {
      return;
    }
    if (this.hasBorderShaders && this.borderShaders && this.borderShaders.length) {
      this.borderShaders.forEach(function(shader) {
        shader.style.backgroundColor = qrMatch ? Constants.BORDER_SHADER_MATCH_COLOR : Constants.BORDER_SHADER_DEFAULT_COLOR;
      });
    }
    this.qrMatch = qrMatch;
  };
  Html5Qrcode2.prototype.possiblyCloseLastScanImageFile = function() {
    if (this.lastScanImageFile) {
      URL.revokeObjectURL(this.lastScanImageFile);
      this.lastScanImageFile = null;
    }
  };
  Html5Qrcode2.prototype.createCanvasElement = function(width, height, customId) {
    var canvasWidth = width;
    var canvasHeight = height;
    var canvasElement = document.createElement("canvas");
    canvasElement.style.width = "".concat(canvasWidth, "px");
    canvasElement.style.height = "".concat(canvasHeight, "px");
    canvasElement.style.display = "none";
    canvasElement.id = isNullOrUndefined(customId) ? "qr-canvas" : customId;
    return canvasElement;
  };
  Html5Qrcode2.prototype.getShadedRegionBounds = function(width, height, qrboxSize) {
    if (qrboxSize.width > width || qrboxSize.height > height) {
      throw "'config.qrbox' dimensions should not be greater than the dimensions of the root HTML element.";
    }
    return {
      x: (width - qrboxSize.width) / 2,
      y: (height - qrboxSize.height) / 2,
      width: qrboxSize.width,
      height: qrboxSize.height
    };
  };
  Html5Qrcode2.prototype.possiblyInsertShadingElement = function(element, width, height, qrboxSize) {
    if (width - qrboxSize.width < 1 || height - qrboxSize.height < 1) {
      return;
    }
    var shadingElement = document.createElement("div");
    shadingElement.style.position = "absolute";
    var rightLeftBorderSize = (width - qrboxSize.width) / 2;
    var topBottomBorderSize = (height - qrboxSize.height) / 2;
    shadingElement.style.borderLeft = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderRight = "".concat(rightLeftBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderTop = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.borderBottom = "".concat(topBottomBorderSize, "px solid rgba(0, 0, 0, 0.48)");
    shadingElement.style.boxSizing = "border-box";
    shadingElement.style.top = "0px";
    shadingElement.style.bottom = "0px";
    shadingElement.style.left = "0px";
    shadingElement.style.right = "0px";
    shadingElement.id = "".concat(Constants.SHADED_REGION_ELEMENT_ID);
    if (width - qrboxSize.width < 11 || height - qrboxSize.height < 11) {
      this.hasBorderShaders = false;
    } else {
      var smallSize = 5;
      var largeSize = 40;
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, -smallSize, null, 0, false);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, true);
      this.insertShaderBorders(shadingElement, largeSize, smallSize, null, -smallSize, 0, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, true);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, -smallSize, null, -smallSize, false);
      this.insertShaderBorders(shadingElement, smallSize, largeSize + smallSize, null, -smallSize, -smallSize, false);
      this.hasBorderShaders = true;
    }
    element.append(shadingElement);
  };
  Html5Qrcode2.prototype.insertShaderBorders = function(shaderElem, width, height, top, bottom, side, isLeft) {
    var elem = document.createElement("div");
    elem.style.position = "absolute";
    elem.style.backgroundColor = Constants.BORDER_SHADER_DEFAULT_COLOR;
    elem.style.width = "".concat(width, "px");
    elem.style.height = "".concat(height, "px");
    if (top !== null) {
      elem.style.top = "".concat(top, "px");
    }
    if (bottom !== null) {
      elem.style.bottom = "".concat(bottom, "px");
    }
    if (isLeft) {
      elem.style.left = "".concat(side, "px");
    } else {
      elem.style.right = "".concat(side, "px");
    }
    if (!this.borderShaders) {
      this.borderShaders = [];
    }
    this.borderShaders.push(elem);
    shaderElem.appendChild(elem);
  };
  Html5Qrcode2.prototype.showPausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "block";
  };
  Html5Qrcode2.prototype.hidePausedState = function() {
    if (!this.scannerPausedUiElement) {
      throw "[internal error] scanner paused UI element not found";
    }
    this.scannerPausedUiElement.style.display = "none";
  };
  Html5Qrcode2.prototype.getTimeoutFps = function(fps) {
    return 1e3 / fps;
  };
  return Html5Qrcode2;
}();
var SVG_XML_PREFIX = "data:image/svg+xml;base64,";
var ASSET_CAMERA_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAzNzEuNjQzIDM3MS42NDMiIHN0eWxlPSJlbmFibGUtYmFja2dyb3VuZDpuZXcgMCAwIDM3MS42NDMgMzcxLjY0MyIgeG1sOnNwYWNlPSJwcmVzZXJ2ZSI+PHBhdGggZD0iTTEwNS4wODQgMzguMjcxaDE2My43Njh2MjBIMTA1LjA4NHoiLz48cGF0aCBkPSJNMzExLjU5NiAxOTAuMTg5Yy03LjQ0MS05LjM0Ny0xOC40MDMtMTYuMjA2LTMyLjc0My0yMC41MjJWMzBjMC0xNi41NDItMTMuNDU4LTMwLTMwLTMwSDEyNS4wODRjLTE2LjU0MiAwLTMwIDEzLjQ1OC0zMCAzMHYxMjAuMTQzaC04LjI5NmMtMTYuNTQyIDAtMzAgMTMuNDU4LTMwIDMwdjEuMzMzYTI5LjgwNCAyOS44MDQgMCAwIDAgNC42MDMgMTUuOTM5Yy03LjM0IDUuNDc0LTEyLjEwMyAxNC4yMjEtMTIuMTAzIDI0LjA2MXYxLjMzM2MwIDkuODQgNC43NjMgMTguNTg3IDEyLjEwMyAyNC4wNjJhMjkuODEgMjkuODEgMCAwIDAtNC42MDMgMTUuOTM4djEuMzMzYzAgMTYuNTQyIDEzLjQ1OCAzMCAzMCAzMGg4LjMyNGMuNDI3IDExLjYzMSA3LjUwMyAyMS41ODcgMTcuNTM0IDI2LjE3Ny45MzEgMTAuNTAzIDQuMDg0IDMwLjE4NyAxNC43NjggNDUuNTM3YTkuOTg4IDkuOTg4IDAgMCAwIDguMjE2IDQuMjg4IDkuOTU4IDkuOTU4IDAgMCAwIDUuNzA0LTEuNzkzYzQuNTMzLTMuMTU1IDUuNjUtOS4zODggMi40OTUtMTMuOTIxLTYuNzk4LTkuNzY3LTkuNjAyLTIyLjYwOC0xMC43Ni0zMS40aDgyLjY4NWMuMjcyLjQxNC41NDUuODE4LjgxNSAxLjIxIDMuMTQyIDQuNTQxIDkuMzcyIDUuNjc5IDEzLjkxMyAyLjUzNCA0LjU0Mi0zLjE0MiA1LjY3Ny05LjM3MSAyLjUzNS0xMy45MTMtMTEuOTE5LTE3LjIyOS04Ljc4Ny0zNS44ODQgOS41ODEtNTcuMDEyIDMuMDY3LTIuNjUyIDEyLjMwNy0xMS43MzIgMTEuMjE3LTI0LjAzMy0uODI4LTkuMzQzLTcuMTA5LTE3LjE5NC0xOC42NjktMjMuMzM3YTkuODU3IDkuODU3IDAgMCAwLTEuMDYxLS40ODZjLS40NjYtLjE4Mi0xMS40MDMtNC41NzktOS43NDEtMTUuNzA2IDEuMDA3LTYuNzM3IDE0Ljc2OC04LjI3MyAyMy43NjYtNy42NjYgMjMuMTU2IDEuNTY5IDM5LjY5OCA3LjgwMyA0Ny44MzYgMTguMDI2IDUuNzUyIDcuMjI1IDcuNjA3IDE2LjYyMyA1LjY3MyAyOC43MzMtLjQxMyAyLjU4NS0uODI0IDUuMjQxLTEuMjQ1IDcuOTU5LTUuNzU2IDM3LjE5NC0xMi45MTkgODMuNDgzLTQ5Ljg3IDExNC42NjEtNC4yMjEgMy41NjEtNC43NTYgOS44Ny0xLjE5NCAxNC4wOTJhOS45OCA5Ljk4IDAgMCAwIDcuNjQ4IDMuNTUxIDkuOTU1IDkuOTU1IDAgMCAwIDYuNDQ0LTIuMzU4YzQyLjY3Mi0zNi4wMDUgNTAuODAyLTg4LjUzMyA1Ni43MzctMTI2Ljg4OC40MTUtMi42ODQuODIxLTUuMzA5IDEuMjI5LTcuODYzIDIuODM0LTE3LjcyMS0uNDU1LTMyLjY0MS05Ljc3Mi00NC4zNDV6bS0yMzIuMzA4IDQyLjYyYy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM2MwLTUuNTE0IDQuNDg2LTEwIDEwLTEwaDE1djIxLjMzM2gtMTV6bS0yLjUtNTIuNjY2YzAtNS41MTQgNC40ODYtMTAgMTAtMTBoNy41djIxLjMzM2gtNy41Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi0xLjMzM3ptMTcuNSA5My45OTloLTcuNWMtNS41MTQgMC0xMC00LjQ4Ni0xMC0xMHYtMS4zMzNjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGg3LjV2MjEuMzMzem0zMC43OTYgMjguODg3Yy01LjUxNCAwLTEwLTQuNDg2LTEwLTEwdi04LjI3MWg5MS40NTdjLS44NTEgNi42NjgtLjQzNyAxMi43ODcuNzMxIDE4LjI3MWgtODIuMTg4em03OS40ODItMTEzLjY5OGMtMy4xMjQgMjAuOTA2IDEyLjQyNyAzMy4xODQgMjEuNjI1IDM3LjA0IDUuNDQxIDIuOTY4IDcuNTUxIDUuNjQ3IDcuNzAxIDcuMTg4LjIxIDIuMTUtMi41NTMgNS42ODQtNC40NzcgNy4yNTEtLjQ4Mi4zNzgtLjkyOS44LTEuMzM1IDEuMjYxLTYuOTg3IDcuOTM2LTExLjk4MiAxNS41Mi0xNS40MzIgMjIuNjg4aC05Ny41NjRWMzBjMC01LjUxNCA0LjQ4Ni0xMCAxMC0xMGgxMjMuNzY5YzUuNTE0IDAgMTAgNC40ODYgMTAgMTB2MTM1LjU3OWMtMy4wMzItLjM4MS02LjE1LS42OTQtOS4zODktLjkxNC0yNS4xNTktMS42OTQtNDIuMzcgNy43NDgtNDQuODk4IDI0LjY2NnoiLz48cGF0aCBkPSJNMTc5LjEyOSA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXpNMTcyLjYyOSAxNDIuODZoLTEyLjU2VjEzMC44YTUgNSAwIDEgMC0xMCAwdjE3LjA2MWE1IDUgMCAwIDAgNSA1aDE3LjU2YTUgNSAwIDEgMCAwLTEwLjAwMXpNMjE2LjU2OCA4My4xNjdoLTI0LjA2YTUgNSAwIDAgMC01IDV2MjQuMDYxYTUgNSAwIDAgMCA1IDVoMjQuMDZhNSA1IDAgMCAwIDUtNVY4OC4xNjdhNSA1IDAgMCAwLTUtNXptLTUgMjQuMDYxaC0xNC4wNlY5My4xNjdoMTQuMDZ2MTQuMDYxek0yMTEuNjY5IDEyNS45MzZIMTk3LjQxYTUgNSAwIDAgMC01IDV2MTQuMjU3YTUgNSAwIDAgMCA1IDVoMTQuMjU5YTUgNSAwIDAgMCA1LTV2LTE0LjI1N2E1IDUgMCAwIDAtNS01eiIvPjwvc3ZnPg==";
var ASSET_FILE_SCAN = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1OS4wMTggNTkuMDE4IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA1OS4wMTggNTkuMDE4IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJtNTguNzQxIDU0LjgwOS01Ljk2OS02LjI0NGExMC43NCAxMC43NCAwIDAgMCAyLjgyLTcuMjVjMC01Ljk1My00Ljg0My0xMC43OTYtMTAuNzk2LTEwLjc5NlMzNCAzNS4zNjEgMzQgNDEuMzE0IDM4Ljg0MyA1Mi4xMSA0NC43OTYgNTIuMTFjMi40NDEgMCA0LjY4OC0uODI0IDYuNDk5LTIuMTk2bDYuMDAxIDYuMjc3YS45OTguOTk4IDAgMCAwIDEuNDE0LjAzMiAxIDEgMCAwIDAgLjAzMS0xLjQxNHpNMzYgNDEuMzE0YzAtNC44NSAzLjk0Ni04Ljc5NiA4Ljc5Ni04Ljc5NnM4Ljc5NiAzLjk0NiA4Ljc5NiA4Ljc5Ni0zLjk0NiA4Ljc5Ni04Ljc5NiA4Ljc5NlMzNiA0Ni4xNjQgMzYgNDEuMzE0ek0xMC40MzEgMTYuMDg4YzAgMy4wNyAyLjQ5OCA1LjU2OCA1LjU2OSA1LjU2OHM1LjU2OS0yLjQ5OCA1LjU2OS01LjU2OGMwLTMuMDcxLTIuNDk4LTUuNTY5LTUuNTY5LTUuNTY5cy01LjU2OSAyLjQ5OC01LjU2OSA1LjU2OXptOS4xMzggMGMwIDEuOTY4LTEuNjAyIDMuNTY4LTMuNTY5IDMuNTY4cy0zLjU2OS0xLjYwMS0zLjU2OS0zLjU2OCAxLjYwMi0zLjU2OSAzLjU2OS0zLjU2OSAzLjU2OSAxLjYwMSAzLjU2OSAzLjU2OXoiLz48cGF0aCBkPSJtMzAuODgyIDI4Ljk4NyA5LjE4LTEwLjA1NCAxMS4yNjIgMTAuMzIzYTEgMSAwIDAgMCAxLjM1MS0xLjQ3NWwtMTItMTFhMSAxIDAgMCAwLTEuNDE0LjA2M2wtOS43OTQgMTAuNzI3LTQuNzQzLTQuNzQzYTEuMDAzIDEuMDAzIDAgMCAwLTEuMzY4LS4wNDRMNi4zMzkgMzcuNzY4YTEgMSAwIDEgMCAxLjMyMiAxLjUwMWwxNi4zMTMtMTQuMzYyIDcuMzE5IDcuMzE4YS45OTkuOTk5IDAgMSAwIDEuNDE0LTEuNDE0bC0xLjgyNS0xLjgyNHoiLz48cGF0aCBkPSJNMzAgNDYuNTE4SDJ2LTQyaDU0djI4YTEgMSAwIDEgMCAyIDB2LTI5YTEgMSAwIDAgMC0xLTFIMWExIDEgMCAwIDAtMSAxdjQ0YTEgMSAwIDAgMCAxIDFoMjlhMSAxIDAgMSAwIDAtMnoiLz48L3N2Zz4=";
var ASSET_INFO_ICON_16PX = SVG_XML_PREFIX + "PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA0NjAgNDYwIiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA0NjAgNDYwIiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBkPSJNMjMwIDBDMTAyLjk3NSAwIDAgMTAyLjk3NSAwIDIzMHMxMDIuOTc1IDIzMCAyMzAgMjMwIDIzMC0xMDIuOTc0IDIzMC0yMzBTMzU3LjAyNSAwIDIzMCAwem0zOC4zMzMgMzc3LjM2YzAgOC42NzYtNy4wMzQgMTUuNzEtMTUuNzEgMTUuNzFoLTQzLjEwMWMtOC42NzYgMC0xNS43MS03LjAzNC0xNS43MS0xNS43MVYyMDIuNDc3YzAtOC42NzYgNy4wMzMtMTUuNzEgMTUuNzEtMTUuNzFoNDMuMTAxYzguNjc2IDAgMTUuNzEgNy4wMzMgMTUuNzEgMTUuNzFWMzc3LjM2ek0yMzAgMTU3Yy0yMS41MzkgMC0zOS0xNy40NjEtMzktMzlzMTcuNDYxLTM5IDM5LTM5IDM5IDE3LjQ2MSAzOSAzOS0xNy40NjEgMzktMzkgMzl6Ii8+PC9zdmc+";
var ASSET_CLOSE_ICON_16PX = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAAQgAAAEIBarqQRAAAABl0RVh0U29mdHdhcmUAd3d3Lmlua3NjYXBlLm9yZ5vuPBoAAAE1SURBVDiNfdI7S0NBEAXgLya1otFgpbYSbISAgpXYi6CmiH9KCAiChaVga6OiWPgfRDQ+0itaGVNosXtluWwcuMzePfM4M3sq8lbHBubwg1dc4m1E/J/N4ghDPOIsfk/4xiEao5KX0McFljN4C9d4QTPXuY99jP3DsIoDPGM6BY5i5yI5R7O4q+ImFkJY2DCh3cAH2klyB+9J1xUMMAG7eCh1a+Mr+k48b5diXrFVwwLuS+BJ9MfR7+G0FHOHhTHhnXNWS87VDF4pcnfQK4Ep7XScNLmPTZgURNKKYENYWDpzW1BhscS1WHS8CDgURFJQrWcoF3c13KKbgg1BYQfy8xZWEzTTw1QZbAoKu8FqJnktdu5hcVSHmchiILzzuaDQvjBzV2m8yohCE1jHfPx/xhU+y4G/D75ELlRJsSYAAAAASUVORK5CYII=";
var PersistedDataFactory = function() {
  function PersistedDataFactory2() {
  }
  PersistedDataFactory2.createDefault = function() {
    return {
      hasPermission: false,
      lastUsedCameraId: null
    };
  };
  return PersistedDataFactory2;
}();
var PersistedDataManager = function() {
  function PersistedDataManager2() {
    this.data = PersistedDataFactory.createDefault();
    var data = localStorage.getItem(PersistedDataManager2.LOCAL_STORAGE_KEY);
    if (!data) {
      this.reset();
    } else {
      this.data = JSON.parse(data);
    }
  }
  PersistedDataManager2.prototype.hasCameraPermissions = function() {
    return this.data.hasPermission;
  };
  PersistedDataManager2.prototype.getLastUsedCameraId = function() {
    return this.data.lastUsedCameraId;
  };
  PersistedDataManager2.prototype.setHasPermission = function(hasPermission) {
    this.data.hasPermission = hasPermission;
    this.flush();
  };
  PersistedDataManager2.prototype.setLastUsedCameraId = function(lastUsedCameraId) {
    this.data.lastUsedCameraId = lastUsedCameraId;
    this.flush();
  };
  PersistedDataManager2.prototype.resetLastUsedCameraId = function() {
    this.data.lastUsedCameraId = null;
    this.flush();
  };
  PersistedDataManager2.prototype.reset = function() {
    this.data = PersistedDataFactory.createDefault();
    this.flush();
  };
  PersistedDataManager2.prototype.flush = function() {
    localStorage.setItem(PersistedDataManager2.LOCAL_STORAGE_KEY, JSON.stringify(this.data));
  };
  PersistedDataManager2.LOCAL_STORAGE_KEY = "HTML5_QRCODE_DATA";
  return PersistedDataManager2;
}();
var LibraryInfoDiv = function() {
  function LibraryInfoDiv2() {
    this.infoDiv = document.createElement("div");
  }
  LibraryInfoDiv2.prototype.renderInto = function(parent) {
    this.infoDiv.style.position = "absolute";
    this.infoDiv.style.top = "10px";
    this.infoDiv.style.right = "10px";
    this.infoDiv.style.zIndex = "2";
    this.infoDiv.style.display = "none";
    this.infoDiv.style.padding = "5pt";
    this.infoDiv.style.border = "1px solid #171717";
    this.infoDiv.style.fontSize = "10pt";
    this.infoDiv.style.background = "rgb(0 0 0 / 69%)";
    this.infoDiv.style.borderRadius = "5px";
    this.infoDiv.style.textAlign = "center";
    this.infoDiv.style.fontWeight = "400";
    this.infoDiv.style.color = "white";
    this.infoDiv.innerText = LibraryInfoStrings.poweredBy();
    var projectLink = document.createElement("a");
    projectLink.innerText = "ScanApp";
    projectLink.href = "https://scanapp.org";
    projectLink.target = "new";
    projectLink.style.color = "white";
    this.infoDiv.appendChild(projectLink);
    var breakElemFirst = document.createElement("br");
    var breakElemSecond = document.createElement("br");
    this.infoDiv.appendChild(breakElemFirst);
    this.infoDiv.appendChild(breakElemSecond);
    var reportIssueLink = document.createElement("a");
    reportIssueLink.innerText = LibraryInfoStrings.reportIssues();
    reportIssueLink.href = "https://github.com/mebjas/html5-qrcode/issues";
    reportIssueLink.target = "new";
    reportIssueLink.style.color = "white";
    this.infoDiv.appendChild(reportIssueLink);
    parent.appendChild(this.infoDiv);
  };
  LibraryInfoDiv2.prototype.show = function() {
    this.infoDiv.style.display = "block";
  };
  LibraryInfoDiv2.prototype.hide = function() {
    this.infoDiv.style.display = "none";
  };
  return LibraryInfoDiv2;
}();
var LibraryInfoIcon = function() {
  function LibraryInfoIcon2(onTapIn, onTapOut) {
    this.isShowingInfoIcon = true;
    this.onTapIn = onTapIn;
    this.onTapOut = onTapOut;
    this.infoIcon = document.createElement("img");
  }
  LibraryInfoIcon2.prototype.renderInto = function(parent) {
    var _this = this;
    this.infoIcon.alt = "Info icon";
    this.infoIcon.src = ASSET_INFO_ICON_16PX;
    this.infoIcon.style.position = "absolute";
    this.infoIcon.style.top = "4px";
    this.infoIcon.style.right = "4px";
    this.infoIcon.style.opacity = "0.6";
    this.infoIcon.style.cursor = "pointer";
    this.infoIcon.style.zIndex = "2";
    this.infoIcon.style.width = "16px";
    this.infoIcon.style.height = "16px";
    this.infoIcon.onmouseover = function(_2) {
      return _this.onHoverIn();
    };
    this.infoIcon.onmouseout = function(_2) {
      return _this.onHoverOut();
    };
    this.infoIcon.onclick = function(_2) {
      return _this.onClick();
    };
    parent.appendChild(this.infoIcon);
  };
  LibraryInfoIcon2.prototype.onHoverIn = function() {
    if (this.isShowingInfoIcon) {
      this.infoIcon.style.opacity = "1";
    }
  };
  LibraryInfoIcon2.prototype.onHoverOut = function() {
    if (this.isShowingInfoIcon) {
      this.infoIcon.style.opacity = "0.6";
    }
  };
  LibraryInfoIcon2.prototype.onClick = function() {
    if (this.isShowingInfoIcon) {
      this.isShowingInfoIcon = false;
      this.onTapIn();
      this.infoIcon.src = ASSET_CLOSE_ICON_16PX;
      this.infoIcon.style.opacity = "1";
    } else {
      this.isShowingInfoIcon = true;
      this.onTapOut();
      this.infoIcon.src = ASSET_INFO_ICON_16PX;
      this.infoIcon.style.opacity = "0.6";
    }
  };
  return LibraryInfoIcon2;
}();
var LibraryInfoContainer = function() {
  function LibraryInfoContainer2() {
    var _this = this;
    this.infoDiv = new LibraryInfoDiv();
    this.infoIcon = new LibraryInfoIcon(function() {
      _this.infoDiv.show();
    }, function() {
      _this.infoDiv.hide();
    });
  }
  LibraryInfoContainer2.prototype.renderInto = function(parent) {
    this.infoDiv.renderInto(parent);
    this.infoIcon.renderInto(parent);
  };
  return LibraryInfoContainer2;
}();
var __awaiter$1 = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator$1 = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var CameraPermissions = function() {
  function CameraPermissions2() {
  }
  CameraPermissions2.hasPermissions = function() {
    return __awaiter$1(this, void 0, void 0, function() {
      var devices, _i, devices_1, device;
      return __generator$1(this, function(_a) {
        switch (_a.label) {
          case 0:
            return [4, navigator.mediaDevices.enumerateDevices()];
          case 1:
            devices = _a.sent();
            for (_i = 0, devices_1 = devices; _i < devices_1.length; _i++) {
              device = devices_1[_i];
              if (device.kind === "videoinput" && device.label) {
                return [2, true];
              }
            }
            return [2, false];
        }
      });
    });
  };
  return CameraPermissions2;
}();
var ScanTypeSelector = function() {
  function ScanTypeSelector2(supportedScanTypes) {
    this.supportedScanTypes = this.validateAndReturnScanTypes(supportedScanTypes);
  }
  ScanTypeSelector2.prototype.getDefaultScanType = function() {
    return this.supportedScanTypes[0];
  };
  ScanTypeSelector2.prototype.hasMoreThanOneScanType = function() {
    return this.supportedScanTypes.length > 1;
  };
  ScanTypeSelector2.prototype.isCameraScanRequired = function() {
    for (var _i = 0, _a = this.supportedScanTypes; _i < _a.length; _i++) {
      var scanType = _a[_i];
      if (ScanTypeSelector2.isCameraScanType(scanType)) {
        return true;
      }
    }
    return false;
  };
  ScanTypeSelector2.isCameraScanType = function(scanType) {
    return scanType === Html5QrcodeScanType.SCAN_TYPE_CAMERA;
  };
  ScanTypeSelector2.isFileScanType = function(scanType) {
    return scanType === Html5QrcodeScanType.SCAN_TYPE_FILE;
  };
  ScanTypeSelector2.prototype.validateAndReturnScanTypes = function(supportedScanTypes) {
    if (!supportedScanTypes || supportedScanTypes.length === 0) {
      return Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
    }
    var maxExpectedValues = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.length;
    if (supportedScanTypes.length > maxExpectedValues) {
      throw "Max ".concat(maxExpectedValues, " values expected for ") + "supportedScanTypes";
    }
    for (var _i = 0, supportedScanTypes_1 = supportedScanTypes; _i < supportedScanTypes_1.length; _i++) {
      var scanType = supportedScanTypes_1[_i];
      if (!Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE.includes(scanType)) {
        throw "Unsupported scan type ".concat(scanType);
      }
    }
    return supportedScanTypes;
  };
  return ScanTypeSelector2;
}();
var PublicUiElementIdAndClasses = function() {
  function PublicUiElementIdAndClasses2() {
  }
  PublicUiElementIdAndClasses2.ALL_ELEMENT_CLASS = "html5-qrcode-element";
  PublicUiElementIdAndClasses2.CAMERA_PERMISSION_BUTTON_ID = "html5-qrcode-button-camera-permission";
  PublicUiElementIdAndClasses2.CAMERA_START_BUTTON_ID = "html5-qrcode-button-camera-start";
  PublicUiElementIdAndClasses2.CAMERA_STOP_BUTTON_ID = "html5-qrcode-button-camera-stop";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_ID = "html5-qrcode-button-torch";
  PublicUiElementIdAndClasses2.CAMERA_SELECTION_SELECT_ID = "html5-qrcode-select-camera";
  PublicUiElementIdAndClasses2.FILE_SELECTION_BUTTON_ID = "html5-qrcode-button-file-selection";
  PublicUiElementIdAndClasses2.ZOOM_SLIDER_ID = "html5-qrcode-input-range-zoom";
  PublicUiElementIdAndClasses2.SCAN_TYPE_CHANGE_ANCHOR_ID = "html5-qrcode-anchor-scan-type-change";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_ON = "html5-qrcode-button-torch-on";
  PublicUiElementIdAndClasses2.TORCH_BUTTON_CLASS_TORCH_OFF = "html5-qrcode-button-torch-off";
  return PublicUiElementIdAndClasses2;
}();
var BaseUiElementFactory = function() {
  function BaseUiElementFactory2() {
  }
  BaseUiElementFactory2.createElement = function(elementType, elementId) {
    var element = document.createElement(elementType);
    element.id = elementId;
    element.classList.add(PublicUiElementIdAndClasses.ALL_ELEMENT_CLASS);
    if (elementType === "button") {
      element.setAttribute("type", "button");
    }
    return element;
  };
  return BaseUiElementFactory2;
}();
var __awaiter = function(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1) throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f2, y4, t3, g2;
  return g2 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g2[Symbol.iterator] = function() {
    return this;
  }), g2;
  function verb(n2) {
    return function(v2) {
      return step([n2, v2]);
    };
  }
  function step(op) {
    if (f2) throw new TypeError("Generator is already executing.");
    while (g2 && (g2 = 0, op[0] && (_2 = 0)), _2) try {
      if (f2 = 1, y4 && (t3 = op[0] & 2 ? y4["return"] : op[0] ? y4["throw"] || ((t3 = y4["return"]) && t3.call(y4), 0) : y4.next) && !(t3 = t3.call(y4, op[1])).done) return t3;
      if (y4 = 0, t3) op = [op[0] & 2, t3.value];
      switch (op[0]) {
        case 0:
        case 1:
          t3 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y4 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t3[1]) {
            _2.label = t3[1];
            t3 = op;
            break;
          }
          if (t3 && _2.label < t3[2]) {
            _2.label = t3[2];
            _2.ops.push(op);
            break;
          }
          if (t3[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e3) {
      op = [6, e3];
      y4 = 0;
    } finally {
      f2 = t3 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var TorchController = function() {
  function TorchController2(torchCapability, buttonController, onTorchActionFailureCallback) {
    this.isTorchOn = false;
    this.torchCapability = torchCapability;
    this.buttonController = buttonController;
    this.onTorchActionFailureCallback = onTorchActionFailureCallback;
  }
  TorchController2.prototype.isTorchEnabled = function() {
    return this.isTorchOn;
  };
  TorchController2.prototype.flipState = function() {
    return __awaiter(this, void 0, void 0, function() {
      var isTorchOnExpected, error_1;
      return __generator(this, function(_a) {
        switch (_a.label) {
          case 0:
            this.buttonController.disable();
            isTorchOnExpected = !this.isTorchOn;
            _a.label = 1;
          case 1:
            _a.trys.push([1, 3, , 4]);
            return [4, this.torchCapability.apply(isTorchOnExpected)];
          case 2:
            _a.sent();
            this.updateUiBasedOnLatestSettings(this.torchCapability.value(), isTorchOnExpected);
            return [3, 4];
          case 3:
            error_1 = _a.sent();
            this.propagateFailure(isTorchOnExpected, error_1);
            this.buttonController.enable();
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  TorchController2.prototype.updateUiBasedOnLatestSettings = function(isTorchOn, isTorchOnExpected) {
    if (isTorchOn === isTorchOnExpected) {
      this.buttonController.setText(isTorchOnExpected ? Html5QrcodeScannerStrings.torchOffButton() : Html5QrcodeScannerStrings.torchOnButton());
      this.isTorchOn = isTorchOnExpected;
    } else {
      this.propagateFailure(isTorchOnExpected);
    }
    this.buttonController.enable();
  };
  TorchController2.prototype.propagateFailure = function(isTorchOnExpected, error) {
    var errorMessage = isTorchOnExpected ? Html5QrcodeScannerStrings.torchOnFailedMessage() : Html5QrcodeScannerStrings.torchOffFailedMessage();
    if (error) {
      errorMessage += "; Error = " + error;
    }
    this.onTorchActionFailureCallback(errorMessage);
  };
  TorchController2.prototype.reset = function() {
    this.isTorchOn = false;
  };
  return TorchController2;
}();
var TorchButton = function() {
  function TorchButton2(torchCapability, onTorchActionFailureCallback) {
    this.onTorchActionFailureCallback = onTorchActionFailureCallback;
    this.torchButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.TORCH_BUTTON_ID);
    this.torchController = new TorchController(torchCapability, this, onTorchActionFailureCallback);
  }
  TorchButton2.prototype.render = function(parentElement, torchButtonOptions) {
    var _this = this;
    this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
    this.torchButton.style.display = torchButtonOptions.display;
    this.torchButton.style.marginLeft = torchButtonOptions.marginLeft;
    var $this = this;
    this.torchButton.addEventListener("click", function(_2) {
      return __awaiter(_this, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, $this.torchController.flipState()];
            case 1:
              _a.sent();
              if ($this.torchController.isTorchEnabled()) {
                $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
                $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
              } else {
                $this.torchButton.classList.remove(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_ON);
                $this.torchButton.classList.add(PublicUiElementIdAndClasses.TORCH_BUTTON_CLASS_TORCH_OFF);
              }
              return [2];
          }
        });
      });
    });
    parentElement.appendChild(this.torchButton);
  };
  TorchButton2.prototype.updateTorchCapability = function(torchCapability) {
    this.torchController = new TorchController(torchCapability, this, this.onTorchActionFailureCallback);
  };
  TorchButton2.prototype.getTorchButton = function() {
    return this.torchButton;
  };
  TorchButton2.prototype.hide = function() {
    this.torchButton.style.display = "none";
  };
  TorchButton2.prototype.show = function() {
    this.torchButton.style.display = "inline-block";
  };
  TorchButton2.prototype.disable = function() {
    this.torchButton.disabled = true;
  };
  TorchButton2.prototype.enable = function() {
    this.torchButton.disabled = false;
  };
  TorchButton2.prototype.setText = function(text) {
    this.torchButton.innerText = text;
  };
  TorchButton2.prototype.reset = function() {
    this.torchButton.innerText = Html5QrcodeScannerStrings.torchOnButton();
    this.torchController.reset();
  };
  TorchButton2.create = function(parentElement, torchCapability, torchButtonOptions, onTorchActionFailureCallback) {
    var button = new TorchButton2(torchCapability, onTorchActionFailureCallback);
    button.render(parentElement, torchButtonOptions);
    return button;
  };
  return TorchButton2;
}();
var FileSelectionUi = function() {
  function FileSelectionUi2(parentElement, showOnRender, onFileSelected) {
    this.fileBasedScanRegion = this.createFileBasedScanRegion();
    this.fileBasedScanRegion.style.display = showOnRender ? "block" : "none";
    parentElement.appendChild(this.fileBasedScanRegion);
    var fileScanLabel = document.createElement("label");
    fileScanLabel.setAttribute("for", this.getFileScanInputId());
    fileScanLabel.style.display = "inline-block";
    this.fileBasedScanRegion.appendChild(fileScanLabel);
    this.fileSelectionButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.FILE_SELECTION_BUTTON_ID);
    this.setInitialValueToButton();
    this.fileSelectionButton.addEventListener("click", function(_2) {
      fileScanLabel.click();
    });
    fileScanLabel.append(this.fileSelectionButton);
    this.fileScanInput = BaseUiElementFactory.createElement("input", this.getFileScanInputId());
    this.fileScanInput.type = "file";
    this.fileScanInput.accept = "image/*";
    this.fileScanInput.style.display = "none";
    fileScanLabel.appendChild(this.fileScanInput);
    var $this = this;
    this.fileScanInput.addEventListener("change", function(e3) {
      if (e3 == null || e3.target == null) {
        return;
      }
      var target = e3.target;
      if (target.files && target.files.length === 0) {
        return;
      }
      var fileList = target.files;
      var file = fileList[0];
      var fileName = file.name;
      $this.setImageNameToButton(fileName);
      onFileSelected(file);
    });
    var dragAndDropMessage = this.createDragAndDropMessage();
    this.fileBasedScanRegion.appendChild(dragAndDropMessage);
    this.fileBasedScanRegion.addEventListener("dragenter", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("dragleave", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("dragover", function(event) {
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionActiveBorder();
      event.stopPropagation();
      event.preventDefault();
    });
    this.fileBasedScanRegion.addEventListener("drop", function(event) {
      event.stopPropagation();
      event.preventDefault();
      $this.fileBasedScanRegion.style.border = $this.fileBasedScanRegionDefaultBorder();
      var dataTransfer = event.dataTransfer;
      if (dataTransfer) {
        var files = dataTransfer.files;
        if (!files || files.length === 0) {
          return;
        }
        var isAnyFileImage = false;
        for (var i3 = 0; i3 < files.length; ++i3) {
          var file = files.item(i3);
          if (!file) {
            continue;
          }
          var imageType = /image.*/;
          if (!file.type.match(imageType)) {
            continue;
          }
          isAnyFileImage = true;
          var fileName = file.name;
          $this.setImageNameToButton(fileName);
          onFileSelected(file);
          dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
          break;
        }
        if (!isAnyFileImage) {
          dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessageOnlyImages();
        }
      }
    });
  }
  FileSelectionUi2.prototype.hide = function() {
    this.fileBasedScanRegion.style.display = "none";
    this.fileScanInput.disabled = true;
  };
  FileSelectionUi2.prototype.show = function() {
    this.fileBasedScanRegion.style.display = "block";
    this.fileScanInput.disabled = false;
  };
  FileSelectionUi2.prototype.isShowing = function() {
    return this.fileBasedScanRegion.style.display === "block";
  };
  FileSelectionUi2.prototype.resetValue = function() {
    this.fileScanInput.value = "";
    this.setInitialValueToButton();
  };
  FileSelectionUi2.prototype.createFileBasedScanRegion = function() {
    var fileBasedScanRegion = document.createElement("div");
    fileBasedScanRegion.style.textAlign = "center";
    fileBasedScanRegion.style.margin = "auto";
    fileBasedScanRegion.style.width = "80%";
    fileBasedScanRegion.style.maxWidth = "600px";
    fileBasedScanRegion.style.border = this.fileBasedScanRegionDefaultBorder();
    fileBasedScanRegion.style.padding = "10px";
    fileBasedScanRegion.style.marginBottom = "10px";
    return fileBasedScanRegion;
  };
  FileSelectionUi2.prototype.fileBasedScanRegionDefaultBorder = function() {
    return "6px dashed #ebebeb";
  };
  FileSelectionUi2.prototype.fileBasedScanRegionActiveBorder = function() {
    return "6px dashed rgb(153 151 151)";
  };
  FileSelectionUi2.prototype.createDragAndDropMessage = function() {
    var dragAndDropMessage = document.createElement("div");
    dragAndDropMessage.innerText = Html5QrcodeScannerStrings.dragAndDropMessage();
    dragAndDropMessage.style.fontWeight = "400";
    return dragAndDropMessage;
  };
  FileSelectionUi2.prototype.setImageNameToButton = function(imageFileName) {
    var MAX_CHARS = 20;
    if (imageFileName.length > MAX_CHARS) {
      var start8Chars = imageFileName.substring(0, 8);
      var length_1 = imageFileName.length;
      var last8Chars = imageFileName.substring(length_1 - 8, length_1);
      imageFileName = "".concat(start8Chars, "....").concat(last8Chars);
    }
    var newText = Html5QrcodeScannerStrings.fileSelectionChooseAnother() + " - " + imageFileName;
    this.fileSelectionButton.innerText = newText;
  };
  FileSelectionUi2.prototype.setInitialValueToButton = function() {
    var initialText = Html5QrcodeScannerStrings.fileSelectionChooseImage() + " - " + Html5QrcodeScannerStrings.fileSelectionNoImageSelected();
    this.fileSelectionButton.innerText = initialText;
  };
  FileSelectionUi2.prototype.getFileScanInputId = function() {
    return "html5-qrcode-private-filescan-input";
  };
  FileSelectionUi2.create = function(parentElement, showOnRender, onFileSelected) {
    var button = new FileSelectionUi2(parentElement, showOnRender, onFileSelected);
    return button;
  };
  return FileSelectionUi2;
}();
var CameraSelectionUi = function() {
  function CameraSelectionUi2(cameras) {
    this.selectElement = BaseUiElementFactory.createElement("select", PublicUiElementIdAndClasses.CAMERA_SELECTION_SELECT_ID);
    this.cameras = cameras;
    this.options = [];
  }
  CameraSelectionUi2.prototype.render = function(parentElement) {
    var cameraSelectionContainer = document.createElement("span");
    cameraSelectionContainer.style.marginRight = "10px";
    var numCameras = this.cameras.length;
    if (numCameras === 0) {
      throw new Error("No cameras found");
    }
    if (numCameras === 1) {
      cameraSelectionContainer.style.display = "none";
    } else {
      var selectCameraString = Html5QrcodeScannerStrings.selectCamera();
      cameraSelectionContainer.innerText = "".concat(selectCameraString, " (").concat(this.cameras.length, ")  ");
    }
    var anonymousCameraId = 1;
    for (var _i = 0, _a = this.cameras; _i < _a.length; _i++) {
      var camera = _a[_i];
      var value = camera.id;
      var name_1 = camera.label == null ? value : camera.label;
      if (!name_1 || name_1 === "") {
        name_1 = [
          Html5QrcodeScannerStrings.anonymousCameraPrefix(),
          anonymousCameraId++
        ].join(" ");
      }
      var option = document.createElement("option");
      option.value = value;
      option.innerText = name_1;
      this.options.push(option);
      this.selectElement.appendChild(option);
    }
    cameraSelectionContainer.appendChild(this.selectElement);
    parentElement.appendChild(cameraSelectionContainer);
  };
  CameraSelectionUi2.prototype.disable = function() {
    this.selectElement.disabled = true;
  };
  CameraSelectionUi2.prototype.isDisabled = function() {
    return this.selectElement.disabled === true;
  };
  CameraSelectionUi2.prototype.enable = function() {
    this.selectElement.disabled = false;
  };
  CameraSelectionUi2.prototype.getValue = function() {
    return this.selectElement.value;
  };
  CameraSelectionUi2.prototype.hasValue = function(value) {
    for (var _i = 0, _a = this.options; _i < _a.length; _i++) {
      var option = _a[_i];
      if (option.value === value) {
        return true;
      }
    }
    return false;
  };
  CameraSelectionUi2.prototype.setValue = function(value) {
    if (!this.hasValue(value)) {
      throw new Error("".concat(value, " is not present in the camera list."));
    }
    this.selectElement.value = value;
  };
  CameraSelectionUi2.prototype.hasSingleItem = function() {
    return this.cameras.length === 1;
  };
  CameraSelectionUi2.prototype.numCameras = function() {
    return this.cameras.length;
  };
  CameraSelectionUi2.create = function(parentElement, cameras) {
    var cameraSelectUi = new CameraSelectionUi2(cameras);
    cameraSelectUi.render(parentElement);
    return cameraSelectUi;
  };
  return CameraSelectionUi2;
}();
var CameraZoomUi = function() {
  function CameraZoomUi2() {
    this.onChangeCallback = null;
    this.zoomElementContainer = document.createElement("div");
    this.rangeInput = BaseUiElementFactory.createElement("input", PublicUiElementIdAndClasses.ZOOM_SLIDER_ID);
    this.rangeInput.type = "range";
    this.rangeText = document.createElement("span");
    this.rangeInput.min = "1";
    this.rangeInput.max = "5";
    this.rangeInput.value = "1";
    this.rangeInput.step = "0.1";
  }
  CameraZoomUi2.prototype.render = function(parentElement, renderOnCreate) {
    this.zoomElementContainer.style.display = renderOnCreate ? "block" : "none";
    this.zoomElementContainer.style.padding = "5px 10px";
    this.zoomElementContainer.style.textAlign = "center";
    parentElement.appendChild(this.zoomElementContainer);
    this.rangeInput.style.display = "inline-block";
    this.rangeInput.style.width = "50%";
    this.rangeInput.style.height = "5px";
    this.rangeInput.style.background = "#d3d3d3";
    this.rangeInput.style.outline = "none";
    this.rangeInput.style.opacity = "0.7";
    var zoomString = Html5QrcodeScannerStrings.zoom();
    this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
    this.rangeText.style.marginRight = "10px";
    var $this = this;
    this.rangeInput.addEventListener("input", function() {
      return $this.onValueChange();
    });
    this.rangeInput.addEventListener("change", function() {
      return $this.onValueChange();
    });
    this.zoomElementContainer.appendChild(this.rangeInput);
    this.zoomElementContainer.appendChild(this.rangeText);
  };
  CameraZoomUi2.prototype.onValueChange = function() {
    var zoomString = Html5QrcodeScannerStrings.zoom();
    this.rangeText.innerText = "".concat(this.rangeInput.value, "x ").concat(zoomString);
    if (this.onChangeCallback) {
      this.onChangeCallback(parseFloat(this.rangeInput.value));
    }
  };
  CameraZoomUi2.prototype.setValues = function(minValue, maxValue, defaultValue2, step) {
    this.rangeInput.min = minValue.toString();
    this.rangeInput.max = maxValue.toString();
    this.rangeInput.step = step.toString();
    this.rangeInput.value = defaultValue2.toString();
    this.onValueChange();
  };
  CameraZoomUi2.prototype.show = function() {
    this.zoomElementContainer.style.display = "block";
  };
  CameraZoomUi2.prototype.hide = function() {
    this.zoomElementContainer.style.display = "none";
  };
  CameraZoomUi2.prototype.setOnCameraZoomValueChangeCallback = function(onChangeCallback) {
    this.onChangeCallback = onChangeCallback;
  };
  CameraZoomUi2.prototype.removeOnCameraZoomValueChangeCallback = function() {
    this.onChangeCallback = null;
  };
  CameraZoomUi2.create = function(parentElement, renderOnCreate) {
    var cameraZoomUi = new CameraZoomUi2();
    cameraZoomUi.render(parentElement, renderOnCreate);
    return cameraZoomUi;
  };
  return CameraZoomUi2;
}();
var Html5QrcodeScannerStatus;
(function(Html5QrcodeScannerStatus2) {
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_DEFAULT"] = 0] = "STATUS_DEFAULT";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_SUCCESS"] = 1] = "STATUS_SUCCESS";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_WARNING"] = 2] = "STATUS_WARNING";
  Html5QrcodeScannerStatus2[Html5QrcodeScannerStatus2["STATUS_REQUESTING_PERMISSION"] = 3] = "STATUS_REQUESTING_PERMISSION";
})(Html5QrcodeScannerStatus || (Html5QrcodeScannerStatus = {}));
function toHtml5QrcodeCameraScanConfig(config) {
  return {
    fps: config.fps,
    qrbox: config.qrbox,
    aspectRatio: config.aspectRatio,
    disableFlip: config.disableFlip,
    videoConstraints: config.videoConstraints
  };
}
function toHtml5QrcodeFullConfig(config, verbose) {
  return {
    formatsToSupport: config.formatsToSupport,
    useBarCodeDetectorIfSupported: config.useBarCodeDetectorIfSupported,
    experimentalFeatures: config.experimentalFeatures,
    verbose
  };
}
var Html5QrcodeScanner = function() {
  function Html5QrcodeScanner2(elementId, config, verbose) {
    this.lastMatchFound = null;
    this.cameraScanImage = null;
    this.fileScanImage = null;
    this.fileSelectionUi = null;
    this.elementId = elementId;
    this.config = this.createConfig(config);
    this.verbose = verbose === true;
    if (!document.getElementById(elementId)) {
      throw "HTML Element with id=".concat(elementId, " not found");
    }
    this.scanTypeSelector = new ScanTypeSelector(this.config.supportedScanTypes);
    this.currentScanType = this.scanTypeSelector.getDefaultScanType();
    this.sectionSwapAllowed = true;
    this.logger = new BaseLoggger(this.verbose);
    this.persistedDataManager = new PersistedDataManager();
    if (config.rememberLastUsedCamera !== true) {
      this.persistedDataManager.reset();
    }
  }
  Html5QrcodeScanner2.prototype.render = function(qrCodeSuccessCallback, qrCodeErrorCallback) {
    var _this = this;
    this.lastMatchFound = null;
    this.qrCodeSuccessCallback = function(decodedText, result) {
      if (qrCodeSuccessCallback) {
        qrCodeSuccessCallback(decodedText, result);
      } else {
        if (_this.lastMatchFound === decodedText) {
          return;
        }
        _this.lastMatchFound = decodedText;
        _this.setHeaderMessage(Html5QrcodeScannerStrings.lastMatch(decodedText), Html5QrcodeScannerStatus.STATUS_SUCCESS);
      }
    };
    this.qrCodeErrorCallback = function(errorMessage, error) {
      if (qrCodeErrorCallback) {
        qrCodeErrorCallback(errorMessage, error);
      }
    };
    var container = document.getElementById(this.elementId);
    if (!container) {
      throw "HTML Element with id=".concat(this.elementId, " not found");
    }
    container.innerHTML = "";
    this.createBasicLayout(container);
    this.html5Qrcode = new Html5Qrcode(this.getScanRegionId(), toHtml5QrcodeFullConfig(this.config, this.verbose));
  };
  Html5QrcodeScanner2.prototype.pause = function(shouldPauseVideo) {
    if (isNullOrUndefined(shouldPauseVideo) || shouldPauseVideo !== true) {
      shouldPauseVideo = false;
    }
    this.getHtml5QrcodeOrFail().pause(shouldPauseVideo);
  };
  Html5QrcodeScanner2.prototype.resume = function() {
    this.getHtml5QrcodeOrFail().resume();
  };
  Html5QrcodeScanner2.prototype.getState = function() {
    return this.getHtml5QrcodeOrFail().getState();
  };
  Html5QrcodeScanner2.prototype.clear = function() {
    var _this = this;
    var emptyHtmlContainer = function() {
      var mainContainer = document.getElementById(_this.elementId);
      if (mainContainer) {
        mainContainer.innerHTML = "";
        _this.resetBasicLayout(mainContainer);
      }
    };
    if (this.html5Qrcode) {
      return new Promise(function(resolve, reject) {
        if (!_this.html5Qrcode) {
          resolve();
          return;
        }
        if (_this.html5Qrcode.isScanning) {
          _this.html5Qrcode.stop().then(function(_2) {
            if (!_this.html5Qrcode) {
              resolve();
              return;
            }
            _this.html5Qrcode.clear();
            emptyHtmlContainer();
            resolve();
          }).catch(function(error) {
            if (_this.verbose) {
              _this.logger.logError("Unable to stop qrcode scanner", error);
            }
            reject(error);
          });
        } else {
          _this.html5Qrcode.clear();
          emptyHtmlContainer();
          resolve();
        }
      });
    }
    return Promise.resolve();
  };
  Html5QrcodeScanner2.prototype.getRunningTrackCapabilities = function() {
    return this.getHtml5QrcodeOrFail().getRunningTrackCapabilities();
  };
  Html5QrcodeScanner2.prototype.getRunningTrackSettings = function() {
    return this.getHtml5QrcodeOrFail().getRunningTrackSettings();
  };
  Html5QrcodeScanner2.prototype.applyVideoConstraints = function(videoConstaints) {
    return this.getHtml5QrcodeOrFail().applyVideoConstraints(videoConstaints);
  };
  Html5QrcodeScanner2.prototype.getHtml5QrcodeOrFail = function() {
    if (!this.html5Qrcode) {
      throw "Code scanner not initialized.";
    }
    return this.html5Qrcode;
  };
  Html5QrcodeScanner2.prototype.createConfig = function(config) {
    if (config) {
      if (!config.fps) {
        config.fps = Html5QrcodeConstants.SCAN_DEFAULT_FPS;
      }
      if (config.rememberLastUsedCamera !== !Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED) {
        config.rememberLastUsedCamera = Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED;
      }
      if (!config.supportedScanTypes) {
        config.supportedScanTypes = Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE;
      }
      return config;
    }
    return {
      fps: Html5QrcodeConstants.SCAN_DEFAULT_FPS,
      rememberLastUsedCamera: Html5QrcodeConstants.DEFAULT_REMEMBER_LAST_CAMERA_USED,
      supportedScanTypes: Html5QrcodeConstants.DEFAULT_SUPPORTED_SCAN_TYPE
    };
  };
  Html5QrcodeScanner2.prototype.createBasicLayout = function(parent) {
    parent.style.position = "relative";
    parent.style.padding = "0px";
    parent.style.border = "1px solid silver";
    this.createHeader(parent);
    var qrCodeScanRegion = document.createElement("div");
    var scanRegionId = this.getScanRegionId();
    qrCodeScanRegion.id = scanRegionId;
    qrCodeScanRegion.style.width = "100%";
    qrCodeScanRegion.style.minHeight = "100px";
    qrCodeScanRegion.style.textAlign = "center";
    parent.appendChild(qrCodeScanRegion);
    if (ScanTypeSelector.isCameraScanType(this.currentScanType)) {
      this.insertCameraScanImageToScanRegion();
    } else {
      this.insertFileScanImageToScanRegion();
    }
    var qrCodeDashboard = document.createElement("div");
    var dashboardId = this.getDashboardId();
    qrCodeDashboard.id = dashboardId;
    qrCodeDashboard.style.width = "100%";
    parent.appendChild(qrCodeDashboard);
    this.setupInitialDashboard(qrCodeDashboard);
  };
  Html5QrcodeScanner2.prototype.resetBasicLayout = function(mainContainer) {
    mainContainer.style.border = "none";
  };
  Html5QrcodeScanner2.prototype.setupInitialDashboard = function(dashboard) {
    this.createSection(dashboard);
    this.createSectionControlPanel();
    if (this.scanTypeSelector.hasMoreThanOneScanType()) {
      this.createSectionSwap();
    }
  };
  Html5QrcodeScanner2.prototype.createHeader = function(dashboard) {
    var header = document.createElement("div");
    header.style.textAlign = "left";
    header.style.margin = "0px";
    dashboard.appendChild(header);
    var libraryInfo = new LibraryInfoContainer();
    libraryInfo.renderInto(header);
    var headerMessageContainer = document.createElement("div");
    headerMessageContainer.id = this.getHeaderMessageContainerId();
    headerMessageContainer.style.display = "none";
    headerMessageContainer.style.textAlign = "center";
    headerMessageContainer.style.fontSize = "14px";
    headerMessageContainer.style.padding = "2px 10px";
    headerMessageContainer.style.margin = "4px";
    headerMessageContainer.style.borderTop = "1px solid #f6f6f6";
    header.appendChild(headerMessageContainer);
  };
  Html5QrcodeScanner2.prototype.createSection = function(dashboard) {
    var section = document.createElement("div");
    section.id = this.getDashboardSectionId();
    section.style.width = "100%";
    section.style.padding = "10px 0px 10px 0px";
    section.style.textAlign = "left";
    dashboard.appendChild(section);
  };
  Html5QrcodeScanner2.prototype.createCameraListUi = function(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton) {
    var $this = this;
    $this.showHideScanTypeSwapLink(false);
    $this.setHeaderMessage(Html5QrcodeScannerStrings.cameraPermissionRequesting());
    var createPermissionButtonIfNotExists = function() {
      if (!requestPermissionButton) {
        $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
      }
    };
    Html5Qrcode.getCameras().then(function(cameras) {
      $this.persistedDataManager.setHasPermission(true);
      $this.showHideScanTypeSwapLink(true);
      $this.resetHeaderMessage();
      if (cameras && cameras.length > 0) {
        scpCameraScanRegion.removeChild(requestPermissionContainer);
        $this.renderCameraSelection(cameras);
      } else {
        $this.setHeaderMessage(Html5QrcodeScannerStrings.noCameraFound(), Html5QrcodeScannerStatus.STATUS_WARNING);
        createPermissionButtonIfNotExists();
      }
    }).catch(function(error) {
      $this.persistedDataManager.setHasPermission(false);
      if (requestPermissionButton) {
        requestPermissionButton.disabled = false;
      } else {
        createPermissionButtonIfNotExists();
      }
      $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      $this.showHideScanTypeSwapLink(true);
    });
  };
  Html5QrcodeScanner2.prototype.createPermissionButton = function(scpCameraScanRegion, requestPermissionContainer) {
    var $this = this;
    var requestPermissionButton = BaseUiElementFactory.createElement("button", this.getCameraPermissionButtonId());
    requestPermissionButton.innerText = Html5QrcodeScannerStrings.cameraPermissionTitle();
    requestPermissionButton.addEventListener("click", function() {
      requestPermissionButton.disabled = true;
      $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer, requestPermissionButton);
    });
    requestPermissionContainer.appendChild(requestPermissionButton);
  };
  Html5QrcodeScanner2.prototype.createPermissionsUi = function(scpCameraScanRegion, requestPermissionContainer) {
    var $this = this;
    if (ScanTypeSelector.isCameraScanType(this.currentScanType) && this.persistedDataManager.hasCameraPermissions()) {
      CameraPermissions.hasPermissions().then(function(hasPermissions) {
        if (hasPermissions) {
          $this.createCameraListUi(scpCameraScanRegion, requestPermissionContainer);
        } else {
          $this.persistedDataManager.setHasPermission(false);
          $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
        }
      }).catch(function(_2) {
        $this.persistedDataManager.setHasPermission(false);
        $this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
      });
      return;
    }
    this.createPermissionButton(scpCameraScanRegion, requestPermissionContainer);
  };
  Html5QrcodeScanner2.prototype.createSectionControlPanel = function() {
    var section = document.getElementById(this.getDashboardSectionId());
    var sectionControlPanel = document.createElement("div");
    section.appendChild(sectionControlPanel);
    var scpCameraScanRegion = document.createElement("div");
    scpCameraScanRegion.id = this.getDashboardSectionCameraScanRegionId();
    scpCameraScanRegion.style.display = ScanTypeSelector.isCameraScanType(this.currentScanType) ? "block" : "none";
    sectionControlPanel.appendChild(scpCameraScanRegion);
    var requestPermissionContainer = document.createElement("div");
    requestPermissionContainer.style.textAlign = "center";
    scpCameraScanRegion.appendChild(requestPermissionContainer);
    if (this.scanTypeSelector.isCameraScanRequired()) {
      this.createPermissionsUi(scpCameraScanRegion, requestPermissionContainer);
    }
    this.renderFileScanUi(sectionControlPanel);
  };
  Html5QrcodeScanner2.prototype.renderFileScanUi = function(parent) {
    var showOnRender = ScanTypeSelector.isFileScanType(this.currentScanType);
    var $this = this;
    var onFileSelected = function(file) {
      if (!$this.html5Qrcode) {
        throw "html5Qrcode not defined";
      }
      if (!ScanTypeSelector.isFileScanType($this.currentScanType)) {
        return;
      }
      $this.setHeaderMessage(Html5QrcodeScannerStrings.loadingImage());
      $this.html5Qrcode.scanFileV2(file, true).then(function(html5qrcodeResult) {
        $this.resetHeaderMessage();
        $this.qrCodeSuccessCallback(html5qrcodeResult.decodedText, html5qrcodeResult);
      }).catch(function(error) {
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
        $this.qrCodeErrorCallback(error, Html5QrcodeErrorFactory.createFrom(error));
      });
    };
    this.fileSelectionUi = FileSelectionUi.create(parent, showOnRender, onFileSelected);
  };
  Html5QrcodeScanner2.prototype.renderCameraSelection = function(cameras) {
    var _this = this;
    var $this = this;
    var scpCameraScanRegion = document.getElementById(this.getDashboardSectionCameraScanRegionId());
    scpCameraScanRegion.style.textAlign = "center";
    var cameraZoomUi = CameraZoomUi.create(scpCameraScanRegion, false);
    var renderCameraZoomUiIfSupported = function(cameraCapabilities) {
      var zoomCapability = cameraCapabilities.zoomFeature();
      if (!zoomCapability.isSupported()) {
        return;
      }
      cameraZoomUi.setOnCameraZoomValueChangeCallback(function(zoomValue) {
        zoomCapability.apply(zoomValue);
      });
      var defaultZoom = 1;
      if (_this.config.defaultZoomValueIfSupported) {
        defaultZoom = _this.config.defaultZoomValueIfSupported;
      }
      defaultZoom = clip(defaultZoom, zoomCapability.min(), zoomCapability.max());
      cameraZoomUi.setValues(zoomCapability.min(), zoomCapability.max(), defaultZoom, zoomCapability.step());
      cameraZoomUi.show();
    };
    var cameraSelectUi = CameraSelectionUi.create(scpCameraScanRegion, cameras);
    var cameraActionContainer = document.createElement("span");
    var cameraActionStartButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_START_BUTTON_ID);
    cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
    cameraActionContainer.appendChild(cameraActionStartButton);
    var cameraActionStopButton = BaseUiElementFactory.createElement("button", PublicUiElementIdAndClasses.CAMERA_STOP_BUTTON_ID);
    cameraActionStopButton.innerText = Html5QrcodeScannerStrings.scanButtonStopScanningText();
    cameraActionStopButton.style.display = "none";
    cameraActionStopButton.disabled = true;
    cameraActionContainer.appendChild(cameraActionStopButton);
    var torchButton;
    var createAndShowTorchButtonIfSupported = function(cameraCapabilities) {
      if (!cameraCapabilities.torchFeature().isSupported()) {
        if (torchButton) {
          torchButton.hide();
        }
        return;
      }
      if (!torchButton) {
        torchButton = TorchButton.create(cameraActionContainer, cameraCapabilities.torchFeature(), { display: "none", marginLeft: "5px" }, function(errorMessage) {
          $this.setHeaderMessage(errorMessage, Html5QrcodeScannerStatus.STATUS_WARNING);
        });
      } else {
        torchButton.updateTorchCapability(cameraCapabilities.torchFeature());
      }
      torchButton.show();
    };
    scpCameraScanRegion.appendChild(cameraActionContainer);
    var resetCameraActionStartButton = function(shouldShow) {
      if (!shouldShow) {
        cameraActionStartButton.style.display = "none";
      }
      cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonStartScanningText();
      cameraActionStartButton.style.opacity = "1";
      cameraActionStartButton.disabled = false;
      if (shouldShow) {
        cameraActionStartButton.style.display = "inline-block";
      }
    };
    cameraActionStartButton.addEventListener("click", function(_2) {
      cameraActionStartButton.innerText = Html5QrcodeScannerStrings.scanButtonScanningStarting();
      cameraSelectUi.disable();
      cameraActionStartButton.disabled = true;
      cameraActionStartButton.style.opacity = "0.5";
      if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
        $this.showHideScanTypeSwapLink(false);
      }
      $this.resetHeaderMessage();
      var cameraId2 = cameraSelectUi.getValue();
      $this.persistedDataManager.setLastUsedCameraId(cameraId2);
      $this.html5Qrcode.start(cameraId2, toHtml5QrcodeCameraScanConfig($this.config), $this.qrCodeSuccessCallback, $this.qrCodeErrorCallback).then(function(_3) {
        cameraActionStopButton.disabled = false;
        cameraActionStopButton.style.display = "inline-block";
        resetCameraActionStartButton(false);
        var cameraCapabilities = $this.html5Qrcode.getRunningTrackCameraCapabilities();
        if (_this.config.showTorchButtonIfSupported === true) {
          createAndShowTorchButtonIfSupported(cameraCapabilities);
        }
        if (_this.config.showZoomSliderIfSupported === true) {
          renderCameraZoomUiIfSupported(cameraCapabilities);
        }
      }).catch(function(error) {
        $this.showHideScanTypeSwapLink(true);
        cameraSelectUi.enable();
        resetCameraActionStartButton(true);
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      });
    });
    if (cameraSelectUi.hasSingleItem()) {
      cameraActionStartButton.click();
    }
    cameraActionStopButton.addEventListener("click", function(_2) {
      if (!$this.html5Qrcode) {
        throw "html5Qrcode not defined";
      }
      cameraActionStopButton.disabled = true;
      $this.html5Qrcode.stop().then(function(_3) {
        if (_this.scanTypeSelector.hasMoreThanOneScanType()) {
          $this.showHideScanTypeSwapLink(true);
        }
        cameraSelectUi.enable();
        cameraActionStartButton.disabled = false;
        cameraActionStopButton.style.display = "none";
        cameraActionStartButton.style.display = "inline-block";
        if (torchButton) {
          torchButton.reset();
          torchButton.hide();
        }
        cameraZoomUi.removeOnCameraZoomValueChangeCallback();
        cameraZoomUi.hide();
        $this.insertCameraScanImageToScanRegion();
      }).catch(function(error) {
        cameraActionStopButton.disabled = false;
        $this.setHeaderMessage(error, Html5QrcodeScannerStatus.STATUS_WARNING);
      });
    });
    if ($this.persistedDataManager.getLastUsedCameraId()) {
      var cameraId = $this.persistedDataManager.getLastUsedCameraId();
      if (cameraSelectUi.hasValue(cameraId)) {
        cameraSelectUi.setValue(cameraId);
        cameraActionStartButton.click();
      } else {
        $this.persistedDataManager.resetLastUsedCameraId();
      }
    }
  };
  Html5QrcodeScanner2.prototype.createSectionSwap = function() {
    var $this = this;
    var TEXT_IF_CAMERA_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfCameraScanSelected();
    var TEXT_IF_FILE_SCAN_SELECTED = Html5QrcodeScannerStrings.textIfFileScanSelected();
    var section = document.getElementById(this.getDashboardSectionId());
    var switchContainer = document.createElement("div");
    switchContainer.style.textAlign = "center";
    var switchScanTypeLink = BaseUiElementFactory.createElement("span", this.getDashboardSectionSwapLinkId());
    switchScanTypeLink.style.textDecoration = "underline";
    switchScanTypeLink.style.cursor = "pointer";
    switchScanTypeLink.innerText = ScanTypeSelector.isCameraScanType(this.currentScanType) ? TEXT_IF_CAMERA_SCAN_SELECTED : TEXT_IF_FILE_SCAN_SELECTED;
    switchScanTypeLink.addEventListener("click", function() {
      if (!$this.sectionSwapAllowed) {
        if ($this.verbose) {
          $this.logger.logError("Section swap called when not allowed");
        }
        return;
      }
      $this.resetHeaderMessage();
      $this.fileSelectionUi.resetValue();
      $this.sectionSwapAllowed = false;
      if (ScanTypeSelector.isCameraScanType($this.currentScanType)) {
        $this.clearScanRegion();
        $this.getCameraScanRegion().style.display = "none";
        $this.fileSelectionUi.show();
        switchScanTypeLink.innerText = TEXT_IF_FILE_SCAN_SELECTED;
        $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_FILE;
        $this.insertFileScanImageToScanRegion();
      } else {
        $this.clearScanRegion();
        $this.getCameraScanRegion().style.display = "block";
        $this.fileSelectionUi.hide();
        switchScanTypeLink.innerText = TEXT_IF_CAMERA_SCAN_SELECTED;
        $this.currentScanType = Html5QrcodeScanType.SCAN_TYPE_CAMERA;
        $this.insertCameraScanImageToScanRegion();
        $this.startCameraScanIfPermissionExistsOnSwap();
      }
      $this.sectionSwapAllowed = true;
    });
    switchContainer.appendChild(switchScanTypeLink);
    section.appendChild(switchContainer);
  };
  Html5QrcodeScanner2.prototype.startCameraScanIfPermissionExistsOnSwap = function() {
    var _this = this;
    var $this = this;
    if (this.persistedDataManager.hasCameraPermissions()) {
      CameraPermissions.hasPermissions().then(function(hasPermissions) {
        if (hasPermissions) {
          var permissionButton = document.getElementById($this.getCameraPermissionButtonId());
          if (!permissionButton) {
            _this.logger.logError("Permission button not found, fail;");
            throw "Permission button not found";
          }
          permissionButton.click();
        } else {
          $this.persistedDataManager.setHasPermission(false);
        }
      }).catch(function(_2) {
        $this.persistedDataManager.setHasPermission(false);
      });
      return;
    }
  };
  Html5QrcodeScanner2.prototype.resetHeaderMessage = function() {
    var messageDiv = document.getElementById(this.getHeaderMessageContainerId());
    messageDiv.style.display = "none";
  };
  Html5QrcodeScanner2.prototype.setHeaderMessage = function(messageText, scannerStatus) {
    if (!scannerStatus) {
      scannerStatus = Html5QrcodeScannerStatus.STATUS_DEFAULT;
    }
    var messageDiv = this.getHeaderMessageDiv();
    messageDiv.innerText = messageText;
    messageDiv.style.display = "block";
    switch (scannerStatus) {
      case Html5QrcodeScannerStatus.STATUS_SUCCESS:
        messageDiv.style.background = "rgba(106, 175, 80, 0.26)";
        messageDiv.style.color = "#477735";
        break;
      case Html5QrcodeScannerStatus.STATUS_WARNING:
        messageDiv.style.background = "rgba(203, 36, 49, 0.14)";
        messageDiv.style.color = "#cb2431";
        break;
      case Html5QrcodeScannerStatus.STATUS_DEFAULT:
      default:
        messageDiv.style.background = "rgba(0, 0, 0, 0)";
        messageDiv.style.color = "rgb(17, 17, 17)";
        break;
    }
  };
  Html5QrcodeScanner2.prototype.showHideScanTypeSwapLink = function(shouldDisplay) {
    if (this.scanTypeSelector.hasMoreThanOneScanType()) {
      if (shouldDisplay !== true) {
        shouldDisplay = false;
      }
      this.sectionSwapAllowed = shouldDisplay;
      this.getDashboardSectionSwapLink().style.display = shouldDisplay ? "inline-block" : "none";
    }
  };
  Html5QrcodeScanner2.prototype.insertCameraScanImageToScanRegion = function() {
    var $this = this;
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    if (this.cameraScanImage) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild(this.cameraScanImage);
      return;
    }
    this.cameraScanImage = new Image();
    this.cameraScanImage.onload = function(_2) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild($this.cameraScanImage);
    };
    this.cameraScanImage.width = 64;
    this.cameraScanImage.style.opacity = "0.8";
    this.cameraScanImage.src = ASSET_CAMERA_SCAN;
    this.cameraScanImage.alt = Html5QrcodeScannerStrings.cameraScanAltText();
  };
  Html5QrcodeScanner2.prototype.insertFileScanImageToScanRegion = function() {
    var $this = this;
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    if (this.fileScanImage) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild(this.fileScanImage);
      return;
    }
    this.fileScanImage = new Image();
    this.fileScanImage.onload = function(_2) {
      qrCodeScanRegion.innerHTML = "<br>";
      qrCodeScanRegion.appendChild($this.fileScanImage);
    };
    this.fileScanImage.width = 64;
    this.fileScanImage.style.opacity = "0.8";
    this.fileScanImage.src = ASSET_FILE_SCAN;
    this.fileScanImage.alt = Html5QrcodeScannerStrings.fileScanAltText();
  };
  Html5QrcodeScanner2.prototype.clearScanRegion = function() {
    var qrCodeScanRegion = document.getElementById(this.getScanRegionId());
    qrCodeScanRegion.innerHTML = "";
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionId = function() {
    return "".concat(this.elementId, "__dashboard_section");
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionCameraScanRegionId = function() {
    return "".concat(this.elementId, "__dashboard_section_csr");
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionSwapLinkId = function() {
    return PublicUiElementIdAndClasses.SCAN_TYPE_CHANGE_ANCHOR_ID;
  };
  Html5QrcodeScanner2.prototype.getScanRegionId = function() {
    return "".concat(this.elementId, "__scan_region");
  };
  Html5QrcodeScanner2.prototype.getDashboardId = function() {
    return "".concat(this.elementId, "__dashboard");
  };
  Html5QrcodeScanner2.prototype.getHeaderMessageContainerId = function() {
    return "".concat(this.elementId, "__header_message");
  };
  Html5QrcodeScanner2.prototype.getCameraPermissionButtonId = function() {
    return PublicUiElementIdAndClasses.CAMERA_PERMISSION_BUTTON_ID;
  };
  Html5QrcodeScanner2.prototype.getCameraScanRegion = function() {
    return document.getElementById(this.getDashboardSectionCameraScanRegionId());
  };
  Html5QrcodeScanner2.prototype.getDashboardSectionSwapLink = function() {
    return document.getElementById(this.getDashboardSectionSwapLinkId());
  };
  Html5QrcodeScanner2.prototype.getHeaderMessageDiv = function() {
    return document.getElementById(this.getHeaderMessageContainerId());
  };
  return Html5QrcodeScanner2;
}();
function BarcodeScannerDialog({
  open,
  onOpenChange,
  onScan
}) {
  const scannerRef = reactExports.useRef(null);
  reactExports.useEffect(() => {
    if (open && !scannerRef.current) {
      scannerRef.current = new Html5QrcodeScanner(
        "reader",
        { fps: 10, qrbox: { width: 250, height: 250 } },
        /* verbose= */
        false
      );
      scannerRef.current.render(
        (decodedText) => {
          if (scannerRef.current) {
            scannerRef.current.clear();
            onScan(decodedText);
            onOpenChange(false);
          }
        },
        (error) => {
          console.warn(`Code scan error = ${error}`);
        }
      );
    }
    return () => {
      if (scannerRef.current) {
        scannerRef.current.clear();
        scannerRef.current = null;
      }
    };
  }, [open, onOpenChange, onScan]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { id: "reader" }) }) });
}
const Textarea = reactExports.forwardRef(
  ({ className, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "textarea",
      {
        className: cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref,
        ...props
      }
    );
  }
);
Textarea.displayName = "Textarea";
function BasicDetailsTab({
  form,
  categories: categories2 = [],
  locations: locations2 = [],
  cabinets = [],
  projects: projects2 = []
}) {
  const getFlattenedCategoryOptions = reactExports.useMemo(() => {
    const options = [];
    categories2.forEach((category) => {
      options.push({ id: category.name, name: category.name });
      if (category.children && category.children.length > 0) {
        category.children.forEach((child) => {
          options.push({
            id: `${category.name}/${child.name}`,
            name: `${category.name}/${child.name}`
          });
        });
      }
    });
    return options;
  }, [categories2]);
  const getFlattenedLocationOptions = reactExports.useMemo(() => {
    const options = [];
    locations2.forEach((location2) => {
      options.push({ id: location2.id, name: location2.name });
      if (location2.children && location2.children.length > 0) {
        location2.children.forEach((subcat) => {
          options.push({
            id: `${location2.id}/${subcat.id}`,
            name: `${location2.name}/${subcat.name}`
          });
        });
      }
    });
    return options;
  }, [locations2]);
  const availableCabinets = reactExports.useMemo(() => {
    const locationId = form.watch("location")?.split("/")[0];
    return cabinets?.filter((cabinet) => cabinet.locationId === locationId) || [];
  }, [form.watch("location"), cabinets]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "name",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Name*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter item name" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "description",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Description" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Textarea,
            {
              ...field,
              placeholder: "Enter item description",
              className: "min-h-[80px]"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormField,
          {
            control: form.control,
            name: "category",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Category*" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  onValueChange: field.onChange,
                  value: field.value,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select category" }) }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: getFlattenedCategoryOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: option.id, children: option.name }, option.id)) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
            ] })
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormField,
          {
            control: form.control,
            name: "project",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Project" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  onValueChange: field.onChange,
                  value: field.value || void 0,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select project" }) }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "none", children: "None" }),
                      projects2.map((project) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: project.id, children: project.name }, project.id))
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
            ] })
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormField,
          {
            control: form.control,
            name: "location",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Location*" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  onValueChange: (value) => {
                    field.onChange(value);
                    form.setValue("cabinet", "");
                  },
                  value: field.value,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select location" }) }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: getFlattenedLocationOptions.map((option) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: option.id, children: option.name }, option.id)) })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
            ] })
          }
        ),
        availableCabinets.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
          FormField,
          {
            control: form.control,
            name: "cabinet",
            render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Cabinet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  onValueChange: field.onChange,
                  value: field.value || void 0,
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select cabinet" }) }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "none", children: "None" }),
                      availableCabinets.map((cabinet) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: cabinet.id, children: [
                        cabinet.name,
                        " ",
                        cabinet.isSecure && "🔒"
                      ] }, cabinet.id))
                    ] })
                  ]
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormDescription, { children: "Items in secure cabinets require checkout" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
            ] })
          }
        )
      ] })
    ] })
  ] });
}
function InventorySupplyTab$1({ form, units: units2, suppliers: suppliers2 }) {
  const unitSubcategories = reactExports.useMemo(() => {
    const selectedUnit = form.watch("unit");
    const unitItem = units2.find((u3) => u3.name === selectedUnit);
    return unitItem?.children || [];
  }, [form.watch("unit"), units2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "unit",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Unit*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: (value) => {
                if (value !== field.value) {
                  field.onChange(value);
                  form.setValue("unitSubcategory", "");
                }
              },
              value: field.value,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select unit" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: units2.map((unit) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: unit.name, children: [
                  unit.name,
                  unit.children && unit.children.length > 0 && " (Has Subcategories)"
                ] }, unit.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    unitSubcategories.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "unitSubcategory",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Unit Size" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: field.onChange,
              value: field.value || "",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select unit size" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: unitSubcategories.map((subUnit) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: subUnit.name, children: subUnit.name }, subUnit.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormDescription, { children: [
            form.watch("unit"),
            " sizes available"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "quantity",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Quantity*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              min: "0",
              step: "1",
              ...field,
              onChange: (e3) => field.onChange(Number(e3.target.value))
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "minQuantity",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Minimum Quantity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              min: "0",
              step: "1",
              ...field,
              value: field.value ?? "",
              onChange: (e3) => {
                const val = e3.target.value === "" ? void 0 : Number(e3.target.value);
                field.onChange(val);
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormDescription, { children: "Leave empty or set to 0 for no minimum quantity alert" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "supplier",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Supplier" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: field.onChange,
              value: field.value || "",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select supplier" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: suppliers2.map((sup) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: sup.name, children: sup.name }, sup.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "supplierWebsite",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Supplier Website" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "url",
              ...field,
              placeholder: "https://supplier.com"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    )
  ] }) });
}
function AdditionalInfoTab$1({ form, onScanBarcode }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "barcode",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Barcode" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter barcode" }) }),
              onScanBarcode && /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  type: "button",
                  variant: "outline",
                  size: "icon",
                  onClick: onScanBarcode,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScanLine, { className: "h-4 w-4" })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "serialNumber",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Serial Number" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter serial number" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "manufacturer",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Manufacturer" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter manufacturer" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "modelNumber",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Model Number" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter model number" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "dateInService",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Date in Service" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { type: "date", ...field }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "manufacturerNotes",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Manufacturer Notes" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                ...field,
                placeholder: "Enter manufacturer notes",
                className: "min-h-[80px]"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "maintenanceNotes",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Maintenance Notes" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                ...field,
                placeholder: "Enter maintenance notes",
                className: "min-h-[80px]"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "additionalNotes",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Additional Notes" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Textarea,
              {
                ...field,
                placeholder: "Enter additional notes",
                className: "min-h-[80px]"
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      )
    ] })
  ] });
}
const ensureUrlProtocol = (url2) => {
  if (!url2) return url2;
  if (!/^https?:\/\//i.test(url2)) {
    return `https://${url2}`;
  }
  return url2;
};
const formSchema$2 = objectType({
  name: stringType().min(2, "Name must be at least 2 characters"),
  description: stringType().optional(),
  category: stringType().min(1, "Category is required"),
  quantity: numberType().min(0, "Quantity must be 0 or greater"),
  unit: stringType().min(1, "Unit is required"),
  unitSubcategory: stringType().optional(),
  location: stringType().min(1, "Location is required"),
  locationSubcategory: stringType().optional(),
  cabinet: stringType().optional(),
  project: stringType().optional(),
  minQuantity: numberType().min(0).optional(),
  costPerUnit: numberType().min(0).optional(),
  barcode: stringType().optional(),
  serialNumber: stringType().optional(),
  manufacturer: stringType().optional(),
  modelNumber: stringType().optional(),
  dateInService: stringType().optional(),
  manufacturerNotes: stringType().optional(),
  maintenanceNotes: stringType().optional(),
  additionalNotes: stringType().optional(),
  supplier: stringType().optional(),
  supplierWebsite: stringType().url().optional()
});
function AddItemForm({
  onSubmit,
  onCancel,
  categories: categories2,
  units: units2,
  locations: locations2,
  suppliers: suppliers2,
  projects: projects2,
  cabinets,
  isSubmitting = false,
  initialValues,
  existingItems = [],
  existingManufacturers = [],
  existingSuppliers = [],
  existingProjects = []
}) {
  const [activeTab, setActiveTab] = reactExports.useState("details");
  const [isScannerOpen, setIsScannerOpen] = reactExports.useState(false);
  const form = useForm({
    resolver: t2(formSchema$2),
    defaultValues: {
      name: initialValues?.name || "",
      description: initialValues?.description || "",
      category: initialValues?.category || "",
      quantity: initialValues?.quantity || 0,
      unit: initialValues?.unit || "",
      unitSubcategory: initialValues?.unitSubcategory || "",
      location: initialValues?.location || "",
      locationSubcategory: initialValues?.locationSubcategory || "",
      cabinet: initialValues?.cabinet || "",
      project: initialValues?.project || "",
      minQuantity: initialValues?.minQuantity || 0,
      costPerUnit: initialValues?.costPerUnit || 0,
      barcode: initialValues?.barcode || "",
      serialNumber: initialValues?.serialNumber || "",
      manufacturer: initialValues?.manufacturer || "",
      modelNumber: initialValues?.modelNumber || "",
      dateInService: initialValues?.dateInService || "",
      manufacturerNotes: initialValues?.manufacturerNotes || "",
      maintenanceNotes: initialValues?.maintenanceNotes || "",
      additionalNotes: initialValues?.additionalNotes || "",
      supplier: initialValues?.supplier || "",
      supplierWebsite: initialValues?.supplierWebsite || ""
    }
  });
  const handleScanResult = (result) => {
    form.setValue("barcode", result);
    ue.success(`Barcode scanned: ${result}`);
    setIsScannerOpen(false);
  };
  const onSubmitForm = async (values) => {
    try {
      const processedValues = {
        ...values,
        supplierWebsite: values.supplierWebsite ? ensureUrlProtocol(values.supplierWebsite) : ""
      };
      await onSubmit(processedValues);
    } catch (error) {
      console.error("Form submission error:", error);
      ue.error("Failed to submit form");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { ...form, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmitForm), className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "details", children: "Item Details" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "inventory", children: "Inventory & Supply" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "additional", children: "Additional Info" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "details", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BasicDetailsTab,
          {
            form,
            categories: categories2,
            locations: locations2,
            cabinets,
            projects: projects2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "inventory", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InventorySupplyTab$1,
          {
            form,
            units: units2,
            suppliers: suppliers2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "additional", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdditionalInfoTab$1,
          {
            form,
            onScanBarcode: () => setIsScannerOpen(true)
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2 mt-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onCancel, type: "button", children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { type: "submit", disabled: isSubmitting, children: [
          isSubmitting && /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
          "Add Item"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BarcodeScannerDialog,
      {
        open: isScannerOpen,
        onOpenChange: setIsScannerOpen,
        onScan: handleScanResult
      }
    )
  ] });
}
const Card = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    ),
    ...props
  }
));
Card.displayName = "Card";
const CardHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn("flex flex-col space-y-1.5 p-6", className),
    ...props
  }
));
CardHeader.displayName = "CardHeader";
const CardTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "h3",
  {
    ref,
    className: cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
CardTitle.displayName = "CardTitle";
const CardDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "p",
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
CardDescription.displayName = "CardDescription";
const CardContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("p-6 pt-0", className), ...props }));
CardContent.displayName = "CardContent";
const CardFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn("flex items-center p-6 pt-0", className),
    ...props
  }
));
CardFooter.displayName = "CardFooter";
function AddItemDialog({
  open,
  onOpenChange,
  onSubmit,
  categories: categories2,
  units: units2,
  locations: locations2,
  suppliers: suppliers2,
  projects: projects2,
  selectedTemplate: externalSelectedTemplate,
  existingItems
}) {
  const [templates, setTemplates] = reactExports.useState([]);
  const [selectedTemplate, setSelectedTemplate] = reactExports.useState(null);
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [activeTab, setActiveTab] = reactExports.useState("new");
  const [formValues, setFormValues] = reactExports.useState(void 0);
  const [lastAction, setLastAction] = reactExports.useState("");
  reactExports.useEffect(() => {
    if (open) {
      console.error("[DEBUG] Dialog opened");
      try {
        const loadedTemplates = getTemplates();
        console.error("[DEBUG] Templates loaded:", loadedTemplates);
        if (Array.isArray(loadedTemplates)) {
          const validTemplates = loadedTemplates.map((template) => {
            if (typeof template === "object" && template !== null && template.templateName) {
              return template;
            }
            console.error("[DEBUG] Invalid template found:", template);
            return null;
          }).filter((t3) => t3 !== null);
          console.error("[DEBUG] Valid templates:", validTemplates);
          setTemplates(validTemplates);
        } else {
          console.error("[DEBUG] Loaded templates is not an array:", loadedTemplates);
          setTemplates([]);
        }
      } catch (error) {
        console.error("[DEBUG] Error loading templates:", error);
        ue.error("Failed to load templates");
        setTemplates([]);
      }
    }
  }, [open]);
  reactExports.useEffect(() => {
    if (externalSelectedTemplate) {
      const supplierMatch = suppliers2.find((s4) => s4.name === externalSelectedTemplate.supplier);
      const locationMatch = locations2.find((l2) => l2.id === externalSelectedTemplate.location);
      const unitMatch = units2.find((u3) => u3.name === externalSelectedTemplate.unit);
      const projectMatch = projects2.find((p2) => p2.name === externalSelectedTemplate.project);
      const templateValues = {
        name: externalSelectedTemplate.name,
        description: externalSelectedTemplate.description,
        quantity: 0,
        minQuantity: externalSelectedTemplate.minQuantity,
        unit: unitMatch ? unitMatch.name : "",
        costPerUnit: externalSelectedTemplate.costPerUnit,
        category: externalSelectedTemplate.category,
        location: locationMatch ? locationMatch.id : "",
        supplier: supplierMatch ? supplierMatch.name : "",
        supplierWebsite: externalSelectedTemplate.supplierWebsite,
        project: projectMatch ? projectMatch.name : "",
        notes: externalSelectedTemplate.notes,
        orderStatus: externalSelectedTemplate.orderStatus,
        deliveryPercentage: externalSelectedTemplate.deliveryPercentage
      };
      setFormValues(templateValues);
      setSelectedTemplate(externalSelectedTemplate);
      setActiveTab("new");
    }
  }, [externalSelectedTemplate, suppliers2, locations2, units2, projects2]);
  const handleTemplateSelect = (templateName) => {
    console.error("[DEBUG] Template selected:", templateName);
    const selectedTemplate2 = templates.find((t3) => t3.templateName === templateName);
    if (selectedTemplate2) {
      console.error("[DEBUG] Found template:", selectedTemplate2);
      const supplierMatch = suppliers2.find((s4) => s4.name === selectedTemplate2.supplier);
      const locationMatch = locations2.find((l2) => l2.id === selectedTemplate2.location);
      const unitMatch = units2.find((u3) => u3.name === selectedTemplate2.unit);
      const projectMatch = projects2.find((p2) => p2.name === selectedTemplate2.project);
      const newFormValues = {
        name: selectedTemplate2.name,
        description: selectedTemplate2.description,
        quantity: 0,
        minQuantity: selectedTemplate2.minQuantity,
        unit: unitMatch ? unitMatch.name : "",
        costPerUnit: selectedTemplate2.costPerUnit,
        category: selectedTemplate2.category,
        location: locationMatch ? locationMatch.id : "",
        supplier: supplierMatch ? supplierMatch.name : "",
        supplierWebsite: selectedTemplate2.supplierWebsite,
        project: projectMatch ? projectMatch.name : "",
        notes: selectedTemplate2.notes,
        orderStatus: selectedTemplate2.orderStatus,
        deliveryPercentage: selectedTemplate2.deliveryPercentage
      };
      console.error("[DEBUG] Setting form values:", newFormValues);
      setFormValues(newFormValues);
      setSelectedTemplate(selectedTemplate2);
      setActiveTab("new");
      ue.success(`Template "${templateName}" loaded`);
    }
  };
  const handleTabChange = (value) => {
    console.error("[DEBUG] Tab changed to:", value);
    setActiveTab(value);
    if (value === "new" && !selectedTemplate) {
      console.error("[DEBUG] Resetting form values");
      setFormValues(void 0);
    }
  };
  const handleSubmit = async (values) => {
    console.log("[AddItemDialog] Received values for submit:", values);
    setIsSubmitting(true);
    try {
      await onSubmit(values);
      onOpenChange(false);
    } catch (error) {
      console.error("Error submitting form:", error);
      ue.error("Failed to add item");
    } finally {
      setIsSubmitting(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange: (newOpen) => {
    setLastAction(`Dialog ${newOpen ? "opened" : "closed"}`);
    if (!selectedTemplate || !newOpen) {
      onOpenChange(newOpen);
    }
  }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-[625px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Add New Inventory Item" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-xs text-muted-foreground mb-2", children: [
      "Last Action: ",
      lastAction
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: handleTabChange, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid grid-cols-2 mb-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "new", children: "New Item" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "template", children: "From Template" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "new", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        AddItemForm,
        {
          onSubmit: handleSubmit,
          onCancel: () => onOpenChange(false),
          categories: categories2,
          units: units2,
          locations: locations2,
          suppliers: suppliers2,
          projects: projects2,
          isSubmitting,
          existingItems,
          initialValues: formValues
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "template", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: templates.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Card, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "pt-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "No templates available. Create templates from existing items to reuse them later." }) }) }) : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Select a Template" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Select,
          {
            onValueChange: handleTemplateSelect,
            defaultValue: templates[0]?.templateName || "",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Choose a template" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: templates.map((template) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                SelectItem,
                {
                  value: template.templateName,
                  children: template.templateName
                },
                template.templateId
              )) })
            ]
          }
        )
      ] }) }) })
    ] })
  ] }) });
}
const formSchema$1 = objectType({
  name: stringType().min(1, "Name is required"),
  description: stringType().optional(),
  category: stringType().min(1, "Category is required"),
  subcategory: stringType().optional(),
  unit: stringType().min(1, "Unit is required"),
  location: stringType().min(1, "Location is required"),
  locationSubcategory: stringType().optional(),
  cabinet: stringType().optional(),
  quantity: coerce.number().min(0, "Quantity cannot be negative"),
  supplier: stringType().optional(),
  supplierWebsite: stringType().transform((val) => val ? ensureUrlProtocol(val.trim()) : "").optional(),
  project: stringType().optional(),
  notes: stringType().optional(),
  orderStatus: nativeEnumType(OrderStatus, {
    errorMap: () => ({ message: "Please select a valid order status" })
  }).default(OrderStatus.COMPLETED),
  deliveryPercentage: coerce.number().min(0).max(100).default(100),
  expectedDeliveryDate: stringType().optional(),
  minQuantity: coerce.number().min(0, "Minimum quantity cannot be negative").optional().transform((val) => val === 0 ? void 0 : val),
  costPerUnit: coerce.number().min(0).optional(),
  barcode: stringType().optional(),
  serialNumber: stringType().optional(),
  manufacturer: stringType().optional(),
  modelNumber: stringType().optional(),
  dateInService: stringType().optional(),
  maintenanceNotes: stringType().optional(),
  unitSubcategory: stringType().optional()
});
const InventorySupplyTab = ({ form, units: units2, suppliers: suppliers2 }) => {
  const unitSubcategories = reactExports.useMemo(() => {
    const selectedUnit = form.watch("unit");
    const unitItem = units2.find((u3) => u3.name === selectedUnit);
    return unitItem?.children || [];
  }, [form.watch("unit"), units2]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "unit",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Unit*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: (value) => {
                if (value !== field.value) {
                  field.onChange(value);
                  form.setValue("unitSubcategory", "");
                }
              },
              value: field.value,
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select unit" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: units2.map((unit) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: unit.name, children: [
                  unit.name,
                  unit.children && unit.children.length > 0 && " (Has Subcategories)"
                ] }, unit.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    unitSubcategories.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "unitSubcategory",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Unit Size" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: field.onChange,
              value: field.value || "",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select unit size" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: unitSubcategories.map((subUnit) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: subUnit.name, children: subUnit.name }, subUnit.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(FormDescription, { children: [
            form.watch("unit"),
            " sizes available"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "quantity",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Quantity*" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              min: "0",
              step: "1",
              ...field,
              onChange: (e3) => field.onChange(Number(e3.target.value))
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "minQuantity",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Minimum Quantity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "number",
              min: "0",
              step: "1",
              ...field,
              value: field.value ?? "",
              onChange: (e3) => {
                const val = e3.target.value === "" ? void 0 : Number(e3.target.value);
                field.onChange(val);
              }
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormDescription, { children: "Leave empty or set to 0 for no minimum quantity alert" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "supplier",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Supplier" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              onValueChange: field.onChange,
              value: field.value || "",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select supplier" }) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: suppliers2.map((sup) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: sup.name, children: sup.name }, sup.name)) })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "supplierWebsite",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Supplier Website" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "url",
              ...field,
              placeholder: "https://supplier.com"
            }
          ) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    )
  ] }) });
};
const AdditionalInfoTab = ({ form }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "barcode",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Barcode" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter barcode" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "serialNumber",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Serial Number" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter serial number" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "manufacturer",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Manufacturer" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter manufacturer" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "modelNumber",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Model Number" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter model number" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "dateInService",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Date In Service" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Input,
              {
                type: "date",
                ...field,
                value: field.value || ""
              }
            ) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "maintenanceNotes",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Maintenance Notes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter maintenance notes" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      FormField,
      {
        control: form.control,
        name: "notes",
        render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Additional Notes" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter additional notes" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
        ] })
      }
    )
  ] });
};
function EditItemForm({
  item,
  onSubmit: handleSubmit,
  onCancel,
  categories: categories2,
  units: units2,
  locations: locations2,
  suppliers: suppliers2,
  projects: projects2,
  cabinets,
  isSubmitting = false,
  existingItems = [],
  existingManufacturers = [],
  existingSuppliers = [],
  existingProjects = []
}) {
  const [activeTab, setActiveTab] = reactExports.useState("details");
  const initialLocationName = reactExports.useMemo(() => {
    const locationObj = locations2.find((loc) => loc.id === item.location);
    console.log(`Initial location ID: ${item.location}, found name: ${locationObj?.name || "NOT FOUND"}`);
    return locationObj?.id || "";
  }, [item.location, locations2]);
  const defaultValues = reactExports.useMemo(() => {
    let expectedDeliveryDate = item.expectedDeliveryDate;
    if (expectedDeliveryDate) {
      if (expectedDeliveryDate instanceof Date) {
        expectedDeliveryDate = expectedDeliveryDate.toISOString().split("T")[0];
      } else if (typeof expectedDeliveryDate === "string") {
        try {
          expectedDeliveryDate = new Date(expectedDeliveryDate).toISOString().split("T")[0];
        } catch (e3) {
          expectedDeliveryDate = "";
        }
      }
    }
    let dateInService = item.dateInService;
    if (dateInService) {
      if (dateInService instanceof Date) {
        dateInService = dateInService.toISOString().split("T")[0];
      } else if (typeof dateInService === "string") {
        try {
          dateInService = new Date(dateInService).toISOString().split("T")[0];
        } catch (e3) {
          dateInService = "";
        }
      }
    }
    return {
      name: item.name || "",
      description: item.description || "",
      category: item.category || "",
      subcategory: item.subcategory || "",
      unit: item.unit || "",
      location: initialLocationName,
      // Use location ID
      locationSubcategory: item.locationSubcategory || "",
      cabinet: item.cabinet || "",
      quantity: item.quantity || 0,
      supplier: item.supplier || "",
      supplierWebsite: item.supplierWebsite || "",
      project: item.project || "",
      notes: item.notes || "",
      orderStatus: item.orderStatus || OrderStatus.COMPLETED,
      deliveryPercentage: item.deliveryPercentage || 100,
      expectedDeliveryDate,
      minQuantity: item.minQuantity || 0,
      costPerUnit: item.costPerUnit || 0,
      barcode: item.barcode || "",
      serialNumber: item.serialNumber || "",
      manufacturer: item.manufacturer || "",
      modelNumber: item.modelNumber || "",
      dateInService,
      maintenanceNotes: item.maintenanceNotes || "",
      unitSubcategory: item.unitSubcategory || ""
    };
  }, [item, initialLocationName]);
  const form = useForm({
    resolver: t2(formSchema$1),
    defaultValues
  });
  const formState = form.formState;
  reactExports.useEffect(() => {
    console.log("Form is valid:", formState.isValid);
    console.log("Form errors:", formState.errors);
    const requiredFields = ["name", "category", "unit", "location"];
    requiredFields.forEach((field) => {
      const value = form.getValues(field);
      console.log(`Field ${field}: "${value || ""}" (${value ? "valid" : "invalid"})`);
    });
  }, [formState.isValid, formState.errors, form]);
  const onSubmit = (values) => {
    const locationObj = locations2.find((loc) => loc.name === values.location);
    const locationId = locationObj?.id || "";
    console.log(`Submitting form: location name "${values.location}" → ID: ${locationId}`);
    handleSubmit({
      ...values,
      location: locationId
      // Use the location ID instead of name
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...form, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-3", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "details", children: "Item Details" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "inventory", children: "Inventory & Supply" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "additional", children: "Additional Info" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "details", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        BasicDetailsTab,
        {
          form,
          categories: categories2,
          locations: locations2,
          cabinets,
          projects: projects2
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "inventory", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        InventorySupplyTab,
        {
          form,
          units: units2,
          suppliers: suppliers2
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "additional", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AdditionalInfoTab, { form }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2 mt-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onCancel, type: "button", children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { type: "submit", disabled: false, children: [
        isSubmitting && /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
        "Save Changes"
      ] })
    ] })
  ] }) });
}
function EditItemDialog({
  item,
  isOpen,
  onClose,
  onSave,
  categories: categories2,
  units: units2,
  locations: locations2,
  suppliers: suppliers2,
  projects: projects2,
  cabinets,
  existingItems
}) {
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const handleSubmit = async (values) => {
    try {
      setIsSubmitting(true);
      const locationObj = locations2.find((loc) => loc.id === item.location);
      console.log("FORM SUBMIT - Original location:", {
        id: item.location,
        name: locationObj?.name
      });
      console.log("FORM SUBMIT - New location value:", values.location);
      if (item.cabinet || values.cabinet) {
        const cabinetObj = cabinets.find((cab) => cab.id === (values.cabinet || item.cabinet));
        console.log("FORM SUBMIT - Cabinet info:", {
          id: values.cabinet || item.cabinet,
          name: cabinetObj?.name,
          locationId: cabinetObj?.locationId,
          matchesLocation: cabinetObj?.locationId === values.location
        });
      }
      const updatedItem = {
        ...item,
        // Start with all original values
        // Carefully merge updates, preserving original values if new values are empty/undefined
        name: values.name ?? item.name,
        description: values.description ?? item.description,
        category: values.category ?? item.category,
        subcategory: values.subcategory ?? item.subcategory,
        unit: values.unit ?? item.unit,
        location: values.location ?? item.location,
        cabinet: values.cabinet ?? item.cabinet,
        quantity: values.quantity !== void 0 ? Number(values.quantity) : item.quantity,
        supplier: values.supplier ?? item.supplier,
        supplierWebsite: values.supplierWebsite ?? item.supplierWebsite,
        project: values.project ?? item.project,
        notes: values.notes ?? item.notes,
        orderStatus: values.orderStatus ?? item.orderStatus,
        deliveryPercentage: values.deliveryPercentage !== void 0 ? Number(values.deliveryPercentage) : item.deliveryPercentage,
        expectedDeliveryDate: values.expectedDeliveryDate ?? item.expectedDeliveryDate,
        minQuantity: values.minQuantity !== void 0 ? Number(values.minQuantity) : item.minQuantity ?? 0,
        costPerUnit: values.costPerUnit !== void 0 ? Number(values.costPerUnit) : item.costPerUnit ?? 0,
        barcode: values.barcode ?? item.barcode,
        serialNumber: values.serialNumber ?? item.serialNumber,
        manufacturer: values.manufacturer ?? item.manufacturer,
        modelNumber: values.modelNumber ?? item.modelNumber,
        dateInService: values.dateInService ?? item.dateInService,
        maintenanceNotes: values.maintenanceNotes ?? item.maintenanceNotes,
        unitSubcategory: values.unitSubcategory ?? item.unitSubcategory,
        lastUpdated: /* @__PURE__ */ new Date()
      };
      console.log("Original item:", item);
      console.log("Form values:", values);
      console.log("Updated item:", updatedItem);
      await onSave(updatedItem);
      onClose();
    } catch (error) {
      console.error("Error updating item:", error);
      ue.error("Failed to update item");
    } finally {
      setIsSubmitting(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: (open) => !open && onClose(), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-[625px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Edit Inventory Item" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Make changes to your inventory item here. Click save when you're done." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      EditItemForm,
      {
        item,
        onSubmit: handleSubmit,
        onCancel: onClose,
        categories: categories2,
        units: units2,
        locations: locations2,
        suppliers: suppliers2,
        projects: projects2,
        cabinets,
        isSubmitting,
        existingItems
      },
      item.id
    )
  ] }) });
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked ?? false,
      onChange: onCheckedChange,
      caller: CHECKBOX_NAME
    });
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form2 = button?.form;
      if (form2) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form2.addEventListener("reset", reset);
        return () => form2.removeEventListener("reset", reset);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        CheckboxBubbleInput,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" },
          defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate(context.state) || context.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context.state),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BUBBLE_INPUT_NAME = "CheckboxBubbleInput";
var CheckboxBubbleInput = reactExports.forwardRef(
  ({
    __scopeCheckbox,
    control,
    checked,
    bubbles = true,
    defaultChecked,
    ...props
  }, forwardedRef) => {
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(ref, forwardedRef);
    const prevChecked = usePrevious$1(checked);
    const controlSize = useSize(control);
    reactExports.useEffect(() => {
      const input = ref.current;
      if (!input) return;
      const inputProto = window.HTMLInputElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        inputProto,
        "checked"
      );
      const setChecked = descriptor.set;
      if (prevChecked !== checked && setChecked) {
        const event = new Event("click", { bubbles });
        input.indeterminate = isIndeterminate(checked);
        setChecked.call(input, isIndeterminate(checked) ? false : checked);
        input.dispatchEvent(event);
      }
    }, [prevChecked, checked, bubbles]);
    const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.input,
      {
        type: "checkbox",
        "aria-hidden": true,
        defaultChecked: defaultChecked ?? defaultCheckedRef.current,
        ...props,
        tabIndex: -1,
        ref: composedRefs,
        style: {
          ...props.style,
          ...controlSize,
          position: "absolute",
          pointerEvents: "none",
          opacity: 0,
          margin: 0
        }
      }
    );
  }
);
CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME;
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$1 = Checkbox$1;
var Indicator = CheckboxIndicator;
const Checkbox = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$1,
  {
    ref,
    className: cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Indicator,
      {
        className: cn("flex items-center justify-center text-current"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" })
      }
    )
  }
));
Checkbox.displayName = Root$1.displayName;
function DuplicateItemDialog({
  isOpen,
  onClose,
  item,
  onDuplicate
}) {
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const [newName, setNewName] = reactExports.useState(`${item.name} (Copy)`);
  const [quantity, setQuantity] = reactExports.useState(0);
  const [resetOrderStatus, setResetOrderStatus] = reactExports.useState(true);
  const [fieldsToCopy, setFieldsToCopy] = reactExports.useState({
    description: true,
    unit: true,
    costPerUnit: true,
    category: true,
    location: true,
    reorderLevel: true,
    barcode: false,
    // Default false for barcode as it should be unique
    notes: true,
    supplier: true,
    supplierWebsite: true,
    project: true
  });
  const toggleField = (field) => {
    setFieldsToCopy((prev) => ({
      ...prev,
      [field]: !prev[field]
    }));
  };
  const handleDuplicate = async () => {
    if (!newName.trim()) {
      ue.error("Item name is required");
      return;
    }
    setIsSubmitting(true);
    try {
      const newItem = {
        name: newName.trim(),
        quantity
      };
      Object.keys(fieldsToCopy).forEach((field) => {
        if (fieldsToCopy[field]) {
          newItem[field] = item[field];
        }
      });
      if (!resetOrderStatus) {
        newItem.orderStatus = item.orderStatus;
        newItem.deliveryPercentage = item.deliveryPercentage;
        newItem.expectedDeliveryDate = item.expectedDeliveryDate;
      } else {
        newItem.orderStatus = "delivered";
        newItem.deliveryPercentage = 100;
        newItem.expectedDeliveryDate = void 0;
      }
      await onDuplicate(newItem);
      ue.success(`Duplicated "${item.name}" successfully`);
      onClose();
    } catch (error) {
      console.error("Duplication error:", error);
      ue.error("Failed to duplicate item");
    } finally {
      setIsSubmitting(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: (open) => !open && onClose(), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Duplicate Item" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { children: [
        'Create a copy of "',
        item.name,
        '" with your selected properties.'
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "py-4 space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "new-name", children: "New Item Name" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: "new-name",
            value: newName,
            onChange: (e3) => setNewName(e3.target.value),
            placeholder: "Enter name for the duplicate item"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "quantity", children: "Initial Quantity" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: "quantity",
            type: "number",
            min: "0",
            step: "any",
            value: quantity,
            onChange: (e3) => setQuantity(Number(e3.target.value)),
            placeholder: "Enter initial quantity"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            id: "reset-order-status",
            checked: resetOrderStatus,
            onCheckedChange: () => setResetOrderStatus(!resetOrderStatus)
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "reset-order-status", children: 'Reset order status to "Delivered"' })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Properties to Copy" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-2 max-h-60 overflow-y-auto border rounded-md p-2", children: Object.keys(fieldsToCopy).map((field) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              id: `field-${field}`,
              checked: fieldsToCopy[field],
              onCheckedChange: () => toggleField(field)
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: `field-${field}`, className: "capitalize", children: field.replace(/([A-Z])/g, " $1").trim() })
        ] }, field)) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          onClick: handleDuplicate,
          disabled: isSubmitting || !newName.trim(),
          children: isSubmitting ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
            "Creating..."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "mr-2 h-4 w-4" }),
            "Create Duplicate"
          ] })
        }
      )
    ] })
  ] }) });
}
function ExportDialog({ isOpen, onClose, items, defaultFilename }) {
  const [format2, setFormat] = reactExports.useState("csv");
  const [filename, setFilename] = reactExports.useState(defaultFilename || `inventory_export_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`);
  const handleExport = () => {
    try {
      const headers = ["Name", "Category", "Location", "Project", "Quantity", "Unit", "Notes", "Last Updated"];
      const rows = items.map((item) => [
        item.name,
        item.category || "",
        item.location || "",
        item.project || "",
        item.quantity.toString(),
        item.unit || "",
        item.notes || "",
        new Date(item.lastUpdated).toLocaleDateString()
      ]);
      if (format2 === "csv") {
        const csvContent = [
          headers.join(","),
          ...rows.map((row) => row.map(
            (cell) => `"${String(cell).replace(/"/g, '""')}"`
          ).join(","))
        ].join("\n");
        const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
        const url2 = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.setAttribute("href", url2);
        link.setAttribute("download", `${filename}.csv`);
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url2);
      } else {
        console.error("XLSX export not yet implemented");
      }
      onClose();
    } catch (error) {
      console.error("Export error:", error);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: onClose, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-[425px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Export Inventory" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Choose your export format and filename" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-4 py-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "format", children: "Export Format" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Select,
          {
            value: format2,
            onValueChange: (value) => setFormat(value),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select format" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "csv", children: "CSV (Comma Separated Values)" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "xlsx", children: "Excel Workbook (XLSX)" })
              ] })
            ]
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "filename", children: "Filename" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: "filename",
            value: filename,
            onChange: (e3) => setFilename(e3.target.value),
            placeholder: "Enter filename without extension"
          }
        )
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleExport, children: "Export" })
    ] })
  ] }) });
}
const Table = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "relative w-full overflow-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
  "table",
  {
    ref,
    className: cn("w-full caption-bottom text-sm", className),
    ...props
  }
) }));
Table.displayName = "Table";
const TableHeader = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { ref, className: cn("[&_tr]:border-b", className), ...props }));
TableHeader.displayName = "TableHeader";
const TableBody = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tbody",
  {
    ref,
    className: cn("[&_tr:last-child]:border-0", className),
    ...props
  }
));
TableBody.displayName = "TableBody";
const TableFooter = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tfoot",
  {
    ref,
    className: cn("bg-primary font-medium text-primary-foreground", className),
    ...props
  }
));
TableFooter.displayName = "TableFooter";
const TableRow = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "tr",
  {
    ref,
    className: cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    ),
    ...props
  }
));
TableRow.displayName = "TableRow";
const TableHead = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "th",
  {
    ref,
    className: cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    ),
    ...props
  }
));
TableHead.displayName = "TableHead";
const TableCell = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "td",
  {
    ref,
    className: cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className),
    ...props
  }
));
TableCell.displayName = "TableCell";
const TableCaption = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "caption",
  {
    ref,
    className: cn("mt-4 text-sm text-muted-foreground", className),
    ...props
  }
));
TableCaption.displayName = "TableCaption";
var ROOT_NAME = "AlertDialog";
var [createAlertDialogContext, createAlertDialogScope] = createContextScope(ROOT_NAME, [
  createDialogScope
]);
var useDialogScope = createDialogScope();
var AlertDialog$1 = (props) => {
  const { __scopeAlertDialog, ...alertDialogProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root$4, { ...dialogScope, ...alertDialogProps, modal: true });
};
AlertDialog$1.displayName = ROOT_NAME;
var TRIGGER_NAME = "AlertDialogTrigger";
var AlertDialogTrigger = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...triggerProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Trigger$2, { ...dialogScope, ...triggerProps, ref: forwardedRef });
  }
);
AlertDialogTrigger.displayName = TRIGGER_NAME;
var PORTAL_NAME = "AlertDialogPortal";
var AlertDialogPortal$1 = (props) => {
  const { __scopeAlertDialog, ...portalProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { ...dialogScope, ...portalProps });
};
AlertDialogPortal$1.displayName = PORTAL_NAME;
var OVERLAY_NAME = "AlertDialogOverlay";
var AlertDialogOverlay$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...overlayProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Overlay, { ...dialogScope, ...overlayProps, ref: forwardedRef });
  }
);
AlertDialogOverlay$1.displayName = OVERLAY_NAME;
var CONTENT_NAME = "AlertDialogContent";
var [AlertDialogContentProvider, useAlertDialogContentContext] = createAlertDialogContext(CONTENT_NAME);
var Slottable = /* @__PURE__ */ createSlottable("AlertDialogContent");
var AlertDialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, children, ...contentProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    const cancelRef = reactExports.useRef(null);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      WarningProvider,
      {
        contentName: CONTENT_NAME,
        titleName: TITLE_NAME$1,
        docsSlug: "alert-dialog",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogContentProvider, { scope: __scopeAlertDialog, cancelRef, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Content$1,
          {
            role: "alertdialog",
            ...dialogScope,
            ...contentProps,
            ref: composedRefs,
            onOpenAutoFocus: composeEventHandlers(contentProps.onOpenAutoFocus, (event) => {
              event.preventDefault();
              cancelRef.current?.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (event) => event.preventDefault(),
            onInteractOutside: (event) => event.preventDefault(),
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Slottable, { children }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef })
            ]
          }
        ) })
      }
    );
  }
);
AlertDialogContent$1.displayName = CONTENT_NAME;
var TITLE_NAME$1 = "AlertDialogTitle";
var AlertDialogTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...titleProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Title$1, { ...dialogScope, ...titleProps, ref: forwardedRef });
  }
);
AlertDialogTitle$1.displayName = TITLE_NAME$1;
var DESCRIPTION_NAME$1 = "AlertDialogDescription";
var AlertDialogDescription$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeAlertDialog, ...descriptionProps } = props;
  const dialogScope = useDialogScope(__scopeAlertDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Description$1, { ...dialogScope, ...descriptionProps, ref: forwardedRef });
});
AlertDialogDescription$1.displayName = DESCRIPTION_NAME$1;
var ACTION_NAME$1 = "AlertDialogAction";
var AlertDialogAction$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...actionProps } = props;
    const dialogScope = useDialogScope(__scopeAlertDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Close$1, { ...dialogScope, ...actionProps, ref: forwardedRef });
  }
);
AlertDialogAction$1.displayName = ACTION_NAME$1;
var CANCEL_NAME = "AlertDialogCancel";
var AlertDialogCancel$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeAlertDialog, ...cancelProps } = props;
    const { cancelRef } = useAlertDialogContentContext(CANCEL_NAME, __scopeAlertDialog);
    const dialogScope = useDialogScope(__scopeAlertDialog);
    const ref = useComposedRefs(forwardedRef, cancelRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Close$1, { ...dialogScope, ...cancelProps, ref });
  }
);
AlertDialogCancel$1.displayName = CANCEL_NAME;
var DescriptionWarning = ({ contentRef }) => {
  const MESSAGE = `\`${CONTENT_NAME}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${CONTENT_NAME}\` by passing a \`${DESCRIPTION_NAME$1}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${CONTENT_NAME}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  reactExports.useEffect(() => {
    const hasDescription = document.getElementById(
      contentRef.current?.getAttribute("aria-describedby")
    );
    if (!hasDescription) console.warn(MESSAGE);
  }, [MESSAGE, contentRef]);
  return null;
};
var Root2$1 = AlertDialog$1;
var Portal2 = AlertDialogPortal$1;
var Overlay2 = AlertDialogOverlay$1;
var Content2 = AlertDialogContent$1;
var Action$2 = AlertDialogAction$1;
var Cancel = AlertDialogCancel$1;
var Title2 = AlertDialogTitle$1;
var Description2 = AlertDialogDescription$1;
const AlertDialog = Root2$1;
const AlertDialogPortal = Portal2;
const AlertDialogOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay2,
  {
    className: cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props,
    ref
  }
));
AlertDialogOverlay.displayName = Overlay2.displayName;
const AlertDialogContent = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertDialogPortal, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogOverlay, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content2,
    {
      ref,
      className: cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props
    }
  )
] }));
AlertDialogContent.displayName = Content2.displayName;
const AlertDialogHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    ),
    ...props
  }
);
AlertDialogHeader.displayName = "AlertDialogHeader";
const AlertDialogFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
AlertDialogFooter.displayName = "AlertDialogFooter";
const AlertDialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title2,
  {
    ref,
    className: cn("text-lg font-semibold", className),
    ...props
  }
));
AlertDialogTitle.displayName = Title2.displayName;
const AlertDialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description2,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
AlertDialogDescription.displayName = Description2.displayName;
const AlertDialogAction = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Action$2,
  {
    ref,
    className: cn(buttonVariants(), className),
    ...props
  }
));
AlertDialogAction.displayName = Action$2.displayName;
const AlertDialogCancel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Cancel,
  {
    ref,
    className: cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    ),
    ...props
  }
));
AlertDialogCancel.displayName = Cancel.displayName;
const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
function Badge({ className, variant, ...props }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: cn(badgeVariants({ variant }), className), ...props });
}
function FormatCellValue({ item, column }) {
  if (column === "lastUpdated") {
    const dateValue = item[column] instanceof Date ? item[column] : new Date(item[column]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: format(dateValue, "MMM d, yyyy") }),
      item.lastModifiedBy && /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-xs text-muted-foreground", children: [
        "by ",
        item.lastModifiedBy
      ] })
    ] });
  }
  if (column === "costPerUnit") {
    return formatCurrency(item[column]);
  }
  if (column === "totalValue") {
    return formatCurrency(item.quantity * (item.costPerUnit || 0));
  }
  if (column === "quantity") {
    return `${item[column]} ${item.unit || ""}`;
  }
  if (column === "name") {
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item[column]?.toString() || "-" }),
      item.reorderLevel !== void 0 && item.quantity <= item.reorderLevel && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Badge, { variant: "destructive", className: "flex items-center gap-1 px-2 py-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(BarChart2, { className: "h-3 w-3" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-xs", children: "Low" })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { children: [
          "Quantity below reorder level (",
          item.reorderLevel,
          ")"
        ] }) })
      ] }) }),
      item.notes && /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "flex items-center gap-1 px-2 py-0", children: /* @__PURE__ */ jsxRuntimeExports.jsx(StickyNote, { className: "h-3 w-3" }) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { side: "right", className: "max-w-[300px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "whitespace-pre-wrap break-words text-sm", children: item.notes }) })
      ] }) })
    ] });
  }
  const value = item[column];
  return value?.toString() || "-";
}
function flattenCategories(categories2) {
  if (!categories2 || !Array.isArray(categories2)) {
    return [];
  }
  const flattened = [];
  const traverse = (node, parentPath = "") => {
    const currentPath = parentPath ? `${parentPath}/${node.name}` : node.name;
    flattened.push(currentPath);
    if (node.children) {
      node.children.forEach((child) => traverse(child, currentPath));
    }
  };
  categories2.forEach((category) => traverse(category));
  return flattened.sort();
}
const convertToCategories = (items) => {
  return items.map((item) => ({
    id: item.id,
    name: item.name,
    children: item.subcategories ? item.subcategories.map((sub) => ({
      id: crypto.randomUUID(),
      name: sub,
      parentId: item.id
    })) : void 0
  }));
};
function InventoryPage() {
  const navigate = useNavigate();
  const location2 = useLocation();
  const [searchParams, setSearchParams] = useSearchParams();
  const { user } = useAuth();
  const categoryFilter = searchParams.get("category") || "";
  const locationFilter = searchParams.get("location") || "";
  const supplierFilter = searchParams.get("supplier") || "";
  const projectFilter = searchParams.get("project") || "";
  const [items, setItems] = useLocalStorage("inventoryItems", []);
  const [searchQuery, setSearchQuery] = reactExports.useState("");
  const [selectedCategory, setSelectedCategory] = reactExports.useState(categoryFilter);
  const [selectedLocation, setSelectedLocation] = reactExports.useState(locationFilter);
  const [selectedSupplier, setSelectedSupplier] = reactExports.useState(supplierFilter);
  const [selectedProject, setSelectedProject] = reactExports.useState(projectFilter);
  const [selectedItems, setSelectedItems] = reactExports.useState([]);
  const [isAllSelected, setIsAllSelected] = reactExports.useState(false);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = reactExports.useState(false);
  const [itemToDelete, setItemToDelete] = reactExports.useState(null);
  const [isAddDialogOpen, setIsAddDialogOpen] = reactExports.useState(false);
  const [isEditDialogOpen, setIsEditDialogOpen] = reactExports.useState(false);
  const [isDuplicateDialogOpen, setIsDuplicateDialogOpen] = reactExports.useState(false);
  const [selectedItem, setSelectedItem] = reactExports.useState(null);
  const [highlightedItemId, setHighlightedItemId] = reactExports.useState(null);
  const [isExportDialogOpen, setIsExportDialogOpen] = reactExports.useState(false);
  const [categories2, setCategories] = reactExports.useState([]);
  const [units2, setUnits] = reactExports.useState([]);
  const [locations2, setLocations] = reactExports.useState([]);
  const [suppliers2, setSuppliers] = reactExports.useState([]);
  const [projects2, setProjects] = reactExports.useState([]);
  reactExports.useEffect(() => {
    const loadSettings = () => {
      const settings = getSettings();
      setCategories(convertToCategories(settings.categories));
      setUnits(settings.units);
      setLocations(settings.locations);
      setSuppliers(settings.suppliers);
      setProjects(settings.projects);
    };
    loadSettings();
  }, []);
  const template = location2.state?.template;
  const [sortField, setSortField] = reactExports.useState("name");
  const [sortDirection, setSortDirection] = reactExports.useState("asc");
  const [updateTrigger, setUpdateTrigger] = reactExports.useState(0);
  const flattenedCategories = reactExports.useMemo(() => flattenCategories(categories2), [categories2]);
  reactExports.useMemo(() => locations2.map((loc) => loc.name), [locations2]);
  reactExports.useMemo(() => projects2.map((proj) => proj.name), [projects2]);
  reactExports.useMemo(() => suppliers2.map((sup) => sup.name), [suppliers2]);
  const filteredItems = reactExports.useMemo(() => {
    const filtered = items.filter((item) => {
      const searchFields = [
        item.name,
        item.category,
        item.location,
        item.project,
        item.notes
      ].map((field) => field?.toLowerCase() || "");
      const matchesSearch = !searchQuery || searchFields.some((field) => field.includes(searchQuery.toLowerCase()));
      const matchesCategory = !selectedCategory || item.category === selectedCategory;
      const matchesLocation = !selectedLocation || item.location === selectedLocation;
      const matchesProject = !selectedProject || item.project === selectedProject;
      return matchesSearch && matchesCategory && matchesLocation && matchesProject;
    });
    return [...filtered].sort((a4, b2) => {
      const aValue = a4[sortField];
      const bValue = b2[sortField];
      if (aValue === bValue) return 0;
      if (aValue === null || aValue === void 0) return 1;
      if (bValue === null || bValue === void 0) return -1;
      const comparison = String(aValue).localeCompare(String(bValue));
      return sortDirection === "asc" ? comparison : -comparison;
    });
  }, [items, searchQuery, selectedCategory, selectedLocation, selectedProject, sortField, sortDirection]);
  const handleSort = (field) => {
    if (sortField === field) {
      setSortDirection((prev) => prev === "asc" ? "desc" : "asc");
    } else {
      setSortField(field);
      setSortDirection("asc");
    }
  };
  const toggleSelectAll = () => {
    if (isAllSelected) {
      setSelectedItems([]);
    } else {
      setSelectedItems(filteredItems.map((item) => item.id));
    }
    setIsAllSelected(!isAllSelected);
  };
  const toggleItemSelection = (itemId) => {
    setSelectedItems((prev) => {
      const newSelection = prev.includes(itemId) ? prev.filter((id2) => id2 !== itemId) : [...prev, itemId];
      setIsAllSelected(newSelection.length === filteredItems.length);
      return newSelection;
    });
  };
  const clearSelection = () => {
    setSelectedItems([]);
    setIsAllSelected(false);
  };
  const handleDelete = (item) => {
    setItemToDelete(item);
    setIsDeleteDialogOpen(true);
  };
  const confirmDelete = () => {
    if (itemToDelete) {
      const updatedItems = items.filter((item) => item.id !== itemToDelete.id);
      setItems(updatedItems);
      ue.success(`Deleted "${itemToDelete.name}"`);
      setIsDeleteDialogOpen(false);
      setItemToDelete(null);
    }
  };
  const filters = reactExports.useMemo(() => ({
    category: selectedCategory,
    location: selectedLocation,
    project: selectedProject
  }), [selectedCategory, selectedLocation, selectedProject]);
  reactExports.useEffect(() => {
    const newParams = new URLSearchParams();
    Object.entries(filters).forEach(([key, value]) => {
      if (value) newParams.set(key, value);
    });
    if (newParams.toString() !== searchParams.toString()) {
      setSearchParams(newParams);
    }
  }, [filters, setSearchParams, searchParams]);
  reactExports.useEffect(() => {
    if (highlightedItemId) {
      const timer = setTimeout(() => {
        setHighlightedItemId(null);
      }, 3e3);
      return () => clearTimeout(timer);
    }
  }, [highlightedItemId]);
  const handleAddItem = async (newItemData) => {
    const newItem = {
      ...newItemData,
      id: v4(),
      lastUpdated: /* @__PURE__ */ new Date(),
      lastModifiedBy: user?.username || user?.displayName || "Unknown"
    };
    setItems([...items, newItem]);
    setHighlightedItemId(newItem.id);
    ue.success(`Added "${newItem.name}" to inventory`);
    setIsAddDialogOpen(false);
    return Promise.resolve();
  };
  const handleSaveEdit = async (updatedItem) => {
    try {
      const updatedItems = items.map(
        (item) => item.id === updatedItem.id ? {
          ...updatedItem,
          lastUpdated: /* @__PURE__ */ new Date(),
          lastModifiedBy: user?.username || user?.displayName || "Unknown"
        } : item
      );
      setItems(updatedItems);
      ue.success(`Updated "${updatedItem.name}"`);
      setIsEditDialogOpen(false);
      setSelectedItem(null);
      setHighlightedItemId(updatedItem.id);
    } catch (error) {
      console.error("Error updating item:", error);
      ue.error("Failed to update item");
    }
  };
  const handleDuplicateItem = async (newItemData) => {
    const newItem = {
      ...newItemData,
      id: v4(),
      lastUpdated: /* @__PURE__ */ new Date(),
      lastModifiedBy: user?.username || user?.displayName || "Unknown"
    };
    setItems([...items, newItem]);
    setHighlightedItemId(newItem.id);
    setIsDuplicateDialogOpen(false);
    ue.success(`Duplicated "${selectedItem?.name}" successfully`);
  };
  const handleFilterChange = (field, value) => {
    switch (field) {
      case "category":
        setSelectedCategory(value === "all" ? "" : value);
        break;
      case "location":
        setSelectedLocation(value === "all" ? "" : value);
        break;
      case "project":
        setSelectedProject(value === "all" ? "" : value);
        break;
    }
  };
  reactExports.useEffect(() => {
    if (template) {
      setIsAddDialogOpen(true);
      navigate(location2.pathname, { replace: true });
    }
  }, [template, navigate, location2.pathname]);
  const [isDetailedView, setIsDetailedView] = reactExports.useState(false);
  const SIMPLE_COLUMNS = ["name", "category", "location", "project", "quantity", "lastUpdated"];
  const DETAILED_COLUMNS = ["name", "category", "quantity", "unit", "costPerUnit", "totalValue", "location", "project", "lastUpdated"];
  const activeColumns = isDetailedView ? DETAILED_COLUMNS : SIMPLE_COLUMNS;
  reactExports.useMemo(
    () => suppliers2.map((name) => ({ id: name, name, subcategories: [] })),
    [suppliers2]
  );
  reactExports.useMemo(
    () => projects2.map((name) => ({ id: name, name, subcategories: [] })),
    [projects2]
  );
  reactExports.useEffect(() => {
    const shouldRedirect = sessionStorage.getItem("redirectToInventory");
    if (shouldRedirect) {
      sessionStorage.removeItem("redirectToInventory");
      navigate("/inventory", { replace: true });
    }
  }, [navigate]);
  reactExports.useEffect(() => {
    if (location2.state?.forceRefresh) {
      navigate("/inventory", { replace: true, state: {} });
      setUpdateTrigger((prev) => prev + 1);
    }
  }, [location2.state?.forceRefresh, navigate]);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto px-4 py-6 space-y-4 min-h-screen", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold", children: "Inventory" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              type: "text",
              placeholder: "Search inventory...",
              value: searchQuery,
              onChange: (e3) => setSearchQuery(e3.target.value),
              className: "min-w-[240px]"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedCategory || "all", onValueChange: (value) => handleFilterChange("category", value), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "min-w-[200px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Filter by category" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { className: "min-w-[200px]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "all", children: "All Categories" }),
                flattenedCategories.map((category) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: category, children: category }, category))
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedLocation || "all", onValueChange: (value) => handleFilterChange("location", value === "all" ? "" : value), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "min-w-[200px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "All Locations" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { className: "min-w-[200px]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "all", children: "All Locations" }),
                locations2.map((location22) => /* @__PURE__ */ jsxRuntimeExports.jsxs(reactExports.Fragment, { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: location22.name, children: location22.name }),
                  location22.subcategories?.map((subcategory) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: `${location22.name}/${subcategory}`, children: [
                    location22.name,
                    " - ",
                    subcategory
                  ] }, `${location22.name}/${subcategory}`))
                ] }, location22.id))
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedProject || "all", onValueChange: (value) => handleFilterChange("project", value === "all" ? "" : value), children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "min-w-[200px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "All Projects" }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { className: "min-w-[200px]", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "all", children: "All Projects" }),
                projects2.map((project) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: project.name, children: project.name }, project.id))
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tooltip, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "ghost",
                  size: "icon",
                  onClick: () => {
                    handleFilterChange("category", "all");
                    handleFilterChange("location", "all");
                    handleFilterChange("project", "all");
                  },
                  className: "ml-1",
                  disabled: !selectedCategory && !selectedLocation && !selectedProject,
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4" })
                }
              ) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(TooltipContent, { children: selectedCategory || selectedLocation || selectedProject ? "Clear all filters" : "No active filters" })
            ] }) })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2 mr-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              id: "view-mode",
              checked: isDetailedView,
              onCheckedChange: setIsDetailedView
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "view-mode", className: "text-sm", children: isDetailedView ? "Detailed View" : "Simple View" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: () => setIsAddDialogOpen(true), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "mr-2 h-4 w-4" }),
          "Add Item"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm text-muted-foreground", children: [
        filteredItems.length,
        " ",
        filteredItems.length === 1 ? "item" : "items",
        " found"
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outline", onClick: () => setIsExportDialogOpen(true), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
        "Export Current View"
      ] })
    ] }),
    selectedItems.length > 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(
      BatchOperations,
      {
        selectedItems: items.filter((item) => selectedItems.includes(item.id)),
        onClearSelection: clearSelection,
        onItemsUpdated: () => {
          setIsAllSelected(false);
          setSelectedItems([]);
          setSearchQuery((prev) => prev + " ");
          setTimeout(() => setSearchQuery((prev) => prev.trim()), 0);
        },
        onDelete: (itemsToDelete) => {
          const updatedItems = items.filter((item) => !itemsToDelete.some((i3) => i3.id === item.id));
          setItems(updatedItems);
          clearSelection();
        }
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "bg-white rounded-lg shadow", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { className: "w-[30px]", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: isAllSelected,
            onCheckedChange: toggleSelectAll
          }
        ) }),
        activeColumns.map((column) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-1 cursor-pointer", onClick: () => handleSort(column), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: column.charAt(0).toUpperCase() + column.slice(1).replace(/([A-Z])/g, " $1") }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(ArrowUpDown, { className: "h-4 w-4" })
        ] }) }, column)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "Actions" })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableBody, { children: filteredItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { className: highlightedItemId === item.id ? "bg-blue-50" : "", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Checkbox,
          {
            checked: selectedItems.includes(item.id),
            onCheckedChange: () => toggleItemSelection(item.id)
          }
        ) }),
        activeColumns.map((column) => /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormatCellValue, { item, column }) }, column)),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", onClick: () => {
            setSelectedItem(item);
            setIsEditDialogOpen(true);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pencil, { className: "h-4 w-4" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", onClick: () => handleDelete(item), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash, { className: "h-4 w-4" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", onClick: () => {
            setSelectedItem(item);
            setIsDuplicateDialogOpen(true);
          }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4" }) })
        ] }) })
      ] }, item.id)) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AddItemDialog,
      {
        open: isAddDialogOpen,
        onOpenChange: setIsAddDialogOpen,
        onSubmit: handleAddItem,
        categories: categories2,
        units: units2,
        locations: locations2,
        suppliers: suppliers2,
        projects: projects2,
        existingItems: items,
        selectedTemplate: template
      }
    ),
    selectedItem && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        EditItemDialog,
        {
          item: selectedItem,
          isOpen: isEditDialogOpen,
          onClose: () => setIsEditDialogOpen(false),
          onSave: handleSaveEdit,
          categories: categories2,
          units: units2,
          locations: locations2,
          suppliers: suppliers2,
          projects: projects2,
          cabinets: [],
          existingItems: items
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        DuplicateItemDialog,
        {
          isOpen: isDuplicateDialogOpen,
          onClose: () => setIsDuplicateDialogOpen(false),
          item: selectedItem,
          onDuplicate: handleDuplicateItem
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialog, { open: isDeleteDialogOpen, onOpenChange: setIsDeleteDialogOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertDialogContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertDialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogTitle, { children: "Are you sure?" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertDialogDescription, { children: [
          'This will permanently delete "',
          itemToDelete?.name,
          '" from your inventory.'
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(AlertDialogFooter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogCancel, { children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDialogAction, { onClick: confirmDelete, children: "Delete" })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      ExportDialog,
      {
        isOpen: isExportDialogOpen,
        onClose: () => setIsExportDialogOpen(false),
        items: filteredItems,
        defaultFilename: `inventory_export_${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}_${filteredItems.length}_items`
      }
    )
  ] });
}
function DashboardPage() {
  const navigate = useNavigate();
  const [items, setItems] = useLocalStorage("inventoryItems", []);
  const [activeView, setActiveView] = reactExports.useState("project");
  const [activeSegment, setActiveSegment] = reactExports.useState(null);
  reactExports.useEffect(() => {
    const handleStorageChange = (e3) => {
      if (e3.key === "inventoryItems") {
        const newItems = e3.newValue ? JSON.parse(e3.newValue) : [];
        setItems(newItems);
      }
    };
    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, [setItems]);
  reactExports.useEffect(() => {
    const checkStorage = () => {
      const storedItems = localStorage.getItem("inventoryItems");
      if (storedItems) {
        const parsedItems = JSON.parse(storedItems);
        if (JSON.stringify(parsedItems) !== JSON.stringify(items)) {
          setItems(parsedItems);
        }
      }
    };
    const interval = setInterval(checkStorage, 1e3);
    return () => clearInterval(interval);
  }, [items, setItems]);
  const projectStats = reactExports.useMemo(() => {
    const stats = items.reduce((acc, item) => {
      const project = item.project || "Unassigned";
      if (!acc[project]) {
        acc[project] = { count: 0, items: [], totalValue: 0 };
      }
      acc[project].count += 1;
      acc[project].items.push(item);
      acc[project].totalValue += (item.quantity || 0) * (item.costPerUnit || 0);
      return acc;
    }, {});
    return Object.entries(stats).map(([name, data]) => ({
      name,
      value: data.count,
      items: data.items,
      percentage: (data.count / items.length * 100).toFixed(1),
      totalValue: data.totalValue.toFixed(2),
      totalQuantity: data.items.reduce((sum, item) => sum + (item.quantity || 0), 0)
    })).sort((a4, b2) => b2.value - a4.value);
  }, [items]);
  const locationStats = reactExports.useMemo(() => {
    const stats = items.reduce((acc, item) => {
      const location2 = item.location || "Unspecified";
      if (!acc[location2]) {
        acc[location2] = { count: 0, items: [], totalValue: 0 };
      }
      acc[location2].count += 1;
      acc[location2].items.push(item);
      acc[location2].totalValue += (item.quantity || 0) * (item.costPerUnit || 0);
      return acc;
    }, {});
    return Object.entries(stats).map(([name, data]) => ({
      name,
      value: data.count,
      items: data.items,
      percentage: (data.count / items.length * 100).toFixed(1),
      totalValue: data.totalValue.toFixed(2),
      totalQuantity: data.items.reduce((sum, item) => sum + (item.quantity || 0), 0)
    })).sort((a4, b2) => b2.value - a4.value);
  }, [items]);
  const activeStats = activeView === "project" ? projectStats : locationStats;
  const colors = [
    "#3B82F6",
    // 2024:NAB - bright blue
    "#10B981",
    // REMOTE_KIT_BUILD - emerald green
    "#F59E0B",
    // STUDIO_UPGRADE - amber
    "#F97316",
    // INFRASTRUCTURE - orange
    "#A78BFA",
    // Unassigned - purple
    "#84CC16",
    // 2025:SUTRO - lime green
    "#FCD34D"
    // MAINTENANCE - yellow
  ];
  const getTooltipContent = (stat) => {
    return `${stat.name}
${stat.value} items
Total Quantity: ${stat.totalQuantity}
Total Value: $${stat.totalValue}`;
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold", children: "Dashboard" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: () => navigate("/inventory"), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "mr-2 h-4 w-4" }),
        "Manage Inventory"
      ] })
    ] }),
    items.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Welcome to TEd_trackIT" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Get started by adding your first inventory items" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Your inventory is currently empty. Start by adding some items to track." }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: () => navigate("/inventory"), children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "mr-2 h-4 w-4" }),
          "Go to Inventory"
        ] })
      ] })
    ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeView, onValueChange: (value) => setActiveView(value), children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "project", children: "By Project" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "location", children: "By Location" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "project", className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Items by Project" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Distribution of inventory items across projects" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-12", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[300px] h-[300px] relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 100 100", className: "w-full h-full", children: activeStats.map((stat, index2) => {
              const startAngle = activeStats.slice(0, index2).reduce((sum, s4) => sum + Number(s4.value) / items.length * 360, 0);
              const endAngle = startAngle + stat.value / items.length * 360;
              const x1 = 50 + 40 * Math.cos((startAngle - 90) * Math.PI / 180);
              const y1 = 50 + 40 * Math.sin((startAngle - 90) * Math.PI / 180);
              const x22 = 50 + 40 * Math.cos((endAngle - 90) * Math.PI / 180);
              const y22 = 50 + 40 * Math.sin((endAngle - 90) * Math.PI / 180);
              const largeArc = endAngle - startAngle > 180 ? 1 : 0;
              const midAngle = (startAngle + endAngle) / 2;
              const textX = 50 + 30 * Math.cos((midAngle - 90) * Math.PI / 180);
              const textY = 50 + 30 * Math.sin((midAngle - 90) * Math.PI / 180);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: getTooltipContent(stat) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: `M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArc} 1 ${x22} ${y22} Z`,
                    fill: colors[index2 % colors.length],
                    className: "cursor-pointer hover:opacity-90 transition-opacity",
                    onMouseEnter: () => setActiveSegment(stat.name),
                    onMouseLeave: () => setActiveSegment(null),
                    onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                    opacity: "0",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "animate",
                      {
                        attributeName: "opacity",
                        from: "0",
                        to: "1",
                        dur: "0.3s",
                        begin: `${index2 * 0.1}s`,
                        fill: "freeze",
                        calcMode: "spline",
                        keySplines: "0.4 0 0.2 1"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "text",
                  {
                    x: textX,
                    y: textY,
                    textAnchor: "middle",
                    dominantBaseline: "middle",
                    fill: "white",
                    fontSize: "4",
                    className: "select-none pointer-events-none font-medium",
                    opacity: "0",
                    children: [
                      stat.value,
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          from: "0",
                          to: "1",
                          dur: "0.3s",
                          begin: `${index2 * 0.1 + 0.15}s`,
                          fill: "freeze",
                          calcMode: "spline",
                          keySplines: "0.4 0 0.2 1"
                        }
                      )
                    ]
                  }
                )
              ] }, stat.name);
            }) }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-16", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: activeStats.slice(0, Math.ceil(activeStats.length / 2)).map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `flex items-center gap-3 mb-4 cursor-pointer ${activeSegment === stat.name ? "opacity-100" : "opacity-80"}`,
                  onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                  onMouseEnter: () => setActiveSegment(stat.name),
                  onMouseLeave: () => setActiveSegment(null),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "w-4 h-4 rounded-full flex-shrink-0",
                        style: { backgroundColor: colors[index2 % colors.length] }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "font-medium truncate",
                          style: { color: colors[index2 % colors.length] },
                          children: stat.name
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground whitespace-nowrap", children: [
                        stat.value,
                        " items"
                      ] })
                    ] }) })
                  ]
                },
                stat.name
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: activeStats.slice(Math.ceil(activeStats.length / 2)).map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `flex items-center gap-3 mb-4 cursor-pointer ${activeSegment === stat.name ? "opacity-100" : "opacity-80"}`,
                  onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                  onMouseEnter: () => setActiveSegment(stat.name),
                  onMouseLeave: () => setActiveSegment(null),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "w-4 h-4 rounded-full flex-shrink-0",
                        style: { backgroundColor: colors[(index2 + Math.ceil(activeStats.length / 2)) % colors.length] }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "font-medium truncate",
                          style: { color: colors[(index2 + Math.ceil(activeStats.length / 2)) % colors.length] },
                          children: stat.name
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground whitespace-nowrap", children: [
                        stat.value,
                        " items"
                      ] })
                    ] }) })
                  ]
                },
                stat.name
              )) })
            ] }) })
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "location", className: "mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Items by Location" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Distribution of inventory items across locations" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-12", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-[300px] h-[300px] relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute inset-0 flex items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("svg", { viewBox: "0 0 100 100", className: "w-full h-full", children: activeStats.map((stat, index2) => {
              const startAngle = activeStats.slice(0, index2).reduce((sum, s4) => sum + Number(s4.value) / items.length * 360, 0);
              const endAngle = startAngle + stat.value / items.length * 360;
              const x1 = 50 + 40 * Math.cos((startAngle - 90) * Math.PI / 180);
              const y1 = 50 + 40 * Math.sin((startAngle - 90) * Math.PI / 180);
              const x22 = 50 + 40 * Math.cos((endAngle - 90) * Math.PI / 180);
              const y22 = 50 + 40 * Math.sin((endAngle - 90) * Math.PI / 180);
              const largeArc = endAngle - startAngle > 180 ? 1 : 0;
              const midAngle = (startAngle + endAngle) / 2;
              const textX = 50 + 30 * Math.cos((midAngle - 90) * Math.PI / 180);
              const textY = 50 + 30 * Math.sin((midAngle - 90) * Math.PI / 180);
              return /* @__PURE__ */ jsxRuntimeExports.jsxs("g", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("title", { children: getTooltipContent(stat) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "path",
                  {
                    d: `M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArc} 1 ${x22} ${y22} Z`,
                    fill: colors[index2 % colors.length],
                    className: "cursor-pointer hover:opacity-90 transition-opacity",
                    onMouseEnter: () => setActiveSegment(stat.name),
                    onMouseLeave: () => setActiveSegment(null),
                    onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                    opacity: "0",
                    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "animate",
                      {
                        attributeName: "opacity",
                        from: "0",
                        to: "1",
                        dur: "0.3s",
                        begin: `${index2 * 0.1}s`,
                        fill: "freeze",
                        calcMode: "spline",
                        keySplines: "0.4 0 0.2 1"
                      }
                    )
                  }
                ),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(
                  "text",
                  {
                    x: textX,
                    y: textY,
                    textAnchor: "middle",
                    dominantBaseline: "middle",
                    fill: "white",
                    fontSize: "4",
                    className: "select-none pointer-events-none font-medium",
                    opacity: "0",
                    children: [
                      stat.value,
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "animate",
                        {
                          attributeName: "opacity",
                          from: "0",
                          to: "1",
                          dur: "0.3s",
                          begin: `${index2 * 0.1 + 0.15}s`,
                          fill: "freeze",
                          calcMode: "spline",
                          keySplines: "0.4 0 0.2 1"
                        }
                      )
                    ]
                  }
                )
              ] }, stat.name);
            }) }) }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-16", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: activeStats.slice(0, Math.ceil(activeStats.length / 2)).map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `flex items-center gap-3 mb-4 cursor-pointer ${activeSegment === stat.name ? "opacity-100" : "opacity-80"}`,
                  onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                  onMouseEnter: () => setActiveSegment(stat.name),
                  onMouseLeave: () => setActiveSegment(null),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "w-4 h-4 rounded-full flex-shrink-0",
                        style: { backgroundColor: colors[index2 % colors.length] }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "font-medium truncate",
                          style: { color: colors[index2 % colors.length] },
                          children: stat.name
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground whitespace-nowrap", children: [
                        stat.value,
                        " items"
                      ] })
                    ] }) })
                  ]
                },
                stat.name
              )) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1", children: activeStats.slice(Math.ceil(activeStats.length / 2)).map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
                "div",
                {
                  className: `flex items-center gap-3 mb-4 cursor-pointer ${activeSegment === stat.name ? "opacity-100" : "opacity-80"}`,
                  onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
                  onMouseEnter: () => setActiveSegment(stat.name),
                  onMouseLeave: () => setActiveSegment(null),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "div",
                      {
                        className: "w-4 h-4 rounded-full flex-shrink-0",
                        style: { backgroundColor: colors[(index2 + Math.ceil(activeStats.length / 2)) % colors.length] }
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex-1 min-w-0", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsx(
                        "span",
                        {
                          className: "font-medium truncate",
                          style: { color: colors[(index2 + Math.ceil(activeStats.length / 2)) % colors.length] },
                          children: stat.name
                        }
                      ),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-sm text-muted-foreground whitespace-nowrap", children: [
                        stat.value,
                        " items"
                      ] })
                    ] }) })
                  ]
                },
                stat.name
              )) })
            ] }) })
          ] }) })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Quick Filters" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Jump to filtered inventory views" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { variant: "outline", className: "flex items-center gap-2", onClick: () => navigate("/inventory"), children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Filter, { className: "h-4 w-4" }),
            "All Items"
          ] }),
          activeStats.slice(0, 5).map((stat, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "outline",
              className: "flex items-center gap-2 relative pl-6",
              onClick: () => navigate(`/inventory?${activeView}=${encodeURIComponent(stat.name)}`),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "div",
                  {
                    className: "absolute left-0 top-0 bottom-0 w-2 rounded-l-md",
                    style: { backgroundColor: colors[index2 % colors.length] }
                  }
                ),
                stat.name
              ]
            },
            stat.name
          ))
        ] }) })
      ] })
    ] })
  ] });
}
const Alert = reactExports.forwardRef(
  ({ className, variant = "default", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
    "div",
    {
      ref,
      role: "alert",
      className: cn(
        "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
        variant === "destructive" && "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
        className
      ),
      ...props
    }
  )
);
Alert.displayName = "Alert";
const AlertTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "h5",
  {
    ref,
    className: cn("mb-1 font-medium leading-none tracking-tight", className),
    ...props
  }
));
AlertTitle.displayName = "AlertTitle";
const AlertDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    ref,
    className: cn("text-sm [&_p]:leading-relaxed", className),
    ...props
  }
));
AlertDescription.displayName = "AlertDescription";
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return reactExports.useMemo(
    () => (node) => {
      refs.forEach((ref) => ref(node));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    refs
  );
}
const canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || // In Electron context the Window object serializes to [object global]
  elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node) {
  const {
    Document
  } = getWindow(node);
  return node instanceof Document;
}
function isHTMLElement$1(node) {
  if (isWindow(node)) {
    return false;
  }
  return node instanceof getWindow(node).HTMLElement;
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement$1(target) || isSVGElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
const useIsomorphicLayoutEffect = canUseDOM ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEvent(handler) {
  const handlerRef = reactExports.useRef(handler);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return reactExports.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = reactExports.useRef(null);
  const set2 = reactExports.useCallback((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = reactExports.useCallback(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set2, clear];
}
function useLatestValue(value, dependencies) {
  if (dependencies === void 0) {
    dependencies = [value];
  }
  const valueRef = reactExports.useRef(value);
  useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = reactExports.useRef();
  return reactExports.useMemo(
    () => {
      const newValue = callback(valueRef.current);
      valueRef.current = newValue;
      return newValue;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...dependencies]
  );
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node = reactExports.useRef(null);
  const setNodeRef = reactExports.useCallback(
    (element) => {
      if (element !== node.current) {
        onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
      }
      node.current = element;
    },
    //eslint-disable-next-line
    []
  );
  return [node, setNodeRef];
}
function usePrevious(value) {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
let ids = {};
function useUniqueId(prefix, value) {
  return reactExports.useMemo(() => {
    if (value) {
      return value;
    }
    const id2 = ids[prefix] == null ? 0 : ids[prefix] + 1;
    ids[prefix] = id2;
    return prefix + "-" + id2;
  }, [prefix, value]);
}
function createAdjustmentFn(modifier) {
  return function(object) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key, valueAdjustment] of entries) {
        const value = accumulator[key];
        if (value != null) {
          accumulator[key] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object
    });
  };
}
const add = /* @__PURE__ */ createAdjustmentFn(1);
const subtract = /* @__PURE__ */ createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.touches[0];
      return {
        x: x3,
        y: y4
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x3,
        clientY: y4
      } = event.changedTouches[0];
      return {
        x: x3,
        y: y4
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
const CSS$1 = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x: x3,
        y: y4
      } = transform;
      return "translate3d(" + (x3 ? Math.round(x3) : 0) + "px, " + (y4 ? Math.round(y4) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX,
        scaleY
      } = transform;
      return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS$1.Translate.toString(transform), CSS$1.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString(_ref) {
      let {
        property,
        duration,
        easing
      } = _ref;
      return property + " " + duration + "ms " + easing;
    }
  }
});
const SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}
const hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id: id2,
    value
  } = _ref;
  return React$1.createElement("div", {
    id: id2,
    style: hiddenStyles
  }, value);
}
function LiveRegion(_ref) {
  let {
    id: id2,
    announcement,
    ariaLiveType = "assertive"
  } = _ref;
  const visuallyHidden = {
    position: "fixed",
    top: 0,
    left: 0,
    width: 1,
    height: 1,
    margin: -1,
    border: 0,
    padding: 0,
    overflow: "hidden",
    clip: "rect(0 0 0 0)",
    clipPath: "inset(100%)",
    whiteSpace: "nowrap"
  };
  return React$1.createElement("div", {
    id: id2,
    style: visuallyHidden,
    role: "status",
    "aria-live": ariaLiveType,
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = reactExports.useState("");
  const announce = reactExports.useCallback((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}
const DndMonitorContext = /* @__PURE__ */ reactExports.createContext(null);
function useDndMonitor(listener) {
  const registerListener = reactExports.useContext(DndMonitorContext);
  reactExports.useEffect(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners2] = reactExports.useState(() => /* @__PURE__ */ new Set());
  const registerListener = reactExports.useCallback((listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  }, [listeners2]);
  const dispatch2 = reactExports.useCallback((_ref) => {
    let {
      type,
      event
    } = _ref;
    listeners2.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
    });
  }, [listeners2]);
  return [dispatch2, registerListener];
}
const defaultScreenReaderInstructions = {
  draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
const defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },
  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;
    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }
    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },
  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;
    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }
    return "Draggable item " + active.id + " was dropped.";
  },
  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }
};
function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId("DndLiveRegion");
  const [mounted, setMounted] = reactExports.useState(false);
  reactExports.useEffect(() => {
    setMounted(true);
  }, []);
  useDndMonitor(reactExports.useMemo(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = React$1.createElement(React$1.Fragment, null, React$1.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), React$1.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? reactDomExports.createPortal(markup, container) : markup;
}
var Action$1;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action$1 || (Action$1 = {}));
function noop() {
}
function useSensor(sensor, options) {
  return reactExports.useMemo(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [sensor, options]
  );
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return reactExports.useMemo(
    () => [...sensors].filter((sensor) => sensor != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...sensors]
  );
}
const defaultCoordinates = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a4
    }
  } = _ref;
  let {
    data: {
      value: b2
    }
  } = _ref2;
  return a4 - b2;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a4
    }
  } = _ref3;
  let {
    data: {
      value: b2
    }
  } = _ref4;
  return b2 - a4;
}
function cornersOfRectangle(_ref5) {
  let {
    left,
    top,
    height,
    width
  } = _ref5;
  return [{
    x: left,
    y: top
  }, {
    x: left + width,
    y: top
  }, {
    x: left,
    y: top + height
  }, {
    x: left + width,
    y: top + height
  }];
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return firstCollision[property];
}
function centerOfRectangle(rect, left, top) {
  if (left === void 0) {
    left = rect.left;
  }
  if (top === void 0) {
    top = rect.top;
  }
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
const closestCenter = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id: id2
    } = droppableContainer;
    const rect = droppableRects.get(id2);
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id: id2,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
const closestCorners = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const corners = cornersOfRectangle(collisionRect);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id: id2
    } = droppableContainer;
    const rect = droppableRects.get(id2);
    if (rect) {
      const rectCorners = cornersOfRectangle(rect);
      const distances = corners.reduce((accumulator, corner, index2) => {
        return accumulator + distanceBetween(rectCorners[index2], corner);
      }, 0);
      const effectiveDistance = Number((distances / 4).toFixed(4));
      collisions.push({
        id: id2,
        data: {
          droppableContainer,
          value: effectiveDistance
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
const rectIntersection = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id: id2
    } = droppableContainer;
    const rect = droppableRects.get(id2);
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > 0) {
        collisions.push({
          id: id2,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }
  return collisions.sort(sortCollisionsDesc);
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
const getAdjustedRect = /* @__PURE__ */ createRectAdjustmentFn(1);
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin2) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x3 = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin2);
  const y4 = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin2.slice(transformOrigin2.indexOf(" ") + 1));
  const w3 = scaleX ? rect.width / scaleX : rect.width;
  const h4 = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w3,
    height: h4,
    top: y4,
    right: x3 + w3,
    bottom: y4 + h4,
    left: x3
  };
}
const defaultOptions = {
  ignoreTransform: false
};
function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin: transformOrigin2
    } = getWindow(element).getComputedStyle(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin2);
    }
  }
  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(node).getComputedStyle(node);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties2 = ["overflow", "overflowX", "overflowY"];
  return properties2.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement$1(node) || isSVGElement(node)) {
      return scrollParents;
    }
    if (scrollParents.includes(node)) {
      return scrollParents;
    }
    const computedStyle = getWindow(element).getComputedStyle(node);
    if (node !== element) {
      if (isScrollable(node, computedStyle)) {
        scrollParents.push(node);
      }
    }
    if (isFixed(node, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement$1(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
const defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref;
  if (acceleration === void 0) {
    acceleration = 10;
  }
  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollXCoordinate(node);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollYCoordinate(node);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
const properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
class Rect {
  constructor(rect, element) {
    this.rect = void 0;
    this.width = void 0;
    this.height = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.right = void 0;
    this.left = void 0;
    const scrollableAncestors = getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = {
      ...rect
    };
    this.width = rect.width;
    this.height = rect.height;
    for (const [axis, keys2, getScrollOffset] of properties) {
      for (const key of keys2) {
        Object.defineProperty(this, key, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }
    Object.defineProperty(this, "rect", {
      enumerable: false
    });
  }
}
class Listeners {
  constructor(target) {
    this.target = void 0;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
    this.target = target;
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
}
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName2) {
  EventName2["Click"] = "click";
  EventName2["DragStart"] = "dragstart";
  EventName2["Keydown"] = "keydown";
  EventName2["ContextMenu"] = "contextmenu";
  EventName2["Resize"] = "resize";
  EventName2["SelectionChange"] = "selectionchange";
  EventName2["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode2) {
  KeyboardCode2["Space"] = "Space";
  KeyboardCode2["Down"] = "ArrowDown";
  KeyboardCode2["Right"] = "ArrowRight";
  KeyboardCode2["Left"] = "ArrowLeft";
  KeyboardCode2["Up"] = "ArrowUp";
  KeyboardCode2["Esc"] = "Escape";
  KeyboardCode2["Enter"] = "Enter";
  KeyboardCode2["Tab"] = "Tab";
})(KeyboardCode || (KeyboardCode = {}));
const defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter, KeyboardCode.Tab]
};
const defaultKeyboardCoordinateGetter = (event, _ref) => {
  let {
    currentCoordinates
  } = _ref;
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
class KeyboardSensor {
  constructor(props) {
    this.props = void 0;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = void 0;
    this.listeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node = activeNode.node.current;
    if (node) {
      scrollIntoViewIfNeeded(node);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const {
        collisionRect
      } = context.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }
            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }
            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }
            break;
          }
        }
        this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
}
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;
      if (activator && event.target !== activator) {
        return false;
      }
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
class AbstractPointerSensor {
  constructor(props, events2, listenerTarget) {
    var _getEventCoordinates;
    if (listenerTarget === void 0) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }
    this.props = void 0;
    this.events = void 0;
    this.autoScrollEnabled = true;
    this.document = void 0;
    this.activated = false;
    this.initialCoordinates = void 0;
    this.timeoutId = null;
    this.listeners = void 0;
    this.documentListeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    this.events = events2;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow(target));
    this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint,
          bypassActivationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    if (events2.cancel) {
      this.listeners.add(events2.cancel.name, this.handleCancel);
    }
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (bypassActivationConstraint != null && bypassActivationConstraint({
        event: this.props.event,
        activeNode: this.props.activeNode,
        options: this.props.options
      })) {
        return this.handleStart();
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        this.handlePending(activationConstraint);
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        this.handlePending(activationConstraint);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handlePending(constraint, offset2) {
    const {
      active,
      onPending
    } = this.props;
    onPending(active, constraint, this.initialCoordinates, offset2);
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    var _getEventCoordinates2;
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
      }
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
      }
      this.handlePending(activationConstraint, delta);
      return;
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onAbort,
      onEnd
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onEnd();
  }
  handleCancel() {
    const {
      onAbort,
      onCancel
    } = this.props;
    this.detach();
    if (!this.activated) {
      onAbort(this.props.active);
    }
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
}
const events = {
  cancel: {
    name: "pointercancel"
  },
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class PointerSensor extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }
}
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
class MouseSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
}
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
const events$2 = {
  cancel: {
    name: "touchcancel"
  },
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class TouchSensor extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
}
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = reactExports.useRef({
    x: 0,
    y: 0
  });
  const scrollDirection = reactExports.useRef({
    x: 0,
    y: 0
  });
  const rect = reactExports.useMemo(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = reactExports.useRef(null);
  const autoScroll = reactExports.useCallback(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = reactExports.useMemo(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  reactExports.useEffect(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index2 = scrollableAncestors.indexOf(scrollContainer);
        const scrollContainerRect = scrollableAncestorRects[index2];
        if (!scrollContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
        for (const axis of ["x", "y"]) {
          if (!scrollIntent[axis][direction[axis]]) {
            speed[axis] = 0;
            direction[axis] = 0;
          }
        }
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll, interval);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      acceleration,
      autoScroll,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(rect),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(scrollIntent),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(threshold)
    ]
  );
}
const defaultScrollIntent = {
  x: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  },
  y: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  }
};
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id2) {
  const draggableNode = id2 != null ? draggableNodes.get(id2) : void 0;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id2 == null) {
      return null;
    }
    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id2]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return reactExports.useMemo(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
const defaultValue = /* @__PURE__ */ new Map();
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [queue, setQueue] = reactExports.useState(null);
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = reactExports.useRef(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = reactExports.useCallback(function(ids2) {
    if (ids2 === void 0) {
      ids2 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setQueue((value) => {
      if (value === null) {
        return ids2;
      }
      return value.concat(ids2.filter((id2) => !value.includes(id2)));
    });
  }, [disabledRef]);
  const timeoutId = reactExports.useRef(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
      const map = /* @__PURE__ */ new Map();
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
          map.set(container.id, container.rect.current);
          continue;
        }
        const node = container.node.current;
        const rect = node ? new Rect(measure(node), node) : null;
        container.rect.current = rect;
        if (rect) {
          map.set(container.id, rect);
        }
      }
      return map;
    }
    return previousValue;
  }, [containers, queue, dragging, disabled, measure]);
  reactExports.useEffect(() => {
    containersRef.current = containers;
  }, [containers]);
  reactExports.useEffect(
    () => {
      if (disabled) {
        return;
      }
      measureDroppableContainers();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [dragging, disabled]
  );
  reactExports.useEffect(
    () => {
      if (queue && queue.length > 0) {
        setQueue(null);
      }
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(queue)]
  );
  reactExports.useEffect(
    () => {
      if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
        return;
      }
      timeoutId.current = setTimeout(() => {
        measureDroppableContainers();
        timeoutId.current = null;
      }, frequency);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [frequency, disabled, measureDroppableContainers, ...dependencies]
  );
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue != null
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node, measure) {
  return useInitialValue(node, measure);
}
function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = useEvent(callback);
  const mutationObserver = reactExports.useMemo(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return void 0;
    }
    const {
      MutationObserver: MutationObserver2
    } = window;
    return new MutationObserver2(handleMutations);
  }, [handleMutations, disabled]);
  reactExports.useEffect(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver$1(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = useEvent(callback);
  const resizeObserver = reactExports.useMemo(
    () => {
      if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
        return void 0;
      }
      const {
        ResizeObserver: ResizeObserver2
      } = window;
      return new ResizeObserver2(handleResize);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [disabled]
  );
  reactExports.useEffect(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }
  const [rect, setRect] = reactExports.useState(null);
  function measureRect() {
    setRect((currentRect) => {
      if (!element) {
        return null;
      }
      if (element.isConnected === false) {
        var _ref;
        return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
      }
      const newRect = measure(element);
      if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
        return currentRect;
      }
      return newRect;
    });
  }
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver$1({
    callback: measureRect
  });
  useIsomorphicLayoutEffect(() => {
    measureRect();
    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
const defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = reactExports.useRef(node);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node);
  }, [node]);
  reactExports.useEffect(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = reactExports.useState(null);
  const prevElements = reactExports.useRef(elements);
  const handleScroll2 = reactExports.useCallback((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  reactExports.useEffect(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll2, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll2);
      });
    }
  }, [handleScroll2, elements]);
  return reactExports.useMemo(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  const initialScrollOffsets = reactExports.useRef(null);
  reactExports.useEffect(
    () => {
      initialScrollOffsets.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    dependencies
  );
  reactExports.useEffect(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  reactExports.useEffect(
    () => {
      if (!canUseDOM) {
        return;
      }
      const teardownFns = sensors.map((_ref) => {
        let {
          sensor
        } = _ref;
        return sensor.setup == null ? void 0 : sensor.setup();
      });
      return () => {
        for (const teardown of teardownFns) {
          teardown == null ? void 0 : teardown();
        }
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    sensors.map((_ref2) => {
      let {
        sensor
      } = _ref2;
      return sensor;
    })
  );
}
function useSyntheticListeners(listeners2, id2) {
  return reactExports.useMemo(() => {
    return listeners2.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;
      acc[eventName] = (event) => {
        handler(event, id2);
      };
      return acc;
    }, {});
  }, [listeners2, id2]);
}
function useWindowRect(element) {
  return reactExports.useMemo(() => element ? getWindowClientRect(element) : null, [element]);
}
const defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
  const [rects, setRects] = reactExports.useState(defaultValue$2);
  function measureRects() {
    setRects(() => {
      if (!elements.length) {
        return defaultValue$2;
      }
      return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
    });
  }
  const resizeObserver = useResizeObserver$1({
    callback: measureRects
  });
  useIsomorphicLayoutEffect(() => {
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    measureRects();
    elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
  }, [elements]);
  return rects;
}
function getMeasurableNode(node) {
  if (!node) {
    return null;
  }
  if (node.children.length > 1) {
    return node;
  }
  const firstChild = node.children[0];
  return isHTMLElement$1(firstChild) ? firstChild : node;
}
function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = reactExports.useState(null);
  const handleResize = reactExports.useCallback((entries) => {
    for (const {
      target
    } of entries) {
      if (isHTMLElement$1(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver$1({
    callback: handleResize
  });
  const handleNodeChange = reactExports.useCallback((element) => {
    const node = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    if (node) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node);
    }
    setRect(node ? measure(node) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef2] = useNodeRef(handleNodeChange);
  return reactExports.useMemo(() => ({
    nodeRef,
    rect,
    setRef: setRef2
  }), [rect, nodeRef, setRef2]);
}
const defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
const defaultData = {
  current: {}
};
const defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};
class DroppableContainersMap extends Map {
  get(id2) {
    var _super$get;
    return id2 != null ? (_super$get = super.get(id2)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((_ref) => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }
  getNodeFor(id2) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id2)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
}
const defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop,
  windowRect: null,
  measuringScheduled: false
};
const defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: noop,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: noop
};
const InternalContext = /* @__PURE__ */ reactExports.createContext(defaultInternalContext);
const PublicContext = /* @__PURE__ */ reactExports.createContext(defaultPublicContext);
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer$1(state, action) {
  switch (action.type) {
    case Action$1.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action$1.DragMove:
      if (state.draggable.active == null) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action$1.DragEnd:
    case Action$1.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action$1.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id: id2
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action$1.SetDroppableDisabled: {
      const {
        id: id2,
        key,
        disabled
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id2, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action$1.UnregisterDroppable: {
      const {
        id: id2,
        key
      } = action;
      const element = state.droppable.containers.get(id2);
      if (!element || key !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id2);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = reactExports.useContext(InternalContext);
  const previousActivatorEvent = usePrevious(activatorEvent);
  const previousActiveId = usePrevious(active == null ? void 0 : active.id);
  reactExports.useEffect(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node
      } = draggableNode;
      if (!activatorNode.current && !node.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config) {
  return reactExports.useMemo(
    () => ({
      draggable: {
        ...defaultMeasuringConfiguration.draggable,
        ...config == null ? void 0 : config.draggable
      },
      droppable: {
        ...defaultMeasuringConfiguration.droppable,
        ...config == null ? void 0 : config.droppable
      },
      dragOverlay: {
        ...defaultMeasuringConfiguration.dragOverlay,
        ...config == null ? void 0 : config.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
  );
}
function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = reactExports.useRef(false);
  const {
    x: x3,
    y: y4
  } = typeof config === "boolean" ? {
    x: config,
    y: config
  } : config;
  useIsomorphicLayoutEffect(() => {
    const disabled = !x3 && !y4;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node = activeNode == null ? void 0 : activeNode.node.current;
    if (!node || node.isConnected === false) {
      return;
    }
    const rect = measure(node);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x3) {
      rectDelta.x = 0;
    }
    if (!y4) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x3, y4, initialRect, measure]);
}
const ActiveDraggableContext = /* @__PURE__ */ reactExports.createContext({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;
(function(Status2) {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
const DndContext = /* @__PURE__ */ reactExports.memo(function DndContext2(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
  let {
    id: id2,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = reactExports.useReducer(reducer$1, void 0, getInitialState);
  const [state, dispatch2] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = reactExports.useState(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId != null ? draggableNodes.get(activeId) : null;
  const activeRects = reactExports.useRef({
    initial: null,
    translated: null
  });
  const active = reactExports.useMemo(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      // It's possible for the active node to unmount while dragging
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = reactExports.useRef(null);
  const [activeSensor, setActiveSensor] = reactExports.useState(null);
  const [activatorEvent, setActivatorEvent] = reactExports.useState(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId("DndDescribedBy", id2);
  const enabledDroppableContainers = reactExports.useMemo(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate.x, translate.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = reactExports.useMemo(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId != null ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = reactExports.useRef({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  });
  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
  const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors);
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors);
  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = getFirstCollision(collisions, "id");
  const [over, setOver] = reactExports.useState(null);
  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const activeSensorRef = reactExports.useRef(null);
  const instantiateSensor = reactExports.useCallback(
    (event, _ref2) => {
      let {
        sensor: Sensor,
        options
      } = _ref2;
      if (activeRef.current == null) {
        return;
      }
      const activeNode2 = draggableNodes.get(activeRef.current);
      if (!activeNode2) {
        return;
      }
      const activatorEvent2 = event.nativeEvent;
      const sensorInstance = new Sensor({
        active: activeRef.current,
        activeNode: activeNode2,
        event: activatorEvent2,
        options,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: sensorContext,
        onAbort(id3) {
          const draggableNode = draggableNodes.get(id3);
          if (!draggableNode) {
            return;
          }
          const {
            onDragAbort
          } = latestProps.current;
          const event2 = {
            id: id3
          };
          onDragAbort == null ? void 0 : onDragAbort(event2);
          dispatchMonitorEvent({
            type: "onDragAbort",
            event: event2
          });
        },
        onPending(id3, constraint, initialCoordinates, offset2) {
          const draggableNode = draggableNodes.get(id3);
          if (!draggableNode) {
            return;
          }
          const {
            onDragPending
          } = latestProps.current;
          const event2 = {
            id: id3,
            constraint,
            initialCoordinates,
            offset: offset2
          };
          onDragPending == null ? void 0 : onDragPending(event2);
          dispatchMonitorEvent({
            type: "onDragPending",
            event: event2
          });
        },
        onStart(initialCoordinates) {
          const id3 = activeRef.current;
          if (id3 == null) {
            return;
          }
          const draggableNode = draggableNodes.get(id3);
          if (!draggableNode) {
            return;
          }
          const {
            onDragStart
          } = latestProps.current;
          const event2 = {
            activatorEvent: activatorEvent2,
            active: {
              id: id3,
              data: draggableNode.data,
              rect: activeRects
            }
          };
          reactDomExports.unstable_batchedUpdates(() => {
            onDragStart == null ? void 0 : onDragStart(event2);
            setStatus(Status.Initializing);
            dispatch2({
              type: Action$1.DragStart,
              initialCoordinates,
              active: id3
            });
            dispatchMonitorEvent({
              type: "onDragStart",
              event: event2
            });
            setActiveSensor(activeSensorRef.current);
            setActivatorEvent(activatorEvent2);
          });
        },
        onMove(coordinates) {
          dispatch2({
            type: Action$1.DragMove,
            coordinates
          });
        },
        onEnd: createHandler(Action$1.DragEnd),
        onCancel: createHandler(Action$1.DragCancel)
      });
      activeSensorRef.current = sensorInstance;
      function createHandler(type) {
        return async function handler() {
          const {
            active: active2,
            collisions: collisions2,
            over: over2,
            scrollAdjustedTranslate: scrollAdjustedTranslate2
          } = sensorContext.current;
          let event2 = null;
          if (active2 && scrollAdjustedTranslate2) {
            const {
              cancelDrop
            } = latestProps.current;
            event2 = {
              activatorEvent: activatorEvent2,
              active: active2,
              collisions: collisions2,
              delta: scrollAdjustedTranslate2,
              over: over2
            };
            if (type === Action$1.DragEnd && typeof cancelDrop === "function") {
              const shouldCancel = await Promise.resolve(cancelDrop(event2));
              if (shouldCancel) {
                type = Action$1.DragCancel;
              }
            }
          }
          activeRef.current = null;
          reactDomExports.unstable_batchedUpdates(() => {
            dispatch2({
              type
            });
            setStatus(Status.Uninitialized);
            setOver(null);
            setActiveSensor(null);
            setActivatorEvent(null);
            activeSensorRef.current = null;
            const eventName = type === Action$1.DragEnd ? "onDragEnd" : "onDragCancel";
            if (event2) {
              const handler2 = latestProps.current[eventName];
              handler2 == null ? void 0 : handler2(event2);
              dispatchMonitorEvent({
                type: eventName,
                event: event2
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes]
  );
  const bindActivatorToSensorInstantiator = reactExports.useCallback((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active2);
      if (
        // Another sensor is already instantiating
        activeRef.current !== null || // No active draggable
        !activeDraggableNode || // Event has already been captured
        nativeEvent.dndKit || nativeEvent.defaultPrevented
      ) {
        return;
      }
      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event, sensor.options, activationContext);
      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  reactExports.useEffect(
    () => {
      const {
        onDragMove
      } = latestProps.current;
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        over: over2
      } = sensorContext.current;
      if (!active2 || !activatorEvent2) {
        return;
      }
      const event = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate.x,
          y: scrollAdjustedTranslate.y
        },
        over: over2
      };
      reactDomExports.unstable_batchedUpdates(() => {
        onDragMove == null ? void 0 : onDragMove(event);
        dispatchMonitorEvent({
          type: "onDragMove",
          event
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
  );
  reactExports.useEffect(
    () => {
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        droppableContainers: droppableContainers2,
        scrollAdjustedTranslate: scrollAdjustedTranslate2
      } = sensorContext.current;
      if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
        return;
      }
      const {
        onDragOver
      } = latestProps.current;
      const overContainer = droppableContainers2.get(overId);
      const over2 = overContainer && overContainer.rect.current ? {
        id: overContainer.id,
        rect: overContainer.rect.current,
        data: overContainer.data,
        disabled: overContainer.disabled
      } : null;
      const event = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate2.x,
          y: scrollAdjustedTranslate2.y
        },
        over: over2
      };
      reactDomExports.unstable_batchedUpdates(() => {
        setOver(over2);
        onDragOver == null ? void 0 : onDragOver(event);
        dispatchMonitorEvent({
          type: "onDragOver",
          event
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [overId]
  );
  useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({
    ...autoScrollOptions,
    delta: translate,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = reactExports.useMemo(() => {
    const context = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = reactExports.useMemo(() => {
    const context = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch: dispatch2,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch2, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return React$1.createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, React$1.createElement(InternalContext.Provider, {
    value: internalContext
  }, React$1.createElement(PublicContext.Provider, {
    value: publicContext
  }, React$1.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), React$1.createElement(RestoreFocus, {
    disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
  })), React$1.createElement(Accessibility, {
    ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
const NullContext = /* @__PURE__ */ reactExports.createContext(null);
const defaultRole = "button";
const ID_PREFIX$1 = "Draggable";
function useDraggable(_ref) {
  let {
    id: id2,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = reactExports.useContext(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id2;
  const transform = reactExports.useContext(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners2 = useSyntheticListeners(activators, id2);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect(
    () => {
      draggableNodes.set(id2, {
        id: id2,
        key,
        node,
        activatorNode,
        data: dataRef
      });
      return () => {
        const node2 = draggableNodes.get(id2);
        if (node2 && node2.key === key) {
          draggableNodes.delete(id2);
        }
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [draggableNodes, id2]
  );
  const memoizedAttributes = reactExports.useMemo(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? void 0 : listeners2,
    node,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return reactExports.useContext(PublicContext);
}
const ID_PREFIX$1$1 = "Droppable";
const defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id: id2,
    resizeObserverConfig
  } = _ref;
  const key = useUniqueId(ID_PREFIX$1$1);
  const {
    active,
    dispatch: dispatch2,
    over,
    measureDroppableContainers
  } = reactExports.useContext(InternalContext);
  const previous = reactExports.useRef({
    disabled
  });
  const resizeObserverConnected = reactExports.useRef(false);
  const rect = reactExports.useRef(null);
  const callbackId = reactExports.useRef(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id2);
  const handleResize = reactExports.useCallback(
    () => {
      if (!resizeObserverConnected.current) {
        resizeObserverConnected.current = true;
        return;
      }
      if (callbackId.current != null) {
        clearTimeout(callbackId.current);
      }
      callbackId.current = setTimeout(() => {
        measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
        callbackId.current = null;
      }, resizeObserverTimeout);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [resizeObserverTimeout]
  );
  const resizeObserver = useResizeObserver$1({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = reactExports.useCallback((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  reactExports.useEffect(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  reactExports.useEffect(
    () => {
      dispatch2({
        type: Action$1.RegisterDroppable,
        element: {
          id: id2,
          key,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch2({
        type: Action$1.UnregisterDroppable,
        key,
        id: id2
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [id2]
  );
  reactExports.useEffect(() => {
    if (disabled !== previous.current.disabled) {
      dispatch2({
        type: Action$1.SetDroppableDisabled,
        id: id2,
        key,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id2, key, disabled, dispatch2]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id2,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function arrayMove(array, from, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id2, index2) => {
    const rect = rects.get(id2);
    if (rect) {
      accumulator[index2] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index2) {
  return index2 !== null && index2 >= 0;
}
function itemsEqual(a4, b2) {
  if (a4 === b2) {
    return true;
  }
  if (a4.length !== b2.length) {
    return false;
  }
  for (let i3 = 0; i3 < a4.length; i3++) {
    if (a4[i3] !== b2[i3]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
const rectSortingStrategy = (_ref) => {
  let {
    rects,
    activeIndex,
    overIndex,
    index: index2
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index2];
  const newRect = newRects[index2];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
const defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
const verticalListSortingStrategy = (_ref) => {
  var _rects$activeIndex;
  let {
    activeIndex,
    activeNodeRect: fallbackActiveRect,
    index: index2,
    rects,
    overIndex
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index2 === activeIndex) {
    const overIndexRect = rects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
      ...defaultScale$1
    };
  }
  const itemGap = getItemGap$1(rects, index2, activeIndex);
  if (index2 > activeIndex && index2 <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }
  if (index2 < activeIndex && index2 >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};
function getItemGap$1(clientRects, index2, activeIndex) {
  const currentRect = clientRects[index2];
  const previousRect = clientRects[index2 - 1];
  const nextRect = clientRects[index2 + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index2) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
const ID_PREFIX = "Sortable";
const Context = /* @__PURE__ */ React$1.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id: id2,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId(ID_PREFIX, id2);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = reactExports.useMemo(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = reactExports.useRef(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  reactExports.useEffect(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = reactExports.useMemo(
    () => ({
      activeIndex,
      containerId,
      disabled,
      disableTransforms,
      items,
      overIndex,
      useDragOverlay,
      sortedRects: getSortedRects(items, droppableRects),
      strategy
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
  );
  return React$1.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
const defaultNewIndexGetter = (_ref) => {
  let {
    id: id2,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id2);
};
const defaultAnimateLayoutChanges = (_ref2) => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index: index2,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition
  } = _ref2;
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index2 === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index2 && containerId === previousContainerId;
};
const defaultTransition = {
  duration: 200,
  easing: "ease"
};
const transitionProperty = "transform";
const disabledTransition = /* @__PURE__ */ CSS$1.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
const defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform(_ref) {
  let {
    disabled,
    index: index2,
    node,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = reactExports.useState(null);
  const previousIndex = reactExports.useRef(index2);
  useIsomorphicLayoutEffect(() => {
    if (!disabled && index2 !== previousIndex.current && node.current) {
      const initial = rect.current;
      if (initial) {
        const current = getClientRect(node.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current.left,
          y: initial.top - current.top,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index2 !== previousIndex.current) {
      previousIndex.current = index2;
    }
  }, [disabled, index2, node, rect]);
  reactExports.useEffect(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id: id2,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = reactExports.useContext(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index2 = items.indexOf(id2);
  const data = reactExports.useMemo(() => ({
    sortable: {
      containerId,
      index: index2,
      items
    },
    ...customData
  }), [containerId, customData, index2, items]);
  const itemsAfterCurrentSortable = reactExports.useMemo(() => items.slice(items.indexOf(id2)), [items, id2]);
  const {
    rect,
    node,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id: id2,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners: listeners2,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id: id2,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index: index2
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id: id2,
    items,
    activeIndex,
    overIndex
  }) : index2;
  const activeId = active == null ? void 0 : active.id;
  const previous = reactExports.useRef({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id: id2,
    index: index2,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index: index2,
    node,
    rect
  });
  reactExports.useEffect(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }
    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }
    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  reactExports.useEffect(() => {
    if (activeId === previous.current.activeId) {
      return;
    }
    if (activeId && !previous.current.activeId) {
      previous.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index: index2,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners: listeners2,
    node,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      derivedTransform || // Or to prevent items jumping to back to their "new" position when items change
      itemsHaveChanged && previous.current.newIndex === index2
    ) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS$1.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      // Backwards compatibility
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
const directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];
const sortableKeyboardCoordinates = (event, _ref) => {
  let {
    context: {
      active,
      collisionRect,
      droppableRects,
      droppableContainers,
      over,
      scrollableAncestors
    }
  } = _ref;
  if (directions.includes(event.code)) {
    event.preventDefault();
    if (!active || !collisionRect) {
      return;
    }
    const filteredContainers = [];
    droppableContainers.getEnabled().forEach((entry) => {
      if (!entry || entry != null && entry.disabled) {
        return;
      }
      const rect = droppableRects.get(entry.id);
      if (!rect) {
        return;
      }
      switch (event.code) {
        case KeyboardCode.Down:
          if (collisionRect.top < rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Up:
          if (collisionRect.top > rect.top) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Left:
          if (collisionRect.left > rect.left) {
            filteredContainers.push(entry);
          }
          break;
        case KeyboardCode.Right:
          if (collisionRect.left < rect.left) {
            filteredContainers.push(entry);
          }
          break;
      }
    });
    const collisions = closestCorners({
      collisionRect,
      droppableRects,
      droppableContainers: filteredContainers
    });
    let closestId = getFirstCollision(collisions, "id");
    if (closestId === (over == null ? void 0 : over.id) && collisions.length > 1) {
      closestId = collisions[1].id;
    }
    if (closestId != null) {
      const activeDroppable = droppableContainers.get(active.id);
      const newDroppable = droppableContainers.get(closestId);
      const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
      const newNode = newDroppable == null ? void 0 : newDroppable.node.current;
      if (newNode && newRect && activeDroppable && newDroppable) {
        const newScrollAncestors = getScrollableAncestors(newNode);
        const hasDifferentScrollAncestors = newScrollAncestors.some((element, index2) => scrollableAncestors[index2] !== element);
        const hasSameContainer = isSameContainer(activeDroppable, newDroppable);
        const isAfterActive = isAfter(activeDroppable, newDroppable);
        const offset2 = hasDifferentScrollAncestors || !hasSameContainer ? {
          x: 0,
          y: 0
        } : {
          x: isAfterActive ? collisionRect.width - newRect.width : 0,
          y: isAfterActive ? collisionRect.height - newRect.height : 0
        };
        const rectCoordinates = {
          x: newRect.left,
          y: newRect.top
        };
        const newCoordinates = offset2.x && offset2.y ? rectCoordinates : subtract(rectCoordinates, offset2);
        return newCoordinates;
      }
    }
  }
  return void 0;
};
function isSameContainer(a4, b2) {
  if (!hasSortableData(a4) || !hasSortableData(b2)) {
    return false;
  }
  return a4.data.current.sortable.containerId === b2.data.current.sortable.containerId;
}
function isAfter(a4, b2) {
  if (!hasSortableData(a4) || !hasSortableData(b2)) {
    return false;
  }
  if (!isSameContainer(a4, b2)) {
    return false;
  }
  return a4.data.current.sortable.index < b2.data.current.sortable.index;
}
function SortableItem({
  item,
  onEdit,
  onDelete,
  onAddSubcategory,
  onEditSubcategory,
  onDeleteSubcategory,
  enableSubcategories = true
}) {
  const [isEditing, setIsEditing] = reactExports.useState(false);
  const [editValue, setEditValue] = reactExports.useState(item.name);
  const [newSubcategory, setNewSubcategory] = reactExports.useState("");
  const [editingSubcategory, setEditingSubcategory] = reactExports.useState(null);
  const { attributes, listeners: listeners2, setNodeRef, transform, transition } = useSortable({ id: item.id });
  const style = {
    transform: CSS$1.Transform.toString(transform),
    transition
  };
  const handleSave = () => {
    if (editValue.trim() !== item.name) {
      onEdit(item.id, editValue.trim());
    }
    setIsEditing(false);
  };
  const handleCancel = () => {
    setEditValue(item.name);
    setIsEditing(false);
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter") {
      handleSave();
    } else if (e3.key === "Escape") {
      handleCancel();
    }
  };
  const handleAddSubcategory = () => {
    if (newSubcategory.trim()) {
      onAddSubcategory(item.id, newSubcategory.trim());
      setNewSubcategory("");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: setNodeRef, style, className: "space-y-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center p-2 bg-gray-100 rounded-md", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center flex-1", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("button", { ...attributes, ...listeners2, className: "p-1 mr-2 cursor-grab active:cursor-grabbing", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, { className: "h-4 w-4 text-gray-500" }) }),
        isEditing ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            value: editValue,
            onChange: (e3) => setEditValue(e3.target.value),
            onBlur: handleSave,
            onKeyDown: handleKeyDown,
            className: "h-8",
            autoFocus: true
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: item.name })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: () => setIsEditing(true), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pencil, { className: "h-4 w-4 text-gray-600" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: () => onDelete(item.id), className: "text-gray-600 hover:text-gray-800", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" }) })
      ] })
    ] }),
    enableSubcategories && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "pl-8 space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            type: "text",
            className: "flex-1",
            placeholder: "Add subcategory",
            value: newSubcategory,
            onChange: (e3) => setNewSubcategory(e3.target.value),
            onKeyDown: (e3) => {
              if (e3.key === "Enter") {
                handleAddSubcategory();
              }
            }
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(
          Button,
          {
            onClick: handleAddSubcategory,
            variant: "outline",
            className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border border-gray-300",
            children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4 mr-2" }),
              "Add"
            ]
          }
        )
      ] }),
      item.children?.map((child) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center p-2 bg-gray-50 rounded-md border border-gray-200", children: editingSubcategory === child.name ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          value: editValue,
          onChange: (e3) => setEditValue(e3.target.value),
          onBlur: () => {
            if (editValue.trim() !== child.name) {
              onEditSubcategory(item.id, child.name, editValue.trim());
            }
            setEditingSubcategory(null);
          },
          onKeyDown: (e3) => {
            if (e3.key === "Enter") {
              if (editValue.trim() !== child.name) {
                onEditSubcategory(item.id, child.name, editValue.trim());
              }
              setEditingSubcategory(null);
            } else if (e3.key === "Escape") {
              setEditingSubcategory(null);
            }
          },
          className: "h-8",
          autoFocus: true
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: child.name }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "sm", onClick: () => setEditingSubcategory(child.name), className: "text-gray-600", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pencil, { className: "h-4 w-4" }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "ghost",
              size: "sm",
              onClick: () => onDeleteSubcategory(item.id, child.name),
              className: "text-gray-600 hover:text-gray-800",
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
            }
          )
        ] })
      ] }) }, child.name))
    ] })
  ] });
}
function EditableItemWithSubcategoriesList({
  items,
  setItems,
  title,
  description,
  enableSubcategories = true,
  onCheckBeforeDelete
}) {
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    })
  );
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (over && active.id !== over.id) {
      const oldIndex = items.findIndex((item) => item.id === active.id);
      const newIndex = items.findIndex((item) => item.id === over.id);
      setItems(arrayMove(items, oldIndex, newIndex));
    }
  };
  const handleAddItem = () => {
    const input = document.querySelector(`input[placeholder="Add new ${title.toLowerCase().slice(0, -1)}"]`);
    if (input && input.value.trim()) {
      const newItem = {
        id: Date.now().toString(),
        name: input.value.trim(),
        children: []
      };
      setItems([...items, newItem]);
      input.value = "";
    }
  };
  const handleEditItem = (id2, newValue) => {
    const newItems = items.map(
      (item) => item.id === id2 ? { ...item, name: newValue } : item
    );
    setItems(newItems);
  };
  const handleDeleteItem = (id2) => {
    const itemToDelete = items.find((item) => item.id === id2);
    if (itemToDelete && onCheckBeforeDelete) {
      onCheckBeforeDelete(itemToDelete.name, () => {
        setItems(items.filter((item) => item.id !== id2));
      });
    } else {
      setItems(items.filter((item) => item.id !== id2));
    }
  };
  const handleAddSubcategory = (id2, subcategoryName) => {
    const newItems = items.map((item) => {
      if (item.id === id2) {
        return {
          ...item,
          children: [...item.children || [], {
            id: Date.now().toString(),
            name: subcategoryName
          }]
        };
      }
      return item;
    });
    setItems(newItems);
  };
  const handleEditSubcategory = (id2, oldValue, newValue) => {
    const newItems = items.map((item) => {
      if (item.id === id2) {
        return {
          ...item,
          children: item.children?.map(
            (child) => child.name === oldValue ? { ...child, name: newValue } : child
          )
        };
      }
      return item;
    });
    setItems(newItems);
  };
  const handleDeleteSubcategory = (id2, subcategoryName) => {
    const newItems = items.map((item) => {
      if (item.id === id2) {
        return {
          ...item,
          children: item.children?.filter((child) => child.name !== subcategoryName)
        };
      }
      return item;
    });
    setItems(newItems);
  };
  const handleKeyDown = (e3) => {
    if (e3.key === "Enter") {
      handleAddItem();
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-lg font-medium text-gray-800", children: title }),
      description && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: description })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex space-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Input,
        {
          type: "text",
          className: "flex-1",
          placeholder: `Add new ${title.toLowerCase().slice(0, -1)}`,
          onKeyDown: handleKeyDown
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Button,
        {
          onClick: handleAddItem,
          className: "bg-gray-200 hover:bg-gray-300 text-gray-800 border border-gray-300",
          variant: "outline",
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "h-4 w-4 mr-2" }),
            "Add"
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(DndContext, { sensors, collisionDetection: closestCenter, onDragEnd: handleDragEnd, children: /* @__PURE__ */ jsxRuntimeExports.jsx(SortableContext, { items: items.map((item) => item.id), strategy: verticalListSortingStrategy, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2", children: items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      SortableItem,
      {
        item,
        onEdit: handleEditItem,
        onDelete: handleDeleteItem,
        onAddSubcategory: handleAddSubcategory,
        onEditSubcategory: handleEditSubcategory,
        onDeleteSubcategory: handleDeleteSubcategory,
        enableSubcategories
      },
      item.id
    )) }) }) })
  ] });
}
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a4, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop))
      __defNormalProp(a4, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a4, prop, b2[prop]);
    }
  return a4;
};
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
/**
 * @license QR Code generator library (TypeScript)
 * Copyright (c) Project Nayuki.
 * SPDX-License-Identifier: MIT
 */
var qrcodegen;
((qrcodegen2) => {
  const _QrCode = class _QrCode2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code with the given version number,
    // error correction level, data codeword bytes, and mask number.
    // This is a low-level API that most users should not use directly.
    // A mid-level API is the encodeSegments() function.
    constructor(version, errorCorrectionLevel, dataCodewords, msk) {
      this.version = version;
      this.errorCorrectionLevel = errorCorrectionLevel;
      this.modules = [];
      this.isFunction = [];
      if (version < _QrCode2.MIN_VERSION || version > _QrCode2.MAX_VERSION)
        throw new RangeError("Version value out of range");
      if (msk < -1 || msk > 7)
        throw new RangeError("Mask value out of range");
      this.size = version * 4 + 17;
      let row = [];
      for (let i3 = 0; i3 < this.size; i3++)
        row.push(false);
      for (let i3 = 0; i3 < this.size; i3++) {
        this.modules.push(row.slice());
        this.isFunction.push(row.slice());
      }
      this.drawFunctionPatterns();
      const allCodewords = this.addEccAndInterleave(dataCodewords);
      this.drawCodewords(allCodewords);
      if (msk == -1) {
        let minPenalty = 1e9;
        for (let i3 = 0; i3 < 8; i3++) {
          this.applyMask(i3);
          this.drawFormatBits(i3);
          const penalty = this.getPenaltyScore();
          if (penalty < minPenalty) {
            msk = i3;
            minPenalty = penalty;
          }
          this.applyMask(i3);
        }
      }
      assert(0 <= msk && msk <= 7);
      this.mask = msk;
      this.applyMask(msk);
      this.drawFormatBits(msk);
      this.isFunction = [];
    }
    /*-- Static factory functions (high level) --*/
    // Returns a QR Code representing the given Unicode text string at the given error correction level.
    // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
    // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
    // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
    // ecl argument if it can be done without increasing the version.
    static encodeText(text, ecl) {
      const segs = qrcodegen2.QrSegment.makeSegments(text);
      return _QrCode2.encodeSegments(segs, ecl);
    }
    // Returns a QR Code representing the given binary data at the given error correction level.
    // This function always encodes using the binary segment mode, not any text mode. The maximum number of
    // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
    // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
    static encodeBinary(data, ecl) {
      const seg = qrcodegen2.QrSegment.makeBytes(data);
      return _QrCode2.encodeSegments([seg], ecl);
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a QR Code representing the given segments with the given encoding parameters.
    // The smallest possible QR Code version within the given range is automatically
    // chosen for the output. Iff boostEcl is true, then the ECC level of the result
    // may be higher than the ecl argument if it can be done without increasing the
    // version. The mask number is either between 0 to 7 (inclusive) to force that
    // mask, or -1 to automatically choose an appropriate mask (which may be slow).
    // This function allows the user to create a custom sequence of segments that switches
    // between modes (such as alphanumeric and byte) to encode text in less space.
    // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
    static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
      if (!(_QrCode2.MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= _QrCode2.MAX_VERSION) || mask < -1 || mask > 7)
        throw new RangeError("Invalid value");
      let version;
      let dataUsedBits;
      for (version = minVersion; ; version++) {
        const dataCapacityBits2 = _QrCode2.getNumDataCodewords(version, ecl) * 8;
        const usedBits = QrSegment.getTotalBits(segs, version);
        if (usedBits <= dataCapacityBits2) {
          dataUsedBits = usedBits;
          break;
        }
        if (version >= maxVersion)
          throw new RangeError("Data too long");
      }
      for (const newEcl of [_QrCode2.Ecc.MEDIUM, _QrCode2.Ecc.QUARTILE, _QrCode2.Ecc.HIGH]) {
        if (boostEcl && dataUsedBits <= _QrCode2.getNumDataCodewords(version, newEcl) * 8)
          ecl = newEcl;
      }
      let bb2 = [];
      for (const seg of segs) {
        appendBits(seg.mode.modeBits, 4, bb2);
        appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb2);
        for (const b2 of seg.getData())
          bb2.push(b2);
      }
      assert(bb2.length == dataUsedBits);
      const dataCapacityBits = _QrCode2.getNumDataCodewords(version, ecl) * 8;
      assert(bb2.length <= dataCapacityBits);
      appendBits(0, Math.min(4, dataCapacityBits - bb2.length), bb2);
      appendBits(0, (8 - bb2.length % 8) % 8, bb2);
      assert(bb2.length % 8 == 0);
      for (let padByte = 236; bb2.length < dataCapacityBits; padByte ^= 236 ^ 17)
        appendBits(padByte, 8, bb2);
      let dataCodewords = [];
      while (dataCodewords.length * 8 < bb2.length)
        dataCodewords.push(0);
      bb2.forEach((b2, i3) => dataCodewords[i3 >>> 3] |= b2 << 7 - (i3 & 7));
      return new _QrCode2(version, ecl, dataCodewords, mask);
    }
    /*-- Accessor methods --*/
    // Returns the color of the module (pixel) at the given coordinates, which is false
    // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
    // If the given coordinates are out of bounds, then false (light) is returned.
    getModule(x3, y4) {
      return 0 <= x3 && x3 < this.size && 0 <= y4 && y4 < this.size && this.modules[y4][x3];
    }
    // Modified to expose modules for easy access
    getModules() {
      return this.modules;
    }
    /*-- Private helper methods for constructor: Drawing function modules --*/
    // Reads this object's version field, and draws and marks all function modules.
    drawFunctionPatterns() {
      for (let i3 = 0; i3 < this.size; i3++) {
        this.setFunctionModule(6, i3, i3 % 2 == 0);
        this.setFunctionModule(i3, 6, i3 % 2 == 0);
      }
      this.drawFinderPattern(3, 3);
      this.drawFinderPattern(this.size - 4, 3);
      this.drawFinderPattern(3, this.size - 4);
      const alignPatPos = this.getAlignmentPatternPositions();
      const numAlign = alignPatPos.length;
      for (let i3 = 0; i3 < numAlign; i3++) {
        for (let j2 = 0; j2 < numAlign; j2++) {
          if (!(i3 == 0 && j2 == 0 || i3 == 0 && j2 == numAlign - 1 || i3 == numAlign - 1 && j2 == 0))
            this.drawAlignmentPattern(alignPatPos[i3], alignPatPos[j2]);
        }
      }
      this.drawFormatBits(0);
      this.drawVersion();
    }
    // Draws two copies of the format bits (with its own error correction code)
    // based on the given mask and this object's error correction level field.
    drawFormatBits(mask) {
      const data = this.errorCorrectionLevel.formatBits << 3 | mask;
      let rem = data;
      for (let i3 = 0; i3 < 10; i3++)
        rem = rem << 1 ^ (rem >>> 9) * 1335;
      const bits = (data << 10 | rem) ^ 21522;
      assert(bits >>> 15 == 0);
      for (let i3 = 0; i3 <= 5; i3++)
        this.setFunctionModule(8, i3, getBit(bits, i3));
      this.setFunctionModule(8, 7, getBit(bits, 6));
      this.setFunctionModule(8, 8, getBit(bits, 7));
      this.setFunctionModule(7, 8, getBit(bits, 8));
      for (let i3 = 9; i3 < 15; i3++)
        this.setFunctionModule(14 - i3, 8, getBit(bits, i3));
      for (let i3 = 0; i3 < 8; i3++)
        this.setFunctionModule(this.size - 1 - i3, 8, getBit(bits, i3));
      for (let i3 = 8; i3 < 15; i3++)
        this.setFunctionModule(8, this.size - 15 + i3, getBit(bits, i3));
      this.setFunctionModule(8, this.size - 8, true);
    }
    // Draws two copies of the version bits (with its own error correction code),
    // based on this object's version field, iff 7 <= version <= 40.
    drawVersion() {
      if (this.version < 7)
        return;
      let rem = this.version;
      for (let i3 = 0; i3 < 12; i3++)
        rem = rem << 1 ^ (rem >>> 11) * 7973;
      const bits = this.version << 12 | rem;
      assert(bits >>> 18 == 0);
      for (let i3 = 0; i3 < 18; i3++) {
        const color = getBit(bits, i3);
        const a4 = this.size - 11 + i3 % 3;
        const b2 = Math.floor(i3 / 3);
        this.setFunctionModule(a4, b2, color);
        this.setFunctionModule(b2, a4, color);
      }
    }
    // Draws a 9*9 finder pattern including the border separator,
    // with the center module at (x, y). Modules can be out of bounds.
    drawFinderPattern(x3, y4) {
      for (let dy = -4; dy <= 4; dy++) {
        for (let dx = -4; dx <= 4; dx++) {
          const dist = Math.max(Math.abs(dx), Math.abs(dy));
          const xx = x3 + dx;
          const yy = y4 + dy;
          if (0 <= xx && xx < this.size && 0 <= yy && yy < this.size)
            this.setFunctionModule(xx, yy, dist != 2 && dist != 4);
        }
      }
    }
    // Draws a 5*5 alignment pattern, with the center module
    // at (x, y). All modules must be in bounds.
    drawAlignmentPattern(x3, y4) {
      for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++)
          this.setFunctionModule(x3 + dx, y4 + dy, Math.max(Math.abs(dx), Math.abs(dy)) != 1);
      }
    }
    // Sets the color of a module and marks it as a function module.
    // Only used by the constructor. Coordinates must be in bounds.
    setFunctionModule(x3, y4, isDark) {
      this.modules[y4][x3] = isDark;
      this.isFunction[y4][x3] = true;
    }
    /*-- Private helper methods for constructor: Codewords and masking --*/
    // Returns a new byte string representing the given data with the appropriate error correction
    // codewords appended to it, based on this object's version and error correction level.
    addEccAndInterleave(data) {
      const ver = this.version;
      const ecl = this.errorCorrectionLevel;
      if (data.length != _QrCode2.getNumDataCodewords(ver, ecl))
        throw new RangeError("Invalid argument");
      const numBlocks = _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
      const blockEccLen = _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
      const rawCodewords = Math.floor(_QrCode2.getNumRawDataModules(ver) / 8);
      const numShortBlocks = numBlocks - rawCodewords % numBlocks;
      const shortBlockLen = Math.floor(rawCodewords / numBlocks);
      let blocks = [];
      const rsDiv = _QrCode2.reedSolomonComputeDivisor(blockEccLen);
      for (let i3 = 0, k3 = 0; i3 < numBlocks; i3++) {
        let dat = data.slice(k3, k3 + shortBlockLen - blockEccLen + (i3 < numShortBlocks ? 0 : 1));
        k3 += dat.length;
        const ecc = _QrCode2.reedSolomonComputeRemainder(dat, rsDiv);
        if (i3 < numShortBlocks)
          dat.push(0);
        blocks.push(dat.concat(ecc));
      }
      let result = [];
      for (let i3 = 0; i3 < blocks[0].length; i3++) {
        blocks.forEach((block, j2) => {
          if (i3 != shortBlockLen - blockEccLen || j2 >= numShortBlocks)
            result.push(block[i3]);
        });
      }
      assert(result.length == rawCodewords);
      return result;
    }
    // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
    // data area of this QR Code. Function modules need to be marked off before this is called.
    drawCodewords(data) {
      if (data.length != Math.floor(_QrCode2.getNumRawDataModules(this.version) / 8))
        throw new RangeError("Invalid argument");
      let i3 = 0;
      for (let right = this.size - 1; right >= 1; right -= 2) {
        if (right == 6)
          right = 5;
        for (let vert = 0; vert < this.size; vert++) {
          for (let j2 = 0; j2 < 2; j2++) {
            const x3 = right - j2;
            const upward = (right + 1 & 2) == 0;
            const y4 = upward ? this.size - 1 - vert : vert;
            if (!this.isFunction[y4][x3] && i3 < data.length * 8) {
              this.modules[y4][x3] = getBit(data[i3 >>> 3], 7 - (i3 & 7));
              i3++;
            }
          }
        }
      }
      assert(i3 == data.length * 8);
    }
    // XORs the codeword modules in this QR Code with the given mask pattern.
    // The function modules must be marked and the codeword bits must be drawn
    // before masking. Due to the arithmetic of XOR, calling applyMask() with
    // the same mask value a second time will undo the mask. A final well-formed
    // QR Code needs exactly one (not zero, two, etc.) mask applied.
    applyMask(mask) {
      if (mask < 0 || mask > 7)
        throw new RangeError("Mask value out of range");
      for (let y4 = 0; y4 < this.size; y4++) {
        for (let x3 = 0; x3 < this.size; x3++) {
          let invert;
          switch (mask) {
            case 0:
              invert = (x3 + y4) % 2 == 0;
              break;
            case 1:
              invert = y4 % 2 == 0;
              break;
            case 2:
              invert = x3 % 3 == 0;
              break;
            case 3:
              invert = (x3 + y4) % 3 == 0;
              break;
            case 4:
              invert = (Math.floor(x3 / 3) + Math.floor(y4 / 2)) % 2 == 0;
              break;
            case 5:
              invert = x3 * y4 % 2 + x3 * y4 % 3 == 0;
              break;
            case 6:
              invert = (x3 * y4 % 2 + x3 * y4 % 3) % 2 == 0;
              break;
            case 7:
              invert = ((x3 + y4) % 2 + x3 * y4 % 3) % 2 == 0;
              break;
            default:
              throw new Error("Unreachable");
          }
          if (!this.isFunction[y4][x3] && invert)
            this.modules[y4][x3] = !this.modules[y4][x3];
        }
      }
    }
    // Calculates and returns the penalty score based on state of this QR Code's current modules.
    // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
    getPenaltyScore() {
      let result = 0;
      for (let y4 = 0; y4 < this.size; y4++) {
        let runColor = false;
        let runX = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let x3 = 0; x3 < this.size; x3++) {
          if (this.modules[y4][x3] == runColor) {
            runX++;
            if (runX == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runX > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runX, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y4][x3];
            runX = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let x3 = 0; x3 < this.size; x3++) {
        let runColor = false;
        let runY = 0;
        let runHistory = [0, 0, 0, 0, 0, 0, 0];
        for (let y4 = 0; y4 < this.size; y4++) {
          if (this.modules[y4][x3] == runColor) {
            runY++;
            if (runY == 5)
              result += _QrCode2.PENALTY_N1;
            else if (runY > 5)
              result++;
          } else {
            this.finderPenaltyAddHistory(runY, runHistory);
            if (!runColor)
              result += this.finderPenaltyCountPatterns(runHistory) * _QrCode2.PENALTY_N3;
            runColor = this.modules[y4][x3];
            runY = 1;
          }
        }
        result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * _QrCode2.PENALTY_N3;
      }
      for (let y4 = 0; y4 < this.size - 1; y4++) {
        for (let x3 = 0; x3 < this.size - 1; x3++) {
          const color = this.modules[y4][x3];
          if (color == this.modules[y4][x3 + 1] && color == this.modules[y4 + 1][x3] && color == this.modules[y4 + 1][x3 + 1])
            result += _QrCode2.PENALTY_N2;
        }
      }
      let dark = 0;
      for (const row of this.modules)
        dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
      const total = this.size * this.size;
      const k3 = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
      assert(0 <= k3 && k3 <= 9);
      result += k3 * _QrCode2.PENALTY_N4;
      assert(0 <= result && result <= 2568888);
      return result;
    }
    /*-- Private helper functions --*/
    // Returns an ascending list of positions of alignment patterns for this version number.
    // Each position is in the range [0,177), and are used on both the x and y axes.
    // This could be implemented as lookup table of 40 variable-length lists of integers.
    getAlignmentPatternPositions() {
      if (this.version == 1)
        return [];
      else {
        const numAlign = Math.floor(this.version / 7) + 2;
        const step = this.version == 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
        let result = [6];
        for (let pos = this.size - 7; result.length < numAlign; pos -= step)
          result.splice(1, 0, pos);
        return result;
      }
    }
    // Returns the number of data bits that can be stored in a QR Code of the given version number, after
    // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
    // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
    static getNumRawDataModules(ver) {
      if (ver < _QrCode2.MIN_VERSION || ver > _QrCode2.MAX_VERSION)
        throw new RangeError("Version number out of range");
      let result = (16 * ver + 128) * ver + 64;
      if (ver >= 2) {
        const numAlign = Math.floor(ver / 7) + 2;
        result -= (25 * numAlign - 10) * numAlign - 55;
        if (ver >= 7)
          result -= 36;
      }
      assert(208 <= result && result <= 29648);
      return result;
    }
    // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
    // QR Code of the given version number and error correction level, with remainder bits discarded.
    // This stateless pure function could be implemented as a (40*4)-cell lookup table.
    static getNumDataCodewords(ver, ecl) {
      return Math.floor(_QrCode2.getNumRawDataModules(ver) / 8) - _QrCode2.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] * _QrCode2.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
    }
    // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
    // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
    static reedSolomonComputeDivisor(degree) {
      if (degree < 1 || degree > 255)
        throw new RangeError("Degree out of range");
      let result = [];
      for (let i3 = 0; i3 < degree - 1; i3++)
        result.push(0);
      result.push(1);
      let root = 1;
      for (let i3 = 0; i3 < degree; i3++) {
        for (let j2 = 0; j2 < result.length; j2++) {
          result[j2] = _QrCode2.reedSolomonMultiply(result[j2], root);
          if (j2 + 1 < result.length)
            result[j2] ^= result[j2 + 1];
        }
        root = _QrCode2.reedSolomonMultiply(root, 2);
      }
      return result;
    }
    // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
    static reedSolomonComputeRemainder(data, divisor) {
      let result = divisor.map((_2) => 0);
      for (const b2 of data) {
        const factor = b2 ^ result.shift();
        result.push(0);
        divisor.forEach((coef, i3) => result[i3] ^= _QrCode2.reedSolomonMultiply(coef, factor));
      }
      return result;
    }
    // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
    // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
    static reedSolomonMultiply(x3, y4) {
      if (x3 >>> 8 != 0 || y4 >>> 8 != 0)
        throw new RangeError("Byte out of range");
      let z3 = 0;
      for (let i3 = 7; i3 >= 0; i3--) {
        z3 = z3 << 1 ^ (z3 >>> 7) * 285;
        z3 ^= (y4 >>> i3 & 1) * x3;
      }
      assert(z3 >>> 8 == 0);
      return z3;
    }
    // Can only be called immediately after a light run is added, and
    // returns either 0, 1, or 2. A helper function for getPenaltyScore().
    finderPenaltyCountPatterns(runHistory) {
      const n2 = runHistory[1];
      assert(n2 <= this.size * 3);
      const core = n2 > 0 && runHistory[2] == n2 && runHistory[3] == n2 * 3 && runHistory[4] == n2 && runHistory[5] == n2;
      return (core && runHistory[0] >= n2 * 4 && runHistory[6] >= n2 ? 1 : 0) + (core && runHistory[6] >= n2 * 4 && runHistory[0] >= n2 ? 1 : 0);
    }
    // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
    finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
      if (currentRunColor) {
        this.finderPenaltyAddHistory(currentRunLength, runHistory);
        currentRunLength = 0;
      }
      currentRunLength += this.size;
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      return this.finderPenaltyCountPatterns(runHistory);
    }
    // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
    finderPenaltyAddHistory(currentRunLength, runHistory) {
      if (runHistory[0] == 0)
        currentRunLength += this.size;
      runHistory.pop();
      runHistory.unshift(currentRunLength);
    }
  };
  _QrCode.MIN_VERSION = 1;
  _QrCode.MAX_VERSION = 40;
  _QrCode.PENALTY_N1 = 3;
  _QrCode.PENALTY_N2 = 3;
  _QrCode.PENALTY_N3 = 40;
  _QrCode.PENALTY_N4 = 10;
  _QrCode.ECC_CODEWORDS_PER_BLOCK = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Low
    [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
    // Medium
    [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
    // Quartile
    [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
    // High
  ];
  _QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
    // Version: (note that index 0 is for padding, and is set to an illegal value)
    //0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
    [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
    // Low
    [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
    // Medium
    [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
    // Quartile
    [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
    // High
  ];
  qrcodegen2.QrCode = _QrCode;
  function appendBits(val, len, bb2) {
    if (len < 0 || len > 31 || val >>> len != 0)
      throw new RangeError("Value out of range");
    for (let i3 = len - 1; i3 >= 0; i3--)
      bb2.push(val >>> i3 & 1);
  }
  function getBit(x3, i3) {
    return (x3 >>> i3 & 1) != 0;
  }
  function assert(cond) {
    if (!cond)
      throw new Error("Assertion error");
  }
  const _QrSegment = class _QrSegment2 {
    /*-- Constructor (low level) and fields --*/
    // Creates a new QR Code segment with the given attributes and data.
    // The character count (numChars) must agree with the mode and the bit buffer length,
    // but the constraint isn't checked. The given bit buffer is cloned and stored.
    constructor(mode, numChars, bitData) {
      this.mode = mode;
      this.numChars = numChars;
      this.bitData = bitData;
      if (numChars < 0)
        throw new RangeError("Invalid argument");
      this.bitData = bitData.slice();
    }
    /*-- Static factory functions (mid level) --*/
    // Returns a segment representing the given binary data encoded in
    // byte mode. All input byte arrays are acceptable. Any text string
    // can be converted to UTF-8 bytes and encoded as a byte mode segment.
    static makeBytes(data) {
      let bb2 = [];
      for (const b2 of data)
        appendBits(b2, 8, bb2);
      return new _QrSegment2(_QrSegment2.Mode.BYTE, data.length, bb2);
    }
    // Returns a segment representing the given string of decimal digits encoded in numeric mode.
    static makeNumeric(digits) {
      if (!_QrSegment2.isNumeric(digits))
        throw new RangeError("String contains non-numeric characters");
      let bb2 = [];
      for (let i3 = 0; i3 < digits.length; ) {
        const n2 = Math.min(digits.length - i3, 3);
        appendBits(parseInt(digits.substring(i3, i3 + n2), 10), n2 * 3 + 1, bb2);
        i3 += n2;
      }
      return new _QrSegment2(_QrSegment2.Mode.NUMERIC, digits.length, bb2);
    }
    // Returns a segment representing the given text string encoded in alphanumeric mode.
    // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
    // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static makeAlphanumeric(text) {
      if (!_QrSegment2.isAlphanumeric(text))
        throw new RangeError("String contains unencodable characters in alphanumeric mode");
      let bb2 = [];
      let i3;
      for (i3 = 0; i3 + 2 <= text.length; i3 += 2) {
        let temp = _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i3)) * 45;
        temp += _QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i3 + 1));
        appendBits(temp, 11, bb2);
      }
      if (i3 < text.length)
        appendBits(_QrSegment2.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i3)), 6, bb2);
      return new _QrSegment2(_QrSegment2.Mode.ALPHANUMERIC, text.length, bb2);
    }
    // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
    // The result may use various segment modes and switch modes to optimize the length of the bit stream.
    static makeSegments(text) {
      if (text == "")
        return [];
      else if (_QrSegment2.isNumeric(text))
        return [_QrSegment2.makeNumeric(text)];
      else if (_QrSegment2.isAlphanumeric(text))
        return [_QrSegment2.makeAlphanumeric(text)];
      else
        return [_QrSegment2.makeBytes(_QrSegment2.toUtf8ByteArray(text))];
    }
    // Returns a segment representing an Extended Channel Interpretation
    // (ECI) designator with the given assignment value.
    static makeEci(assignVal) {
      let bb2 = [];
      if (assignVal < 0)
        throw new RangeError("ECI assignment value out of range");
      else if (assignVal < 1 << 7)
        appendBits(assignVal, 8, bb2);
      else if (assignVal < 1 << 14) {
        appendBits(2, 2, bb2);
        appendBits(assignVal, 14, bb2);
      } else if (assignVal < 1e6) {
        appendBits(6, 3, bb2);
        appendBits(assignVal, 21, bb2);
      } else
        throw new RangeError("ECI assignment value out of range");
      return new _QrSegment2(_QrSegment2.Mode.ECI, 0, bb2);
    }
    // Tests whether the given string can be encoded as a segment in numeric mode.
    // A string is encodable iff each character is in the range 0 to 9.
    static isNumeric(text) {
      return _QrSegment2.NUMERIC_REGEX.test(text);
    }
    // Tests whether the given string can be encoded as a segment in alphanumeric mode.
    // A string is encodable iff each character is in the following set: 0 to 9, A to Z
    // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
    static isAlphanumeric(text) {
      return _QrSegment2.ALPHANUMERIC_REGEX.test(text);
    }
    /*-- Methods --*/
    // Returns a new copy of the data bits of this segment.
    getData() {
      return this.bitData.slice();
    }
    // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
    // the given version. The result is infinity if a segment has too many characters to fit its length field.
    static getTotalBits(segs, version) {
      let result = 0;
      for (const seg of segs) {
        const ccbits = seg.mode.numCharCountBits(version);
        if (seg.numChars >= 1 << ccbits)
          return Infinity;
        result += 4 + ccbits + seg.bitData.length;
      }
      return result;
    }
    // Returns a new array of bytes representing the given string encoded in UTF-8.
    static toUtf8ByteArray(str) {
      str = encodeURI(str);
      let result = [];
      for (let i3 = 0; i3 < str.length; i3++) {
        if (str.charAt(i3) != "%")
          result.push(str.charCodeAt(i3));
        else {
          result.push(parseInt(str.substring(i3 + 1, i3 + 3), 16));
          i3 += 2;
        }
      }
      return result;
    }
  };
  _QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
  _QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
  _QrSegment.ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
  let QrSegment = _QrSegment;
  qrcodegen2.QrSegment = _QrSegment;
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrCode2) => {
    const _Ecc = class _Ecc {
      // The QR Code can tolerate about 30% erroneous codewords
      /*-- Constructor and fields --*/
      constructor(ordinal, formatBits) {
        this.ordinal = ordinal;
        this.formatBits = formatBits;
      }
    };
    _Ecc.LOW = new _Ecc(0, 1);
    _Ecc.MEDIUM = new _Ecc(1, 0);
    _Ecc.QUARTILE = new _Ecc(2, 3);
    _Ecc.HIGH = new _Ecc(3, 2);
    QrCode2.Ecc = _Ecc;
  })(qrcodegen2.QrCode || (qrcodegen2.QrCode = {}));
})(qrcodegen || (qrcodegen = {}));
((qrcodegen2) => {
  ((QrSegment2) => {
    const _Mode = class _Mode {
      /*-- Constructor and fields --*/
      constructor(modeBits, numBitsCharCount) {
        this.modeBits = modeBits;
        this.numBitsCharCount = numBitsCharCount;
      }
      /*-- Method --*/
      // (Package-private) Returns the bit width of the character count field for a segment in
      // this mode in a QR Code at the given version number. The result is in the range [0, 16].
      numCharCountBits(ver) {
        return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
      }
    };
    _Mode.NUMERIC = new _Mode(1, [10, 12, 14]);
    _Mode.ALPHANUMERIC = new _Mode(2, [9, 11, 13]);
    _Mode.BYTE = new _Mode(4, [8, 16, 16]);
    _Mode.KANJI = new _Mode(8, [8, 10, 12]);
    _Mode.ECI = new _Mode(7, [0, 0, 0]);
    QrSegment2.Mode = _Mode;
  })(qrcodegen2.QrSegment || (qrcodegen2.QrSegment = {}));
})(qrcodegen || (qrcodegen = {}));
var qrcodegen_default = qrcodegen;
/**
 * @license qrcode.react
 * Copyright (c) Paul O'Shannessy
 * SPDX-License-Identifier: ISC
 */
var ERROR_LEVEL_MAP = {
  L: qrcodegen_default.QrCode.Ecc.LOW,
  M: qrcodegen_default.QrCode.Ecc.MEDIUM,
  Q: qrcodegen_default.QrCode.Ecc.QUARTILE,
  H: qrcodegen_default.QrCode.Ecc.HIGH
};
var DEFAULT_SIZE = 128;
var DEFAULT_LEVEL = "L";
var DEFAULT_BGCOLOR = "#FFFFFF";
var DEFAULT_FGCOLOR = "#000000";
var DEFAULT_INCLUDEMARGIN = false;
var DEFAULT_MINVERSION = 1;
var SPEC_MARGIN_SIZE = 4;
var DEFAULT_MARGIN_SIZE = 0;
var DEFAULT_IMG_SCALE = 0.1;
function generatePath(modules, margin = 0) {
  const ops = [];
  modules.forEach(function(row, y4) {
    let start = null;
    row.forEach(function(cell, x3) {
      if (!cell && start !== null) {
        ops.push(
          `M${start + margin} ${y4 + margin}h${x3 - start}v1H${start + margin}z`
        );
        start = null;
        return;
      }
      if (x3 === row.length - 1) {
        if (!cell) {
          return;
        }
        if (start === null) {
          ops.push(`M${x3 + margin},${y4 + margin} h1v1H${x3 + margin}z`);
        } else {
          ops.push(
            `M${start + margin},${y4 + margin} h${x3 + 1 - start}v1H${start + margin}z`
          );
        }
        return;
      }
      if (cell && start === null) {
        start = x3;
      }
    });
  });
  return ops.join("");
}
function excavateModules(modules, excavation) {
  return modules.slice().map((row, y4) => {
    if (y4 < excavation.y || y4 >= excavation.y + excavation.h) {
      return row;
    }
    return row.map((cell, x3) => {
      if (x3 < excavation.x || x3 >= excavation.x + excavation.w) {
        return cell;
      }
      return false;
    });
  });
}
function getImageSettings(cells, size2, margin, imageSettings) {
  if (imageSettings == null) {
    return null;
  }
  const numCells = cells.length + margin * 2;
  const defaultSize = Math.floor(size2 * DEFAULT_IMG_SCALE);
  const scale = numCells / size2;
  const w3 = (imageSettings.width || defaultSize) * scale;
  const h4 = (imageSettings.height || defaultSize) * scale;
  const x3 = imageSettings.x == null ? cells.length / 2 - w3 / 2 : imageSettings.x * scale;
  const y4 = imageSettings.y == null ? cells.length / 2 - h4 / 2 : imageSettings.y * scale;
  const opacity = imageSettings.opacity == null ? 1 : imageSettings.opacity;
  let excavation = null;
  if (imageSettings.excavate) {
    let floorX = Math.floor(x3);
    let floorY = Math.floor(y4);
    let ceilW = Math.ceil(w3 + x3 - floorX);
    let ceilH = Math.ceil(h4 + y4 - floorY);
    excavation = { x: floorX, y: floorY, w: ceilW, h: ceilH };
  }
  const crossOrigin = imageSettings.crossOrigin;
  return { x: x3, y: y4, h: h4, w: w3, excavation, opacity, crossOrigin };
}
function getMarginSize(includeMargin, marginSize) {
  if (marginSize != null) {
    return Math.max(Math.floor(marginSize), 0);
  }
  return includeMargin ? SPEC_MARGIN_SIZE : DEFAULT_MARGIN_SIZE;
}
function useQRCode({
  value,
  level,
  minVersion,
  includeMargin,
  marginSize,
  imageSettings,
  size: size2,
  boostLevel
}) {
  let qrcode = React$1.useMemo(() => {
    const values = Array.isArray(value) ? value : [value];
    const segments = values.reduce((accum, v2) => {
      accum.push(...qrcodegen_default.QrSegment.makeSegments(v2));
      return accum;
    }, []);
    return qrcodegen_default.QrCode.encodeSegments(
      segments,
      ERROR_LEVEL_MAP[level],
      minVersion,
      void 0,
      void 0,
      boostLevel
    );
  }, [value, level, minVersion, boostLevel]);
  const { cells, margin, numCells, calculatedImageSettings } = React$1.useMemo(() => {
    let cells2 = qrcode.getModules();
    const margin2 = getMarginSize(includeMargin, marginSize);
    const numCells2 = cells2.length + margin2 * 2;
    const calculatedImageSettings2 = getImageSettings(
      cells2,
      size2,
      margin2,
      imageSettings
    );
    return {
      cells: cells2,
      margin: margin2,
      numCells: numCells2,
      calculatedImageSettings: calculatedImageSettings2
    };
  }, [qrcode, size2, imageSettings, includeMargin, marginSize]);
  return {
    qrcode,
    margin,
    cells,
    numCells,
    calculatedImageSettings
  };
}
var SUPPORTS_PATH2D = function() {
  try {
    new Path2D().addPath(new Path2D());
  } catch (e3) {
    return false;
  }
  return true;
}();
var QRCodeCanvas = React$1.forwardRef(
  function QRCodeCanvas2(props, forwardedRef) {
    const _a = props, {
      value,
      size: size2 = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      boostLevel,
      marginSize,
      imageSettings
    } = _a, extraProps = __objRest(_a, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "marginSize",
      "imageSettings"
    ]);
    const _b = extraProps, { style } = _b, otherProps = __objRest(_b, ["style"]);
    const imgSrc = imageSettings == null ? void 0 : imageSettings.src;
    const _canvas = React$1.useRef(null);
    const _image = React$1.useRef(null);
    const setCanvasRef = React$1.useCallback(
      (node) => {
        _canvas.current = node;
        if (typeof forwardedRef === "function") {
          forwardedRef(node);
        } else if (forwardedRef) {
          forwardedRef.current = node;
        }
      },
      [forwardedRef]
    );
    const [isImgLoaded, setIsImageLoaded] = React$1.useState(false);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value,
      level,
      minVersion,
      boostLevel,
      includeMargin,
      marginSize,
      imageSettings,
      size: size2
    });
    React$1.useEffect(() => {
      if (_canvas.current != null) {
        const canvas = _canvas.current;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return;
        }
        let cellsToDraw = cells;
        const image = _image.current;
        const haveImageToRender = calculatedImageSettings != null && image !== null && image.complete && image.naturalHeight !== 0 && image.naturalWidth !== 0;
        if (haveImageToRender) {
          if (calculatedImageSettings.excavation != null) {
            cellsToDraw = excavateModules(
              cells,
              calculatedImageSettings.excavation
            );
          }
        }
        const pixelRatio = window.devicePixelRatio || 1;
        canvas.height = canvas.width = size2 * pixelRatio;
        const scale = size2 / numCells * pixelRatio;
        ctx.scale(scale, scale);
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, numCells, numCells);
        ctx.fillStyle = fgColor;
        if (SUPPORTS_PATH2D) {
          ctx.fill(new Path2D(generatePath(cellsToDraw, margin)));
        } else {
          cells.forEach(function(row, rdx) {
            row.forEach(function(cell, cdx) {
              if (cell) {
                ctx.fillRect(cdx + margin, rdx + margin, 1, 1);
              }
            });
          });
        }
        if (calculatedImageSettings) {
          ctx.globalAlpha = calculatedImageSettings.opacity;
        }
        if (haveImageToRender) {
          ctx.drawImage(
            image,
            calculatedImageSettings.x + margin,
            calculatedImageSettings.y + margin,
            calculatedImageSettings.w,
            calculatedImageSettings.h
          );
        }
      }
    });
    React$1.useEffect(() => {
      setIsImageLoaded(false);
    }, [imgSrc]);
    const canvasStyle = __spreadValues({ height: size2, width: size2 }, style);
    let img = null;
    if (imgSrc != null) {
      img = /* @__PURE__ */ React$1.createElement(
        "img",
        {
          src: imgSrc,
          key: imgSrc,
          style: { display: "none" },
          onLoad: () => {
            setIsImageLoaded(true);
          },
          ref: _image,
          crossOrigin: calculatedImageSettings == null ? void 0 : calculatedImageSettings.crossOrigin
        }
      );
    }
    return /* @__PURE__ */ React$1.createElement(React$1.Fragment, null, /* @__PURE__ */ React$1.createElement(
      "canvas",
      __spreadValues({
        style: canvasStyle,
        height: size2,
        width: size2,
        ref: setCanvasRef,
        role: "img"
      }, otherProps)
    ), img);
  }
);
QRCodeCanvas.displayName = "QRCodeCanvas";
var QRCodeSVG = React$1.forwardRef(
  function QRCodeSVG2(props, forwardedRef) {
    const _a = props, {
      value,
      size: size2 = DEFAULT_SIZE,
      level = DEFAULT_LEVEL,
      bgColor = DEFAULT_BGCOLOR,
      fgColor = DEFAULT_FGCOLOR,
      includeMargin = DEFAULT_INCLUDEMARGIN,
      minVersion = DEFAULT_MINVERSION,
      boostLevel,
      title,
      marginSize,
      imageSettings
    } = _a, otherProps = __objRest(_a, [
      "value",
      "size",
      "level",
      "bgColor",
      "fgColor",
      "includeMargin",
      "minVersion",
      "boostLevel",
      "title",
      "marginSize",
      "imageSettings"
    ]);
    const { margin, cells, numCells, calculatedImageSettings } = useQRCode({
      value,
      level,
      minVersion,
      boostLevel,
      includeMargin,
      marginSize,
      imageSettings,
      size: size2
    });
    let cellsToDraw = cells;
    let image = null;
    if (imageSettings != null && calculatedImageSettings != null) {
      if (calculatedImageSettings.excavation != null) {
        cellsToDraw = excavateModules(
          cells,
          calculatedImageSettings.excavation
        );
      }
      image = /* @__PURE__ */ React$1.createElement(
        "image",
        {
          href: imageSettings.src,
          height: calculatedImageSettings.h,
          width: calculatedImageSettings.w,
          x: calculatedImageSettings.x + margin,
          y: calculatedImageSettings.y + margin,
          preserveAspectRatio: "none",
          opacity: calculatedImageSettings.opacity,
          crossOrigin: calculatedImageSettings.crossOrigin
        }
      );
    }
    const fgPath = generatePath(cellsToDraw, margin);
    return /* @__PURE__ */ React$1.createElement(
      "svg",
      __spreadValues({
        height: size2,
        width: size2,
        viewBox: `0 0 ${numCells} ${numCells}`,
        ref: forwardedRef,
        role: "img"
      }, otherProps),
      !!title && /* @__PURE__ */ React$1.createElement("title", null, title),
      /* @__PURE__ */ React$1.createElement(
        "path",
        {
          fill: bgColor,
          d: `M0,0 h${numCells}v${numCells}H0z`,
          shapeRendering: "crispEdges"
        }
      ),
      /* @__PURE__ */ React$1.createElement("path", { fill: fgColor, d: fgPath, shapeRendering: "crispEdges" }),
      image
    );
  }
);
QRCodeSVG.displayName = "QRCodeSVG";
const formSchema = objectType({
  itemId: stringType().min(1, "Item is required"),
  quantity: coerce.number().min(1, "Quantity must be greater than 0"),
  action: enumType(["check-in", "check-out"])
});
function ItemCheckInOut({
  cabinetId,
  cabinetName,
  isSecure,
  locationId,
  onCheckIn,
  onCheckOut
}) {
  const { items } = useInventory();
  const locationItems = React$1.useMemo(() => {
    return items.filter((item) => item.location === locationId);
  }, [items, locationId]);
  const form = useForm({
    resolver: t2(formSchema),
    defaultValues: {
      itemId: "",
      quantity: 1,
      action: "check-out"
    }
  });
  const onSubmit = (values) => {
    if (values.action === "check-in") {
      onCheckIn(values.itemId, values.quantity);
    } else {
      onCheckOut(values.itemId, values.quantity);
    }
    form.reset();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Quick Actions" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardDescription, { children: [
        "Check items in or out of ",
        cabinetName
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...form, children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(onSubmit), className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "itemId",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Item" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { onValueChange: field.onChange, defaultValue: field.value, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select an item" }) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: locationItems.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: item.id, children: [
                item.name,
                " (",
                item.quantity || 0,
                " available)"
              ] }, item.id)) })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {}),
            locationItems.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mt-2", children: "No items found for this location. Add items to this location first." })
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "quantity",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Quantity" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { type: "number", min: "1", ...field }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "action",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Action" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { onValueChange: field.onChange, defaultValue: field.value, children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }) }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectContent, { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "check-out", children: "Check Out" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "check-in", children: "Check In" })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-end", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", disabled: locationItems.length === 0, children: "Submit" }) })
    ] }) }) })
  ] });
}
function QRCodeManager({
  cabinetId,
  cabinetName,
  isSecure,
  description,
  notes,
  locationId,
  requireCheckout,
  onCheckIn,
  onCheckOut
}) {
  const qrValue = JSON.stringify({
    type: "cabinet",
    id: cabinetId,
    name: cabinetName,
    isSecure
  });
  const handlePrint = () => {
    const printWindow = window.open("", "_blank");
    if (printWindow) {
      printWindow.document.write(`
        <html>
          <head>
            <title>Print QR Code - ${cabinetName}</title>
            <style>
              body { font-family: system-ui, sans-serif; text-align: center; padding: 20px; }
              .qr-container { margin: 20px auto; }
              .cabinet-info { margin: 20px 0; }
              @media print {
                @page { margin: 0; }
                body { margin: 1.6cm; }
              }
            </style>
          </head>
          <body>
            <div class="qr-container">
              ${document.getElementById("qr-code-" + cabinetId)?.innerHTML || ""}
            </div>
            <div class="cabinet-info">
              <h2>${cabinetName}</h2>
              <p>Cabinet ID: ${cabinetId}</p>
              ${isSecure ? "<p><strong>Secure Cabinet</strong></p>" : ""}
            </div>
          </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.print();
    }
  };
  const handleDownload = () => {
    const svg = document.getElementById("qr-code-" + cabinetId)?.querySelector("svg");
    if (svg) {
      const svgData = new XMLSerializer().serializeToString(svg);
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      const img = new Image();
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx?.drawImage(img, 0, 0);
        const pngFile = canvas.toDataURL("image/png");
        const downloadLink = document.createElement("a");
        downloadLink.download = `qr-${cabinetId}.png`;
        downloadLink.href = pngFile;
        downloadLink.click();
      };
      img.src = "data:image/svg+xml;base64," + btoa(svgData);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: cabinetName }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: description })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(QrCode, { className: "h-4 w-4" }) }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Cabinet QR Code" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { children: [
                "Print or download QR code for ",
                cabinetName
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "div",
                {
                  id: `qr-code-${cabinetId}`,
                  className: "flex justify-center p-4 bg-white rounded-lg border",
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    QRCodeSVG,
                    {
                      value: qrValue,
                      size: 200,
                      level: "H",
                      includeMargin: true,
                      className: "w-full h-auto max-w-[200px]"
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2 justify-center", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handlePrint, variant: "outline", className: "w-32", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Printer, { className: "w-4 h-4 mr-2" }),
                  "Print"
                ] }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleDownload, variant: "outline", className: "w-32", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "w-4 h-4 mr-2" }),
                  "Download"
                ] })
              ] })
            ] })
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: "Location:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { children: locationId })
        ] }),
        isSecure && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: "Security:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-yellow-600", children: "Secure Cabinet" })
        ] }),
        notes && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "text-sm", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-muted-foreground", children: "Notes:" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "mt-1", children: notes })
        ] })
      ] }) })
    ] }),
    (isSecure || requireCheckout) && onCheckIn && onCheckOut && /* @__PURE__ */ jsxRuntimeExports.jsx(
      ItemCheckInOut,
      {
        cabinetId,
        cabinetName,
        isSecure,
        locationId,
        onCheckIn,
        onCheckOut
      }
    )
  ] });
}
function CheckoutHistory({ cabinetId, records }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "rounded-md border", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Table, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(TableHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "Item" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "User" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "Action" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "Quantity" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TableHead, { children: "When" })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TableBody, { children: [
      records.map((record) => /* @__PURE__ */ jsxRuntimeExports.jsxs(TableRow, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: record.itemName }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-muted-foreground", children: record.itemId })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "font-medium", children: record.userName }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-muted-foreground", children: record.userId })
        ] }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Badge,
          {
            variant: record.type === "check-out" ? "destructive" : "default",
            children: record.type === "check-out" ? "Checked Out" : "Checked In"
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: record.quantity }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { children: formatDistanceToNow(new Date(record.timestamp), { addSuffix: true }) })
      ] }, record.id)),
      records.length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx(TableRow, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TableCell, { colSpan: 5, className: "text-center text-muted-foreground", children: "No records found" }) })
    ] })
  ] }) });
}
const defaultSettingsSchema = z2.object({
  defaultLocation: z2.string().optional(),
  defaultUnit: z2.string().optional(),
  defaultCategory: z2.string().optional(),
  defaultSupplier: z2.string().optional(),
  defaultProject: z2.string().optional(),
  defaultOrderStatus: z2.enum(["delivered", "partially_delivered", "backordered", "on_order", "not_ordered"]).default("delivered"),
  enableQRTracking: z2.boolean().default(true),
  requireCheckoutForSecureCabinets: z2.boolean().default(true),
  autoGenerateQRCodes: z2.boolean().default(true),
  defaultMinQuantity: z2.number().min(0).default(0),
  defaultReorderLevel: z2.number().min(0).default(5)
});
class SettingsService {
  static SETTINGS_KEY = "defaultSettings";
  static CABINETS_KEY = "cabinets";
  // Load default settings
  static loadDefaultSettings() {
    try {
      const settings = window.electronStore.getData(this.SETTINGS_KEY);
      if (!settings) return this.getDefaultSettings();
      return defaultSettingsSchema.parse(settings);
    } catch (error) {
      console.error("Error loading settings:", error);
      return this.getDefaultSettings();
    }
  }
  // Save default settings
  static saveDefaultSettings(settings) {
    try {
      const validated = defaultSettingsSchema.parse(settings);
      window.electronStore.setData(this.SETTINGS_KEY, validated);
    } catch (error) {
      console.error("Error saving settings:", error);
      throw error;
    }
  }
  // Get initial default settings
  static getDefaultSettings() {
    return {
      defaultOrderStatus: "delivered",
      enableQRTracking: true,
      requireCheckoutForSecureCabinets: true,
      autoGenerateQRCodes: true,
      defaultMinQuantity: 0,
      defaultReorderLevel: 5
    };
  }
  // Cabinet Management
  static async getCabinets() {
    try {
      const cabinets = window.electronStore.getData(this.CABINETS_KEY);
      return cabinets || [];
    } catch (error) {
      console.error("Error loading cabinets:", error);
      return [];
    }
  }
  static async saveCabinet(cabinet) {
    try {
      const cabinets = await this.getCabinets();
      const existingIndex = cabinets.findIndex((c3) => c3.id === cabinet.id);
      if (existingIndex >= 0) {
        cabinets[existingIndex] = cabinet;
      } else {
        cabinets.push(cabinet);
      }
      window.electronStore.setData(this.CABINETS_KEY, cabinets);
    } catch (error) {
      console.error("Error saving cabinet:", error);
      throw error;
    }
  }
  static async deleteCabinet(cabinetId) {
    try {
      const cabinets = await this.getCabinets();
      const filtered = cabinets.filter((c3) => c3.id !== cabinetId);
      window.electronStore.setData(this.CABINETS_KEY, filtered);
    } catch (error) {
      console.error("Error deleting cabinet:", error);
      throw error;
    }
  }
  static async getCabinetsByLocation(locationId) {
    try {
      const cabinets = await this.getCabinets();
      return cabinets.filter((c3) => c3.locationId === locationId);
    } catch (error) {
      console.error("Error getting cabinets by location:", error);
      return [];
    }
  }
  static async getCabinetWithItems(cabinetId, items) {
    try {
      const cabinets = await this.getCabinets();
      const cabinet = cabinets.find((c3) => c3.id === cabinetId);
      if (!cabinet) return null;
      const cabinetItems = items.filter((item) => item.cabinet === cabinetId);
      return {
        ...cabinet,
        items: cabinetItems.map((item) => ({
          id: item.id,
          name: item.name,
          quantity: item.quantity
        }))
      };
    } catch (error) {
      console.error("Error getting cabinet with items:", error);
      return null;
    }
  }
}
const generateQRCode = (cabinetId) => {
  return `cabinet-${cabinetId}-${Date.now()}`;
};
function SortableCabinet({ cabinet, onEdit, onDelete }) {
  const {
    attributes,
    listeners: listeners2,
    setNodeRef,
    transform,
    transition
  } = useSortable({ id: cabinet.id });
  const style = {
    transform: CSS$1.Transform.toString(transform),
    transition
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { ref: setNodeRef, style, className: "flex items-center gap-2 p-2 bg-white rounded-lg shadow mb-2", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ...attributes, ...listeners2, className: "cursor-move", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, { className: "h-5 w-5 text-gray-400" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "font-medium", children: cabinet.name }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: cabinet.description }),
      cabinet.notes && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-400 mt-1", children: cabinet.notes })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", onClick: () => onEdit(cabinet), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pencil, { className: "h-4 w-4" }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "ghost", size: "icon", onClick: () => onDelete(cabinet.id), children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" }) })
    ] })
  ] });
}
function CabinetManagement({ locations: locations2 = [] }) {
  const [activeTab, setActiveTab] = reactExports.useState("cabinets");
  const [cabinets, setCabinets] = reactExports.useState([]);
  const [settings, setSettings] = reactExports.useState({
    defaultLocation: locations2[0] || "",
    enableQRTracking: true,
    requireCheckoutForSecureCabinets: true
  });
  const [cabinetForm, setCabinetForm] = reactExports.useState({
    id: "",
    name: "",
    locationId: locations2[0] || "",
    description: "",
    isSecure: false,
    allowedCategories: [],
    qrCode: "",
    notes: ""
  });
  const [editingCabinet, setEditingCabinet] = reactExports.useState(null);
  const sensors = useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    })
  );
  const [checkoutHistory, setCheckoutHistory] = reactExports.useState({});
  reactExports.useEffect(() => {
    const loadCabinets = async () => {
      try {
        const loadedCabinets = await SettingsService.getCabinets();
        console.log("Loaded cabinets:", loadedCabinets);
        setCabinets(loadedCabinets);
      } catch (error) {
        console.error("Error loading cabinets:", error);
        ue.error("Failed to load cabinets");
      }
    };
    loadCabinets();
  }, []);
  const saveCabinets = async (newCabinets) => {
    try {
      console.log("Attempting to save cabinets:", newCabinets);
      for (const cabinet of newCabinets) {
        await SettingsService.saveCabinet(cabinet);
      }
      setCabinets(newCabinets);
      console.log("Cabinets saved successfully");
    } catch (error) {
      console.error("Error saving cabinets:", error);
      ue.error("Failed to save cabinet");
    }
  };
  reactExports.useEffect(() => {
    if (locations2.length > 0 && !locations2.includes(settings.defaultLocation)) {
      setSettings((prev) => ({ ...prev, defaultLocation: locations2[0] }));
    }
    if (locations2.length > 0 && !locations2.includes(cabinetForm.locationId)) {
      setCabinetForm((prev) => ({ ...prev, locationId: locations2[0] }));
    }
  }, [locations2]);
  const handleSaveCabinet = () => {
    console.log("Save button clicked");
    console.log("Current form state:", cabinetForm);
    if (!cabinetForm.id.trim() || !cabinetForm.name.trim() || !cabinetForm.locationId) {
      console.log("Validation failed:", {
        id: !cabinetForm.id.trim(),
        name: !cabinetForm.name.trim(),
        locationId: !cabinetForm.locationId
      });
      ue.error("Cabinet ID, name, and location are required");
      return;
    }
    if (cabinetForm.id.length > 8) {
      ue.error("Cabinet ID must be 8 characters or less");
      return;
    }
    const formattedId = cabinetForm.id.trim().toUpperCase();
    if (!editingCabinet && cabinets.some((cab) => cab.id === formattedId)) {
      ue.error("Cabinet ID already exists");
      return;
    }
    const newCabinet = {
      ...cabinetForm,
      id: formattedId,
      name: cabinetForm.name.trim(),
      description: cabinetForm.description.trim(),
      notes: cabinetForm.notes?.trim(),
      qrCode: generateQRCode(formattedId)
    };
    console.log("Saving new cabinet:", newCabinet);
    if (editingCabinet) {
      saveCabinets(cabinets.map((cab) => cab.id === editingCabinet.id ? newCabinet : cab));
      ue.success("Cabinet updated successfully");
    } else {
      saveCabinets([...cabinets, newCabinet]);
      ue.success("Cabinet saved successfully");
    }
    setCabinetForm({
      id: "",
      name: "",
      locationId: locations2[0] || "",
      description: "",
      isSecure: false,
      allowedCategories: [],
      qrCode: "",
      notes: ""
    });
    setEditingCabinet(null);
  };
  const handleDeleteCabinet = (id2) => {
    saveCabinets(cabinets.filter((cabinet) => cabinet.id !== id2));
    ue.success("Cabinet deleted successfully");
  };
  const handleUpdateSettings = (newSettings) => {
    setSettings({ ...settings, ...newSettings });
  };
  const handleEditCabinet = (cabinet) => {
    setEditingCabinet(cabinet);
    setCabinetForm(cabinet);
  };
  const handleDragEnd = (event) => {
    const { active, over } = event;
    if (active.id !== over?.id && over) {
      setCabinets((items) => {
        const oldIndex = items.findIndex((item) => item.id === active.id);
        const newIndex = items.findIndex((item) => item.id === over.id);
        const newOrder = arrayMove(items, oldIndex, newIndex);
        saveCabinets(newOrder);
        return newOrder;
      });
    }
  };
  const handleCheckIn = async (cabinetId, itemId, quantity) => {
    try {
      const newCheckout = {
        id: Date.now().toString(),
        itemId,
        itemName: `Item ${itemId}`,
        // In real app, get from item database
        quantity,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        userId: "current-user",
        // In real app, get from auth context
        userName: "Current User",
        // In real app, get from auth context
        type: "check-in"
      };
      setCheckoutHistory((prev) => ({
        ...prev,
        [cabinetId]: [...prev[cabinetId] || [], newCheckout]
      }));
      ue.success("Item checked in successfully");
    } catch (error) {
      console.error("Error checking in item:", error);
      ue.error("Failed to check in item");
    }
  };
  const handleCheckOut = async (cabinetId, itemId, quantity) => {
    try {
      const newCheckout = {
        id: Date.now().toString(),
        itemId,
        itemName: `Item ${itemId}`,
        // In real app, get from item database
        quantity,
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        userId: "current-user",
        // In real app, get from auth context
        userName: "Current User",
        // In real app, get from auth context
        type: "check-out"
      };
      setCheckoutHistory((prev) => ({
        ...prev,
        [cabinetId]: [...prev[cabinetId] || [], newCheckout]
      }));
      ue.success("Item checked out successfully");
    } catch (error) {
      console.error("Error checking out item:", error);
      ue.error("Failed to check out item");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "cabinets", children: "Cabinet List" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "settings", children: "Cabinet Settings" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsContent, { value: "cabinets", className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Add New Cabinet" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Create a new storage cabinet for inventory management." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { className: "space-y-6", autoComplete: "off", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "cabinet-id", children: "Cabinet ID" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    id: "cabinet-id",
                    name: "cabinet-id",
                    placeholder: "Enter cabinet ID",
                    className: "h-12 text-lg",
                    value: cabinetForm.id,
                    maxLength: 8,
                    autoComplete: "off",
                    onChange: (e3) => {
                      const value = e3.target.value.toUpperCase();
                      setCabinetForm({ ...cabinetForm, id: value });
                    }
                  }
                )
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "name", children: "Name" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(
                  Input,
                  {
                    id: "name",
                    name: "cabinet-name",
                    placeholder: "Enter cabinet name",
                    className: "h-12 text-lg",
                    value: cabinetForm.name,
                    maxLength: 12,
                    autoComplete: "off",
                    onChange: (e3) => setCabinetForm({ ...cabinetForm, name: e3.target.value })
                  }
                )
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "description", children: "Description" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  id: "description",
                  name: "cabinet-description",
                  placeholder: "Enter cabinet description",
                  className: "h-12 text-lg",
                  value: cabinetForm.description,
                  autoComplete: "off",
                  onChange: (e3) => setCabinetForm({ ...cabinetForm, description: e3.target.value })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "notes", children: "Notes" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "textarea",
                {
                  id: "notes",
                  name: "cabinet-notes",
                  placeholder: "Enter additional notes about this cabinet",
                  className: "w-full min-h-[100px] px-3 py-2 text-lg rounded-md border border-input bg-background ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
                  value: cabinetForm.notes || "",
                  autoComplete: "off",
                  onChange: (e3) => setCabinetForm({ ...cabinetForm, notes: e3.target.value })
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "location", children: "Location" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(
                Select,
                {
                  value: cabinetForm.locationId,
                  onValueChange: (value) => setCabinetForm({ ...cabinetForm, locationId: value }),
                  children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "location", name: "cabinet-location", className: "h-12 text-lg", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select a location" }) }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: (locations2 || []).map((location2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: location2, children: location2 }, location2)) })
                  ]
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Switch,
                {
                  id: "secure",
                  name: "cabinet-secure",
                  checked: cabinetForm.isSecure,
                  onCheckedChange: (checked) => setCabinetForm({ ...cabinetForm, isSecure: checked })
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "secure", children: "Secure Cabinet" })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "button", onClick: handleSaveCabinet, children: editingCabinet ? "Update Cabinet" : "Add Cabinet" })
        ] }) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Existing Cabinets" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage and reorder your storage cabinets." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          DndContext,
          {
            sensors,
            collisionDetection: closestCenter,
            onDragEnd: handleDragEnd,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              SortableContext,
              {
                items: cabinets.map((c3) => c3.id),
                strategy: verticalListSortingStrategy,
                children: cabinets.map((cabinet) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    SortableCabinet,
                    {
                      cabinet,
                      onEdit: handleEditCabinet,
                      onDelete: handleDeleteCabinet
                    }
                  ),
                  settings.enableQRTracking && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      QRCodeManager,
                      {
                        cabinetId: cabinet.id,
                        cabinetName: cabinet.name,
                        description: cabinet.description || "",
                        locationId: cabinet.locationId,
                        isSecure: cabinet.isSecure,
                        notes: cabinet.notes,
                        requireCheckout: settings.requireCheckoutForSecureCabinets,
                        onCheckIn: (itemId, quantity) => handleCheckIn(cabinet.id, itemId, quantity),
                        onCheckOut: (itemId, quantity) => handleCheckOut(cabinet.id, itemId, quantity)
                      }
                    ),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      CheckoutHistory,
                      {
                        cabinetId: cabinet.id,
                        records: checkoutHistory[cabinet.id] || []
                      }
                    )
                  ] })
                ] }, cabinet.id))
              }
            )
          }
        ) })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "settings", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Default Settings" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Configure cabinet-wide default settings" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "space-y-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Default Location" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Select,
            {
              value: settings.defaultLocation,
              onValueChange: (value) => handleUpdateSettings({ defaultLocation: value }),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: (locations2 || []).map((location2) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: location2, children: location2 }, location2)) })
              ]
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              checked: settings.enableQRTracking,
              onCheckedChange: (checked) => handleUpdateSettings({ enableQRTracking: checked })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Enable QR Tracking" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Switch,
            {
              checked: settings.requireCheckoutForSecureCabinets,
              onCheckedChange: (checked) => handleUpdateSettings({ requireCheckoutForSecureCabinets: checked })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Require Checkout for Secure Cabinets" })
        ] })
      ] })
    ] }) })
  ] }) });
}
const TOAST_LIMIT = 5;
const TOAST_REMOVE_DELAY = 1e6;
const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST"
};
let count = 0;
function genId() {
  count = (count + 1) % Number.MAX_VALUE;
  return count.toString();
}
const toastTimeouts = /* @__PURE__ */ new Map();
const reducer = (state, action) => {
  switch (action.type) {
    case actionTypes.ADD_TOAST:
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT)
      };
    case actionTypes.UPDATE_TOAST:
      return {
        ...state,
        toasts: state.toasts.map(
          (t3) => t3.id === action.toast.id ? { ...t3, ...action.toast } : t3
        )
      };
    case actionTypes.DISMISS_TOAST: {
      const { toastId } = action;
      if (toastId) {
        toastTimeouts.set(
          toastId,
          setTimeout(() => {
            toastTimeouts.delete(toastId);
            dispatch({
              type: actionTypes.REMOVE_TOAST,
              toastId
            });
          }, TOAST_REMOVE_DELAY)
        );
      }
      return {
        ...state,
        toasts: state.toasts.map(
          (t3) => t3.id === toastId || toastId === void 0 ? {
            ...t3,
            open: false
          } : t3
        )
      };
    }
    case actionTypes.REMOVE_TOAST:
      if (action.toastId === void 0) {
        return {
          ...state,
          toasts: []
        };
      }
      return {
        ...state,
        toasts: state.toasts.filter((t3) => t3.id !== action.toastId)
      };
  }
};
const listeners = [];
let memoryState = { toasts: [] };
function dispatch(action) {
  memoryState = reducer(memoryState, action);
  listeners.forEach((listener) => {
    listener(memoryState);
  });
}
function toast({ ...props }) {
  const id2 = genId();
  const update = (props2) => dispatch({
    type: actionTypes.UPDATE_TOAST,
    toast: { ...props2, id: id2 }
  });
  const dismiss = () => dispatch({ type: actionTypes.DISMISS_TOAST, toastId: id2 });
  dispatch({
    type: actionTypes.ADD_TOAST,
    toast: {
      ...props,
      id: id2,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss();
      }
    }
  });
  return {
    id: id2,
    dismiss,
    update
  };
}
function useToast() {
  const [state, setState] = reactExports.useState(memoryState);
  reactExports.useEffect(() => {
    listeners.push(setState);
    return () => {
      const index2 = listeners.indexOf(setState);
      if (index2 > -1) {
        listeners.splice(index2, 1);
      }
    };
  }, [state]);
  return {
    ...state,
    toast,
    dismiss: (toastId) => dispatch({ type: actionTypes.DISMISS_TOAST, toastId })
  };
}
function DataBackupTab({
  onExportData,
  onExportExcel,
  onImportData,
  onImportExcel,
  onBackupData,
  onRestoreData
}) {
  const { toast: toast2 } = useToast();
  const [activeTab, setActiveTab] = reactExports.useState("import-export");
  const [isImporting, setIsImporting] = reactExports.useState(false);
  const [isRestoring, setIsRestoring] = reactExports.useState(false);
  const jsonImportRef = React$1.useRef(null);
  const excelImportRef = React$1.useRef(null);
  const restoreRef = React$1.useRef(null);
  const handleJsonFileChange = async (e3) => {
    const file = e3.target.files?.[0];
    if (!file) return;
    try {
      setIsImporting(true);
      await onImportData(file);
      toast2({
        title: "Import successful",
        description: "Your data has been imported successfully."
      });
    } catch (error) {
      toast2({
        title: "Import failed",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    } finally {
      setIsImporting(false);
      if (jsonImportRef.current) {
        jsonImportRef.current.value = "";
      }
    }
  };
  const handleExcelFileChange = async (e3) => {
    const file = e3.target.files?.[0];
    if (!file) return;
    try {
      await onImportExcel(file);
    } catch (error) {
      toast2({
        title: "Import failed",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    } finally {
      if (excelImportRef.current) {
        excelImportRef.current.value = "";
      }
    }
  };
  const handleRestore = async (e3) => {
    const file = e3.target.files?.[0];
    if (!file) return;
    try {
      setIsRestoring(true);
      await onRestoreData(file);
      toast2({
        title: "Restore successful",
        description: "Your backup has been restored successfully."
      });
    } catch (error) {
      toast2({
        title: "Restore failed",
        description: error instanceof Error ? error.message : "An unknown error occurred",
        variant: "destructive"
      });
    } finally {
      setIsRestoring(false);
      if (restoreRef.current) {
        restoreRef.current.value = "";
      }
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Data Management" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { children: "Use these tools to import, export, backup, and restore your data. Always create a backup before making significant changes." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "import-export", children: "Import & Export" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "backup-restore", children: "Backup & Restore" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "import-export", className: "space-y-4 pt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FileJson, { className: "h-5 w-5" }),
            "Import & Export Data"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Import data from another system or export your current data in JSON format." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: "Export Data" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Export your current data to a JSON file that can be used for imports." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onExportData,
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  children: "Export as JSON"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  onClick: onExportExcel,
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  children: "Export as Excel"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: "Import Data" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Import data from a JSON file. This will merge with your current data." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  onClick: () => jsonImportRef.current?.click(),
                  children: "Import JSON"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "file",
                  ref: jsonImportRef,
                  onChange: handleJsonFileChange,
                  accept: ".json",
                  className: "hidden"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  onClick: () => excelImportRef.current?.click(),
                  children: "Import Excel"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "file",
                  ref: excelImportRef,
                  onChange: handleExcelFileChange,
                  accept: ".xlsx,.xls",
                  className: "hidden"
                }
              )
            ] })
          ] })
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "backup-restore", className: "space-y-4 pt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardTitle, { className: "flex items-center gap-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Database, { className: "h-5 w-5" }),
            "Backup & Restore"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Create a complete backup of your system or restore from a previous backup." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-4", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: "Create Backup" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Create a complete backup of your data, settings, and configurations." }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Button,
              {
                onClick: onBackupData,
                className: "w-full",
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { className: "mr-2 h-4 w-4" }),
                  "Create Backup"
                ]
              }
            )
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-sm font-medium", children: "Restore Backup" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "Restore your system from a previous backup file." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                onClick: () => restoreRef.current?.click(),
                children: "Restore from Backup"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "input",
              {
                type: "file",
                ref: restoreRef,
                onChange: handleRestore,
                accept: ".json",
                className: "hidden"
              }
            )
          ] })
        ] }) })
      ] }) })
    ] })
  ] });
}
function GeneralSettingsTab({ onOpenCameraSettings }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Camera Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Configure camera settings for scanning QR codes" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: onOpenCameraSettings, variant: "outline", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Camera, { className: "h-4 w-4 mr-2" }),
      "Configure Camera"
    ] }) })
  ] }) });
}
const CAMERA_DEVICE_ID_KEY = "selectedCameraDeviceId";
function CameraSettingsDialog({ isOpen, onClose }) {
  const [devices, setDevices] = reactExports.useState([]);
  const [selectedDeviceId, setSelectedDeviceId] = reactExports.useState("");
  const [initialDeviceId, setInitialDeviceId] = reactExports.useState("");
  reactExports.useEffect(() => {
    const getDevices = async () => {
      try {
        await navigator.mediaDevices.getUserMedia({ video: true });
        const allDevices = await navigator.mediaDevices.enumerateDevices();
        const videoDevices = allDevices.filter((device) => device.kind === "videoinput");
        setDevices(videoDevices);
        const savedDeviceId = localStorage.getItem(CAMERA_DEVICE_ID_KEY) || "";
        setSelectedDeviceId(savedDeviceId);
        setInitialDeviceId(savedDeviceId);
        if (videoDevices.length > 0 && !savedDeviceId) {
          setSelectedDeviceId(videoDevices[0].deviceId);
        }
      } catch (err) {
        console.error("Error accessing media devices:", err);
        ue.error("Could not access cameras. Please check permissions.");
        setDevices([]);
      }
    };
    if (isOpen) {
      getDevices();
    }
  }, [isOpen]);
  const handleSave = () => {
    localStorage.setItem(CAMERA_DEVICE_ID_KEY, selectedDeviceId);
    ue.success("Camera setting saved.");
    onClose();
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isOpen, onOpenChange: (open) => !open && onClose(), children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-[480px]", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Camera Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Select the camera device to use for barcode scanning." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-4 space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "camera-select", children: "Select Camera" }),
      devices.length > 0 ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
        Select,
        {
          value: selectedDeviceId,
          onValueChange: setSelectedDeviceId,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { id: "camera-select", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select a camera" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: devices.map((device) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: device.deviceId, children: device.label || `Camera ${devices.indexOf(device) + 1}` }, device.deviceId)) })
          ]
        }
      ) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "No cameras found or permission denied. Please ensure your browser has camera access." })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onClose, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleSave, disabled: devices.length === 0 || selectedDeviceId === initialDeviceId, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { className: "mr-2 h-4 w-4" }),
        "Save"
      ] })
    ] })
  ] }) });
}
/*! xlsx.js (C) 2013-present SheetJS -- http://sheetjs.com */
var XLSX = {};
XLSX.version = "0.18.5";
var current_ansi = 1252;
var VALID_ANSI = [874, 932, 936, 949, 950, 1250, 1251, 1252, 1253, 1254, 1255, 1256, 1257, 1258, 1e4];
var CS2CP = {
  /*::[*/
  0: 1252,
  /* ANSI */
  /*::[*/
  1: 65001,
  /* DEFAULT */
  /*::[*/
  2: 65001,
  /* SYMBOL */
  /*::[*/
  77: 1e4,
  /* MAC */
  /*::[*/
  128: 932,
  /* SHIFTJIS */
  /*::[*/
  129: 949,
  /* HANGUL */
  /*::[*/
  130: 1361,
  /* JOHAB */
  /*::[*/
  134: 936,
  /* GB2312 */
  /*::[*/
  136: 950,
  /* CHINESEBIG5 */
  /*::[*/
  161: 1253,
  /* GREEK */
  /*::[*/
  162: 1254,
  /* TURKISH */
  /*::[*/
  163: 1258,
  /* VIETNAMESE */
  /*::[*/
  177: 1255,
  /* HEBREW */
  /*::[*/
  178: 1256,
  /* ARABIC */
  /*::[*/
  186: 1257,
  /* BALTIC */
  /*::[*/
  204: 1251,
  /* RUSSIAN */
  /*::[*/
  222: 874,
  /* THAI */
  /*::[*/
  238: 1250,
  /* EASTEUROPE */
  /*::[*/
  255: 1252,
  /* OEM */
  /*::[*/
  69: 6969
  /* MISC */
};
var set_ansi = function(cp) {
  if (VALID_ANSI.indexOf(cp) == -1) return;
  current_ansi = CS2CP[0] = cp;
};
function reset_ansi() {
  set_ansi(1252);
}
var set_cp = function(cp) {
  set_ansi(cp);
};
function reset_cp() {
  set_cp(1200);
  reset_ansi();
}
function char_codes(data) {
  var o2 = [];
  for (var i3 = 0, len = data.length; i3 < len; ++i3) o2[i3] = data.charCodeAt(i3);
  return o2;
}
function utf16leread(data) {
  var o2 = [];
  for (var i3 = 0; i3 < data.length >> 1; ++i3) o2[i3] = String.fromCharCode(data.charCodeAt(2 * i3) + (data.charCodeAt(2 * i3 + 1) << 8));
  return o2.join("");
}
function utf16beread(data) {
  var o2 = [];
  for (var i3 = 0; i3 < data.length >> 1; ++i3) o2[i3] = String.fromCharCode(data.charCodeAt(2 * i3 + 1) + (data.charCodeAt(2 * i3) << 8));
  return o2.join("");
}
var debom = function(data) {
  var c1 = data.charCodeAt(0), c22 = data.charCodeAt(1);
  if (c1 == 255 && c22 == 254) return utf16leread(data.slice(2));
  if (c1 == 254 && c22 == 255) return utf16beread(data.slice(2));
  if (c1 == 65279) return data.slice(1);
  return data;
};
var _getchar = function _gc1(x3) {
  return String.fromCharCode(x3);
};
var _getansi = function _ga1(x3) {
  return String.fromCharCode(x3);
};
var $cptable;
var Base64_map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function Base64_encode(input) {
  var o2 = "";
  var c1 = 0, c22 = 0, c3 = 0, e1 = 0, e22 = 0, e3 = 0, e4 = 0;
  for (var i3 = 0; i3 < input.length; ) {
    c1 = input.charCodeAt(i3++);
    e1 = c1 >> 2;
    c22 = input.charCodeAt(i3++);
    e22 = (c1 & 3) << 4 | c22 >> 4;
    c3 = input.charCodeAt(i3++);
    e3 = (c22 & 15) << 2 | c3 >> 6;
    e4 = c3 & 63;
    if (isNaN(c22)) {
      e3 = e4 = 64;
    } else if (isNaN(c3)) {
      e4 = 64;
    }
    o2 += Base64_map.charAt(e1) + Base64_map.charAt(e22) + Base64_map.charAt(e3) + Base64_map.charAt(e4);
  }
  return o2;
}
function Base64_decode(input) {
  var o2 = "";
  var c1 = 0, c22 = 0, c3 = 0, e1 = 0, e22 = 0, e3 = 0, e4 = 0;
  input = input.replace(/[^\w\+\/\=]/g, "");
  for (var i3 = 0; i3 < input.length; ) {
    e1 = Base64_map.indexOf(input.charAt(i3++));
    e22 = Base64_map.indexOf(input.charAt(i3++));
    c1 = e1 << 2 | e22 >> 4;
    o2 += String.fromCharCode(c1);
    e3 = Base64_map.indexOf(input.charAt(i3++));
    c22 = (e22 & 15) << 4 | e3 >> 2;
    if (e3 !== 64) {
      o2 += String.fromCharCode(c22);
    }
    e4 = Base64_map.indexOf(input.charAt(i3++));
    c3 = (e3 & 3) << 6 | e4;
    if (e4 !== 64) {
      o2 += String.fromCharCode(c3);
    }
  }
  return o2;
}
var has_buf = /* @__PURE__ */ function() {
  return typeof Buffer !== "undefined" && typeof process !== "undefined" && typeof process.versions !== "undefined" && !!process.versions.node;
}();
var Buffer_from = /* @__PURE__ */ function() {
  if (typeof Buffer !== "undefined") {
    var nbfs = !Buffer.from;
    if (!nbfs) try {
      Buffer.from("foo", "utf8");
    } catch (e3) {
      nbfs = true;
    }
    return nbfs ? function(buf, enc) {
      return enc ? new Buffer(buf, enc) : new Buffer(buf);
    } : Buffer.from.bind(Buffer);
  }
  return function() {
  };
}();
function new_raw_buf(len) {
  if (has_buf) return Buffer.alloc ? Buffer.alloc(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
function new_unsafe_buf(len) {
  if (has_buf) return Buffer.allocUnsafe ? Buffer.allocUnsafe(len) : new Buffer(len);
  return typeof Uint8Array != "undefined" ? new Uint8Array(len) : new Array(len);
}
var s2a = function s2a2(s4) {
  if (has_buf) return Buffer_from(s4, "binary");
  return s4.split("").map(function(x3) {
    return x3.charCodeAt(0) & 255;
  });
};
function s2ab(s4) {
  if (typeof ArrayBuffer === "undefined") return s2a(s4);
  var buf = new ArrayBuffer(s4.length), view = new Uint8Array(buf);
  for (var i3 = 0; i3 != s4.length; ++i3) view[i3] = s4.charCodeAt(i3) & 255;
  return buf;
}
function a2s(data) {
  if (Array.isArray(data)) return data.map(function(c3) {
    return String.fromCharCode(c3);
  }).join("");
  var o2 = [];
  for (var i3 = 0; i3 < data.length; ++i3) o2[i3] = String.fromCharCode(data[i3]);
  return o2.join("");
}
function a2u(data) {
  if (typeof Uint8Array === "undefined") throw new Error("Unsupported");
  return new Uint8Array(data);
}
function ab2a(data) {
  if (typeof ArrayBuffer == "undefined") throw new Error("Unsupported");
  if (data instanceof ArrayBuffer) return ab2a(new Uint8Array(data));
  var o2 = new Array(data.length);
  for (var i3 = 0; i3 < data.length; ++i3) o2[i3] = data[i3];
  return o2;
}
var bconcat = has_buf ? function(bufs) {
  return Buffer.concat(bufs.map(function(buf) {
    return Buffer.isBuffer(buf) ? buf : Buffer_from(buf);
  }));
} : function(bufs) {
  if (typeof Uint8Array !== "undefined") {
    var i3 = 0, maxlen = 0;
    for (i3 = 0; i3 < bufs.length; ++i3) maxlen += bufs[i3].length;
    var o2 = new Uint8Array(maxlen);
    var len = 0;
    for (i3 = 0, maxlen = 0; i3 < bufs.length; maxlen += len, ++i3) {
      len = bufs[i3].length;
      if (bufs[i3] instanceof Uint8Array) o2.set(bufs[i3], maxlen);
      else if (typeof bufs[i3] == "string") {
        throw "wtf";
      } else o2.set(new Uint8Array(bufs[i3]), maxlen);
    }
    return o2;
  }
  return [].concat.apply([], bufs.map(function(buf) {
    return Array.isArray(buf) ? buf : [].slice.call(buf);
  }));
};
function utf8decode(content) {
  var out = [], widx = 0, L3 = content.length + 250;
  var o2 = new_raw_buf(content.length + 255);
  for (var ridx = 0; ridx < content.length; ++ridx) {
    var c3 = content.charCodeAt(ridx);
    if (c3 < 128) o2[widx++] = c3;
    else if (c3 < 2048) {
      o2[widx++] = 192 | c3 >> 6 & 31;
      o2[widx++] = 128 | c3 & 63;
    } else if (c3 >= 55296 && c3 < 57344) {
      c3 = (c3 & 1023) + 64;
      var d4 = content.charCodeAt(++ridx) & 1023;
      o2[widx++] = 240 | c3 >> 8 & 7;
      o2[widx++] = 128 | c3 >> 2 & 63;
      o2[widx++] = 128 | d4 >> 6 & 15 | (c3 & 3) << 4;
      o2[widx++] = 128 | d4 & 63;
    } else {
      o2[widx++] = 224 | c3 >> 12 & 15;
      o2[widx++] = 128 | c3 >> 6 & 63;
      o2[widx++] = 128 | c3 & 63;
    }
    if (widx > L3) {
      out.push(o2.slice(0, widx));
      widx = 0;
      o2 = new_raw_buf(65535);
      L3 = 65530;
    }
  }
  out.push(o2.slice(0, widx));
  return bconcat(out);
}
var chr0 = /\u0000/g, chr1 = /[\u0001-\u0006]/g;
function _strrev(x3) {
  var o2 = "", i3 = x3.length - 1;
  while (i3 >= 0) o2 += x3.charAt(i3--);
  return o2;
}
function pad0(v2, d4) {
  var t3 = "" + v2;
  return t3.length >= d4 ? t3 : fill("0", d4 - t3.length) + t3;
}
function pad_(v2, d4) {
  var t3 = "" + v2;
  return t3.length >= d4 ? t3 : fill(" ", d4 - t3.length) + t3;
}
function rpad_(v2, d4) {
  var t3 = "" + v2;
  return t3.length >= d4 ? t3 : t3 + fill(" ", d4 - t3.length);
}
function pad0r1(v2, d4) {
  var t3 = "" + Math.round(v2);
  return t3.length >= d4 ? t3 : fill("0", d4 - t3.length) + t3;
}
function pad0r2(v2, d4) {
  var t3 = "" + v2;
  return t3.length >= d4 ? t3 : fill("0", d4 - t3.length) + t3;
}
var p2_32 = /* @__PURE__ */ Math.pow(2, 32);
function pad0r(v2, d4) {
  if (v2 > p2_32 || v2 < -p2_32) return pad0r1(v2, d4);
  var i3 = Math.round(v2);
  return pad0r2(i3, d4);
}
function SSF_isgeneral(s4, i3) {
  i3 = i3 || 0;
  return s4.length >= 7 + i3 && (s4.charCodeAt(i3) | 32) === 103 && (s4.charCodeAt(i3 + 1) | 32) === 101 && (s4.charCodeAt(i3 + 2) | 32) === 110 && (s4.charCodeAt(i3 + 3) | 32) === 101 && (s4.charCodeAt(i3 + 4) | 32) === 114 && (s4.charCodeAt(i3 + 5) | 32) === 97 && (s4.charCodeAt(i3 + 6) | 32) === 108;
}
var days = [
  ["Sun", "Sunday"],
  ["Mon", "Monday"],
  ["Tue", "Tuesday"],
  ["Wed", "Wednesday"],
  ["Thu", "Thursday"],
  ["Fri", "Friday"],
  ["Sat", "Saturday"]
];
var months = [
  ["J", "Jan", "January"],
  ["F", "Feb", "February"],
  ["M", "Mar", "March"],
  ["A", "Apr", "April"],
  ["M", "May", "May"],
  ["J", "Jun", "June"],
  ["J", "Jul", "July"],
  ["A", "Aug", "August"],
  ["S", "Sep", "September"],
  ["O", "Oct", "October"],
  ["N", "Nov", "November"],
  ["D", "Dec", "December"]
];
function SSF_init_table(t3) {
  if (!t3) t3 = {};
  t3[0] = "General";
  t3[1] = "0";
  t3[2] = "0.00";
  t3[3] = "#,##0";
  t3[4] = "#,##0.00";
  t3[9] = "0%";
  t3[10] = "0.00%";
  t3[11] = "0.00E+00";
  t3[12] = "# ?/?";
  t3[13] = "# ??/??";
  t3[14] = "m/d/yy";
  t3[15] = "d-mmm-yy";
  t3[16] = "d-mmm";
  t3[17] = "mmm-yy";
  t3[18] = "h:mm AM/PM";
  t3[19] = "h:mm:ss AM/PM";
  t3[20] = "h:mm";
  t3[21] = "h:mm:ss";
  t3[22] = "m/d/yy h:mm";
  t3[37] = "#,##0 ;(#,##0)";
  t3[38] = "#,##0 ;[Red](#,##0)";
  t3[39] = "#,##0.00;(#,##0.00)";
  t3[40] = "#,##0.00;[Red](#,##0.00)";
  t3[45] = "mm:ss";
  t3[46] = "[h]:mm:ss";
  t3[47] = "mmss.0";
  t3[48] = "##0.0E+0";
  t3[49] = "@";
  t3[56] = '"上午/下午 "hh"時"mm"分"ss"秒 "';
  return t3;
}
var table_fmt = {
  0: "General",
  1: "0",
  2: "0.00",
  3: "#,##0",
  4: "#,##0.00",
  9: "0%",
  10: "0.00%",
  11: "0.00E+00",
  12: "# ?/?",
  13: "# ??/??",
  14: "m/d/yy",
  15: "d-mmm-yy",
  16: "d-mmm",
  17: "mmm-yy",
  18: "h:mm AM/PM",
  19: "h:mm:ss AM/PM",
  20: "h:mm",
  21: "h:mm:ss",
  22: "m/d/yy h:mm",
  37: "#,##0 ;(#,##0)",
  38: "#,##0 ;[Red](#,##0)",
  39: "#,##0.00;(#,##0.00)",
  40: "#,##0.00;[Red](#,##0.00)",
  45: "mm:ss",
  46: "[h]:mm:ss",
  47: "mmss.0",
  48: "##0.0E+0",
  49: "@",
  56: '"上午/下午 "hh"時"mm"分"ss"秒 "'
};
var SSF_default_map = {
  5: 37,
  6: 38,
  7: 39,
  8: 40,
  //  5 -> 37 ...  8 -> 40
  23: 0,
  24: 0,
  25: 0,
  26: 0,
  // 23 ->  0 ... 26 ->  0
  27: 14,
  28: 14,
  29: 14,
  30: 14,
  31: 14,
  // 27 -> 14 ... 31 -> 14
  50: 14,
  51: 14,
  52: 14,
  53: 14,
  54: 14,
  // 50 -> 14 ... 58 -> 14
  55: 14,
  56: 14,
  57: 14,
  58: 14,
  59: 1,
  60: 2,
  61: 3,
  62: 4,
  // 59 ->  1 ... 62 ->  4
  67: 9,
  68: 10,
  // 67 ->  9 ... 68 -> 10
  69: 12,
  70: 13,
  71: 14,
  // 69 -> 12 ... 71 -> 14
  72: 14,
  73: 15,
  74: 16,
  75: 17,
  // 72 -> 14 ... 75 -> 17
  76: 20,
  77: 21,
  78: 22,
  // 76 -> 20 ... 78 -> 22
  79: 45,
  80: 46,
  81: 47,
  // 79 -> 45 ... 81 -> 47
  82: 0
  // 82 ->  0 ... 65536 -> 0 (omitted)
};
var SSF_default_str = {
  //  5 -- Currency,   0 decimal, black negative
  5: '"$"#,##0_);\\("$"#,##0\\)',
  63: '"$"#,##0_);\\("$"#,##0\\)',
  //  6 -- Currency,   0 decimal, red   negative
  6: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  64: '"$"#,##0_);[Red]\\("$"#,##0\\)',
  //  7 -- Currency,   2 decimal, black negative
  7: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  65: '"$"#,##0.00_);\\("$"#,##0.00\\)',
  //  8 -- Currency,   2 decimal, red   negative
  8: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  66: '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  // 41 -- Accounting, 0 decimal, No Symbol
  41: '_(* #,##0_);_(* \\(#,##0\\);_(* "-"_);_(@_)',
  // 42 -- Accounting, 0 decimal, $  Symbol
  42: '_("$"* #,##0_);_("$"* \\(#,##0\\);_("$"* "-"_);_(@_)',
  // 43 -- Accounting, 2 decimal, No Symbol
  43: '_(* #,##0.00_);_(* \\(#,##0.00\\);_(* "-"??_);_(@_)',
  // 44 -- Accounting, 2 decimal, $  Symbol
  44: '_("$"* #,##0.00_);_("$"* \\(#,##0.00\\);_("$"* "-"??_);_(@_)'
};
function SSF_frac(x3, D3, mixed) {
  var sgn = x3 < 0 ? -1 : 1;
  var B3 = x3 * sgn;
  var P_2 = 0, P_1 = 1, P2 = 0;
  var Q_2 = 1, Q_1 = 0, Q3 = 0;
  var A2 = Math.floor(B3);
  while (Q_1 < D3) {
    A2 = Math.floor(B3);
    P2 = A2 * P_1 + P_2;
    Q3 = A2 * Q_1 + Q_2;
    if (B3 - A2 < 5e-8) break;
    B3 = 1 / (B3 - A2);
    P_2 = P_1;
    P_1 = P2;
    Q_2 = Q_1;
    Q_1 = Q3;
  }
  if (Q3 > D3) {
    if (Q_1 > D3) {
      Q3 = Q_2;
      P2 = P_2;
    } else {
      Q3 = Q_1;
      P2 = P_1;
    }
  }
  if (!mixed) return [0, sgn * P2, Q3];
  var q3 = Math.floor(sgn * P2 / Q3);
  return [q3, sgn * P2 - q3 * Q3, Q3];
}
function SSF_parse_date_code(v2, opts, b2) {
  if (v2 > 2958465 || v2 < 0) return null;
  var date = v2 | 0, time = Math.floor(86400 * (v2 - date)), dow = 0;
  var dout = [];
  var out = { D: date, T: time, u: 86400 * (v2 - date) - time, y: 0, m: 0, d: 0, H: 0, M: 0, S: 0, q: 0 };
  if (Math.abs(out.u) < 1e-6) out.u = 0;
  if (opts && opts.date1904) date += 1462;
  if (out.u > 0.9999) {
    out.u = 0;
    if (++time == 86400) {
      out.T = time = 0;
      ++date;
      ++out.D;
    }
  }
  if (date === 60) {
    dout = b2 ? [1317, 10, 29] : [1900, 2, 29];
    dow = 3;
  } else if (date === 0) {
    dout = b2 ? [1317, 8, 29] : [1900, 1, 0];
    dow = 6;
  } else {
    if (date > 60) --date;
    var d4 = new Date(1900, 0, 1);
    d4.setDate(d4.getDate() + date - 1);
    dout = [d4.getFullYear(), d4.getMonth() + 1, d4.getDate()];
    dow = d4.getDay();
    if (date < 60) dow = (dow + 6) % 7;
    if (b2) dow = SSF_fix_hijri(d4, dout);
  }
  out.y = dout[0];
  out.m = dout[1];
  out.d = dout[2];
  out.S = time % 60;
  time = Math.floor(time / 60);
  out.M = time % 60;
  time = Math.floor(time / 60);
  out.H = time;
  out.q = dow;
  return out;
}
var SSFbasedate = /* @__PURE__ */ new Date(1899, 11, 31, 0, 0, 0);
var SSFdnthresh = /* @__PURE__ */ SSFbasedate.getTime();
var SSFbase1904 = /* @__PURE__ */ new Date(1900, 2, 1, 0, 0, 0);
function datenum_local(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  if (date1904) epoch -= 1461 * 24 * 60 * 60 * 1e3;
  else if (v2 >= SSFbase1904) epoch += 24 * 60 * 60 * 1e3;
  return (epoch - (SSFdnthresh + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ SSFbasedate.getTimezoneOffset()) * 6e4)) / (24 * 60 * 60 * 1e3);
}
function SSF_strip_decimal(o2) {
  return o2.indexOf(".") == -1 ? o2 : o2.replace(/(?:\.0*|(\.\d*[1-9])0+)$/, "$1");
}
function SSF_normalize_exp(o2) {
  if (o2.indexOf("E") == -1) return o2;
  return o2.replace(/(?:\.0*|(\.\d*[1-9])0+)[Ee]/, "$1E").replace(/(E[+-])(\d)$/, "$10$2");
}
function SSF_small_exp(v2) {
  var w3 = v2 < 0 ? 12 : 11;
  var o2 = SSF_strip_decimal(v2.toFixed(12));
  if (o2.length <= w3) return o2;
  o2 = v2.toPrecision(10);
  if (o2.length <= w3) return o2;
  return v2.toExponential(5);
}
function SSF_large_exp(v2) {
  var o2 = SSF_strip_decimal(v2.toFixed(11));
  return o2.length > (v2 < 0 ? 12 : 11) || o2 === "0" || o2 === "-0" ? v2.toPrecision(6) : o2;
}
function SSF_general_num(v2) {
  var V2 = Math.floor(Math.log(Math.abs(v2)) * Math.LOG10E), o2;
  if (V2 >= -4 && V2 <= -1) o2 = v2.toPrecision(10 + V2);
  else if (Math.abs(V2) <= 9) o2 = SSF_small_exp(v2);
  else if (V2 === 10) o2 = v2.toFixed(10).substr(0, 12);
  else o2 = SSF_large_exp(v2);
  return SSF_strip_decimal(SSF_normalize_exp(o2.toUpperCase()));
}
function SSF_general(v2, opts) {
  switch (typeof v2) {
    case "string":
      return v2;
    case "boolean":
      return v2 ? "TRUE" : "FALSE";
    case "number":
      return (v2 | 0) === v2 ? v2.toString(10) : SSF_general_num(v2);
    case "undefined":
      return "";
    case "object":
      if (v2 == null) return "";
      if (v2 instanceof Date) return SSF_format(14, datenum_local(v2, opts && opts.date1904), opts);
  }
  throw new Error("unsupported value in General format: " + v2);
}
function SSF_fix_hijri(date, o2) {
  o2[0] -= 581;
  var dow = date.getDay();
  if (date < 60) dow = (dow + 6) % 7;
  return dow;
}
function SSF_write_date(type, fmt, val, ss0) {
  var o2 = "", ss = 0, tt2 = 0, y4 = val.y, out, outl = 0;
  switch (type) {
    case 98:
      y4 = val.y + 543;
    case 121:
      switch (fmt.length) {
        case 1:
        case 2:
          out = y4 % 100;
          outl = 2;
          break;
        default:
          out = y4 % 1e4;
          outl = 4;
          break;
      }
      break;
    case 109:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.m;
          outl = fmt.length;
          break;
        case 3:
          return months[val.m - 1][1];
        case 5:
          return months[val.m - 1][0];
        default:
          return months[val.m - 1][2];
      }
      break;
    case 100:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.d;
          outl = fmt.length;
          break;
        case 3:
          return days[val.q][0];
        default:
          return days[val.q][1];
      }
      break;
    case 104:
      switch (fmt.length) {
        case 1:
        case 2:
          out = 1 + (val.H + 11) % 12;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 72:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.H;
          outl = fmt.length;
          break;
        default:
          throw "bad hour format: " + fmt;
      }
      break;
    case 77:
      switch (fmt.length) {
        case 1:
        case 2:
          out = val.M;
          outl = fmt.length;
          break;
        default:
          throw "bad minute format: " + fmt;
      }
      break;
    case 115:
      if (fmt != "s" && fmt != "ss" && fmt != ".0" && fmt != ".00" && fmt != ".000") throw "bad second format: " + fmt;
      if (val.u === 0 && (fmt == "s" || fmt == "ss")) return pad0(val.S, fmt.length);
      if (ss0 >= 2) tt2 = ss0 === 3 ? 1e3 : 100;
      else tt2 = ss0 === 1 ? 10 : 1;
      ss = Math.round(tt2 * (val.S + val.u));
      if (ss >= 60 * tt2) ss = 0;
      if (fmt === "s") return ss === 0 ? "0" : "" + ss / tt2;
      o2 = pad0(ss, 2 + ss0);
      if (fmt === "ss") return o2.substr(0, 2);
      return "." + o2.substr(2, fmt.length - 1);
    case 90:
      switch (fmt) {
        case "[h]":
        case "[hh]":
          out = val.D * 24 + val.H;
          break;
        case "[m]":
        case "[mm]":
          out = (val.D * 24 + val.H) * 60 + val.M;
          break;
        case "[s]":
        case "[ss]":
          out = ((val.D * 24 + val.H) * 60 + val.M) * 60 + Math.round(val.S + val.u);
          break;
        default:
          throw "bad abstime format: " + fmt;
      }
      outl = fmt.length === 3 ? 1 : 2;
      break;
    case 101:
      out = y4;
      outl = 1;
      break;
  }
  var outstr = outl > 0 ? pad0(out, outl) : "";
  return outstr;
}
function commaify(s4) {
  var w3 = 3;
  if (s4.length <= w3) return s4;
  var j2 = s4.length % w3, o2 = s4.substr(0, j2);
  for (; j2 != s4.length; j2 += w3) o2 += (o2.length > 0 ? "," : "") + s4.substr(j2, w3);
  return o2;
}
var pct1 = /%/g;
function write_num_pct(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_cm(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_exp(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (o2.indexOf("e") === -1) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else o2 += "E+" + (fakee - ee2);
      while (o2.substr(0, 2) === "0.") {
        o2 = o2.charAt(0) + o2.substr(2, period) + "." + o2.substr(2 + period);
        o2 = o2.replace(/^0+([1-9])/, "$1").replace(/^0+\./, "0.");
      }
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
var frac1 = /# (\?+)( ?)\/( ?)(\d+)/;
function write_num_f1(r2, aval, sign) {
  var den = parseInt(r2[4], 10), rr = Math.round(aval * den), base = Math.floor(rr / den);
  var myn = rr - base * den, myd = den;
  return sign + (base === 0 ? "" : "" + base) + " " + (myn === 0 ? fill(" ", r2[1].length + 1 + r2[4].length) : pad_(myn, r2[1].length) + r2[2] + "/" + r2[3] + pad0(myd, r2[4].length));
}
function write_num_f2(r2, aval, sign) {
  return sign + (aval === 0 ? "" : "" + aval) + fill(" ", r2[1].length + 2 + r2[4].length);
}
var dec1 = /^#*0*\.([0#]+)/;
var closeparen = /\).*[0#]/;
var phone = /\(###\) ###\\?-####/;
function hashq(str) {
  var o2 = "", cc2;
  for (var i3 = 0; i3 != str.length; ++i3) switch (cc2 = str.charCodeAt(i3)) {
    case 35:
      break;
    case 63:
      o2 += " ";
      break;
    case 48:
      o2 += "0";
      break;
    default:
      o2 += String.fromCharCode(cc2);
  }
  return o2;
}
function rnd(val, d4) {
  var dd2 = Math.pow(10, d4);
  return "" + Math.round(val * dd2) / dd2;
}
function dec(val, d4) {
  var _frac = val - Math.floor(val), dd2 = Math.pow(10, d4);
  if (d4 < ("" + Math.round(_frac * dd2)).length) return 0;
  return Math.round(_frac * dd2);
}
function carry(val, d4) {
  if (d4 < ("" + Math.round((val - Math.floor(val)) * Math.pow(10, d4))).length) {
    return 1;
  }
  return 0;
}
function flr(val) {
  if (val < 2147483647 && val > -2147483648) return "" + (val >= 0 ? val | 0 : val - 1 | 0);
  return "" + Math.floor(val);
}
function write_num_flt(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_flt("n", ffmt, val);
    return "(" + write_num_flt("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_flt(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r2, ri2, ff2, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign + pad0r(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = pad0r(val, 0);
    if (o2 === "0") o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(frac1)) return write_num_f1(r2, aval, sign);
  if (fmt.match(/^#+0+$/)) return sign + pad0r(aval, fmt.length - fmt.indexOf("0"));
  if (r2 = fmt.match(dec1)) {
    o2 = rnd(val, r2[1].length).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1])).replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(
        /*::(*/
        r2[1]
      ).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + rnd(aval, r2[2].length).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
  }
  if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify(pad0r(aval, 0));
  if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify("" + (Math.floor(val) + carry(val, r2[1].length))) + "." + pad0(dec(val, r2[1].length), r2[1].length);
  }
  if (r2 = fmt.match(/^#,#*,#0/)) return write_num_flt(type, fmt.replace(/^#,#*,/, ""), val);
  if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_flt(type, fmt.replace(/[\\-]/g, ""), val));
    ri2 = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x4) {
      return ri2 < o2.length ? o2.charAt(ri2++) : x4 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_flt(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa2 = "";
  if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri2 = Math.min(
      /*::String(*/
      r2[4].length,
      7
    );
    ff2 = SSF_frac(aval, Math.pow(10, ri2) - 1, false);
    o2 = "" + sign;
    oa2 = write_num(
      "n",
      /*::String(*/
      r2[1],
      ff2[1]
    );
    if (oa2.charAt(oa2.length - 1) == " ") oa2 = oa2.substr(0, oa2.length - 1) + "0";
    o2 += oa2 + /*::String(*/
    r2[2] + "/" + /*::String(*/
    r2[3];
    oa2 = rpad_(ff2[2], ri2);
    if (oa2.length < r2[4].length) oa2 = hashq(r2[4].substr(r2[4].length - oa2.length)) + oa2;
    o2 += oa2;
    return o2;
  }
  if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri2 = Math.min(Math.max(r2[1].length, r2[4].length), 7);
    ff2 = SSF_frac(aval, Math.pow(10, ri2) - 1, true);
    return sign + (ff2[0] || (ff2[1] ? "" : "0")) + " " + (ff2[1] ? pad_(ff2[1], ri2) + r2[2] + "/" + r2[3] + rpad_(ff2[2], ri2) : fill(" ", 2 * ri2 + 1 + r2[2].length + r2[3].length));
  }
  if (r2 = fmt.match(/^[#0?]+$/)) {
    o2 = pad0r(val, 0);
    if (fmt.length <= o2.length) return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(/^([#0?]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri2 = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri2, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
    ri2 = dec(val, r2[1].length);
    return val < 0 ? "-" + write_num_flt(type, fmt, -val) : commaify(flr(val)).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(ri2, r2[1].length);
  }
  switch (fmt) {
    case "###,##0.00":
      return write_num_flt(type, "#,##0.00", val);
    case "###,###":
    case "##,###":
    case "#,###":
      var x3 = commaify(pad0r(aval, 0));
      return x3 !== "0" ? sign + x3 : "";
    case "###,###.00":
      return write_num_flt(type, "###,##0.00", val).replace(/^0\./, ".");
    case "#,###.00":
      return write_num_flt(type, "#,##0.00", val).replace(/^0\./, ".");
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num_cm2(type, fmt, val) {
  var idx = fmt.length - 1;
  while (fmt.charCodeAt(idx - 1) === 44) --idx;
  return write_num(type, fmt.substr(0, idx), val / Math.pow(10, 3 * (fmt.length - idx)));
}
function write_num_pct2(type, fmt, val) {
  var sfmt = fmt.replace(pct1, ""), mul = fmt.length - sfmt.length;
  return write_num(type, sfmt, val * Math.pow(10, 2 * mul)) + fill("%", mul);
}
function write_num_exp2(fmt, val) {
  var o2;
  var idx = fmt.indexOf("E") - fmt.indexOf(".") - 1;
  if (fmt.match(/^#+0.0E\+0$/)) {
    if (val == 0) return "0.0E+0";
    else if (val < 0) return "-" + write_num_exp2(fmt, -val);
    var period = fmt.indexOf(".");
    if (period === -1) period = fmt.indexOf("E");
    var ee2 = Math.floor(Math.log(val) * Math.LOG10E) % period;
    if (ee2 < 0) ee2 += period;
    o2 = (val / Math.pow(10, ee2)).toPrecision(idx + 1 + (period + ee2) % period);
    if (!o2.match(/[Ee]/)) {
      var fakee = Math.floor(Math.log(val) * Math.LOG10E);
      if (o2.indexOf(".") === -1) o2 = o2.charAt(0) + "." + o2.substr(1) + "E+" + (fakee - o2.length + ee2);
      else o2 += "E+" + (fakee - ee2);
      o2 = o2.replace(/\+-/, "-");
    }
    o2 = o2.replace(/^([+-]?)(\d*)\.(\d*)[Ee]/, function($$, $1, $2, $3) {
      return $1 + $2 + $3.substr(0, (period + ee2) % period) + "." + $3.substr(ee2) + "E";
    });
  } else o2 = val.toExponential(idx);
  if (fmt.match(/E\+00$/) && o2.match(/e[+-]\d$/)) o2 = o2.substr(0, o2.length - 1) + "0" + o2.charAt(o2.length - 1);
  if (fmt.match(/E\-/) && o2.match(/e\+/)) o2 = o2.replace(/e\+/, "e");
  return o2.replace("e", "E");
}
function write_num_int(type, fmt, val) {
  if (type.charCodeAt(0) === 40 && !fmt.match(closeparen)) {
    var ffmt = fmt.replace(/\( */, "").replace(/ \)/, "").replace(/\)/, "");
    if (val >= 0) return write_num_int("n", ffmt, val);
    return "(" + write_num_int("n", ffmt, -val) + ")";
  }
  if (fmt.charCodeAt(fmt.length - 1) === 44) return write_num_cm2(type, fmt, val);
  if (fmt.indexOf("%") !== -1) return write_num_pct2(type, fmt, val);
  if (fmt.indexOf("E") !== -1) return write_num_exp2(fmt, val);
  if (fmt.charCodeAt(0) === 36) return "$" + write_num_int(type, fmt.substr(fmt.charAt(1) == " " ? 2 : 1), val);
  var o2;
  var r2, ri2, ff2, aval = Math.abs(val), sign = val < 0 ? "-" : "";
  if (fmt.match(/^00+$/)) return sign + pad0(aval, fmt.length);
  if (fmt.match(/^[#?]+$/)) {
    o2 = "" + val;
    if (val === 0) o2 = "";
    return o2.length > fmt.length ? o2 : hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(frac1)) return write_num_f2(r2, aval, sign);
  if (fmt.match(/^#+0+$/)) return sign + pad0(aval, fmt.length - fmt.indexOf("0"));
  if (r2 = fmt.match(dec1)) {
    o2 = ("" + val).replace(/^([^\.]+)$/, "$1." + hashq(r2[1])).replace(/\.$/, "." + hashq(r2[1]));
    o2 = o2.replace(/\.(\d*)$/, function($$, $1) {
      return "." + $1 + fill("0", hashq(r2[1]).length - $1.length);
    });
    return fmt.indexOf("0.") !== -1 ? o2 : o2.replace(/^0\./, ".");
  }
  fmt = fmt.replace(/^#+([0.])/, "$1");
  if (r2 = fmt.match(/^(0*)\.(#*)$/)) {
    return sign + ("" + aval).replace(/\.(\d*[1-9])0*$/, ".$1").replace(/^(-?\d*)$/, "$1.").replace(/^0\./, r2[1].length ? "0." : ".");
  }
  if (r2 = fmt.match(/^#{1,3},##0(\.?)$/)) return sign + commaify("" + aval);
  if (r2 = fmt.match(/^#,##0\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val) + "." + fill("0", r2[1].length);
  }
  if (r2 = fmt.match(/^#,#*,#0/)) return write_num_int(type, fmt.replace(/^#,#*,/, ""), val);
  if (r2 = fmt.match(/^([0#]+)(\\?-([0#]+))+$/)) {
    o2 = _strrev(write_num_int(type, fmt.replace(/[\\-]/g, ""), val));
    ri2 = 0;
    return _strrev(_strrev(fmt.replace(/\\/g, "")).replace(/[0#]/g, function(x4) {
      return ri2 < o2.length ? o2.charAt(ri2++) : x4 === "0" ? "0" : "";
    }));
  }
  if (fmt.match(phone)) {
    o2 = write_num_int(type, "##########", val);
    return "(" + o2.substr(0, 3) + ") " + o2.substr(3, 3) + "-" + o2.substr(6);
  }
  var oa2 = "";
  if (r2 = fmt.match(/^([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri2 = Math.min(
      /*::String(*/
      r2[4].length,
      7
    );
    ff2 = SSF_frac(aval, Math.pow(10, ri2) - 1, false);
    o2 = "" + sign;
    oa2 = write_num(
      "n",
      /*::String(*/
      r2[1],
      ff2[1]
    );
    if (oa2.charAt(oa2.length - 1) == " ") oa2 = oa2.substr(0, oa2.length - 1) + "0";
    o2 += oa2 + /*::String(*/
    r2[2] + "/" + /*::String(*/
    r2[3];
    oa2 = rpad_(ff2[2], ri2);
    if (oa2.length < r2[4].length) oa2 = hashq(r2[4].substr(r2[4].length - oa2.length)) + oa2;
    o2 += oa2;
    return o2;
  }
  if (r2 = fmt.match(/^# ([#0?]+)( ?)\/( ?)([#0?]+)/)) {
    ri2 = Math.min(Math.max(r2[1].length, r2[4].length), 7);
    ff2 = SSF_frac(aval, Math.pow(10, ri2) - 1, true);
    return sign + (ff2[0] || (ff2[1] ? "" : "0")) + " " + (ff2[1] ? pad_(ff2[1], ri2) + r2[2] + "/" + r2[3] + rpad_(ff2[2], ri2) : fill(" ", 2 * ri2 + 1 + r2[2].length + r2[3].length));
  }
  if (r2 = fmt.match(/^[#0?]+$/)) {
    o2 = "" + val;
    if (fmt.length <= o2.length) return o2;
    return hashq(fmt.substr(0, fmt.length - o2.length)) + o2;
  }
  if (r2 = fmt.match(/^([#0]+)\.([#0]+)$/)) {
    o2 = "" + val.toFixed(Math.min(r2[2].length, 10)).replace(/([^0])0+$/, "$1");
    ri2 = o2.indexOf(".");
    var lres = fmt.indexOf(".") - ri2, rres = fmt.length - o2.length - lres;
    return hashq(fmt.substr(0, lres) + o2 + fmt.substr(fmt.length - rres));
  }
  if (r2 = fmt.match(/^00,000\.([#0]*0)$/)) {
    return val < 0 ? "-" + write_num_int(type, fmt, -val) : commaify("" + val).replace(/^\d,\d{3}$/, "0$&").replace(/^\d*$/, function($$) {
      return "00," + ($$.length < 3 ? pad0(0, 3 - $$.length) : "") + $$;
    }) + "." + pad0(0, r2[1].length);
  }
  switch (fmt) {
    case "###,###":
    case "##,###":
    case "#,###":
      var x3 = commaify("" + aval);
      return x3 !== "0" ? sign + x3 : "";
    default:
      if (fmt.match(/\.[0#?]*$/)) return write_num_int(type, fmt.slice(0, fmt.lastIndexOf(".")), val) + hashq(fmt.slice(fmt.lastIndexOf(".")));
  }
  throw new Error("unsupported format |" + fmt + "|");
}
function write_num(type, fmt, val) {
  return (val | 0) === val ? write_num_int(type, fmt, val) : write_num_flt(type, fmt, val);
}
function SSF_split_fmt(fmt) {
  var out = [];
  var in_str = false;
  for (var i3 = 0, j2 = 0; i3 < fmt.length; ++i3) switch (
    /*cc=*/
    fmt.charCodeAt(i3)
  ) {
    case 34:
      in_str = !in_str;
      break;
    case 95:
    case 42:
    case 92:
      ++i3;
      break;
    case 59:
      out[out.length] = fmt.substr(j2, i3 - j2);
      j2 = i3 + 1;
  }
  out[out.length] = fmt.substr(j2);
  if (in_str === true) throw new Error("Format |" + fmt + "| unterminated string ");
  return out;
}
var SSF_abstime = /\[[HhMmSs\u0E0A\u0E19\u0E17]*\]/;
function fmt_is_date(fmt) {
  var i3 = 0, c3 = "", o2 = "";
  while (i3 < fmt.length) {
    switch (c3 = fmt.charAt(i3)) {
      case "G":
        if (SSF_isgeneral(fmt, i3)) i3 += 6;
        i3++;
        break;
      case '"':
        for (
          ;
          /*cc=*/
          fmt.charCodeAt(++i3) !== 34 && i3 < fmt.length;
        ) {
        }
        ++i3;
        break;
      case "\\":
        i3 += 2;
        break;
      case "_":
        i3 += 2;
        break;
      case "@":
        ++i3;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i3 + 1) === "1" || fmt.charAt(i3 + 1) === "2") return true;
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        return true;
      case "A":
      case "a":
      case "上":
        if (fmt.substr(i3, 3).toUpperCase() === "A/P") return true;
        if (fmt.substr(i3, 5).toUpperCase() === "AM/PM") return true;
        if (fmt.substr(i3, 5).toUpperCase() === "上午/下午") return true;
        ++i3;
        break;
      case "[":
        o2 = c3;
        while (fmt.charAt(i3++) !== "]" && i3 < fmt.length) o2 += fmt.charAt(i3);
        if (o2.match(SSF_abstime)) return true;
        break;
      case ".":
      case "0":
      case "#":
        while (i3 < fmt.length && ("0#?.,E+-%".indexOf(c3 = fmt.charAt(++i3)) > -1 || c3 == "\\" && fmt.charAt(i3 + 1) == "-" && "0#".indexOf(fmt.charAt(i3 + 2)) > -1)) {
        }
        break;
      case "?":
        while (fmt.charAt(++i3) === c3) {
        }
        break;
      case "*":
        ++i3;
        if (fmt.charAt(i3) == " " || fmt.charAt(i3) == "*") ++i3;
        break;
      case "(":
      case ")":
        ++i3;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        while (i3 < fmt.length && "0123456789".indexOf(fmt.charAt(++i3)) > -1) {
        }
        break;
      case " ":
        ++i3;
        break;
      default:
        ++i3;
        break;
    }
  }
  return false;
}
function eval_fmt(fmt, v2, opts, flen) {
  var out = [], o2 = "", i3 = 0, c3 = "", lst = "t", dt, j2, cc2;
  var hr = "H";
  while (i3 < fmt.length) {
    switch (c3 = fmt.charAt(i3)) {
      case "G":
        if (!SSF_isgeneral(fmt, i3)) throw new Error("unrecognized character " + c3 + " in " + fmt);
        out[out.length] = { t: "G", v: "General" };
        i3 += 7;
        break;
      case '"':
        for (o2 = ""; (cc2 = fmt.charCodeAt(++i3)) !== 34 && i3 < fmt.length; ) o2 += String.fromCharCode(cc2);
        out[out.length] = { t: "t", v: o2 };
        ++i3;
        break;
      case "\\":
        var w3 = fmt.charAt(++i3), t3 = w3 === "(" || w3 === ")" ? w3 : "t";
        out[out.length] = { t: t3, v: w3 };
        ++i3;
        break;
      case "_":
        out[out.length] = { t: "t", v: " " };
        i3 += 2;
        break;
      case "@":
        out[out.length] = { t: "T", v: v2 };
        ++i3;
        break;
      case "B":
      case "b":
        if (fmt.charAt(i3 + 1) === "1" || fmt.charAt(i3 + 1) === "2") {
          if (dt == null) {
            dt = SSF_parse_date_code(v2, opts, fmt.charAt(i3 + 1) === "2");
            if (dt == null) return "";
          }
          out[out.length] = { t: "X", v: fmt.substr(i3, 2) };
          lst = c3;
          i3 += 2;
          break;
        }
      case "M":
      case "D":
      case "Y":
      case "H":
      case "S":
      case "E":
        c3 = c3.toLowerCase();
      case "m":
      case "d":
      case "y":
      case "h":
      case "s":
      case "e":
      case "g":
        if (v2 < 0) return "";
        if (dt == null) {
          dt = SSF_parse_date_code(v2, opts);
          if (dt == null) return "";
        }
        o2 = c3;
        while (++i3 < fmt.length && fmt.charAt(i3).toLowerCase() === c3) o2 += c3;
        if (c3 === "m" && lst.toLowerCase() === "h") c3 = "M";
        if (c3 === "h") c3 = hr;
        out[out.length] = { t: c3, v: o2 };
        lst = c3;
        break;
      case "A":
      case "a":
      case "上":
        var q3 = { t: c3, v: c3 };
        if (dt == null) dt = SSF_parse_date_code(v2, opts);
        if (fmt.substr(i3, 3).toUpperCase() === "A/P") {
          if (dt != null) q3.v = dt.H >= 12 ? "P" : "A";
          q3.t = "T";
          hr = "h";
          i3 += 3;
        } else if (fmt.substr(i3, 5).toUpperCase() === "AM/PM") {
          if (dt != null) q3.v = dt.H >= 12 ? "PM" : "AM";
          q3.t = "T";
          i3 += 5;
          hr = "h";
        } else if (fmt.substr(i3, 5).toUpperCase() === "上午/下午") {
          if (dt != null) q3.v = dt.H >= 12 ? "下午" : "上午";
          q3.t = "T";
          i3 += 5;
          hr = "h";
        } else {
          q3.t = "t";
          ++i3;
        }
        if (dt == null && q3.t === "T") return "";
        out[out.length] = q3;
        lst = c3;
        break;
      case "[":
        o2 = c3;
        while (fmt.charAt(i3++) !== "]" && i3 < fmt.length) o2 += fmt.charAt(i3);
        if (o2.slice(-1) !== "]") throw 'unterminated "[" block: |' + o2 + "|";
        if (o2.match(SSF_abstime)) {
          if (dt == null) {
            dt = SSF_parse_date_code(v2, opts);
            if (dt == null) return "";
          }
          out[out.length] = { t: "Z", v: o2.toLowerCase() };
          lst = o2.charAt(1);
        } else if (o2.indexOf("$") > -1) {
          o2 = (o2.match(/\$([^-\[\]]*)/) || [])[1] || "$";
          if (!fmt_is_date(fmt)) out[out.length] = { t: "t", v: o2 };
        }
        break;
      case ".":
        if (dt != null) {
          o2 = c3;
          while (++i3 < fmt.length && (c3 = fmt.charAt(i3)) === "0") o2 += c3;
          out[out.length] = { t: "s", v: o2 };
          break;
        }
      case "0":
      case "#":
        o2 = c3;
        while (++i3 < fmt.length && "0#?.,E+-%".indexOf(c3 = fmt.charAt(i3)) > -1) o2 += c3;
        out[out.length] = { t: "n", v: o2 };
        break;
      case "?":
        o2 = c3;
        while (fmt.charAt(++i3) === c3) o2 += c3;
        out[out.length] = { t: c3, v: o2 };
        lst = c3;
        break;
      case "*":
        ++i3;
        if (fmt.charAt(i3) == " " || fmt.charAt(i3) == "*") ++i3;
        break;
      case "(":
      case ")":
        out[out.length] = { t: flen === 1 ? "t" : c3, v: c3 };
        ++i3;
        break;
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9":
        o2 = c3;
        while (i3 < fmt.length && "0123456789".indexOf(fmt.charAt(++i3)) > -1) o2 += fmt.charAt(i3);
        out[out.length] = { t: "D", v: o2 };
        break;
      case " ":
        out[out.length] = { t: c3, v: c3 };
        ++i3;
        break;
      case "$":
        out[out.length] = { t: "t", v: "$" };
        ++i3;
        break;
      default:
        if (",$-+/():!^&'~{}<>=€acfijklopqrtuvwxzP".indexOf(c3) === -1) throw new Error("unrecognized character " + c3 + " in " + fmt);
        out[out.length] = { t: "t", v: c3 };
        ++i3;
        break;
    }
  }
  var bt2 = 0, ss0 = 0, ssm;
  for (i3 = out.length - 1, lst = "t"; i3 >= 0; --i3) {
    switch (out[i3].t) {
      case "h":
      case "H":
        out[i3].t = hr;
        lst = "h";
        if (bt2 < 1) bt2 = 1;
        break;
      case "s":
        if (ssm = out[i3].v.match(/\.0+$/)) ss0 = Math.max(ss0, ssm[0].length - 1);
        if (bt2 < 3) bt2 = 3;
      case "d":
      case "y":
      case "M":
      case "e":
        lst = out[i3].t;
        break;
      case "m":
        if (lst === "s") {
          out[i3].t = "M";
          if (bt2 < 2) bt2 = 2;
        }
        break;
      case "X":
        break;
      case "Z":
        if (bt2 < 1 && out[i3].v.match(/[Hh]/)) bt2 = 1;
        if (bt2 < 2 && out[i3].v.match(/[Mm]/)) bt2 = 2;
        if (bt2 < 3 && out[i3].v.match(/[Ss]/)) bt2 = 3;
    }
  }
  switch (bt2) {
    case 0:
      break;
    case 1:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      if (dt.M >= 60) {
        dt.M = 0;
        ++dt.H;
      }
      break;
    case 2:
      if (dt.u >= 0.5) {
        dt.u = 0;
        ++dt.S;
      }
      if (dt.S >= 60) {
        dt.S = 0;
        ++dt.M;
      }
      break;
  }
  var nstr = "", jj2;
  for (i3 = 0; i3 < out.length; ++i3) {
    switch (out[i3].t) {
      case "t":
      case "T":
      case " ":
      case "D":
        break;
      case "X":
        out[i3].v = "";
        out[i3].t = ";";
        break;
      case "d":
      case "m":
      case "y":
      case "h":
      case "H":
      case "M":
      case "s":
      case "e":
      case "b":
      case "Z":
        out[i3].v = SSF_write_date(out[i3].t.charCodeAt(0), out[i3].v, dt, ss0);
        out[i3].t = "t";
        break;
      case "n":
      case "?":
        jj2 = i3 + 1;
        while (out[jj2] != null && ((c3 = out[jj2].t) === "?" || c3 === "D" || (c3 === " " || c3 === "t") && out[jj2 + 1] != null && (out[jj2 + 1].t === "?" || out[jj2 + 1].t === "t" && out[jj2 + 1].v === "/") || out[i3].t === "(" && (c3 === " " || c3 === "n" || c3 === ")") || c3 === "t" && (out[jj2].v === "/" || out[jj2].v === " " && out[jj2 + 1] != null && out[jj2 + 1].t == "?"))) {
          out[i3].v += out[jj2].v;
          out[jj2] = { v: "", t: ";" };
          ++jj2;
        }
        nstr += out[i3].v;
        i3 = jj2 - 1;
        break;
      case "G":
        out[i3].t = "t";
        out[i3].v = SSF_general(v2, opts);
        break;
    }
  }
  var vv = "", myv, ostr;
  if (nstr.length > 0) {
    if (nstr.charCodeAt(0) == 40) {
      myv = v2 < 0 && nstr.charCodeAt(0) === 45 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
    } else {
      myv = v2 < 0 && flen > 1 ? -v2 : v2;
      ostr = write_num("n", nstr, myv);
      if (myv < 0 && out[0] && out[0].t == "t") {
        ostr = ostr.substr(1);
        out[0].v = "-" + out[0].v;
      }
    }
    jj2 = ostr.length - 1;
    var decpt = out.length;
    for (i3 = 0; i3 < out.length; ++i3) if (out[i3] != null && out[i3].t != "t" && out[i3].v.indexOf(".") > -1) {
      decpt = i3;
      break;
    }
    var lasti = out.length;
    if (decpt === out.length && ostr.indexOf("E") === -1) {
      for (i3 = out.length - 1; i3 >= 0; --i3) {
        if (out[i3] == null || "n?".indexOf(out[i3].t) === -1) continue;
        if (jj2 >= out[i3].v.length - 1) {
          jj2 -= out[i3].v.length;
          out[i3].v = ostr.substr(jj2 + 1, out[i3].v.length);
        } else if (jj2 < 0) out[i3].v = "";
        else {
          out[i3].v = ostr.substr(0, jj2 + 1);
          jj2 = -1;
        }
        out[i3].t = "t";
        lasti = i3;
      }
      if (jj2 >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj2 + 1) + out[lasti].v;
    } else if (decpt !== out.length && ostr.indexOf("E") === -1) {
      jj2 = ostr.indexOf(".") - 1;
      for (i3 = decpt; i3 >= 0; --i3) {
        if (out[i3] == null || "n?".indexOf(out[i3].t) === -1) continue;
        j2 = out[i3].v.indexOf(".") > -1 && i3 === decpt ? out[i3].v.indexOf(".") - 1 : out[i3].v.length - 1;
        vv = out[i3].v.substr(j2 + 1);
        for (; j2 >= 0; --j2) {
          if (jj2 >= 0 && (out[i3].v.charAt(j2) === "0" || out[i3].v.charAt(j2) === "#")) vv = ostr.charAt(jj2--) + vv;
        }
        out[i3].v = vv;
        out[i3].t = "t";
        lasti = i3;
      }
      if (jj2 >= 0 && lasti < out.length) out[lasti].v = ostr.substr(0, jj2 + 1) + out[lasti].v;
      jj2 = ostr.indexOf(".") + 1;
      for (i3 = decpt; i3 < out.length; ++i3) {
        if (out[i3] == null || "n?(".indexOf(out[i3].t) === -1 && i3 !== decpt) continue;
        j2 = out[i3].v.indexOf(".") > -1 && i3 === decpt ? out[i3].v.indexOf(".") + 1 : 0;
        vv = out[i3].v.substr(0, j2);
        for (; j2 < out[i3].v.length; ++j2) {
          if (jj2 < ostr.length) vv += ostr.charAt(jj2++);
        }
        out[i3].v = vv;
        out[i3].t = "t";
        lasti = i3;
      }
    }
  }
  for (i3 = 0; i3 < out.length; ++i3) if (out[i3] != null && "n?".indexOf(out[i3].t) > -1) {
    myv = flen > 1 && v2 < 0 && i3 > 0 && out[i3 - 1].v === "-" ? -v2 : v2;
    out[i3].v = write_num(out[i3].t, out[i3].v, myv);
    out[i3].t = "t";
  }
  var retval = "";
  for (i3 = 0; i3 !== out.length; ++i3) if (out[i3] != null) retval += out[i3].v;
  return retval;
}
var cfregex2 = /\[(=|>[=]?|<[>=]?)(-?\d+(?:\.\d*)?)\]/;
function chkcond(v2, rr) {
  if (rr == null) return false;
  var thresh = parseFloat(rr[2]);
  switch (rr[1]) {
    case "=":
      if (v2 == thresh) return true;
      break;
    case ">":
      if (v2 > thresh) return true;
      break;
    case "<":
      if (v2 < thresh) return true;
      break;
    case "<>":
      if (v2 != thresh) return true;
      break;
    case ">=":
      if (v2 >= thresh) return true;
      break;
    case "<=":
      if (v2 <= thresh) return true;
      break;
  }
  return false;
}
function choose_fmt(f2, v2) {
  var fmt = SSF_split_fmt(f2);
  var l2 = fmt.length, lat = fmt[l2 - 1].indexOf("@");
  if (l2 < 4 && lat > -1) --l2;
  if (fmt.length > 4) throw new Error("cannot find right format for |" + fmt.join("|") + "|");
  if (typeof v2 !== "number") return [4, fmt.length === 4 || lat > -1 ? fmt[fmt.length - 1] : "@"];
  switch (fmt.length) {
    case 1:
      fmt = lat > -1 ? ["General", "General", "General", fmt[0]] : [fmt[0], fmt[0], fmt[0], "@"];
      break;
    case 2:
      fmt = lat > -1 ? [fmt[0], fmt[0], fmt[0], fmt[1]] : [fmt[0], fmt[1], fmt[0], "@"];
      break;
    case 3:
      fmt = lat > -1 ? [fmt[0], fmt[1], fmt[0], fmt[2]] : [fmt[0], fmt[1], fmt[2], "@"];
      break;
  }
  var ff2 = v2 > 0 ? fmt[0] : v2 < 0 ? fmt[1] : fmt[2];
  if (fmt[0].indexOf("[") === -1 && fmt[1].indexOf("[") === -1) return [l2, ff2];
  if (fmt[0].match(/\[[=<>]/) != null || fmt[1].match(/\[[=<>]/) != null) {
    var m1 = fmt[0].match(cfregex2);
    var m22 = fmt[1].match(cfregex2);
    return chkcond(v2, m1) ? [l2, fmt[0]] : chkcond(v2, m22) ? [l2, fmt[1]] : [l2, fmt[m1 != null && m22 != null ? 2 : 1]];
  }
  return [l2, ff2];
}
function SSF_format(fmt, v2, o2) {
  if (o2 == null) o2 = {};
  var sfmt = "";
  switch (typeof fmt) {
    case "string":
      if (fmt == "m/d/yy" && o2.dateNF) sfmt = o2.dateNF;
      else sfmt = fmt;
      break;
    case "number":
      if (fmt == 14 && o2.dateNF) sfmt = o2.dateNF;
      else sfmt = (o2.table != null ? o2.table : table_fmt)[fmt];
      if (sfmt == null) sfmt = o2.table && o2.table[SSF_default_map[fmt]] || table_fmt[SSF_default_map[fmt]];
      if (sfmt == null) sfmt = SSF_default_str[fmt] || "General";
      break;
  }
  if (SSF_isgeneral(sfmt, 0)) return SSF_general(v2, o2);
  if (v2 instanceof Date) v2 = datenum_local(v2, o2.date1904);
  var f2 = choose_fmt(sfmt, v2);
  if (SSF_isgeneral(f2[1])) return SSF_general(v2, o2);
  if (v2 === true) v2 = "TRUE";
  else if (v2 === false) v2 = "FALSE";
  else if (v2 === "" || v2 == null) return "";
  return eval_fmt(f2[1], v2, o2, f2[0]);
}
function SSF_load(fmt, idx) {
  if (typeof idx != "number") {
    idx = +idx || -1;
    for (var i3 = 0; i3 < 392; ++i3) {
      if (table_fmt[i3] == void 0) {
        if (idx < 0) idx = i3;
        continue;
      }
      if (table_fmt[i3] == fmt) {
        idx = i3;
        break;
      }
    }
    if (idx < 0) idx = 391;
  }
  table_fmt[idx] = fmt;
  return idx;
}
function SSF_load_table(tbl) {
  for (var i3 = 0; i3 != 392; ++i3)
    if (tbl[i3] !== void 0) SSF_load(tbl[i3], i3);
}
function make_ssf() {
  table_fmt = SSF_init_table();
}
var SSFImplicit = {
  "5": '"$"#,##0_);\\("$"#,##0\\)',
  "6": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "7": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "8": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "23": "General",
  "24": "General",
  "25": "General",
  "26": "General",
  "27": "m/d/yy",
  "28": "m/d/yy",
  "29": "m/d/yy",
  "30": "m/d/yy",
  "31": "m/d/yy",
  "32": "h:mm:ss",
  "33": "h:mm:ss",
  "34": "h:mm:ss",
  "35": "h:mm:ss",
  "36": "m/d/yy",
  "41": '_(* #,##0_);_(* (#,##0);_(* "-"_);_(@_)',
  "42": '_("$"* #,##0_);_("$"* (#,##0);_("$"* "-"_);_(@_)',
  "43": '_(* #,##0.00_);_(* (#,##0.00);_(* "-"??_);_(@_)',
  "44": '_("$"* #,##0.00_);_("$"* (#,##0.00);_("$"* "-"??_);_(@_)',
  "50": "m/d/yy",
  "51": "m/d/yy",
  "52": "m/d/yy",
  "53": "m/d/yy",
  "54": "m/d/yy",
  "55": "m/d/yy",
  "56": "m/d/yy",
  "57": "m/d/yy",
  "58": "m/d/yy",
  "59": "0",
  "60": "0.00",
  "61": "#,##0",
  "62": "#,##0.00",
  "63": '"$"#,##0_);\\("$"#,##0\\)',
  "64": '"$"#,##0_);[Red]\\("$"#,##0\\)',
  "65": '"$"#,##0.00_);\\("$"#,##0.00\\)',
  "66": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
  "67": "0%",
  "68": "0.00%",
  "69": "# ?/?",
  "70": "# ??/??",
  "71": "m/d/yy",
  "72": "m/d/yy",
  "73": "d-mmm-yy",
  "74": "d-mmm",
  "75": "mmm-yy",
  "76": "h:mm",
  "77": "h:mm:ss",
  "78": "m/d/yy h:mm",
  "79": "mm:ss",
  "80": "[h]:mm:ss",
  "81": "mmss.0"
};
var dateNFregex = /[dD]+|[mM]+|[yYeE]+|[Hh]+|[Ss]+/g;
function dateNF_regex(dateNF) {
  var fmt = typeof dateNF == "number" ? table_fmt[dateNF] : dateNF;
  fmt = fmt.replace(dateNFregex, "(\\d+)");
  return new RegExp("^" + fmt + "$");
}
function dateNF_fix(str, dateNF, match2) {
  var Y3 = -1, m4 = -1, d4 = -1, H4 = -1, M4 = -1, S4 = -1;
  (dateNF.match(dateNFregex) || []).forEach(function(n2, i3) {
    var v2 = parseInt(match2[i3 + 1], 10);
    switch (n2.toLowerCase().charAt(0)) {
      case "y":
        Y3 = v2;
        break;
      case "d":
        d4 = v2;
        break;
      case "h":
        H4 = v2;
        break;
      case "s":
        S4 = v2;
        break;
      case "m":
        if (H4 >= 0) M4 = v2;
        else m4 = v2;
        break;
    }
  });
  if (S4 >= 0 && M4 == -1 && m4 >= 0) {
    M4 = m4;
    m4 = -1;
  }
  var datestr = ("" + (Y3 >= 0 ? Y3 : (/* @__PURE__ */ new Date()).getFullYear())).slice(-4) + "-" + ("00" + (m4 >= 1 ? m4 : 1)).slice(-2) + "-" + ("00" + (d4 >= 1 ? d4 : 1)).slice(-2);
  if (datestr.length == 7) datestr = "0" + datestr;
  if (datestr.length == 8) datestr = "20" + datestr;
  var timestr = ("00" + (H4 >= 0 ? H4 : 0)).slice(-2) + ":" + ("00" + (M4 >= 0 ? M4 : 0)).slice(-2) + ":" + ("00" + (S4 >= 0 ? S4 : 0)).slice(-2);
  if (H4 == -1 && M4 == -1 && S4 == -1) return datestr;
  if (Y3 == -1 && m4 == -1 && d4 == -1) return timestr;
  return datestr + "T" + timestr;
}
var CRC32 = /* @__PURE__ */ function() {
  var CRC322 = {};
  CRC322.version = "1.2.0";
  function signed_crc_table() {
    var c3 = 0, table = new Array(256);
    for (var n2 = 0; n2 != 256; ++n2) {
      c3 = n2;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      c3 = c3 & 1 ? -306674912 ^ c3 >>> 1 : c3 >>> 1;
      table[n2] = c3;
    }
    return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
  }
  var T0 = signed_crc_table();
  function slice_by_16_tables(T10) {
    var c3 = 0, v2 = 0, n2 = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
    for (n2 = 0; n2 != 256; ++n2) table[n2] = T10[n2];
    for (n2 = 0; n2 != 256; ++n2) {
      v2 = T10[n2];
      for (c3 = 256 + n2; c3 < 4096; c3 += 256) v2 = table[c3] = v2 >>> 8 ^ T10[v2 & 255];
    }
    var out = [];
    for (n2 = 1; n2 != 16; ++n2) out[n2 - 1] = typeof Int32Array !== "undefined" ? table.subarray(n2 * 256, n2 * 256 + 256) : table.slice(n2 * 256, n2 * 256 + 256);
    return out;
  }
  var TT = slice_by_16_tables(T0);
  var T1 = TT[0], T22 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
  var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta2 = TT[9];
  var Tb2 = TT[10], Tc2 = TT[11], Td2 = TT[12], Te2 = TT[13], Tf2 = TT[14];
  function crc32_bstr(bstr, seed) {
    var C2 = seed ^ -1;
    for (var i3 = 0, L3 = bstr.length; i3 < L3; ) C2 = C2 >>> 8 ^ T0[(C2 ^ bstr.charCodeAt(i3++)) & 255];
    return ~C2;
  }
  function crc32_buf(B3, seed) {
    var C2 = seed ^ -1, L3 = B3.length - 15, i3 = 0;
    for (; i3 < L3; ) C2 = Tf2[B3[i3++] ^ C2 & 255] ^ Te2[B3[i3++] ^ C2 >> 8 & 255] ^ Td2[B3[i3++] ^ C2 >> 16 & 255] ^ Tc2[B3[i3++] ^ C2 >>> 24] ^ Tb2[B3[i3++]] ^ Ta2[B3[i3++]] ^ T9[B3[i3++]] ^ T8[B3[i3++]] ^ T7[B3[i3++]] ^ T6[B3[i3++]] ^ T5[B3[i3++]] ^ T4[B3[i3++]] ^ T3[B3[i3++]] ^ T22[B3[i3++]] ^ T1[B3[i3++]] ^ T0[B3[i3++]];
    L3 += 15;
    while (i3 < L3) C2 = C2 >>> 8 ^ T0[(C2 ^ B3[i3++]) & 255];
    return ~C2;
  }
  function crc32_str(str, seed) {
    var C2 = seed ^ -1;
    for (var i3 = 0, L3 = str.length, c3 = 0, d4 = 0; i3 < L3; ) {
      c3 = str.charCodeAt(i3++);
      if (c3 < 128) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ c3) & 255];
      } else if (c3 < 2048) {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (192 | c3 >> 6 & 31)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c3 & 63)) & 255];
      } else if (c3 >= 55296 && c3 < 57344) {
        c3 = (c3 & 1023) + 64;
        d4 = str.charCodeAt(i3++) & 1023;
        C2 = C2 >>> 8 ^ T0[(C2 ^ (240 | c3 >> 8 & 7)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c3 >> 2 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d4 >> 6 & 15 | (c3 & 3) << 4)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | d4 & 63)) & 255];
      } else {
        C2 = C2 >>> 8 ^ T0[(C2 ^ (224 | c3 >> 12 & 15)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c3 >> 6 & 63)) & 255];
        C2 = C2 >>> 8 ^ T0[(C2 ^ (128 | c3 & 63)) & 255];
      }
    }
    return ~C2;
  }
  CRC322.table = T0;
  CRC322.bstr = crc32_bstr;
  CRC322.buf = crc32_buf;
  CRC322.str = crc32_str;
  return CRC322;
}();
var CFB = /* @__PURE__ */ function _CFB() {
  var exports = {};
  exports.version = "1.2.1";
  function namecmp(l2, r2) {
    var L3 = l2.split("/"), R3 = r2.split("/");
    for (var i4 = 0, c3 = 0, Z2 = Math.min(L3.length, R3.length); i4 < Z2; ++i4) {
      if (c3 = L3[i4].length - R3[i4].length) return c3;
      if (L3[i4] != R3[i4]) return L3[i4] < R3[i4] ? -1 : 1;
    }
    return L3.length - R3.length;
  }
  function dirname(p2) {
    if (p2.charAt(p2.length - 1) == "/") return p2.slice(0, -1).indexOf("/") === -1 ? p2 : dirname(p2.slice(0, -1));
    var c3 = p2.lastIndexOf("/");
    return c3 === -1 ? p2 : p2.slice(0, c3 + 1);
  }
  function filename(p2) {
    if (p2.charAt(p2.length - 1) == "/") return filename(p2.slice(0, -1));
    var c3 = p2.lastIndexOf("/");
    return c3 === -1 ? p2 : p2.slice(c3 + 1);
  }
  function write_dos_date(buf, date) {
    if (typeof date === "string") date = new Date(date);
    var hms = date.getHours();
    hms = hms << 6 | date.getMinutes();
    hms = hms << 5 | date.getSeconds() >>> 1;
    buf.write_shift(2, hms);
    var ymd = date.getFullYear() - 1980;
    ymd = ymd << 4 | date.getMonth() + 1;
    ymd = ymd << 5 | date.getDate();
    buf.write_shift(2, ymd);
  }
  function parse_dos_date(buf) {
    var hms = buf.read_shift(2) & 65535;
    var ymd = buf.read_shift(2) & 65535;
    var val = /* @__PURE__ */ new Date();
    var d4 = ymd & 31;
    ymd >>>= 5;
    var m4 = ymd & 15;
    ymd >>>= 4;
    val.setMilliseconds(0);
    val.setFullYear(ymd + 1980);
    val.setMonth(m4 - 1);
    val.setDate(d4);
    var S4 = hms & 31;
    hms >>>= 5;
    var M4 = hms & 63;
    hms >>>= 6;
    val.setHours(hms);
    val.setMinutes(M4);
    val.setSeconds(S4 << 1);
    return val;
  }
  function parse_extra_field(blob) {
    prep_blob(blob, 0);
    var o2 = (
      /*::(*/
      {}
    );
    var flags = 0;
    while (blob.l <= blob.length - 4) {
      var type = blob.read_shift(2);
      var sz = blob.read_shift(2), tgt = blob.l + sz;
      var p2 = {};
      switch (type) {
        case 21589:
          {
            flags = blob.read_shift(1);
            if (flags & 1) p2.mtime = blob.read_shift(4);
            if (sz > 5) {
              if (flags & 2) p2.atime = blob.read_shift(4);
              if (flags & 4) p2.ctime = blob.read_shift(4);
            }
            if (p2.mtime) p2.mt = new Date(p2.mtime * 1e3);
          }
          break;
      }
      blob.l = tgt;
      o2[type] = p2;
    }
    return o2;
  }
  var fs;
  function get_fs() {
    return fs || (fs = {});
  }
  function parse2(file, options) {
    if (file[0] == 80 && file[1] == 75) return parse_zip2(file, options);
    if ((file[0] | 32) == 109 && (file[1] | 32) == 105) return parse_mad(file, options);
    if (file.length < 512) throw new Error("CFB file size " + file.length + " < 512");
    var mver = 3;
    var ssz = 512;
    var nmfs = 0;
    var difat_sec_cnt = 0;
    var dir_start = 0;
    var minifat_start = 0;
    var difat_start = 0;
    var fat_addrs = [];
    var blob = (
      /*::(*/
      file.slice(0, 512)
    );
    prep_blob(blob, 0);
    var mv = check_get_mver(blob);
    mver = mv[0];
    switch (mver) {
      case 3:
        ssz = 512;
        break;
      case 4:
        ssz = 4096;
        break;
      case 0:
        if (mv[1] == 0) return parse_zip2(file, options);
      default:
        throw new Error("Major Version: Expected 3 or 4 saw " + mver);
    }
    if (ssz !== 512) {
      blob = /*::(*/
      file.slice(0, ssz);
      prep_blob(
        blob,
        28
        /* blob.l */
      );
    }
    var header = file.slice(0, ssz);
    check_shifts(blob, mver);
    var dir_cnt = blob.read_shift(4, "i");
    if (mver === 3 && dir_cnt !== 0) throw new Error("# Directory Sectors: Expected 0 saw " + dir_cnt);
    blob.l += 4;
    dir_start = blob.read_shift(4, "i");
    blob.l += 4;
    blob.chk("00100000", "Mini Stream Cutoff Size: ");
    minifat_start = blob.read_shift(4, "i");
    nmfs = blob.read_shift(4, "i");
    difat_start = blob.read_shift(4, "i");
    difat_sec_cnt = blob.read_shift(4, "i");
    for (var q4 = -1, j2 = 0; j2 < 109; ++j2) {
      q4 = blob.read_shift(4, "i");
      if (q4 < 0) break;
      fat_addrs[j2] = q4;
    }
    var sectors = sectorify(file, ssz);
    sleuth_fat(difat_start, difat_sec_cnt, sectors, ssz, fat_addrs);
    var sector_list = make_sector_list(sectors, dir_start, fat_addrs, ssz);
    sector_list[dir_start].name = "!Directory";
    if (nmfs > 0 && minifat_start !== ENDOFCHAIN) sector_list[minifat_start].name = "!MiniFAT";
    sector_list[fat_addrs[0]].name = "!FAT";
    sector_list.fat_addrs = fat_addrs;
    sector_list.ssz = ssz;
    var files = {}, Paths = [], FileIndex = [], FullPaths = [];
    read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, minifat_start);
    build_full_paths(FileIndex, FullPaths, Paths);
    Paths.shift();
    var o2 = {
      FileIndex,
      FullPaths
    };
    if (options && options.raw) o2.raw = { header, sectors };
    return o2;
  }
  function check_get_mver(blob) {
    if (blob[blob.l] == 80 && blob[blob.l + 1] == 75) return [0, 0];
    blob.chk(HEADER_SIGNATURE, "Header Signature: ");
    blob.l += 16;
    var mver = blob.read_shift(2, "u");
    return [blob.read_shift(2, "u"), mver];
  }
  function check_shifts(blob, mver) {
    var shift2 = 9;
    blob.l += 2;
    switch (shift2 = blob.read_shift(2)) {
      case 9:
        if (mver != 3) throw new Error("Sector Shift: Expected 9 saw " + shift2);
        break;
      case 12:
        if (mver != 4) throw new Error("Sector Shift: Expected 12 saw " + shift2);
        break;
      default:
        throw new Error("Sector Shift: Expected 9 or 12 saw " + shift2);
    }
    blob.chk("0600", "Mini Sector Shift: ");
    blob.chk("000000000000", "Reserved: ");
  }
  function sectorify(file, ssz) {
    var nsectors = Math.ceil(file.length / ssz) - 1;
    var sectors = [];
    for (var i4 = 1; i4 < nsectors; ++i4) sectors[i4 - 1] = file.slice(i4 * ssz, (i4 + 1) * ssz);
    sectors[nsectors - 1] = file.slice(nsectors * ssz);
    return sectors;
  }
  function build_full_paths(FI, FP, Paths) {
    var i4 = 0, L3 = 0, R3 = 0, C2 = 0, j2 = 0, pl2 = Paths.length;
    var dad = [], q4 = [];
    for (; i4 < pl2; ++i4) {
      dad[i4] = q4[i4] = i4;
      FP[i4] = Paths[i4];
    }
    for (; j2 < q4.length; ++j2) {
      i4 = q4[j2];
      L3 = FI[i4].L;
      R3 = FI[i4].R;
      C2 = FI[i4].C;
      if (dad[i4] === i4) {
        if (L3 !== -1 && dad[L3] !== L3) dad[i4] = dad[L3];
        if (R3 !== -1 && dad[R3] !== R3) dad[i4] = dad[R3];
      }
      if (C2 !== -1) dad[C2] = i4;
      if (L3 !== -1 && i4 != dad[i4]) {
        dad[L3] = dad[i4];
        if (q4.lastIndexOf(L3) < j2) q4.push(L3);
      }
      if (R3 !== -1 && i4 != dad[i4]) {
        dad[R3] = dad[i4];
        if (q4.lastIndexOf(R3) < j2) q4.push(R3);
      }
    }
    for (i4 = 1; i4 < pl2; ++i4) if (dad[i4] === i4) {
      if (R3 !== -1 && dad[R3] !== R3) dad[i4] = dad[R3];
      else if (L3 !== -1 && dad[L3] !== L3) dad[i4] = dad[L3];
    }
    for (i4 = 1; i4 < pl2; ++i4) {
      if (FI[i4].type === 0) continue;
      j2 = i4;
      if (j2 != dad[j2]) do {
        j2 = dad[j2];
        FP[i4] = FP[j2] + "/" + FP[i4];
      } while (j2 !== 0 && -1 !== dad[j2] && j2 != dad[j2]);
      dad[i4] = -1;
    }
    FP[0] += "/";
    for (i4 = 1; i4 < pl2; ++i4) {
      if (FI[i4].type !== 2) FP[i4] += "/";
    }
  }
  function get_mfat_entry(entry, payload, mini) {
    var start = entry.start, size2 = entry.size;
    var o2 = [];
    var idx = start;
    while (mini && size2 > 0 && idx >= 0) {
      o2.push(payload.slice(idx * MSSZ, idx * MSSZ + MSSZ));
      size2 -= MSSZ;
      idx = __readInt32LE(mini, idx * 4);
    }
    if (o2.length === 0) return new_buf(0);
    return bconcat(o2).slice(0, entry.size);
  }
  function sleuth_fat(idx, cnt, sectors, ssz, fat_addrs) {
    var q4 = ENDOFCHAIN;
    if (idx === ENDOFCHAIN) {
      if (cnt !== 0) throw new Error("DIFAT chain shorter than expected");
    } else if (idx !== -1) {
      var sector = sectors[idx], m4 = (ssz >>> 2) - 1;
      if (!sector) return;
      for (var i4 = 0; i4 < m4; ++i4) {
        if ((q4 = __readInt32LE(sector, i4 * 4)) === ENDOFCHAIN) break;
        fat_addrs.push(q4);
      }
      sleuth_fat(__readInt32LE(sector, ssz - 4), cnt - 1, sectors, ssz, fat_addrs);
    }
  }
  function get_sector_list(sectors, start, fat_addrs, ssz, chkd) {
    var buf = [], buf_chain = [];
    if (!chkd) chkd = [];
    var modulus = ssz - 1, j2 = 0, jj2 = 0;
    for (j2 = start; j2 >= 0; ) {
      chkd[j2] = true;
      buf[buf.length] = j2;
      buf_chain.push(sectors[j2]);
      var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
      jj2 = j2 * 4 & modulus;
      if (ssz < 4 + jj2) throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
      if (!sectors[addr]) break;
      j2 = __readInt32LE(sectors[addr], jj2);
    }
    return { nodes: buf, data: __toBuffer([buf_chain]) };
  }
  function make_sector_list(sectors, dir_start, fat_addrs, ssz) {
    var sl2 = sectors.length, sector_list = [];
    var chkd = [], buf = [], buf_chain = [];
    var modulus = ssz - 1, i4 = 0, j2 = 0, k3 = 0, jj2 = 0;
    for (i4 = 0; i4 < sl2; ++i4) {
      buf = [];
      k3 = i4 + dir_start;
      if (k3 >= sl2) k3 -= sl2;
      if (chkd[k3]) continue;
      buf_chain = [];
      var seen = [];
      for (j2 = k3; j2 >= 0; ) {
        seen[j2] = true;
        chkd[j2] = true;
        buf[buf.length] = j2;
        buf_chain.push(sectors[j2]);
        var addr = fat_addrs[Math.floor(j2 * 4 / ssz)];
        jj2 = j2 * 4 & modulus;
        if (ssz < 4 + jj2) throw new Error("FAT boundary crossed: " + j2 + " 4 " + ssz);
        if (!sectors[addr]) break;
        j2 = __readInt32LE(sectors[addr], jj2);
        if (seen[j2]) break;
      }
      sector_list[k3] = { nodes: buf, data: __toBuffer([buf_chain]) };
    }
    return sector_list;
  }
  function read_directory(dir_start, sector_list, sectors, Paths, nmfs, files, FileIndex, mini) {
    var minifat_store = 0, pl2 = Paths.length ? 2 : 0;
    var sector = sector_list[dir_start].data;
    var i4 = 0, namelen = 0, name;
    for (; i4 < sector.length; i4 += 128) {
      var blob = (
        /*::(*/
        sector.slice(i4, i4 + 128)
      );
      prep_blob(blob, 64);
      namelen = blob.read_shift(2);
      name = __utf16le(blob, 0, namelen - pl2);
      Paths.push(name);
      var o2 = {
        name,
        type: blob.read_shift(1),
        color: blob.read_shift(1),
        L: blob.read_shift(4, "i"),
        R: blob.read_shift(4, "i"),
        C: blob.read_shift(4, "i"),
        clsid: blob.read_shift(16),
        state: blob.read_shift(4, "i"),
        start: 0,
        size: 0
      };
      var ctime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (ctime !== 0) o2.ct = read_date(blob, blob.l - 8);
      var mtime = blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2) + blob.read_shift(2);
      if (mtime !== 0) o2.mt = read_date(blob, blob.l - 8);
      o2.start = blob.read_shift(4, "i");
      o2.size = blob.read_shift(4, "i");
      if (o2.size < 0 && o2.start < 0) {
        o2.size = o2.type = 0;
        o2.start = ENDOFCHAIN;
        o2.name = "";
      }
      if (o2.type === 5) {
        minifat_store = o2.start;
        if (nmfs > 0 && minifat_store !== ENDOFCHAIN) sector_list[minifat_store].name = "!StreamData";
      } else if (o2.size >= 4096) {
        o2.storage = "fat";
        if (sector_list[o2.start] === void 0) sector_list[o2.start] = get_sector_list(sectors, o2.start, sector_list.fat_addrs, sector_list.ssz);
        sector_list[o2.start].name = o2.name;
        o2.content = sector_list[o2.start].data.slice(0, o2.size);
      } else {
        o2.storage = "minifat";
        if (o2.size < 0) o2.size = 0;
        else if (minifat_store !== ENDOFCHAIN && o2.start !== ENDOFCHAIN && sector_list[minifat_store]) {
          o2.content = get_mfat_entry(o2, sector_list[minifat_store].data, (sector_list[mini] || {}).data);
        }
      }
      if (o2.content) prep_blob(o2.content, 0);
      files[name] = o2;
      FileIndex.push(o2);
    }
  }
  function read_date(blob, offset2) {
    return new Date((__readUInt32LE(blob, offset2 + 4) / 1e7 * Math.pow(2, 32) + __readUInt32LE(blob, offset2) / 1e7 - 11644473600) * 1e3);
  }
  function read_file(filename2, options) {
    get_fs();
    return parse2(fs.readFileSync(filename2), options);
  }
  function read(blob, options) {
    var type = options && options.type;
    if (!type) {
      if (has_buf && Buffer.isBuffer(blob)) type = "buffer";
    }
    switch (type || "base64") {
      case "file":
        return read_file(blob, options);
      case "base64":
        return parse2(s2a(Base64_decode(blob)), options);
      case "binary":
        return parse2(s2a(blob), options);
    }
    return parse2(
      /*::typeof blob == 'string' ? new Buffer(blob, 'utf-8') : */
      blob,
      options
    );
  }
  function init_cfb(cfb, opts) {
    var o2 = opts || {}, root = o2.root || "Root Entry";
    if (!cfb.FullPaths) cfb.FullPaths = [];
    if (!cfb.FileIndex) cfb.FileIndex = [];
    if (cfb.FullPaths.length !== cfb.FileIndex.length) throw new Error("inconsistent CFB structure");
    if (cfb.FullPaths.length === 0) {
      cfb.FullPaths[0] = root + "/";
      cfb.FileIndex[0] = { name: root, type: 5 };
    }
    if (o2.CLSID) cfb.FileIndex[0].clsid = o2.CLSID;
    seed_cfb(cfb);
  }
  function seed_cfb(cfb) {
    var nm = "Sh33tJ5";
    if (CFB.find(cfb, "/" + nm)) return;
    var p2 = new_buf(4);
    p2[0] = 55;
    p2[1] = p2[3] = 50;
    p2[2] = 54;
    cfb.FileIndex.push({ name: nm, type: 2, content: p2, size: 4, L: 69, R: 69, C: 69 });
    cfb.FullPaths.push(cfb.FullPaths[0] + nm);
    rebuild_cfb(cfb);
  }
  function rebuild_cfb(cfb, f2) {
    init_cfb(cfb);
    var gc2 = false, s4 = false;
    for (var i4 = cfb.FullPaths.length - 1; i4 >= 0; --i4) {
      var _file = cfb.FileIndex[i4];
      switch (_file.type) {
        case 0:
          if (s4) gc2 = true;
          else {
            cfb.FileIndex.pop();
            cfb.FullPaths.pop();
          }
          break;
        case 1:
        case 2:
        case 5:
          s4 = true;
          if (isNaN(_file.R * _file.L * _file.C)) gc2 = true;
          if (_file.R > -1 && _file.L > -1 && _file.R == _file.L) gc2 = true;
          break;
        default:
          gc2 = true;
          break;
      }
    }
    if (!gc2 && !f2) return;
    var now = new Date(1987, 1, 19), j2 = 0;
    var fullPaths = Object.create ? /* @__PURE__ */ Object.create(null) : {};
    var data = [];
    for (i4 = 0; i4 < cfb.FullPaths.length; ++i4) {
      fullPaths[cfb.FullPaths[i4]] = true;
      if (cfb.FileIndex[i4].type === 0) continue;
      data.push([cfb.FullPaths[i4], cfb.FileIndex[i4]]);
    }
    for (i4 = 0; i4 < data.length; ++i4) {
      var dad = dirname(data[i4][0]);
      s4 = fullPaths[dad];
      if (!s4) {
        data.push([dad, {
          name: filename(dad).replace("/", ""),
          type: 1,
          clsid: HEADER_CLSID,
          ct: now,
          mt: now,
          content: null
        }]);
        fullPaths[dad] = true;
      }
    }
    data.sort(function(x3, y4) {
      return namecmp(x3[0], y4[0]);
    });
    cfb.FullPaths = [];
    cfb.FileIndex = [];
    for (i4 = 0; i4 < data.length; ++i4) {
      cfb.FullPaths[i4] = data[i4][0];
      cfb.FileIndex[i4] = data[i4][1];
    }
    for (i4 = 0; i4 < data.length; ++i4) {
      var elt = cfb.FileIndex[i4];
      var nm = cfb.FullPaths[i4];
      elt.name = filename(nm).replace("/", "");
      elt.L = elt.R = elt.C = -(elt.color = 1);
      elt.size = elt.content ? elt.content.length : 0;
      elt.start = 0;
      elt.clsid = elt.clsid || HEADER_CLSID;
      if (i4 === 0) {
        elt.C = data.length > 1 ? 1 : -1;
        elt.size = 0;
        elt.type = 5;
      } else if (nm.slice(-1) == "/") {
        for (j2 = i4 + 1; j2 < data.length; ++j2) if (dirname(cfb.FullPaths[j2]) == nm) break;
        elt.C = j2 >= data.length ? -1 : j2;
        for (j2 = i4 + 1; j2 < data.length; ++j2) if (dirname(cfb.FullPaths[j2]) == dirname(nm)) break;
        elt.R = j2 >= data.length ? -1 : j2;
        elt.type = 1;
      } else {
        if (dirname(cfb.FullPaths[i4 + 1] || "") == dirname(nm)) elt.R = i4 + 1;
        elt.type = 2;
      }
    }
  }
  function _write(cfb, options) {
    var _opts = options || {};
    if (_opts.fileType == "mad") return write_mad(cfb, _opts);
    rebuild_cfb(cfb);
    switch (_opts.fileType) {
      case "zip":
        return write_zip2(cfb, _opts);
    }
    var L3 = function(cfb2) {
      var mini_size = 0, fat_size = 0;
      for (var i5 = 0; i5 < cfb2.FileIndex.length; ++i5) {
        var file2 = cfb2.FileIndex[i5];
        if (!file2.content) continue;
        var flen2 = file2.content.length;
        if (flen2 > 0) {
          if (flen2 < 4096) mini_size += flen2 + 63 >> 6;
          else fat_size += flen2 + 511 >> 9;
        }
      }
      var dir_cnt = cfb2.FullPaths.length + 3 >> 2;
      var mini_cnt = mini_size + 7 >> 3;
      var mfat_cnt = mini_size + 127 >> 7;
      var fat_base = mini_cnt + fat_size + dir_cnt + mfat_cnt;
      var fat_cnt = fat_base + 127 >> 7;
      var difat_cnt = fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      while (fat_base + fat_cnt + difat_cnt + 127 >> 7 > fat_cnt) difat_cnt = ++fat_cnt <= 109 ? 0 : Math.ceil((fat_cnt - 109) / 127);
      var L4 = [1, difat_cnt, fat_cnt, mfat_cnt, dir_cnt, fat_size, mini_size, 0];
      cfb2.FileIndex[0].size = mini_size << 6;
      L4[7] = (cfb2.FileIndex[0].start = L4[0] + L4[1] + L4[2] + L4[3] + L4[4] + L4[5]) + (L4[6] + 7 >> 3);
      return L4;
    }(cfb);
    var o2 = new_buf(L3[7] << 9);
    var i4 = 0, T3 = 0;
    {
      for (i4 = 0; i4 < 8; ++i4) o2.write_shift(1, HEADER_SIG[i4]);
      for (i4 = 0; i4 < 8; ++i4) o2.write_shift(2, 0);
      o2.write_shift(2, 62);
      o2.write_shift(2, 3);
      o2.write_shift(2, 65534);
      o2.write_shift(2, 9);
      o2.write_shift(2, 6);
      for (i4 = 0; i4 < 3; ++i4) o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, L3[2]);
      o2.write_shift(4, L3[0] + L3[1] + L3[2] + L3[3] - 1);
      o2.write_shift(4, 0);
      o2.write_shift(4, 1 << 12);
      o2.write_shift(4, L3[3] ? L3[0] + L3[1] + L3[2] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L3[3]);
      o2.write_shift(-4, L3[1] ? L3[0] - 1 : ENDOFCHAIN);
      o2.write_shift(4, L3[1]);
      for (i4 = 0; i4 < 109; ++i4) o2.write_shift(-4, i4 < L3[2] ? L3[1] + i4 : -1);
    }
    if (L3[1]) {
      for (T3 = 0; T3 < L3[1]; ++T3) {
        for (; i4 < 236 + T3 * 127; ++i4) o2.write_shift(-4, i4 < L3[2] ? L3[1] + i4 : -1);
        o2.write_shift(-4, T3 === L3[1] - 1 ? ENDOFCHAIN : T3 + 1);
      }
    }
    var chainit = function(w3) {
      for (T3 += w3; i4 < T3 - 1; ++i4) o2.write_shift(-4, i4 + 1);
      if (w3) {
        ++i4;
        o2.write_shift(-4, ENDOFCHAIN);
      }
    };
    T3 = i4 = 0;
    for (T3 += L3[1]; i4 < T3; ++i4) o2.write_shift(-4, consts.DIFSECT);
    for (T3 += L3[2]; i4 < T3; ++i4) o2.write_shift(-4, consts.FATSECT);
    chainit(L3[3]);
    chainit(L3[4]);
    var j2 = 0, flen = 0;
    var file = cfb.FileIndex[0];
    for (; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content) continue;
      flen = file.content.length;
      if (flen < 4096) continue;
      file.start = T3;
      chainit(flen + 511 >> 9);
    }
    chainit(L3[6] + 7 >> 3);
    while (o2.l & 511) o2.write_shift(-4, consts.ENDOFCHAIN);
    T3 = i4 = 0;
    for (j2 = 0; j2 < cfb.FileIndex.length; ++j2) {
      file = cfb.FileIndex[j2];
      if (!file.content) continue;
      flen = file.content.length;
      if (!flen || flen >= 4096) continue;
      file.start = T3;
      chainit(flen + 63 >> 6);
    }
    while (o2.l & 511) o2.write_shift(-4, consts.ENDOFCHAIN);
    for (i4 = 0; i4 < L3[4] << 2; ++i4) {
      var nm = cfb.FullPaths[i4];
      if (!nm || nm.length === 0) {
        for (j2 = 0; j2 < 17; ++j2) o2.write_shift(4, 0);
        for (j2 = 0; j2 < 3; ++j2) o2.write_shift(4, -1);
        for (j2 = 0; j2 < 12; ++j2) o2.write_shift(4, 0);
        continue;
      }
      file = cfb.FileIndex[i4];
      if (i4 === 0) file.start = file.size ? file.start - 1 : ENDOFCHAIN;
      var _nm = i4 === 0 && _opts.root || file.name;
      flen = 2 * (_nm.length + 1);
      o2.write_shift(64, _nm, "utf16le");
      o2.write_shift(2, flen);
      o2.write_shift(1, file.type);
      o2.write_shift(1, file.color);
      o2.write_shift(-4, file.L);
      o2.write_shift(-4, file.R);
      o2.write_shift(-4, file.C);
      if (!file.clsid) for (j2 = 0; j2 < 4; ++j2) o2.write_shift(4, 0);
      else o2.write_shift(16, file.clsid, "hex");
      o2.write_shift(4, file.state || 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, file.start);
      o2.write_shift(4, file.size);
      o2.write_shift(4, 0);
    }
    for (i4 = 1; i4 < cfb.FileIndex.length; ++i4) {
      file = cfb.FileIndex[i4];
      if (file.size >= 4096) {
        o2.l = file.start + 1 << 9;
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 511 & -512;
        } else {
          for (j2 = 0; j2 < file.size; ++j2) o2.write_shift(1, file.content[j2]);
          for (; j2 & 511; ++j2) o2.write_shift(1, 0);
        }
      }
    }
    for (i4 = 1; i4 < cfb.FileIndex.length; ++i4) {
      file = cfb.FileIndex[i4];
      if (file.size > 0 && file.size < 4096) {
        if (has_buf && Buffer.isBuffer(file.content)) {
          file.content.copy(o2, o2.l, 0, file.size);
          o2.l += file.size + 63 & -64;
        } else {
          for (j2 = 0; j2 < file.size; ++j2) o2.write_shift(1, file.content[j2]);
          for (; j2 & 63; ++j2) o2.write_shift(1, 0);
        }
      }
    }
    if (has_buf) {
      o2.l = o2.length;
    } else {
      while (o2.l < o2.length) o2.write_shift(1, 0);
    }
    return o2;
  }
  function find(cfb, path) {
    var UCFullPaths = cfb.FullPaths.map(function(x3) {
      return x3.toUpperCase();
    });
    var UCPaths = UCFullPaths.map(function(x3) {
      var y4 = x3.split("/");
      return y4[y4.length - (x3.slice(-1) == "/" ? 2 : 1)];
    });
    var k3 = false;
    if (path.charCodeAt(0) === 47) {
      k3 = true;
      path = UCFullPaths[0].slice(0, -1) + path;
    } else k3 = path.indexOf("/") !== -1;
    var UCPath = path.toUpperCase();
    var w3 = k3 === true ? UCFullPaths.indexOf(UCPath) : UCPaths.indexOf(UCPath);
    if (w3 !== -1) return cfb.FileIndex[w3];
    var m4 = !UCPath.match(chr1);
    UCPath = UCPath.replace(chr0, "");
    if (m4) UCPath = UCPath.replace(chr1, "!");
    for (w3 = 0; w3 < UCFullPaths.length; ++w3) {
      if ((m4 ? UCFullPaths[w3].replace(chr1, "!") : UCFullPaths[w3]).replace(chr0, "") == UCPath) return cfb.FileIndex[w3];
      if ((m4 ? UCPaths[w3].replace(chr1, "!") : UCPaths[w3]).replace(chr0, "") == UCPath) return cfb.FileIndex[w3];
    }
    return null;
  }
  var MSSZ = 64;
  var ENDOFCHAIN = -2;
  var HEADER_SIGNATURE = "d0cf11e0a1b11ae1";
  var HEADER_SIG = [208, 207, 17, 224, 161, 177, 26, 225];
  var HEADER_CLSID = "00000000000000000000000000000000";
  var consts = {
    /* 2.1 Compund File Sector Numbers and Types */
    MAXREGSECT: -6,
    DIFSECT: -4,
    FATSECT: -3,
    ENDOFCHAIN,
    FREESECT: -1,
    /* 2.2 Compound File Header */
    HEADER_SIGNATURE,
    HEADER_MINOR_VERSION: "3e00",
    MAXREGSID: -6,
    NOSTREAM: -1,
    HEADER_CLSID,
    /* 2.6.1 Compound File Directory Entry */
    EntryTypes: ["unknown", "storage", "stream", "lockbytes", "property", "root"]
  };
  function write_file(cfb, filename2, options) {
    get_fs();
    var o2 = _write(cfb, options);
    fs.writeFileSync(filename2, o2);
  }
  function a2s2(o2) {
    var out = new Array(o2.length);
    for (var i4 = 0; i4 < o2.length; ++i4) out[i4] = String.fromCharCode(o2[i4]);
    return out.join("");
  }
  function write(cfb, options) {
    var o2 = _write(cfb, options);
    switch (options && options.type || "buffer") {
      case "file":
        get_fs();
        fs.writeFileSync(options.filename, o2);
        return o2;
      case "binary":
        return typeof o2 == "string" ? o2 : a2s2(o2);
      case "base64":
        return Base64_encode(typeof o2 == "string" ? o2 : a2s2(o2));
      case "buffer":
        if (has_buf) return Buffer.isBuffer(o2) ? o2 : Buffer_from(o2);
      case "array":
        return typeof o2 == "string" ? s2a(o2) : o2;
    }
    return o2;
  }
  var _zlib;
  function use_zlib(zlib) {
    try {
      var InflateRaw = zlib.InflateRaw;
      var InflRaw = new InflateRaw();
      InflRaw._processChunk(new Uint8Array([3, 0]), InflRaw._finishFlushFlag);
      if (InflRaw.bytesRead) _zlib = zlib;
      else throw new Error("zlib does not expose bytesRead");
    } catch (e3) {
      console.error("cannot use native zlib: " + (e3.message || e3));
    }
  }
  function _inflateRawSync(payload, usz) {
    if (!_zlib) return _inflate(payload, usz);
    var InflateRaw = _zlib.InflateRaw;
    var InflRaw = new InflateRaw();
    var out = InflRaw._processChunk(payload.slice(payload.l), InflRaw._finishFlushFlag);
    payload.l += InflRaw.bytesRead;
    return out;
  }
  function _deflateRawSync(payload) {
    return _zlib ? _zlib.deflateRawSync(payload) : _deflate(payload);
  }
  var CLEN_ORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
  var LEN_LN = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258];
  var DST_LN = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577];
  function bit_swap_8(n2) {
    var t3 = (n2 << 1 | n2 << 11) & 139536 | (n2 << 5 | n2 << 15) & 558144;
    return (t3 >> 16 | t3 >> 8 | t3) & 255;
  }
  var use_typed_arrays = typeof Uint8Array !== "undefined";
  var bitswap8 = use_typed_arrays ? new Uint8Array(1 << 8) : [];
  for (var q3 = 0; q3 < 1 << 8; ++q3) bitswap8[q3] = bit_swap_8(q3);
  function bit_swap_n(n2, b2) {
    var rev = bitswap8[n2 & 255];
    if (b2 <= 8) return rev >>> 8 - b2;
    rev = rev << 8 | bitswap8[n2 >> 8 & 255];
    if (b2 <= 16) return rev >>> 16 - b2;
    rev = rev << 8 | bitswap8[n2 >> 16 & 255];
    return rev >>> 24 - b2;
  }
  function read_bits_2(buf, bl2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    return (buf[h4] | (w3 <= 6 ? 0 : buf[h4 + 1] << 8)) >>> w3 & 3;
  }
  function read_bits_3(buf, bl2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    return (buf[h4] | (w3 <= 5 ? 0 : buf[h4 + 1] << 8)) >>> w3 & 7;
  }
  function read_bits_4(buf, bl2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    return (buf[h4] | (w3 <= 4 ? 0 : buf[h4 + 1] << 8)) >>> w3 & 15;
  }
  function read_bits_5(buf, bl2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    return (buf[h4] | (w3 <= 3 ? 0 : buf[h4 + 1] << 8)) >>> w3 & 31;
  }
  function read_bits_7(buf, bl2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    return (buf[h4] | (w3 <= 1 ? 0 : buf[h4 + 1] << 8)) >>> w3 & 127;
  }
  function read_bits_n(buf, bl2, n2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3, f2 = (1 << n2) - 1;
    var v2 = buf[h4] >>> w3;
    if (n2 < 8 - w3) return v2 & f2;
    v2 |= buf[h4 + 1] << 8 - w3;
    if (n2 < 16 - w3) return v2 & f2;
    v2 |= buf[h4 + 2] << 16 - w3;
    if (n2 < 24 - w3) return v2 & f2;
    v2 |= buf[h4 + 3] << 24 - w3;
    return v2 & f2;
  }
  function write_bits_3(buf, bl2, v2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    if (w3 <= 5) buf[h4] |= (v2 & 7) << w3;
    else {
      buf[h4] |= v2 << w3 & 255;
      buf[h4 + 1] = (v2 & 7) >> 8 - w3;
    }
    return bl2 + 3;
  }
  function write_bits_1(buf, bl2, v2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    v2 = (v2 & 1) << w3;
    buf[h4] |= v2;
    return bl2 + 1;
  }
  function write_bits_8(buf, bl2, v2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    v2 <<= w3;
    buf[h4] |= v2 & 255;
    v2 >>>= 8;
    buf[h4 + 1] = v2;
    return bl2 + 8;
  }
  function write_bits_16(buf, bl2, v2) {
    var w3 = bl2 & 7, h4 = bl2 >>> 3;
    v2 <<= w3;
    buf[h4] |= v2 & 255;
    v2 >>>= 8;
    buf[h4 + 1] = v2 & 255;
    buf[h4 + 2] = v2 >>> 8;
    return bl2 + 16;
  }
  function realloc(b2, sz) {
    var L3 = b2.length, M4 = 2 * L3 > sz ? 2 * L3 : sz + 5, i4 = 0;
    if (L3 >= sz) return b2;
    if (has_buf) {
      var o2 = new_unsafe_buf(M4);
      if (b2.copy) b2.copy(o2);
      else for (; i4 < b2.length; ++i4) o2[i4] = b2[i4];
      return o2;
    } else if (use_typed_arrays) {
      var a4 = new Uint8Array(M4);
      if (a4.set) a4.set(b2);
      else for (; i4 < L3; ++i4) a4[i4] = b2[i4];
      return a4;
    }
    b2.length = M4;
    return b2;
  }
  function zero_fill_array(n2) {
    var o2 = new Array(n2);
    for (var i4 = 0; i4 < n2; ++i4) o2[i4] = 0;
    return o2;
  }
  function build_tree(clens, cmap, MAX) {
    var maxlen = 1, w3 = 0, i4 = 0, j2 = 0, ccode = 0, L3 = clens.length;
    var bl_count = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
    for (i4 = 0; i4 < 32; ++i4) bl_count[i4] = 0;
    for (i4 = L3; i4 < MAX; ++i4) clens[i4] = 0;
    L3 = clens.length;
    var ctree = use_typed_arrays ? new Uint16Array(L3) : zero_fill_array(L3);
    for (i4 = 0; i4 < L3; ++i4) {
      bl_count[w3 = clens[i4]]++;
      if (maxlen < w3) maxlen = w3;
      ctree[i4] = 0;
    }
    bl_count[0] = 0;
    for (i4 = 1; i4 <= maxlen; ++i4) bl_count[i4 + 16] = ccode = ccode + bl_count[i4 - 1] << 1;
    for (i4 = 0; i4 < L3; ++i4) {
      ccode = clens[i4];
      if (ccode != 0) ctree[i4] = bl_count[ccode + 16]++;
    }
    var cleni = 0;
    for (i4 = 0; i4 < L3; ++i4) {
      cleni = clens[i4];
      if (cleni != 0) {
        ccode = bit_swap_n(ctree[i4], maxlen) >> maxlen - cleni;
        for (j2 = (1 << maxlen + 4 - cleni) - 1; j2 >= 0; --j2)
          cmap[ccode | j2 << cleni] = cleni & 15 | i4 << 4;
      }
    }
    return maxlen;
  }
  var fix_lmap = use_typed_arrays ? new Uint16Array(512) : zero_fill_array(512);
  var fix_dmap = use_typed_arrays ? new Uint16Array(32) : zero_fill_array(32);
  if (!use_typed_arrays) {
    for (var i3 = 0; i3 < 512; ++i3) fix_lmap[i3] = 0;
    for (i3 = 0; i3 < 32; ++i3) fix_dmap[i3] = 0;
  }
  (function() {
    var dlens = [];
    var i4 = 0;
    for (; i4 < 32; i4++) dlens.push(5);
    build_tree(dlens, fix_dmap, 32);
    var clens = [];
    i4 = 0;
    for (; i4 <= 143; i4++) clens.push(8);
    for (; i4 <= 255; i4++) clens.push(9);
    for (; i4 <= 279; i4++) clens.push(7);
    for (; i4 <= 287; i4++) clens.push(8);
    build_tree(clens, fix_lmap, 288);
  })();
  var _deflateRaw = /* @__PURE__ */ function _deflateRawIIFE() {
    var DST_LN_RE = use_typed_arrays ? new Uint8Array(32768) : [];
    var j2 = 0, k3 = 0;
    for (; j2 < DST_LN.length - 1; ++j2) {
      for (; k3 < DST_LN[j2 + 1]; ++k3) DST_LN_RE[k3] = j2;
    }
    for (; k3 < 32768; ++k3) DST_LN_RE[k3] = 29;
    var LEN_LN_RE = use_typed_arrays ? new Uint8Array(259) : [];
    for (j2 = 0, k3 = 0; j2 < LEN_LN.length - 1; ++j2) {
      for (; k3 < LEN_LN[j2 + 1]; ++k3) LEN_LN_RE[k3] = j2;
    }
    function write_stored(data, out) {
      var boff = 0;
      while (boff < data.length) {
        var L3 = Math.min(65535, data.length - boff);
        var h4 = boff + L3 == data.length;
        out.write_shift(1, +h4);
        out.write_shift(2, L3);
        out.write_shift(2, ~L3 & 65535);
        while (L3-- > 0) out[out.l++] = data[boff++];
      }
      return out.l;
    }
    function write_huff_fixed(data, out) {
      var bl2 = 0;
      var boff = 0;
      var addrs = use_typed_arrays ? new Uint16Array(32768) : [];
      while (boff < data.length) {
        var L3 = (
          /* data.length - boff; */
          Math.min(65535, data.length - boff)
        );
        if (L3 < 10) {
          bl2 = write_bits_3(out, bl2, +!!(boff + L3 == data.length));
          if (bl2 & 7) bl2 += 8 - (bl2 & 7);
          out.l = bl2 / 8 | 0;
          out.write_shift(2, L3);
          out.write_shift(2, ~L3 & 65535);
          while (L3-- > 0) out[out.l++] = data[boff++];
          bl2 = out.l * 8;
          continue;
        }
        bl2 = write_bits_3(out, bl2, +!!(boff + L3 == data.length) + 2);
        var hash = 0;
        while (L3-- > 0) {
          var d4 = data[boff];
          hash = (hash << 5 ^ d4) & 32767;
          var match2 = -1, mlen = 0;
          if (match2 = addrs[hash]) {
            match2 |= boff & -32768;
            if (match2 > boff) match2 -= 32768;
            if (match2 < boff) while (data[match2 + mlen] == data[boff + mlen] && mlen < 250) ++mlen;
          }
          if (mlen > 2) {
            d4 = LEN_LN_RE[mlen];
            if (d4 <= 22) bl2 = write_bits_8(out, bl2, bitswap8[d4 + 1] >> 1) - 1;
            else {
              write_bits_8(out, bl2, 3);
              bl2 += 5;
              write_bits_8(out, bl2, bitswap8[d4 - 23] >> 5);
              bl2 += 3;
            }
            var len_eb = d4 < 8 ? 0 : d4 - 4 >> 2;
            if (len_eb > 0) {
              write_bits_16(out, bl2, mlen - LEN_LN[d4]);
              bl2 += len_eb;
            }
            d4 = DST_LN_RE[boff - match2];
            bl2 = write_bits_8(out, bl2, bitswap8[d4] >> 3);
            bl2 -= 3;
            var dst_eb = d4 < 4 ? 0 : d4 - 2 >> 1;
            if (dst_eb > 0) {
              write_bits_16(out, bl2, boff - match2 - DST_LN[d4]);
              bl2 += dst_eb;
            }
            for (var q4 = 0; q4 < mlen; ++q4) {
              addrs[hash] = boff & 32767;
              hash = (hash << 5 ^ data[boff]) & 32767;
              ++boff;
            }
            L3 -= mlen - 1;
          } else {
            if (d4 <= 143) d4 = d4 + 48;
            else bl2 = write_bits_1(out, bl2, 1);
            bl2 = write_bits_8(out, bl2, bitswap8[d4]);
            addrs[hash] = boff & 32767;
            ++boff;
          }
        }
        bl2 = write_bits_8(out, bl2, 0) - 1;
      }
      out.l = (bl2 + 7) / 8 | 0;
      return out.l;
    }
    return function _deflateRaw2(data, out) {
      if (data.length < 8) return write_stored(data, out);
      return write_huff_fixed(data, out);
    };
  }();
  function _deflate(data) {
    var buf = new_buf(50 + Math.floor(data.length * 1.1));
    var off = _deflateRaw(data, buf);
    return buf.slice(0, off);
  }
  var dyn_lmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_dmap = use_typed_arrays ? new Uint16Array(32768) : zero_fill_array(32768);
  var dyn_cmap = use_typed_arrays ? new Uint16Array(128) : zero_fill_array(128);
  var dyn_len_1 = 1, dyn_len_2 = 1;
  function dyn(data, boff) {
    var _HLIT = read_bits_5(data, boff) + 257;
    boff += 5;
    var _HDIST = read_bits_5(data, boff) + 1;
    boff += 5;
    var _HCLEN = read_bits_4(data, boff) + 4;
    boff += 4;
    var w3 = 0;
    var clens = use_typed_arrays ? new Uint8Array(19) : zero_fill_array(19);
    var ctree = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    var maxlen = 1;
    var bl_count = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var next_code = use_typed_arrays ? new Uint8Array(8) : zero_fill_array(8);
    var L3 = clens.length;
    for (var i4 = 0; i4 < _HCLEN; ++i4) {
      clens[CLEN_ORDER[i4]] = w3 = read_bits_3(data, boff);
      if (maxlen < w3) maxlen = w3;
      bl_count[w3]++;
      boff += 3;
    }
    var ccode = 0;
    bl_count[0] = 0;
    for (i4 = 1; i4 <= maxlen; ++i4) next_code[i4] = ccode = ccode + bl_count[i4 - 1] << 1;
    for (i4 = 0; i4 < L3; ++i4) if ((ccode = clens[i4]) != 0) ctree[i4] = next_code[ccode]++;
    var cleni = 0;
    for (i4 = 0; i4 < L3; ++i4) {
      cleni = clens[i4];
      if (cleni != 0) {
        ccode = bitswap8[ctree[i4]] >> 8 - cleni;
        for (var j2 = (1 << 7 - cleni) - 1; j2 >= 0; --j2) dyn_cmap[ccode | j2 << cleni] = cleni & 7 | i4 << 3;
      }
    }
    var hcodes = [];
    maxlen = 1;
    for (; hcodes.length < _HLIT + _HDIST; ) {
      ccode = dyn_cmap[read_bits_7(data, boff)];
      boff += ccode & 7;
      switch (ccode >>>= 3) {
        case 16:
          w3 = 3 + read_bits_2(data, boff);
          boff += 2;
          ccode = hcodes[hcodes.length - 1];
          while (w3-- > 0) hcodes.push(ccode);
          break;
        case 17:
          w3 = 3 + read_bits_3(data, boff);
          boff += 3;
          while (w3-- > 0) hcodes.push(0);
          break;
        case 18:
          w3 = 11 + read_bits_7(data, boff);
          boff += 7;
          while (w3-- > 0) hcodes.push(0);
          break;
        default:
          hcodes.push(ccode);
          if (maxlen < ccode) maxlen = ccode;
          break;
      }
    }
    var h1 = hcodes.slice(0, _HLIT), h22 = hcodes.slice(_HLIT);
    for (i4 = _HLIT; i4 < 286; ++i4) h1[i4] = 0;
    for (i4 = _HDIST; i4 < 30; ++i4) h22[i4] = 0;
    dyn_len_1 = build_tree(h1, dyn_lmap, 286);
    dyn_len_2 = build_tree(h22, dyn_dmap, 30);
    return boff;
  }
  function inflate(data, usz) {
    if (data[0] == 3 && !(data[1] & 3)) {
      return [new_raw_buf(usz), 2];
    }
    var boff = 0;
    var header = 0;
    var outbuf = new_unsafe_buf(usz ? usz : 1 << 18);
    var woff = 0;
    var OL = outbuf.length >>> 0;
    var max_len_1 = 0, max_len_2 = 0;
    while ((header & 1) == 0) {
      header = read_bits_3(data, boff);
      boff += 3;
      if (header >>> 1 == 0) {
        if (boff & 7) boff += 8 - (boff & 7);
        var sz = data[boff >>> 3] | data[(boff >>> 3) + 1] << 8;
        boff += 32;
        if (sz > 0) {
          if (!usz && OL < woff + sz) {
            outbuf = realloc(outbuf, woff + sz);
            OL = outbuf.length;
          }
          while (sz-- > 0) {
            outbuf[woff++] = data[boff >>> 3];
            boff += 8;
          }
        }
        continue;
      } else if (header >> 1 == 1) {
        max_len_1 = 9;
        max_len_2 = 5;
      } else {
        boff = dyn(data, boff);
        max_len_1 = dyn_len_1;
        max_len_2 = dyn_len_2;
      }
      for (; ; ) {
        if (!usz && OL < woff + 32767) {
          outbuf = realloc(outbuf, woff + 32767);
          OL = outbuf.length;
        }
        var bits = read_bits_n(data, boff, max_len_1);
        var code = header >>> 1 == 1 ? fix_lmap[bits] : dyn_lmap[bits];
        boff += code & 15;
        code >>>= 4;
        if ((code >>> 8 & 255) === 0) outbuf[woff++] = code;
        else if (code == 256) break;
        else {
          code -= 257;
          var len_eb = code < 8 ? 0 : code - 4 >> 2;
          if (len_eb > 5) len_eb = 0;
          var tgt = woff + LEN_LN[code];
          if (len_eb > 0) {
            tgt += read_bits_n(data, boff, len_eb);
            boff += len_eb;
          }
          bits = read_bits_n(data, boff, max_len_2);
          code = header >>> 1 == 1 ? fix_dmap[bits] : dyn_dmap[bits];
          boff += code & 15;
          code >>>= 4;
          var dst_eb = code < 4 ? 0 : code - 2 >> 1;
          var dst = DST_LN[code];
          if (dst_eb > 0) {
            dst += read_bits_n(data, boff, dst_eb);
            boff += dst_eb;
          }
          if (!usz && OL < tgt) {
            outbuf = realloc(outbuf, tgt + 100);
            OL = outbuf.length;
          }
          while (woff < tgt) {
            outbuf[woff] = outbuf[woff - dst];
            ++woff;
          }
        }
      }
    }
    if (usz) return [outbuf, boff + 7 >>> 3];
    return [outbuf.slice(0, woff), boff + 7 >>> 3];
  }
  function _inflate(payload, usz) {
    var data = payload.slice(payload.l || 0);
    var out = inflate(data, usz);
    payload.l += out[1];
    return out[0];
  }
  function warn_or_throw(wrn, msg) {
    if (wrn) {
      if (typeof console !== "undefined") console.error(msg);
    } else throw new Error(msg);
  }
  function parse_zip2(file, options) {
    var blob = (
      /*::(*/
      file
    );
    prep_blob(blob, 0);
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2, { root: options.root });
    var i4 = blob.length - 4;
    while ((blob[i4] != 80 || blob[i4 + 1] != 75 || blob[i4 + 2] != 5 || blob[i4 + 3] != 6) && i4 >= 0) --i4;
    blob.l = i4 + 4;
    blob.l += 4;
    var fcnt = blob.read_shift(2);
    blob.l += 6;
    var start_cd = blob.read_shift(4);
    blob.l = start_cd;
    for (i4 = 0; i4 < fcnt; ++i4) {
      blob.l += 20;
      var csz = blob.read_shift(4);
      var usz = blob.read_shift(4);
      var namelen = blob.read_shift(2);
      var efsz = blob.read_shift(2);
      var fcsz = blob.read_shift(2);
      blob.l += 8;
      var offset2 = blob.read_shift(4);
      var EF = parse_extra_field(
        /*::(*/
        blob.slice(blob.l + namelen, blob.l + namelen + efsz)
        /*:: :any)*/
      );
      blob.l += namelen + efsz + fcsz;
      var L3 = blob.l;
      blob.l = offset2 + 4;
      parse_local_file(blob, csz, usz, o2, EF);
      blob.l = L3;
    }
    return o2;
  }
  function parse_local_file(blob, csz, usz, o2, EF) {
    blob.l += 2;
    var flags = blob.read_shift(2);
    var meth = blob.read_shift(2);
    var date = parse_dos_date(blob);
    if (flags & 8257) throw new Error("Unsupported ZIP encryption");
    var crc32 = blob.read_shift(4);
    var _csz = blob.read_shift(4);
    var _usz = blob.read_shift(4);
    var namelen = blob.read_shift(2);
    var efsz = blob.read_shift(2);
    var name = "";
    for (var i4 = 0; i4 < namelen; ++i4) name += String.fromCharCode(blob[blob.l++]);
    if (efsz) {
      var ef2 = parse_extra_field(
        /*::(*/
        blob.slice(blob.l, blob.l + efsz)
        /*:: :any)*/
      );
      if ((ef2[21589] || {}).mt) date = ef2[21589].mt;
      if (((EF || {})[21589] || {}).mt) date = EF[21589].mt;
    }
    blob.l += efsz;
    var data = blob.slice(blob.l, blob.l + _csz);
    switch (meth) {
      case 8:
        data = _inflateRawSync(blob, _usz);
        break;
      case 0:
        break;
      default:
        throw new Error("Unsupported ZIP Compression method " + meth);
    }
    var wrn = false;
    if (flags & 8) {
      crc32 = blob.read_shift(4);
      if (crc32 == 134695760) {
        crc32 = blob.read_shift(4);
        wrn = true;
      }
      _csz = blob.read_shift(4);
      _usz = blob.read_shift(4);
    }
    if (_csz != csz) warn_or_throw(wrn, "Bad compressed size: " + csz + " != " + _csz);
    if (_usz != usz) warn_or_throw(wrn, "Bad uncompressed size: " + usz + " != " + _usz);
    cfb_add(o2, name, data, { unsafe: true, mt: date });
  }
  function write_zip2(cfb, options) {
    var _opts = options || {};
    var out = [], cdirs = [];
    var o2 = new_buf(1);
    var method = _opts.compression ? 8 : 0, flags = 0;
    var i4 = 0, j2 = 0;
    var start_cd = 0, fcnt = 0;
    var root = cfb.FullPaths[0], fp = root, fi2 = cfb.FileIndex[0];
    var crcs = [];
    var sz_cd = 0;
    for (i4 = 1; i4 < cfb.FullPaths.length; ++i4) {
      fp = cfb.FullPaths[i4].slice(root.length);
      fi2 = cfb.FileIndex[i4];
      if (!fi2.size || !fi2.content || fp == "Sh33tJ5") continue;
      var start = start_cd;
      var namebuf = new_buf(fp.length);
      for (j2 = 0; j2 < fp.length; ++j2) namebuf.write_shift(1, fp.charCodeAt(j2) & 127);
      namebuf = namebuf.slice(0, namebuf.l);
      crcs[fcnt] = CRC32.buf(
        /*::((*/
        fi2.content,
        0
      );
      var outbuf = fi2.content;
      if (method == 8) outbuf = _deflateRawSync(outbuf);
      o2 = new_buf(30);
      o2.write_shift(4, 67324752);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      if (fi2.mt) write_dos_date(o2, fi2.mt);
      else o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi2.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      start_cd += o2.length;
      out.push(o2);
      start_cd += namebuf.length;
      out.push(namebuf);
      start_cd += outbuf.length;
      out.push(outbuf);
      o2 = new_buf(46);
      o2.write_shift(4, 33639248);
      o2.write_shift(2, 0);
      o2.write_shift(2, 20);
      o2.write_shift(2, flags);
      o2.write_shift(2, method);
      o2.write_shift(4, 0);
      o2.write_shift(-4, crcs[fcnt]);
      o2.write_shift(4, outbuf.length);
      o2.write_shift(
        4,
        /*::(*/
        fi2.content.length
      );
      o2.write_shift(2, namebuf.length);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(2, 0);
      o2.write_shift(4, 0);
      o2.write_shift(4, start);
      sz_cd += o2.l;
      cdirs.push(o2);
      sz_cd += namebuf.length;
      cdirs.push(namebuf);
      ++fcnt;
    }
    o2 = new_buf(22);
    o2.write_shift(4, 101010256);
    o2.write_shift(2, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, fcnt);
    o2.write_shift(2, fcnt);
    o2.write_shift(4, sz_cd);
    o2.write_shift(4, start_cd);
    o2.write_shift(2, 0);
    return bconcat([bconcat(out), bconcat(cdirs), o2]);
  }
  var ContentTypeMap = {
    "htm": "text/html",
    "xml": "text/xml",
    "gif": "image/gif",
    "jpg": "image/jpeg",
    "png": "image/png",
    "mso": "application/x-mso",
    "thmx": "application/vnd.ms-officetheme",
    "sh33tj5": "application/octet-stream"
  };
  function get_content_type(fi2, fp) {
    if (fi2.ctype) return fi2.ctype;
    var ext = fi2.name || "", m4 = ext.match(/\.([^\.]+)$/);
    if (m4 && ContentTypeMap[m4[1]]) return ContentTypeMap[m4[1]];
    if (fp) {
      m4 = (ext = fp).match(/[\.\\]([^\.\\])+$/);
      if (m4 && ContentTypeMap[m4[1]]) return ContentTypeMap[m4[1]];
    }
    return "application/octet-stream";
  }
  function write_base64_76(bstr) {
    var data = Base64_encode(bstr);
    var o2 = [];
    for (var i4 = 0; i4 < data.length; i4 += 76) o2.push(data.slice(i4, i4 + 76));
    return o2.join("\r\n") + "\r\n";
  }
  function write_quoted_printable(text) {
    var encoded = text.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF=]/g, function(c3) {
      var w3 = c3.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (w3.length == 1 ? "0" + w3 : w3);
    });
    encoded = encoded.replace(/ $/mg, "=20").replace(/\t$/mg, "=09");
    if (encoded.charAt(0) == "\n") encoded = "=0D" + encoded.slice(1);
    encoded = encoded.replace(/\r(?!\n)/mg, "=0D").replace(/\n\n/mg, "\n=0A").replace(/([^\r\n])\n/mg, "$1=0A");
    var o2 = [], split = encoded.split("\r\n");
    for (var si2 = 0; si2 < split.length; ++si2) {
      var str = split[si2];
      if (str.length == 0) {
        o2.push("");
        continue;
      }
      for (var i4 = 0; i4 < str.length; ) {
        var end = 76;
        var tmp = str.slice(i4, i4 + end);
        if (tmp.charAt(end - 1) == "=") end--;
        else if (tmp.charAt(end - 2) == "=") end -= 2;
        else if (tmp.charAt(end - 3) == "=") end -= 3;
        tmp = str.slice(i4, i4 + end);
        i4 += end;
        if (i4 < str.length) tmp += "=";
        o2.push(tmp);
      }
    }
    return o2.join("\r\n");
  }
  function parse_quoted_printable(data) {
    var o2 = [];
    for (var di2 = 0; di2 < data.length; ++di2) {
      var line = data[di2];
      while (di2 <= data.length && line.charAt(line.length - 1) == "=") line = line.slice(0, line.length - 1) + data[++di2];
      o2.push(line);
    }
    for (var oi2 = 0; oi2 < o2.length; ++oi2) o2[oi2] = o2[oi2].replace(/[=][0-9A-Fa-f]{2}/g, function($$) {
      return String.fromCharCode(parseInt($$.slice(1), 16));
    });
    return s2a(o2.join("\r\n"));
  }
  function parse_mime(cfb, data, root) {
    var fname = "", cte = "", ctype = "", fdata;
    var di2 = 0;
    for (; di2 < 10; ++di2) {
      var line = data[di2];
      if (!line || line.match(/^\s*$/)) break;
      var m4 = line.match(/^(.*?):\s*([^\s].*)$/);
      if (m4) switch (m4[1].toLowerCase()) {
        case "content-location":
          fname = m4[2].trim();
          break;
        case "content-type":
          ctype = m4[2].trim();
          break;
        case "content-transfer-encoding":
          cte = m4[2].trim();
          break;
      }
    }
    ++di2;
    switch (cte.toLowerCase()) {
      case "base64":
        fdata = s2a(Base64_decode(data.slice(di2).join("")));
        break;
      case "quoted-printable":
        fdata = parse_quoted_printable(data.slice(di2));
        break;
      default:
        throw new Error("Unsupported Content-Transfer-Encoding " + cte);
    }
    var file = cfb_add(cfb, fname.slice(root.length), fdata, { unsafe: true });
    if (ctype) file.ctype = ctype;
  }
  function parse_mad(file, options) {
    if (a2s2(file.slice(0, 13)).toLowerCase() != "mime-version:") throw new Error("Unsupported MAD header");
    var root = options && options.root || "";
    var data = (has_buf && Buffer.isBuffer(file) ? file.toString("binary") : a2s2(file)).split("\r\n");
    var di2 = 0, row = "";
    for (di2 = 0; di2 < data.length; ++di2) {
      row = data[di2];
      if (!/^Content-Location:/i.test(row)) continue;
      row = row.slice(row.indexOf("file"));
      if (!root) root = row.slice(0, row.lastIndexOf("/") + 1);
      if (row.slice(0, root.length) == root) continue;
      while (root.length > 0) {
        root = root.slice(0, root.length - 1);
        root = root.slice(0, root.lastIndexOf("/") + 1);
        if (row.slice(0, root.length) == root) break;
      }
    }
    var mboundary = (data[1] || "").match(/boundary="(.*?)"/);
    if (!mboundary) throw new Error("MAD cannot find boundary");
    var boundary = "--" + (mboundary[1] || "");
    var FileIndex = [], FullPaths = [];
    var o2 = {
      FileIndex,
      FullPaths
    };
    init_cfb(o2);
    var start_di, fcnt = 0;
    for (di2 = 0; di2 < data.length; ++di2) {
      var line = data[di2];
      if (line !== boundary && line !== boundary + "--") continue;
      if (fcnt++) parse_mime(o2, data.slice(start_di, di2), root);
      start_di = di2;
    }
    return o2;
  }
  function write_mad(cfb, options) {
    var opts = options || {};
    var boundary = opts.boundary || "SheetJS";
    boundary = "------=" + boundary;
    var out = [
      "MIME-Version: 1.0",
      'Content-Type: multipart/related; boundary="' + boundary.slice(2) + '"',
      "",
      "",
      ""
    ];
    var root = cfb.FullPaths[0], fp = root, fi2 = cfb.FileIndex[0];
    for (var i4 = 1; i4 < cfb.FullPaths.length; ++i4) {
      fp = cfb.FullPaths[i4].slice(root.length);
      fi2 = cfb.FileIndex[i4];
      if (!fi2.size || !fi2.content || fp == "Sh33tJ5") continue;
      fp = fp.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7E-\xFF]/g, function(c3) {
        return "_x" + c3.charCodeAt(0).toString(16) + "_";
      }).replace(/[\u0080-\uFFFF]/g, function(u3) {
        return "_u" + u3.charCodeAt(0).toString(16) + "_";
      });
      var ca2 = fi2.content;
      var cstr = has_buf && Buffer.isBuffer(ca2) ? ca2.toString("binary") : a2s2(ca2);
      var dispcnt = 0, L3 = Math.min(1024, cstr.length), cc2 = 0;
      for (var csl = 0; csl <= L3; ++csl) if ((cc2 = cstr.charCodeAt(csl)) >= 32 && cc2 < 128) ++dispcnt;
      var qp = dispcnt >= L3 * 4 / 5;
      out.push(boundary);
      out.push("Content-Location: " + (opts.root || "file:///C:/SheetJS/") + fp);
      out.push("Content-Transfer-Encoding: " + (qp ? "quoted-printable" : "base64"));
      out.push("Content-Type: " + get_content_type(fi2, fp));
      out.push("");
      out.push(qp ? write_quoted_printable(cstr) : write_base64_76(cstr));
    }
    out.push(boundary + "--\r\n");
    return out.join("\r\n");
  }
  function cfb_new(opts) {
    var o2 = {};
    init_cfb(o2, opts);
    return o2;
  }
  function cfb_add(cfb, name, content, opts) {
    var unsafe = opts && opts.unsafe;
    if (!unsafe) init_cfb(cfb);
    var file = !unsafe && CFB.find(cfb, name);
    if (!file) {
      var fpath = cfb.FullPaths[0];
      if (name.slice(0, fpath.length) == fpath) fpath = name;
      else {
        if (fpath.slice(-1) != "/") fpath += "/";
        fpath = (fpath + name).replace("//", "/");
      }
      file = { name: filename(name), type: 2 };
      cfb.FileIndex.push(file);
      cfb.FullPaths.push(fpath);
      if (!unsafe) CFB.utils.cfb_gc(cfb);
    }
    file.content = content;
    file.size = content ? content.length : 0;
    if (opts) {
      if (opts.CLSID) file.clsid = opts.CLSID;
      if (opts.mt) file.mt = opts.mt;
      if (opts.ct) file.ct = opts.ct;
    }
    return file;
  }
  function cfb_del(cfb, name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2) if (cfb.FileIndex[j2] == file) {
        cfb.FileIndex.splice(j2, 1);
        cfb.FullPaths.splice(j2, 1);
        return true;
      }
    }
    return false;
  }
  function cfb_mov(cfb, old_name, new_name) {
    init_cfb(cfb);
    var file = CFB.find(cfb, old_name);
    if (file) {
      for (var j2 = 0; j2 < cfb.FileIndex.length; ++j2) if (cfb.FileIndex[j2] == file) {
        cfb.FileIndex[j2].name = filename(new_name);
        cfb.FullPaths[j2] = new_name;
        return true;
      }
    }
    return false;
  }
  function cfb_gc(cfb) {
    rebuild_cfb(cfb, true);
  }
  exports.find = find;
  exports.read = read;
  exports.parse = parse2;
  exports.write = write;
  exports.writeFile = write_file;
  exports.utils = {
    cfb_new,
    cfb_add,
    cfb_del,
    cfb_mov,
    cfb_gc,
    ReadShift,
    CheckField,
    prep_blob,
    bconcat,
    use_zlib,
    _deflateRaw: _deflate,
    _inflateRaw: _inflate,
    consts
  };
  return exports;
}();
function blobify(data) {
  if (typeof data === "string") return s2ab(data);
  if (Array.isArray(data)) return a2u(data);
  return data;
}
function write_dl(fname, payload, enc) {
  if (typeof Deno !== "undefined") {
    if (enc && typeof payload == "string") switch (enc) {
      case "utf8":
        payload = new TextEncoder(enc).encode(payload);
        break;
      case "binary":
        payload = s2ab(payload);
        break;
      default:
        throw new Error("Unsupported encoding " + enc);
    }
    return Deno.writeFileSync(fname, payload);
  }
  var data = enc == "utf8" ? utf8write(payload) : payload;
  if (typeof IE_SaveFile !== "undefined") return IE_SaveFile(data, fname);
  if (typeof Blob !== "undefined") {
    var blob = new Blob([blobify(data)], { type: "application/octet-stream" });
    if (typeof navigator !== "undefined" && navigator.msSaveBlob) return navigator.msSaveBlob(blob, fname);
    if (typeof saveAs !== "undefined") return saveAs(blob, fname);
    if (typeof URL !== "undefined" && typeof document !== "undefined" && document.createElement && URL.createObjectURL) {
      var url2 = URL.createObjectURL(blob);
      if (typeof chrome === "object" && typeof (chrome.downloads || {}).download == "function") {
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
          URL.revokeObjectURL(url2);
        }, 6e4);
        return chrome.downloads.download({ url: url2, filename: fname, saveAs: true });
      }
      var a4 = document.createElement("a");
      if (a4.download != null) {
        a4.download = fname;
        a4.href = url2;
        document.body.appendChild(a4);
        a4.click();
        document.body.removeChild(a4);
        if (URL.revokeObjectURL && typeof setTimeout !== "undefined") setTimeout(function() {
          URL.revokeObjectURL(url2);
        }, 6e4);
        return url2;
      }
    }
  }
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
    var out = File(fname);
    out.open("w");
    out.encoding = "binary";
    if (Array.isArray(payload)) payload = a2s(payload);
    out.write(payload);
    out.close();
    return payload;
  } catch (e3) {
    if (!e3.message || !e3.message.match(/onstruct/)) throw e3;
  }
  throw new Error("cannot save file " + fname);
}
function read_binary(path) {
  if (typeof Deno !== "undefined") return Deno.readFileSync(path);
  if (typeof $ !== "undefined" && typeof File !== "undefined" && typeof Folder !== "undefined") try {
    var infile = File(path);
    infile.open("r");
    infile.encoding = "binary";
    var data = infile.read();
    infile.close();
    return data;
  } catch (e3) {
    if (!e3.message || !e3.message.match(/onstruct/)) throw e3;
  }
  throw new Error("Cannot access file " + path);
}
function keys(o2) {
  var ks = Object.keys(o2), o22 = [];
  for (var i3 = 0; i3 < ks.length; ++i3) if (Object.prototype.hasOwnProperty.call(o2, ks[i3])) o22.push(ks[i3]);
  return o22;
}
function evert_key(obj, key) {
  var o2 = [], K3 = keys(obj);
  for (var i3 = 0; i3 !== K3.length; ++i3) if (o2[obj[K3[i3]][key]] == null) o2[obj[K3[i3]][key]] = K3[i3];
  return o2;
}
function evert(obj) {
  var o2 = [], K3 = keys(obj);
  for (var i3 = 0; i3 !== K3.length; ++i3) o2[obj[K3[i3]]] = K3[i3];
  return o2;
}
function evert_num(obj) {
  var o2 = [], K3 = keys(obj);
  for (var i3 = 0; i3 !== K3.length; ++i3) o2[obj[K3[i3]]] = parseInt(K3[i3], 10);
  return o2;
}
function evert_arr(obj) {
  var o2 = [], K3 = keys(obj);
  for (var i3 = 0; i3 !== K3.length; ++i3) {
    if (o2[obj[K3[i3]]] == null) o2[obj[K3[i3]]] = [];
    o2[obj[K3[i3]]].push(K3[i3]);
  }
  return o2;
}
var basedate = /* @__PURE__ */ new Date(1899, 11, 30, 0, 0, 0);
function datenum(v2, date1904) {
  var epoch = /* @__PURE__ */ v2.getTime();
  var dnthresh2 = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ v2.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
  return (epoch - dnthresh2) / (24 * 60 * 60 * 1e3);
}
var refdate = /* @__PURE__ */ new Date();
var dnthresh = /* @__PURE__ */ basedate.getTime() + (/* @__PURE__ */ refdate.getTimezoneOffset() - /* @__PURE__ */ basedate.getTimezoneOffset()) * 6e4;
var refoffset = /* @__PURE__ */ refdate.getTimezoneOffset();
function numdate(v2) {
  var out = /* @__PURE__ */ new Date();
  out.setTime(v2 * 24 * 60 * 60 * 1e3 + dnthresh);
  if (out.getTimezoneOffset() !== refoffset) {
    out.setTime(out.getTime() + (out.getTimezoneOffset() - refoffset) * 6e4);
  }
  return out;
}
function parse_isodur(s4) {
  var sec = 0, mt = 0, time = false;
  var m4 = s4.match(/P([0-9\.]+Y)?([0-9\.]+M)?([0-9\.]+D)?T([0-9\.]+H)?([0-9\.]+M)?([0-9\.]+S)?/);
  if (!m4) throw new Error("|" + s4 + "| is not an ISO8601 Duration");
  for (var i3 = 1; i3 != m4.length; ++i3) {
    if (!m4[i3]) continue;
    mt = 1;
    if (i3 > 3) time = true;
    switch (m4[i3].slice(m4[i3].length - 1)) {
      case "Y":
        throw new Error("Unsupported ISO Duration Field: " + m4[i3].slice(m4[i3].length - 1));
      case "D":
        mt *= 24;
      case "H":
        mt *= 60;
      case "M":
        if (!time) throw new Error("Unsupported ISO Duration Field: M");
        else mt *= 60;
    }
    sec += mt * parseInt(m4[i3], 10);
  }
  return sec;
}
var good_pd_date_1 = /* @__PURE__ */ new Date("2017-02-19T19:06:09.000Z");
var good_pd_date = /* @__PURE__ */ isNaN(/* @__PURE__ */ good_pd_date_1.getFullYear()) ? /* @__PURE__ */ new Date("2/19/17") : good_pd_date_1;
var good_pd = /* @__PURE__ */ good_pd_date.getFullYear() == 2017;
function parseDate(str, fixdate) {
  var d4 = new Date(str);
  if (good_pd) {
    if (fixdate > 0) d4.setTime(d4.getTime() + d4.getTimezoneOffset() * 60 * 1e3);
    else if (fixdate < 0) d4.setTime(d4.getTime() - d4.getTimezoneOffset() * 60 * 1e3);
    return d4;
  }
  if (str instanceof Date) return str;
  if (good_pd_date.getFullYear() == 1917 && !isNaN(d4.getFullYear())) {
    var s4 = d4.getFullYear();
    if (str.indexOf("" + s4) > -1) return d4;
    d4.setFullYear(d4.getFullYear() + 100);
    return d4;
  }
  var n2 = str.match(/\d+/g) || ["2017", "2", "19", "0", "0", "0"];
  var out = new Date(+n2[0], +n2[1] - 1, +n2[2], +n2[3] || 0, +n2[4] || 0, +n2[5] || 0);
  if (str.indexOf("Z") > -1) out = new Date(out.getTime() - out.getTimezoneOffset() * 60 * 1e3);
  return out;
}
function cc2str(arr, debomit) {
  if (has_buf && Buffer.isBuffer(arr)) {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(arr.slice(2).toString("utf16le"));
      if (arr[1] == 254 && arr[2] == 255) return utf8write(utf16beread(arr.slice(2).toString("binary")));
    }
    return arr.toString("binary");
  }
  if (typeof TextDecoder !== "undefined") try {
    if (debomit) {
      if (arr[0] == 255 && arr[1] == 254) return utf8write(new TextDecoder("utf-16le").decode(arr.slice(2)));
      if (arr[0] == 254 && arr[1] == 255) return utf8write(new TextDecoder("utf-16be").decode(arr.slice(2)));
    }
    var rev = {
      "€": "",
      "‚": "",
      "ƒ": "",
      "„": "",
      "…": "",
      "†": "",
      "‡": "",
      "ˆ": "",
      "‰": "",
      "Š": "",
      "‹": "",
      "Œ": "",
      "Ž": "",
      "‘": "",
      "’": "",
      "“": "",
      "”": "",
      "•": "",
      "–": "",
      "—": "",
      "˜": "",
      "™": "",
      "š": "",
      "›": "",
      "œ": "",
      "ž": "",
      "Ÿ": ""
    };
    if (Array.isArray(arr)) arr = new Uint8Array(arr);
    return new TextDecoder("latin1").decode(arr).replace(/[€‚ƒ„…†‡ˆ‰Š‹ŒŽ‘’“”•–—˜™š›œžŸ]/g, function(c3) {
      return rev[c3] || c3;
    });
  } catch (e3) {
  }
  var o2 = [];
  for (var i3 = 0; i3 != arr.length; ++i3) o2.push(String.fromCharCode(arr[i3]));
  return o2.join("");
}
function dup(o2) {
  if (typeof JSON != "undefined" && !Array.isArray(o2)) return JSON.parse(JSON.stringify(o2));
  if (typeof o2 != "object" || o2 == null) return o2;
  if (o2 instanceof Date) return new Date(o2.getTime());
  var out = {};
  for (var k3 in o2) if (Object.prototype.hasOwnProperty.call(o2, k3)) out[k3] = dup(o2[k3]);
  return out;
}
function fill(c3, l2) {
  var o2 = "";
  while (o2.length < l2) o2 += c3;
  return o2;
}
function fuzzynum(s4) {
  var v2 = Number(s4);
  if (!isNaN(v2)) return isFinite(v2) ? v2 : NaN;
  if (!/\d/.test(s4)) return v2;
  var wt2 = 1;
  var ss = s4.replace(/([\d]),([\d])/g, "$1$2").replace(/[$]/g, "").replace(/[%]/g, function() {
    wt2 *= 100;
    return "";
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt2;
  ss = ss.replace(/[(](.*)[)]/, function($$, $1) {
    wt2 = -wt2;
    return $1;
  });
  if (!isNaN(v2 = Number(ss))) return v2 / wt2;
  return v2;
}
var lower_months = ["january", "february", "march", "april", "may", "june", "july", "august", "september", "october", "november", "december"];
function fuzzydate(s4) {
  var o2 = new Date(s4), n2 = /* @__PURE__ */ new Date(NaN);
  var y4 = o2.getYear(), m4 = o2.getMonth(), d4 = o2.getDate();
  if (isNaN(d4)) return n2;
  var lower = s4.toLowerCase();
  if (lower.match(/jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec/)) {
    lower = lower.replace(/[^a-z]/g, "").replace(/([^a-z]|^)[ap]m?([^a-z]|$)/, "");
    if (lower.length > 3 && lower_months.indexOf(lower) == -1) return n2;
  } else if (lower.match(/[a-z]/)) return n2;
  if (y4 < 0 || y4 > 8099) return n2;
  if ((m4 > 0 || d4 > 1) && y4 != 101) return o2;
  if (s4.match(/[^-0-9:,\/\\]/)) return n2;
  return o2;
}
var split_regex = /* @__PURE__ */ function() {
  var safe_split_regex = "abacaba".split(/(:?b)/i).length == 5;
  return function split_regex2(str, re2, def) {
    if (safe_split_regex || typeof re2 == "string") return str.split(re2);
    var p2 = str.split(re2), o2 = [p2[0]];
    for (var i3 = 1; i3 < p2.length; ++i3) {
      o2.push(def);
      o2.push(p2[i3]);
    }
    return o2;
  };
}();
function getdatastr(data) {
  if (!data) return null;
  if (data.content && data.type) return cc2str(data.content, true);
  if (data.data) return debom(data.data);
  if (data.asNodeBuffer && has_buf) return debom(data.asNodeBuffer().toString("binary"));
  if (data.asBinary) return debom(data.asBinary());
  if (data._data && data._data.getContent) return debom(cc2str(Array.prototype.slice.call(data._data.getContent(), 0)));
  return null;
}
function getdatabin(data) {
  if (!data) return null;
  if (data.data) return char_codes(data.data);
  if (data.asNodeBuffer && has_buf) return data.asNodeBuffer();
  if (data._data && data._data.getContent) {
    var o2 = data._data.getContent();
    if (typeof o2 == "string") return char_codes(o2);
    return Array.prototype.slice.call(o2);
  }
  if (data.content && data.type) return data.content;
  return null;
}
function getdata(data) {
  return data && data.name.slice(-4) === ".bin" ? getdatabin(data) : getdatastr(data);
}
function safegetzipfile(zip, file) {
  var k3 = zip.FullPaths || keys(zip.files);
  var f2 = file.toLowerCase().replace(/[\/]/g, "\\"), g2 = f2.replace(/\\/g, "/");
  for (var i3 = 0; i3 < k3.length; ++i3) {
    var n2 = k3[i3].replace(/^Root Entry[\/]/, "").toLowerCase();
    if (f2 == n2 || g2 == n2) return zip.files ? zip.files[k3[i3]] : zip.FileIndex[i3];
  }
  return null;
}
function getzipfile(zip, file) {
  var o2 = safegetzipfile(zip, file);
  if (o2 == null) throw new Error("Cannot find file " + file + " in zip");
  return o2;
}
function getzipdata(zip, file, safe) {
  if (!safe) return getdata(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipdata(zip, file);
  } catch (e3) {
    return null;
  }
}
function getzipstr(zip, file, safe) {
  if (!safe) return getdatastr(getzipfile(zip, file));
  if (!file) return null;
  try {
    return getzipstr(zip, file);
  } catch (e3) {
    return null;
  }
}
function getzipbin(zip, file, safe) {
  return getdatabin(getzipfile(zip, file));
}
function zipentries(zip) {
  var k3 = zip.FullPaths || keys(zip.files), o2 = [];
  for (var i3 = 0; i3 < k3.length; ++i3) if (k3[i3].slice(-1) != "/") o2.push(k3[i3].replace(/^Root Entry[\/]/, ""));
  return o2.sort();
}
function zip_add_file(zip, path, content) {
  if (zip.FullPaths) {
    if (typeof content == "string") {
      var res;
      if (has_buf) res = Buffer_from(content);
      else res = utf8decode(content);
      return CFB.utils.cfb_add(zip, path, res);
    }
    CFB.utils.cfb_add(zip, path, content);
  } else zip.file(path, content);
}
function zip_new() {
  return CFB.utils.cfb_new();
}
function zip_read(d4, o2) {
  switch (o2.type) {
    case "base64":
      return CFB.read(d4, { type: "base64" });
    case "binary":
      return CFB.read(d4, { type: "binary" });
    case "buffer":
    case "array":
      return CFB.read(d4, { type: "buffer" });
  }
  throw new Error("Unrecognized type " + o2.type);
}
function resolve_path(path, base) {
  if (path.charAt(0) == "/") return path.slice(1);
  var result = base.split("/");
  if (base.slice(-1) != "/") result.pop();
  var target = path.split("/");
  while (target.length !== 0) {
    var step = target.shift();
    if (step === "..") result.pop();
    else if (step !== ".") result.push(step);
  }
  return result.join("/");
}
var XML_HEADER = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var attregexg = /([^"\s?>\/]+)\s*=\s*((?:")([^"]*)(?:")|(?:')([^']*)(?:')|([^'">\s]+))/g;
var tagregex1 = /<[\/\?]?[a-zA-Z0-9:_-]+(?:\s+[^"\s?>\/]+\s*=\s*(?:"[^"]*"|'[^']*'|[^'">\s=]+))*\s*[\/\?]?>/mg, tagregex2 = /<[^>]*>/g;
var tagregex = /* @__PURE__ */ XML_HEADER.match(tagregex1) ? tagregex1 : tagregex2;
var nsregex = /<\w*:/, nsregex2 = /<(\/?)\w+:/;
function parsexmltag(tag, skip_root, skip_LC) {
  var z3 = {};
  var eq = 0, c3 = 0;
  for (; eq !== tag.length; ++eq) if ((c3 = tag.charCodeAt(eq)) === 32 || c3 === 10 || c3 === 13) break;
  if (!skip_root) z3[0] = tag.slice(0, eq);
  if (eq === tag.length) return z3;
  var m4 = tag.match(attregexg), j2 = 0, v2 = "", i3 = 0, q3 = "", cc2 = "", quot = 1;
  if (m4) for (i3 = 0; i3 != m4.length; ++i3) {
    cc2 = m4[i3];
    for (c3 = 0; c3 != cc2.length; ++c3) if (cc2.charCodeAt(c3) === 61) break;
    q3 = cc2.slice(0, c3).trim();
    while (cc2.charCodeAt(c3 + 1) == 32) ++c3;
    quot = (eq = cc2.charCodeAt(c3 + 1)) == 34 || eq == 39 ? 1 : 0;
    v2 = cc2.slice(c3 + 1 + quot, cc2.length - quot);
    for (j2 = 0; j2 != q3.length; ++j2) if (q3.charCodeAt(j2) === 58) break;
    if (j2 === q3.length) {
      if (q3.indexOf("_") > 0) q3 = q3.slice(0, q3.indexOf("_"));
      z3[q3] = v2;
      z3[q3.toLowerCase()] = v2;
    } else {
      var k3 = (j2 === 5 && q3.slice(0, 5) === "xmlns" ? "xmlns" : "") + q3.slice(j2 + 1);
      if (z3[k3] && q3.slice(j2 - 3, j2) == "ext") continue;
      z3[k3] = v2;
      z3[k3.toLowerCase()] = v2;
    }
  }
  return z3;
}
function strip_ns(x3) {
  return x3.replace(nsregex2, "<$1");
}
var encodings = {
  "&quot;": '"',
  "&apos;": "'",
  "&gt;": ">",
  "&lt;": "<",
  "&amp;": "&"
};
var rencoding = /* @__PURE__ */ evert(encodings);
var unescapexml = /* @__PURE__ */ function() {
  var encregex = /&(?:quot|apos|gt|lt|amp|#x?([\da-fA-F]+));/ig, coderegex = /_x([\da-fA-F]{4})_/ig;
  return function unescapexml2(text) {
    var s4 = text + "", i3 = s4.indexOf("<![CDATA[");
    if (i3 == -1) return s4.replace(encregex, function($$, $1) {
      return encodings[$$] || String.fromCharCode(parseInt($1, $$.indexOf("x") > -1 ? 16 : 10)) || $$;
    }).replace(coderegex, function(m4, c3) {
      return String.fromCharCode(parseInt(c3, 16));
    });
    var j2 = s4.indexOf("]]>");
    return unescapexml2(s4.slice(0, i3)) + s4.slice(i3 + 9, j2) + unescapexml2(s4.slice(j2 + 3));
  };
}();
var decregex = /[&<>'"]/g, charegex = /[\u0000-\u0008\u000b-\u001f]/g;
function escapexml(text) {
  var s4 = text + "";
  return s4.replace(decregex, function(y4) {
    return rencoding[y4];
  }).replace(charegex, function(s5) {
    return "_x" + ("000" + s5.charCodeAt(0).toString(16)).slice(-4) + "_";
  });
}
function escapexmltag(text) {
  return escapexml(text).replace(/ /g, "_x0020_");
}
var htmlcharegex = /[\u0000-\u001f]/g;
function escapehtml(text) {
  var s4 = text + "";
  return s4.replace(decregex, function(y4) {
    return rencoding[y4];
  }).replace(/\n/g, "<br/>").replace(htmlcharegex, function(s5) {
    return "&#x" + ("000" + s5.charCodeAt(0).toString(16)).slice(-4) + ";";
  });
}
function escapexlml(text) {
  var s4 = text + "";
  return s4.replace(decregex, function(y4) {
    return rencoding[y4];
  }).replace(htmlcharegex, function(s5) {
    return "&#x" + s5.charCodeAt(0).toString(16).toUpperCase() + ";";
  });
}
var xlml_fixstr = /* @__PURE__ */ function() {
  var entregex = /&#(\d+);/g;
  function entrepl($$, $1) {
    return String.fromCharCode(parseInt($1, 10));
  }
  return function xlml_fixstr2(str) {
    return str.replace(entregex, entrepl);
  };
}();
function xlml_unfixstr(str) {
  return str.replace(/(\r\n|[\r\n])/g, "&#10;");
}
function parsexmlbool(value) {
  switch (value) {
    case 1:
    case true:
    case "1":
    case "true":
    case "TRUE":
      return true;
    default:
      return false;
  }
}
function utf8reada(orig) {
  var out = "", i3 = 0, c3 = 0, d4 = 0, e3 = 0, f2 = 0, w3 = 0;
  while (i3 < orig.length) {
    c3 = orig.charCodeAt(i3++);
    if (c3 < 128) {
      out += String.fromCharCode(c3);
      continue;
    }
    d4 = orig.charCodeAt(i3++);
    if (c3 > 191 && c3 < 224) {
      f2 = (c3 & 31) << 6;
      f2 |= d4 & 63;
      out += String.fromCharCode(f2);
      continue;
    }
    e3 = orig.charCodeAt(i3++);
    if (c3 < 240) {
      out += String.fromCharCode((c3 & 15) << 12 | (d4 & 63) << 6 | e3 & 63);
      continue;
    }
    f2 = orig.charCodeAt(i3++);
    w3 = ((c3 & 7) << 18 | (d4 & 63) << 12 | (e3 & 63) << 6 | f2 & 63) - 65536;
    out += String.fromCharCode(55296 + (w3 >>> 10 & 1023));
    out += String.fromCharCode(56320 + (w3 & 1023));
  }
  return out;
}
function utf8readb(data) {
  var out = new_raw_buf(2 * data.length), w3, i3, j2 = 1, k3 = 0, ww = 0, c3;
  for (i3 = 0; i3 < data.length; i3 += j2) {
    j2 = 1;
    if ((c3 = data.charCodeAt(i3)) < 128) w3 = c3;
    else if (c3 < 224) {
      w3 = (c3 & 31) * 64 + (data.charCodeAt(i3 + 1) & 63);
      j2 = 2;
    } else if (c3 < 240) {
      w3 = (c3 & 15) * 4096 + (data.charCodeAt(i3 + 1) & 63) * 64 + (data.charCodeAt(i3 + 2) & 63);
      j2 = 3;
    } else {
      j2 = 4;
      w3 = (c3 & 7) * 262144 + (data.charCodeAt(i3 + 1) & 63) * 4096 + (data.charCodeAt(i3 + 2) & 63) * 64 + (data.charCodeAt(i3 + 3) & 63);
      w3 -= 65536;
      ww = 55296 + (w3 >>> 10 & 1023);
      w3 = 56320 + (w3 & 1023);
    }
    if (ww !== 0) {
      out[k3++] = ww & 255;
      out[k3++] = ww >>> 8;
      ww = 0;
    }
    out[k3++] = w3 % 256;
    out[k3++] = w3 >>> 8;
  }
  return out.slice(0, k3).toString("ucs2");
}
function utf8readc(data) {
  return Buffer_from(data, "binary").toString("utf8");
}
var utf8corpus = "foo bar bazâð£";
var utf8read = has_buf && (/* @__PURE__ */ utf8readc(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readc || /* @__PURE__ */ utf8readb(utf8corpus) == /* @__PURE__ */ utf8reada(utf8corpus) && utf8readb) || utf8reada;
var utf8write = has_buf ? function(data) {
  return Buffer_from(data, "utf8").toString("binary");
} : function(orig) {
  var out = [], i3 = 0, c3 = 0, d4 = 0;
  while (i3 < orig.length) {
    c3 = orig.charCodeAt(i3++);
    switch (true) {
      case c3 < 128:
        out.push(String.fromCharCode(c3));
        break;
      case c3 < 2048:
        out.push(String.fromCharCode(192 + (c3 >> 6)));
        out.push(String.fromCharCode(128 + (c3 & 63)));
        break;
      case (c3 >= 55296 && c3 < 57344):
        c3 -= 55296;
        d4 = orig.charCodeAt(i3++) - 56320 + (c3 << 10);
        out.push(String.fromCharCode(240 + (d4 >> 18 & 7)));
        out.push(String.fromCharCode(144 + (d4 >> 12 & 63)));
        out.push(String.fromCharCode(128 + (d4 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (d4 & 63)));
        break;
      default:
        out.push(String.fromCharCode(224 + (c3 >> 12)));
        out.push(String.fromCharCode(128 + (c3 >> 6 & 63)));
        out.push(String.fromCharCode(128 + (c3 & 63)));
    }
  }
  return out.join("");
};
var matchtag = /* @__PURE__ */ function() {
  var mtcache = {};
  return function matchtag2(f2, g2) {
    var t3 = f2 + "|" + (g2 || "");
    if (mtcache[t3]) return mtcache[t3];
    return mtcache[t3] = new RegExp("<(?:\\w+:)?" + f2 + '(?: xml:space="preserve")?(?:[^>]*)>([\\s\\S]*?)</(?:\\w+:)?' + f2 + ">", g2 || "");
  };
}();
var htmldecode = /* @__PURE__ */ function() {
  var entities = [
    ["nbsp", " "],
    ["middot", "·"],
    ["quot", '"'],
    ["apos", "'"],
    ["gt", ">"],
    ["lt", "<"],
    ["amp", "&"]
  ].map(function(x3) {
    return [new RegExp("&" + x3[0] + ";", "ig"), x3[1]];
  });
  return function htmldecode2(str) {
    var o2 = str.replace(/^[\t\n\r ]+/, "").replace(/[\t\n\r ]+$/, "").replace(/>\s+/g, ">").replace(/\s+</g, "<").replace(/[\t\n\r ]+/g, " ").replace(/<\s*[bB][rR]\s*\/?>/g, "\n").replace(/<[^>]*>/g, "");
    for (var i3 = 0; i3 < entities.length; ++i3) o2 = o2.replace(entities[i3][0], entities[i3][1]);
    return o2;
  };
}();
var vtregex = /* @__PURE__ */ function() {
  var vt_cache = {};
  return function vt_regex(bt2) {
    if (vt_cache[bt2] !== void 0) return vt_cache[bt2];
    return vt_cache[bt2] = new RegExp("<(?:vt:)?" + bt2 + ">([\\s\\S]*?)</(?:vt:)?" + bt2 + ">", "g");
  };
}();
var vtvregex = /<\/?(?:vt:)?variant>/g, vtmregex = /<(?:vt:)([^>]*)>([\s\S]*)</;
function parseVector(data, opts) {
  var h4 = parsexmltag(data);
  var matches = data.match(vtregex(h4.baseType)) || [];
  var res = [];
  if (matches.length != h4.size) {
    if (opts.WTF) throw new Error("unexpected vector length " + matches.length + " != " + h4.size);
    return res;
  }
  matches.forEach(function(x3) {
    var v2 = x3.replace(vtvregex, "").match(vtmregex);
    if (v2) res.push({ v: utf8read(v2[2]), t: v2[1] });
  });
  return res;
}
var wtregex = /(^\s|\s$|\n)/;
function writetag(f2, g2) {
  return "<" + f2 + (g2.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g2 + "</" + f2 + ">";
}
function wxt_helper(h4) {
  return keys(h4).map(function(k3) {
    return " " + k3 + '="' + h4[k3] + '"';
  }).join("");
}
function writextag(f2, g2, h4) {
  return "<" + f2 + (h4 != null ? wxt_helper(h4) : "") + (g2 != null ? (g2.match(wtregex) ? ' xml:space="preserve"' : "") + ">" + g2 + "</" + f2 : "/") + ">";
}
function write_w3cdtf(d4, t3) {
  try {
    return d4.toISOString().replace(/\.\d*/, "");
  } catch (e3) {
    if (t3) throw e3;
  }
  return "";
}
function write_vt(s4, xlsx) {
  switch (typeof s4) {
    case "string":
      var o2 = writextag("vt:lpwstr", escapexml(s4));
      o2 = o2.replace(/&quot;/g, "_x0022_");
      return o2;
    case "number":
      return writextag((s4 | 0) == s4 ? "vt:i4" : "vt:r8", escapexml(String(s4)));
    case "boolean":
      return writextag("vt:bool", s4 ? "true" : "false");
  }
  if (s4 instanceof Date) return writextag("vt:filetime", write_w3cdtf(s4));
  throw new Error("Unable to serialize " + s4);
}
function xlml_normalize(d4) {
  if (has_buf && /*::typeof Buffer !== "undefined" && d != null && d instanceof Buffer &&*/
  Buffer.isBuffer(d4)) return d4.toString("utf8");
  if (typeof d4 === "string") return d4;
  if (typeof Uint8Array !== "undefined" && d4 instanceof Uint8Array) return utf8read(a2s(ab2a(d4)));
  throw new Error("Bad input format: expected Buffer or string");
}
var xlmlregex = /<(\/?)([^\s?><!\/:]*:|)([^\s?<>:\/]+)(?:[\s?:\/][^>]*)?>/mg;
var XMLNS = {
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/metadata/core-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/custom-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/extended-properties",
  CT: "http://schemas.openxmlformats.org/package/2006/content-types",
  RELS: "http://schemas.openxmlformats.org/package/2006/relationships",
  TCMNT: "http://schemas.microsoft.com/office/spreadsheetml/2018/threadedcomments",
  "dc": "http://purl.org/dc/elements/1.1/",
  "dcterms": "http://purl.org/dc/terms/",
  "dcmitype": "http://purl.org/dc/dcmitype/",
  "r": "http://schemas.openxmlformats.org/officeDocument/2006/relationships",
  "vt": "http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes",
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xsd": "http://www.w3.org/2001/XMLSchema"
};
var XMLNS_main = [
  "http://schemas.openxmlformats.org/spreadsheetml/2006/main",
  "http://purl.oclc.org/ooxml/spreadsheetml/main",
  "http://schemas.microsoft.com/office/excel/2006/main",
  "http://schemas.microsoft.com/office/excel/2006/2"
];
var XLMLNS = {
  "o": "urn:schemas-microsoft-com:office:office",
  "x": "urn:schemas-microsoft-com:office:excel",
  "ss": "urn:schemas-microsoft-com:office:spreadsheet",
  "dt": "uuid:C2F41010-65B3-11d1-A29F-00AA00C14882",
  "mv": "http://macVmlSchemaUri",
  "v": "urn:schemas-microsoft-com:vml",
  "html": "http://www.w3.org/TR/REC-html40"
};
function read_double_le(b2, idx) {
  var s4 = 1 - 2 * (b2[idx + 7] >>> 7);
  var e3 = ((b2[idx + 7] & 127) << 4) + (b2[idx + 6] >>> 4 & 15);
  var m4 = b2[idx + 6] & 15;
  for (var i3 = 5; i3 >= 0; --i3) m4 = m4 * 256 + b2[idx + i3];
  if (e3 == 2047) return m4 == 0 ? s4 * Infinity : NaN;
  if (e3 == 0) e3 = -1022;
  else {
    e3 -= 1023;
    m4 += Math.pow(2, 52);
  }
  return s4 * Math.pow(2, e3 - 52) * m4;
}
function write_double_le(b2, v2, idx) {
  var bs = (v2 < 0 || 1 / v2 == -Infinity ? 1 : 0) << 7, e3 = 0, m4 = 0;
  var av = bs ? -v2 : v2;
  if (!isFinite(av)) {
    e3 = 2047;
    m4 = isNaN(v2) ? 26985 : 0;
  } else if (av == 0) e3 = m4 = 0;
  else {
    e3 = Math.floor(Math.log(av) / Math.LN2);
    m4 = av * Math.pow(2, 52 - e3);
    if (e3 <= -1023 && (!isFinite(m4) || m4 < Math.pow(2, 52))) {
      e3 = -1022;
    } else {
      m4 -= Math.pow(2, 52);
      e3 += 1023;
    }
  }
  for (var i3 = 0; i3 <= 5; ++i3, m4 /= 256) b2[idx + i3] = m4 & 255;
  b2[idx + 6] = (e3 & 15) << 4 | m4 & 15;
  b2[idx + 7] = e3 >> 4 | bs;
}
var ___toBuffer = function(bufs) {
  var x3 = [], w3 = 10240;
  for (var i3 = 0; i3 < bufs[0].length; ++i3) if (bufs[0][i3]) for (var j2 = 0, L3 = bufs[0][i3].length; j2 < L3; j2 += w3) x3.push.apply(x3, bufs[0][i3].slice(j2, j2 + w3));
  return x3;
};
var __toBuffer = has_buf ? function(bufs) {
  return bufs[0].length > 0 && Buffer.isBuffer(bufs[0][0]) ? Buffer.concat(bufs[0].map(function(x3) {
    return Buffer.isBuffer(x3) ? x3 : Buffer_from(x3);
  })) : ___toBuffer(bufs);
} : ___toBuffer;
var ___utf16le = function(b2, s4, e3) {
  var ss = [];
  for (var i3 = s4; i3 < e3; i3 += 2) ss.push(String.fromCharCode(__readUInt16LE(b2, i3)));
  return ss.join("").replace(chr0, "");
};
var __utf16le = has_buf ? function(b2, s4, e3) {
  if (!Buffer.isBuffer(b2)) return ___utf16le(b2, s4, e3);
  return b2.toString("utf16le", s4, e3).replace(chr0, "");
} : ___utf16le;
var ___hexlify = function(b2, s4, l2) {
  var ss = [];
  for (var i3 = s4; i3 < s4 + l2; ++i3) ss.push(("0" + b2[i3].toString(16)).slice(-2));
  return ss.join("");
};
var __hexlify = has_buf ? function(b2, s4, l2) {
  return Buffer.isBuffer(b2) ? b2.toString("hex", s4, s4 + l2) : ___hexlify(b2, s4, l2);
} : ___hexlify;
var ___utf8 = function(b2, s4, e3) {
  var ss = [];
  for (var i3 = s4; i3 < e3; i3++) ss.push(String.fromCharCode(__readUInt8(b2, i3)));
  return ss.join("");
};
var __utf8 = has_buf ? function utf8_b(b2, s4, e3) {
  return Buffer.isBuffer(b2) ? b2.toString("utf8", s4, e3) : ___utf8(b2, s4, e3);
} : ___utf8;
var ___lpstr = function(b2, i3) {
  var len = __readUInt32LE(b2, i3);
  return len > 0 ? __utf8(b2, i3 + 4, i3 + 4 + len - 1) : "";
};
var __lpstr = ___lpstr;
var ___cpstr = function(b2, i3) {
  var len = __readUInt32LE(b2, i3);
  return len > 0 ? __utf8(b2, i3 + 4, i3 + 4 + len - 1) : "";
};
var __cpstr = ___cpstr;
var ___lpwstr = function(b2, i3) {
  var len = 2 * __readUInt32LE(b2, i3);
  return len > 0 ? __utf8(b2, i3 + 4, i3 + 4 + len - 1) : "";
};
var __lpwstr = ___lpwstr;
var ___lpp4 = function lpp4_(b2, i3) {
  var len = __readUInt32LE(b2, i3);
  return len > 0 ? __utf16le(b2, i3 + 4, i3 + 4 + len) : "";
};
var __lpp4 = ___lpp4;
var ___8lpp4 = function(b2, i3) {
  var len = __readUInt32LE(b2, i3);
  return len > 0 ? __utf8(b2, i3 + 4, i3 + 4 + len) : "";
};
var __8lpp4 = ___8lpp4;
var ___double = function(b2, idx) {
  return read_double_le(b2, idx);
};
var __double = ___double;
var is_buf = function is_buf_a(a4) {
  return Array.isArray(a4) || typeof Uint8Array !== "undefined" && a4 instanceof Uint8Array;
};
if (has_buf) {
  __lpstr = function lpstr_b(b2, i3) {
    if (!Buffer.isBuffer(b2)) return ___lpstr(b2, i3);
    var len = b2.readUInt32LE(i3);
    return len > 0 ? b2.toString("utf8", i3 + 4, i3 + 4 + len - 1) : "";
  };
  __cpstr = function cpstr_b(b2, i3) {
    if (!Buffer.isBuffer(b2)) return ___cpstr(b2, i3);
    var len = b2.readUInt32LE(i3);
    return len > 0 ? b2.toString("utf8", i3 + 4, i3 + 4 + len - 1) : "";
  };
  __lpwstr = function lpwstr_b(b2, i3) {
    if (!Buffer.isBuffer(b2)) return ___lpwstr(b2, i3);
    var len = 2 * b2.readUInt32LE(i3);
    return b2.toString("utf16le", i3 + 4, i3 + 4 + len - 1);
  };
  __lpp4 = function lpp4_b(b2, i3) {
    if (!Buffer.isBuffer(b2)) return ___lpp4(b2, i3);
    var len = b2.readUInt32LE(i3);
    return b2.toString("utf16le", i3 + 4, i3 + 4 + len);
  };
  __8lpp4 = function lpp4_8b(b2, i3) {
    if (!Buffer.isBuffer(b2)) return ___8lpp4(b2, i3);
    var len = b2.readUInt32LE(i3);
    return b2.toString("utf8", i3 + 4, i3 + 4 + len);
  };
  __double = function double_(b2, i3) {
    if (Buffer.isBuffer(b2)) return b2.readDoubleLE(i3);
    return ___double(b2, i3);
  };
  is_buf = function is_buf_b(a4) {
    return Buffer.isBuffer(a4) || Array.isArray(a4) || typeof Uint8Array !== "undefined" && a4 instanceof Uint8Array;
  };
}
var __readUInt8 = function(b2, idx) {
  return b2[idx];
};
var __readUInt16LE = function(b2, idx) {
  return b2[idx + 1] * (1 << 8) + b2[idx];
};
var __readInt16LE = function(b2, idx) {
  var u3 = b2[idx + 1] * (1 << 8) + b2[idx];
  return u3 < 32768 ? u3 : (65535 - u3 + 1) * -1;
};
var __readUInt32LE = function(b2, idx) {
  return b2[idx + 3] * (1 << 24) + (b2[idx + 2] << 16) + (b2[idx + 1] << 8) + b2[idx];
};
var __readInt32LE = function(b2, idx) {
  return b2[idx + 3] << 24 | b2[idx + 2] << 16 | b2[idx + 1] << 8 | b2[idx];
};
var __readInt32BE = function(b2, idx) {
  return b2[idx] << 24 | b2[idx + 1] << 16 | b2[idx + 2] << 8 | b2[idx + 3];
};
function ReadShift(size2, t3) {
  var o2 = "", oI, oR, oo = [], w3, vv, i3, loc;
  switch (t3) {
    case "dbcs":
      loc = this.l;
      if (has_buf && Buffer.isBuffer(this)) o2 = this.slice(this.l, this.l + 2 * size2).toString("utf16le");
      else for (i3 = 0; i3 < size2; ++i3) {
        o2 += String.fromCharCode(__readUInt16LE(this, loc));
        loc += 2;
      }
      size2 *= 2;
      break;
    case "utf8":
      o2 = __utf8(this, this.l, this.l + size2);
      break;
    case "utf16le":
      size2 *= 2;
      o2 = __utf16le(this, this.l, this.l + size2);
      break;
    case "wstr":
      return ReadShift.call(this, size2, "dbcs");
    case "lpstr-ansi":
      o2 = __lpstr(this, this.l);
      size2 = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpstr-cp":
      o2 = __cpstr(this, this.l);
      size2 = 4 + __readUInt32LE(this, this.l);
      break;
    case "lpwstr":
      o2 = __lpwstr(this, this.l);
      size2 = 4 + 2 * __readUInt32LE(this, this.l);
      break;
    case "lpp4":
      size2 = 4 + __readUInt32LE(this, this.l);
      o2 = __lpp4(this, this.l);
      if (size2 & 2) size2 += 2;
      break;
    case "8lpp4":
      size2 = 4 + __readUInt32LE(this, this.l);
      o2 = __8lpp4(this, this.l);
      if (size2 & 3) size2 += 4 - (size2 & 3);
      break;
    case "cstr":
      size2 = 0;
      o2 = "";
      while ((w3 = __readUInt8(this, this.l + size2++)) !== 0) oo.push(_getchar(w3));
      o2 = oo.join("");
      break;
    case "_wstr":
      size2 = 0;
      o2 = "";
      while ((w3 = __readUInt16LE(this, this.l + size2)) !== 0) {
        oo.push(_getchar(w3));
        size2 += 2;
      }
      size2 += 2;
      o2 = oo.join("");
      break;
    case "dbcs-cont":
      o2 = "";
      loc = this.l;
      for (i3 = 0; i3 < size2; ++i3) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w3 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size2 - i3, w3 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt16LE(this, loc)));
        loc += 2;
      }
      o2 = oo.join("");
      size2 *= 2;
      break;
    case "cpstr":
    case "sbcs-cont":
      o2 = "";
      loc = this.l;
      for (i3 = 0; i3 != size2; ++i3) {
        if (this.lens && this.lens.indexOf(loc) !== -1) {
          w3 = __readUInt8(this, loc);
          this.l = loc + 1;
          vv = ReadShift.call(this, size2 - i3, w3 ? "dbcs-cont" : "sbcs-cont");
          return oo.join("") + vv;
        }
        oo.push(_getchar(__readUInt8(this, loc)));
        loc += 1;
      }
      o2 = oo.join("");
      break;
    default:
      switch (size2) {
        case 1:
          oI = __readUInt8(this, this.l);
          this.l++;
          return oI;
        case 2:
          oI = (t3 === "i" ? __readInt16LE : __readUInt16LE)(this, this.l);
          this.l += 2;
          return oI;
        case 4:
        case -4:
          if (t3 === "i" || (this[this.l + 3] & 128) === 0) {
            oI = (size2 > 0 ? __readInt32LE : __readInt32BE)(this, this.l);
            this.l += 4;
            return oI;
          } else {
            oR = __readUInt32LE(this, this.l);
            this.l += 4;
          }
          return oR;
        case 8:
        case -8:
          if (t3 === "f") {
            if (size2 == 8) oR = __double(this, this.l);
            else oR = __double([this[this.l + 7], this[this.l + 6], this[this.l + 5], this[this.l + 4], this[this.l + 3], this[this.l + 2], this[this.l + 1], this[this.l + 0]], 0);
            this.l += 8;
            return oR;
          } else size2 = 8;
        case 16:
          o2 = __hexlify(this, this.l, size2);
          break;
      }
  }
  this.l += size2;
  return o2;
}
var __writeUInt32LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
  b2[idx + 2] = val >>> 16 & 255;
  b2[idx + 3] = val >>> 24 & 255;
};
var __writeInt32LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >> 8 & 255;
  b2[idx + 2] = val >> 16 & 255;
  b2[idx + 3] = val >> 24 & 255;
};
var __writeUInt16LE = function(b2, val, idx) {
  b2[idx] = val & 255;
  b2[idx + 1] = val >>> 8 & 255;
};
function WriteShift(t3, val, f2) {
  var size2 = 0, i3 = 0;
  if (f2 === "dbcs") {
    for (i3 = 0; i3 != val.length; ++i3) __writeUInt16LE(this, val.charCodeAt(i3), this.l + 2 * i3);
    size2 = 2 * val.length;
  } else if (f2 === "sbcs") {
    {
      val = val.replace(/[^\x00-\x7F]/g, "_");
      for (i3 = 0; i3 != val.length; ++i3) this[this.l + i3] = val.charCodeAt(i3) & 255;
    }
    size2 = val.length;
  } else if (f2 === "hex") {
    for (; i3 < t3; ++i3) {
      this[this.l++] = parseInt(val.slice(2 * i3, 2 * i3 + 2), 16) || 0;
    }
    return this;
  } else if (f2 === "utf16le") {
    var end = Math.min(this.l + t3, this.length);
    for (i3 = 0; i3 < Math.min(val.length, t3); ++i3) {
      var cc2 = val.charCodeAt(i3);
      this[this.l++] = cc2 & 255;
      this[this.l++] = cc2 >> 8;
    }
    while (this.l < end) this[this.l++] = 0;
    return this;
  } else switch (t3) {
    case 1:
      size2 = 1;
      this[this.l] = val & 255;
      break;
    case 2:
      size2 = 2;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      break;
    case 3:
      size2 = 3;
      this[this.l] = val & 255;
      val >>>= 8;
      this[this.l + 1] = val & 255;
      val >>>= 8;
      this[this.l + 2] = val & 255;
      break;
    case 4:
      size2 = 4;
      __writeUInt32LE(this, val, this.l);
      break;
    case 8:
      size2 = 8;
      if (f2 === "f") {
        write_double_le(this, val, this.l);
        break;
      }
    case 16:
      break;
    case -4:
      size2 = 4;
      __writeInt32LE(this, val, this.l);
      break;
  }
  this.l += size2;
  return this;
}
function CheckField(hexstr, fld) {
  var m4 = __hexlify(this, this.l, hexstr.length >> 1);
  if (m4 !== hexstr) throw new Error(fld + "Expected " + hexstr + " saw " + m4);
  this.l += hexstr.length >> 1;
}
function prep_blob(blob, pos) {
  blob.l = pos;
  blob.read_shift = /*::(*/
  ReadShift;
  blob.chk = CheckField;
  blob.write_shift = WriteShift;
}
function parsenoop(blob, length) {
  blob.l += length;
}
function new_buf(sz) {
  var o2 = new_raw_buf(sz);
  prep_blob(o2, 0);
  return o2;
}
function recordhopper(data, cb2, opts) {
  if (!data) return;
  var tmpbyte, cntbyte, length;
  prep_blob(data, data.l || 0);
  var L3 = data.length, RT = 0, tgt = 0;
  while (data.l < L3) {
    RT = data.read_shift(1);
    if (RT & 128) RT = (RT & 127) + ((data.read_shift(1) & 127) << 7);
    var R3 = XLSBRecordEnum[RT] || XLSBRecordEnum[65535];
    tmpbyte = data.read_shift(1);
    length = tmpbyte & 127;
    for (cntbyte = 1; cntbyte < 4 && tmpbyte & 128; ++cntbyte) length += ((tmpbyte = data.read_shift(1)) & 127) << 7 * cntbyte;
    tgt = data.l + length;
    var d4 = R3.f && R3.f(data, length, opts);
    data.l = tgt;
    if (cb2(d4, R3, RT)) return;
  }
}
function buf_array() {
  var bufs = [], blksz = has_buf ? 256 : 2048;
  var newblk = function ba_newblk(sz) {
    var o2 = new_buf(sz);
    prep_blob(o2, 0);
    return o2;
  };
  var curbuf = newblk(blksz);
  var endbuf = function ba_endbuf() {
    if (!curbuf) return;
    if (curbuf.length > curbuf.l) {
      curbuf = curbuf.slice(0, curbuf.l);
      curbuf.l = curbuf.length;
    }
    if (curbuf.length > 0) bufs.push(curbuf);
    curbuf = null;
  };
  var next = function ba_next(sz) {
    if (curbuf && sz < curbuf.length - curbuf.l) return curbuf;
    endbuf();
    return curbuf = newblk(Math.max(sz + 1, blksz));
  };
  var end = function ba_end() {
    endbuf();
    return bconcat(bufs);
  };
  var push = function ba_push(buf) {
    endbuf();
    curbuf = buf;
    if (curbuf.l == null) curbuf.l = curbuf.length;
    next(blksz);
  };
  return { next, push, end, _bufs: bufs };
}
function write_record(ba, type, payload, length) {
  var t3 = +type, l2;
  if (isNaN(t3)) return;
  if (!length) length = XLSBRecordEnum[t3].p || (payload || []).length || 0;
  l2 = 1 + (t3 >= 128 ? 1 : 0) + 1;
  if (length >= 128) ++l2;
  if (length >= 16384) ++l2;
  if (length >= 2097152) ++l2;
  var o2 = ba.next(l2);
  if (t3 <= 127) o2.write_shift(1, t3);
  else {
    o2.write_shift(1, (t3 & 127) + 128);
    o2.write_shift(1, t3 >> 7);
  }
  for (var i3 = 0; i3 != 4; ++i3) {
    if (length >= 128) {
      o2.write_shift(1, (length & 127) + 128);
      length >>= 7;
    } else {
      o2.write_shift(1, length);
      break;
    }
  }
  if (
    /*:: length != null &&*/
    length > 0 && is_buf(payload)
  ) ba.push(payload);
}
function shift_cell_xls(cell, tgt, opts) {
  var out = dup(cell);
  if (tgt.s) {
    if (out.cRel) out.c += tgt.s.c;
    if (out.rRel) out.r += tgt.s.r;
  } else {
    if (out.cRel) out.c += tgt.c;
    if (out.rRel) out.r += tgt.r;
  }
  if (!opts || opts.biff < 12) {
    while (out.c >= 256) out.c -= 256;
    while (out.r >= 65536) out.r -= 65536;
  }
  return out;
}
function shift_range_xls(cell, range, opts) {
  var out = dup(cell);
  out.s = shift_cell_xls(out.s, range.s, opts);
  out.e = shift_cell_xls(out.e, range.s, opts);
  return out;
}
function encode_cell_xls(c3, biff) {
  if (c3.cRel && c3.c < 0) {
    c3 = dup(c3);
    while (c3.c < 0) c3.c += biff > 8 ? 16384 : 256;
  }
  if (c3.rRel && c3.r < 0) {
    c3 = dup(c3);
    while (c3.r < 0) c3.r += biff > 8 ? 1048576 : biff > 5 ? 65536 : 16384;
  }
  var s4 = encode_cell(c3);
  if (!c3.cRel && c3.cRel != null) s4 = fix_col(s4);
  if (!c3.rRel && c3.rRel != null) s4 = fix_row(s4);
  return s4;
}
function encode_range_xls(r2, opts) {
  if (r2.s.r == 0 && !r2.s.rRel) {
    if (r2.e.r == (opts.biff >= 12 ? 1048575 : opts.biff >= 8 ? 65536 : 16384) && !r2.e.rRel) {
      return (r2.s.cRel ? "" : "$") + encode_col(r2.s.c) + ":" + (r2.e.cRel ? "" : "$") + encode_col(r2.e.c);
    }
  }
  if (r2.s.c == 0 && !r2.s.cRel) {
    if (r2.e.c == (opts.biff >= 12 ? 16383 : 255) && !r2.e.cRel) {
      return (r2.s.rRel ? "" : "$") + encode_row(r2.s.r) + ":" + (r2.e.rRel ? "" : "$") + encode_row(r2.e.r);
    }
  }
  return encode_cell_xls(r2.s, opts.biff) + ":" + encode_cell_xls(r2.e, opts.biff);
}
function decode_row(rowstr) {
  return parseInt(unfix_row(rowstr), 10) - 1;
}
function encode_row(row) {
  return "" + (row + 1);
}
function fix_row(cstr) {
  return cstr.replace(/([A-Z]|^)(\d+)$/, "$1$$$2");
}
function unfix_row(cstr) {
  return cstr.replace(/\$(\d+)$/, "$1");
}
function decode_col(colstr) {
  var c3 = unfix_col(colstr), d4 = 0, i3 = 0;
  for (; i3 !== c3.length; ++i3) d4 = 26 * d4 + c3.charCodeAt(i3) - 64;
  return d4 - 1;
}
function encode_col(col) {
  if (col < 0) throw new Error("invalid column " + col);
  var s4 = "";
  for (++col; col; col = Math.floor((col - 1) / 26)) s4 = String.fromCharCode((col - 1) % 26 + 65) + s4;
  return s4;
}
function fix_col(cstr) {
  return cstr.replace(/^([A-Z])/, "$$$1");
}
function unfix_col(cstr) {
  return cstr.replace(/^\$([A-Z])/, "$1");
}
function split_cell(cstr) {
  return cstr.replace(/(\$?[A-Z]*)(\$?\d*)/, "$1,$2").split(",");
}
function decode_cell(cstr) {
  var R3 = 0, C2 = 0;
  for (var i3 = 0; i3 < cstr.length; ++i3) {
    var cc2 = cstr.charCodeAt(i3);
    if (cc2 >= 48 && cc2 <= 57) R3 = 10 * R3 + (cc2 - 48);
    else if (cc2 >= 65 && cc2 <= 90) C2 = 26 * C2 + (cc2 - 64);
  }
  return { c: C2 - 1, r: R3 - 1 };
}
function encode_cell(cell) {
  var col = cell.c + 1;
  var s4 = "";
  for (; col; col = (col - 1) / 26 | 0) s4 = String.fromCharCode((col - 1) % 26 + 65) + s4;
  return s4 + (cell.r + 1);
}
function decode_range(range) {
  var idx = range.indexOf(":");
  if (idx == -1) return { s: decode_cell(range), e: decode_cell(range) };
  return { s: decode_cell(range.slice(0, idx)), e: decode_cell(range.slice(idx + 1)) };
}
function encode_range(cs, ce2) {
  if (typeof ce2 === "undefined" || typeof ce2 === "number") {
    return encode_range(cs.s, cs.e);
  }
  if (typeof cs !== "string") cs = encode_cell(cs);
  if (typeof ce2 !== "string") ce2 = encode_cell(ce2);
  return cs == ce2 ? cs : cs + ":" + ce2;
}
function safe_decode_range(range) {
  var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
  var idx = 0, i3 = 0, cc2 = 0;
  var len = range.length;
  for (idx = 0; i3 < len; ++i3) {
    if ((cc2 = range.charCodeAt(i3) - 64) < 1 || cc2 > 26) break;
    idx = 26 * idx + cc2;
  }
  o2.s.c = --idx;
  for (idx = 0; i3 < len; ++i3) {
    if ((cc2 = range.charCodeAt(i3) - 48) < 0 || cc2 > 9) break;
    idx = 10 * idx + cc2;
  }
  o2.s.r = --idx;
  if (i3 === len || cc2 != 10) {
    o2.e.c = o2.s.c;
    o2.e.r = o2.s.r;
    return o2;
  }
  ++i3;
  for (idx = 0; i3 != len; ++i3) {
    if ((cc2 = range.charCodeAt(i3) - 64) < 1 || cc2 > 26) break;
    idx = 26 * idx + cc2;
  }
  o2.e.c = --idx;
  for (idx = 0; i3 != len; ++i3) {
    if ((cc2 = range.charCodeAt(i3) - 48) < 0 || cc2 > 9) break;
    idx = 10 * idx + cc2;
  }
  o2.e.r = --idx;
  return o2;
}
function safe_format_cell(cell, v2) {
  var q3 = cell.t == "d" && v2 instanceof Date;
  if (cell.z != null) try {
    return cell.w = SSF_format(cell.z, q3 ? datenum(v2) : v2);
  } catch (e3) {
  }
  try {
    return cell.w = SSF_format((cell.XF || {}).numFmtId || (q3 ? 14 : 0), q3 ? datenum(v2) : v2);
  } catch (e3) {
    return "" + v2;
  }
}
function format_cell(cell, v2, o2) {
  if (cell == null || cell.t == null || cell.t == "z") return "";
  if (cell.w !== void 0) return cell.w;
  if (cell.t == "d" && !cell.z && o2 && o2.dateNF) cell.z = o2.dateNF;
  if (cell.t == "e") return BErr[cell.v] || cell.v;
  if (v2 == void 0) return safe_format_cell(cell, cell.v);
  return safe_format_cell(cell, v2);
}
function sheet_to_workbook(sheet, opts) {
  var n2 = opts && opts.sheet ? opts.sheet : "Sheet1";
  var sheets = {};
  sheets[n2] = sheet;
  return { SheetNames: [n2], Sheets: sheets };
}
function sheet_add_aoa(_ws, data, opts) {
  var o2 = opts || {};
  var dense = _ws ? Array.isArray(_ws) : o2.dense;
  var ws = _ws || (dense ? [] : {});
  var _R = 0, _C = 0;
  if (ws && o2.origin != null) {
    if (typeof o2.origin == "number") _R = o2.origin;
    else {
      var _origin = typeof o2.origin == "string" ? decode_cell(o2.origin) : o2.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
    if (!ws["!ref"]) ws["!ref"] = "A1:A1";
  }
  var range = { s: { c: 1e7, r: 1e7 }, e: { c: 0, r: 0 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.s.c = _range.s.c;
    range.s.r = _range.s.r;
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) range.e.r = _R = _range.e.r + 1;
  }
  for (var R3 = 0; R3 != data.length; ++R3) {
    if (!data[R3]) continue;
    if (!Array.isArray(data[R3])) throw new Error("aoa_to_sheet expects an array of arrays");
    for (var C2 = 0; C2 != data[R3].length; ++C2) {
      if (typeof data[R3][C2] === "undefined") continue;
      var cell = { v: data[R3][C2] };
      var __R = _R + R3, __C = _C + C2;
      if (range.s.r > __R) range.s.r = __R;
      if (range.s.c > __C) range.s.c = __C;
      if (range.e.r < __R) range.e.r = __R;
      if (range.e.c < __C) range.e.c = __C;
      if (data[R3][C2] && typeof data[R3][C2] === "object" && !Array.isArray(data[R3][C2]) && !(data[R3][C2] instanceof Date)) cell = data[R3][C2];
      else {
        if (Array.isArray(cell.v)) {
          cell.f = data[R3][C2][1];
          cell.v = cell.v[0];
        }
        if (cell.v === null) {
          if (cell.f) cell.t = "n";
          else if (o2.nullError) {
            cell.t = "e";
            cell.v = 0;
          } else if (!o2.sheetStubs) continue;
          else cell.t = "z";
        } else if (typeof cell.v === "number") cell.t = "n";
        else if (typeof cell.v === "boolean") cell.t = "b";
        else if (cell.v instanceof Date) {
          cell.z = o2.dateNF || table_fmt[14];
          if (o2.cellDates) {
            cell.t = "d";
            cell.w = SSF_format(cell.z, datenum(cell.v));
          } else {
            cell.t = "n";
            cell.v = datenum(cell.v);
            cell.w = SSF_format(cell.z, cell.v);
          }
        } else cell.t = "s";
      }
      if (dense) {
        if (!ws[__R]) ws[__R] = [];
        if (ws[__R][__C] && ws[__R][__C].z) cell.z = ws[__R][__C].z;
        ws[__R][__C] = cell;
      } else {
        var cell_ref = encode_cell({ c: __C, r: __R });
        if (ws[cell_ref] && ws[cell_ref].z) cell.z = ws[cell_ref].z;
        ws[cell_ref] = cell;
      }
    }
  }
  if (range.s.c < 1e7) ws["!ref"] = encode_range(range);
  return ws;
}
function aoa_to_sheet(data, opts) {
  return sheet_add_aoa(null, data, opts);
}
function parse_Int32LE(data) {
  return data.read_shift(4, "i");
}
function write_UInt32LE(x3, o2) {
  if (!o2) o2 = new_buf(4);
  o2.write_shift(4, x3);
  return o2;
}
function parse_XLWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLWideString(data, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(4 + 2 * data.length);
  }
  o2.write_shift(4, data.length);
  if (data.length > 0) o2.write_shift(0, data, "dbcs");
  return _null ? o2.slice(0, o2.l) : o2;
}
function parse_StrRun(data) {
  return { ich: data.read_shift(2), ifnt: data.read_shift(2) };
}
function write_StrRun(run, o2) {
  if (!o2) o2 = new_buf(4);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  return o2;
}
function parse_RichStr(data, length) {
  var start = data.l;
  var flags = data.read_shift(1);
  var str = parse_XLWideString(data);
  var rgsStrRun = [];
  var z3 = { t: str, h: str };
  if ((flags & 1) !== 0) {
    var dwSizeStrRun = data.read_shift(4);
    for (var i3 = 0; i3 != dwSizeStrRun; ++i3) rgsStrRun.push(parse_StrRun(data));
    z3.r = rgsStrRun;
  } else z3.r = [{ ich: 0, ifnt: 0 }];
  data.l = start + length;
  return z3;
}
function write_RichStr(str, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(15 + 4 * str.t.length);
  }
  o2.write_shift(1, 0);
  write_XLWideString(str.t, o2);
  return _null ? o2.slice(0, o2.l) : o2;
}
var parse_BrtCommentText = parse_RichStr;
function write_BrtCommentText(str, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(23 + 4 * str.t.length);
  }
  o2.write_shift(1, 1);
  write_XLWideString(str.t, o2);
  o2.write_shift(4, 1);
  write_StrRun({}, o2);
  return _null ? o2.slice(0, o2.l) : o2;
}
function parse_XLSBCell(data) {
  var col = data.read_shift(4);
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: col, iStyleRef };
}
function write_XLSBCell(cell, o2) {
  if (o2 == null) o2 = new_buf(8);
  o2.write_shift(-4, cell.c);
  o2.write_shift(3, cell.iStyleRef || cell.s);
  o2.write_shift(1, 0);
  return o2;
}
function parse_XLSBShortCell(data) {
  var iStyleRef = data.read_shift(2);
  iStyleRef += data.read_shift(1) << 16;
  data.l++;
  return { c: -1, iStyleRef };
}
function write_XLSBShortCell(cell, o2) {
  if (o2 == null) o2 = new_buf(4);
  o2.write_shift(3, cell.iStyleRef || cell.s);
  o2.write_shift(1, 0);
  return o2;
}
var parse_XLSBCodeName = parse_XLWideString;
var write_XLSBCodeName = write_XLWideString;
function parse_XLNullableWideString(data) {
  var cchCharacters = data.read_shift(4);
  return cchCharacters === 0 || cchCharacters === 4294967295 ? "" : data.read_shift(cchCharacters, "dbcs");
}
function write_XLNullableWideString(data, o2) {
  var _null = false;
  if (o2 == null) {
    _null = true;
    o2 = new_buf(127);
  }
  o2.write_shift(4, data.length > 0 ? data.length : 4294967295);
  if (data.length > 0) o2.write_shift(0, data, "dbcs");
  return _null ? o2.slice(0, o2.l) : o2;
}
var parse_XLNameWideString = parse_XLWideString;
var parse_RelID = parse_XLNullableWideString;
var write_RelID = write_XLNullableWideString;
function parse_RkNumber(data) {
  var b2 = data.slice(data.l, data.l + 4);
  var fX100 = b2[0] & 1, fInt = b2[0] & 2;
  data.l += 4;
  var RK = fInt === 0 ? __double([0, 0, 0, 0, b2[0] & 252, b2[1], b2[2], b2[3]], 0) : __readInt32LE(b2, 0) >> 2;
  return fX100 ? RK / 100 : RK;
}
function write_RkNumber(data, o2) {
  if (o2 == null) o2 = new_buf(4);
  var fX100 = 0, fInt = 0, d100 = data * 100;
  if (data == (data | 0) && data >= -536870912 && data < 1 << 29) {
    fInt = 1;
  } else if (d100 == (d100 | 0) && d100 >= -536870912 && d100 < 1 << 29) {
    fInt = 1;
    fX100 = 1;
  }
  if (fInt) o2.write_shift(-4, ((fX100 ? d100 : data) << 2) + (fX100 + 2));
  else throw new Error("unsupported RkNumber " + data);
}
function parse_RfX(data) {
  var cell = { s: {}, e: {} };
  cell.s.r = data.read_shift(4);
  cell.e.r = data.read_shift(4);
  cell.s.c = data.read_shift(4);
  cell.e.c = data.read_shift(4);
  return cell;
}
function write_RfX(r2, o2) {
  if (!o2) o2 = new_buf(16);
  o2.write_shift(4, r2.s.r);
  o2.write_shift(4, r2.e.r);
  o2.write_shift(4, r2.s.c);
  o2.write_shift(4, r2.e.c);
  return o2;
}
var parse_UncheckedRfX = parse_RfX;
var write_UncheckedRfX = write_RfX;
function parse_Xnum(data) {
  if (data.length - data.l < 8) throw "XLS Xnum Buffer underflow";
  return data.read_shift(8, "f");
}
function write_Xnum(data, o2) {
  return (o2 || new_buf(8)).write_shift(8, data, "f");
}
function parse_BrtColor(data) {
  var out = {};
  var d4 = data.read_shift(1);
  var xColorType = d4 >>> 1;
  var index2 = data.read_shift(1);
  var nTS = data.read_shift(2, "i");
  var bR = data.read_shift(1);
  var bG = data.read_shift(1);
  var bB = data.read_shift(1);
  data.l++;
  switch (xColorType) {
    case 0:
      out.auto = 1;
      break;
    case 1:
      out.index = index2;
      var icv = XLSIcv[index2];
      if (icv) out.rgb = rgb2Hex(icv);
      break;
    case 2:
      out.rgb = rgb2Hex([bR, bG, bB]);
      break;
    case 3:
      out.theme = index2;
      break;
  }
  if (nTS != 0) out.tint = nTS > 0 ? nTS / 32767 : nTS / 32768;
  return out;
}
function write_BrtColor(color, o2) {
  if (!o2) o2 = new_buf(8);
  if (!color || color.auto) {
    o2.write_shift(4, 0);
    o2.write_shift(4, 0);
    return o2;
  }
  if (color.index != null) {
    o2.write_shift(1, 2);
    o2.write_shift(1, color.index);
  } else if (color.theme != null) {
    o2.write_shift(1, 6);
    o2.write_shift(1, color.theme);
  } else {
    o2.write_shift(1, 5);
    o2.write_shift(1, 0);
  }
  var nTS = color.tint || 0;
  if (nTS > 0) nTS *= 32767;
  else if (nTS < 0) nTS *= 32768;
  o2.write_shift(2, nTS);
  if (!color.rgb || color.theme != null) {
    o2.write_shift(2, 0);
    o2.write_shift(1, 0);
    o2.write_shift(1, 0);
  } else {
    var rgb = color.rgb || "FFFFFF";
    if (typeof rgb == "number") rgb = ("000000" + rgb.toString(16)).slice(-6);
    o2.write_shift(1, parseInt(rgb.slice(0, 2), 16));
    o2.write_shift(1, parseInt(rgb.slice(2, 4), 16));
    o2.write_shift(1, parseInt(rgb.slice(4, 6), 16));
    o2.write_shift(1, 255);
  }
  return o2;
}
function parse_FontFlags(data) {
  var d4 = data.read_shift(1);
  data.l++;
  var out = {
    fBold: d4 & 1,
    fItalic: d4 & 2,
    fUnderline: d4 & 4,
    fStrikeout: d4 & 8,
    fOutline: d4 & 16,
    fShadow: d4 & 32,
    fCondense: d4 & 64,
    fExtend: d4 & 128
  };
  return out;
}
function write_FontFlags(font, o2) {
  if (!o2) o2 = new_buf(2);
  var grbit = (font.italic ? 2 : 0) | (font.strike ? 8 : 0) | (font.outline ? 16 : 0) | (font.shadow ? 32 : 0) | (font.condense ? 64 : 0) | (font.extend ? 128 : 0);
  o2.write_shift(1, grbit);
  o2.write_shift(1, 0);
  return o2;
}
function parse_ClipboardFormatOrString(o2, w3) {
  var ClipFmt = { 2: "BITMAP", 3: "METAFILEPICT", 8: "DIB", 14: "ENHMETAFILE" };
  var m4 = o2.read_shift(4);
  switch (m4) {
    case 0:
      return "";
    case 4294967295:
    case 4294967294:
      return ClipFmt[o2.read_shift(4)] || "";
  }
  if (m4 > 400) throw new Error("Unsupported Clipboard: " + m4.toString(16));
  o2.l -= 4;
  return o2.read_shift(0, w3 == 1 ? "lpstr" : "lpwstr");
}
function parse_ClipboardFormatOrAnsiString(o2) {
  return parse_ClipboardFormatOrString(o2, 1);
}
function parse_ClipboardFormatOrUnicodeString(o2) {
  return parse_ClipboardFormatOrString(o2, 2);
}
var VT_I2 = 2;
var VT_I4 = 3;
var VT_BOOL = 11;
var VT_VARIANT = 12;
var VT_UI4 = 19;
var VT_FILETIME = 64;
var VT_BLOB = 65;
var VT_CF = 71;
var VT_VECTOR_VARIANT = 4108;
var VT_VECTOR_LPSTR = 4126;
var VT_STRING = 80;
var VT_USTR = 81;
var VT_CUSTOM = [VT_STRING, VT_USTR];
var DocSummaryPIDDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Category", t: VT_STRING },
  /*::[*/
  3: { n: "PresentationFormat", t: VT_STRING },
  /*::[*/
  4: { n: "ByteCount", t: VT_I4 },
  /*::[*/
  5: { n: "LineCount", t: VT_I4 },
  /*::[*/
  6: { n: "ParagraphCount", t: VT_I4 },
  /*::[*/
  7: { n: "SlideCount", t: VT_I4 },
  /*::[*/
  8: { n: "NoteCount", t: VT_I4 },
  /*::[*/
  9: { n: "HiddenCount", t: VT_I4 },
  /*::[*/
  10: { n: "MultimediaClipCount", t: VT_I4 },
  /*::[*/
  11: { n: "ScaleCrop", t: VT_BOOL },
  /*::[*/
  12: {
    n: "HeadingPairs",
    t: VT_VECTOR_VARIANT
    /* VT_VECTOR | VT_VARIANT */
  },
  /*::[*/
  13: {
    n: "TitlesOfParts",
    t: VT_VECTOR_LPSTR
    /* VT_VECTOR | VT_LPSTR */
  },
  /*::[*/
  14: { n: "Manager", t: VT_STRING },
  /*::[*/
  15: { n: "Company", t: VT_STRING },
  /*::[*/
  16: { n: "LinksUpToDate", t: VT_BOOL },
  /*::[*/
  17: { n: "CharacterCount", t: VT_I4 },
  /*::[*/
  19: { n: "SharedDoc", t: VT_BOOL },
  /*::[*/
  22: { n: "HyperlinksChanged", t: VT_BOOL },
  /*::[*/
  23: { n: "AppVersion", t: VT_I4, p: "version" },
  /*::[*/
  24: { n: "DigSig", t: VT_BLOB },
  /*::[*/
  26: { n: "ContentType", t: VT_STRING },
  /*::[*/
  27: { n: "ContentStatus", t: VT_STRING },
  /*::[*/
  28: { n: "Language", t: VT_STRING },
  /*::[*/
  29: { n: "Version", t: VT_STRING },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var SummaryPIDSI = {
  /*::[*/
  1: { n: "CodePage", t: VT_I2 },
  /*::[*/
  2: { n: "Title", t: VT_STRING },
  /*::[*/
  3: { n: "Subject", t: VT_STRING },
  /*::[*/
  4: { n: "Author", t: VT_STRING },
  /*::[*/
  5: { n: "Keywords", t: VT_STRING },
  /*::[*/
  6: { n: "Comments", t: VT_STRING },
  /*::[*/
  7: { n: "Template", t: VT_STRING },
  /*::[*/
  8: { n: "LastAuthor", t: VT_STRING },
  /*::[*/
  9: { n: "RevNumber", t: VT_STRING },
  /*::[*/
  10: { n: "EditTime", t: VT_FILETIME },
  /*::[*/
  11: { n: "LastPrinted", t: VT_FILETIME },
  /*::[*/
  12: { n: "CreatedDate", t: VT_FILETIME },
  /*::[*/
  13: { n: "ModifiedDate", t: VT_FILETIME },
  /*::[*/
  14: { n: "PageCount", t: VT_I4 },
  /*::[*/
  15: { n: "WordCount", t: VT_I4 },
  /*::[*/
  16: { n: "CharCount", t: VT_I4 },
  /*::[*/
  17: { n: "Thumbnail", t: VT_CF },
  /*::[*/
  18: { n: "Application", t: VT_STRING },
  /*::[*/
  19: { n: "DocSecurity", t: VT_I4 },
  /*::[*/
  255: {},
  /* [MS-OLEPS] 2.18 */
  /*::[*/
  2147483648: { n: "Locale", t: VT_UI4 },
  /*::[*/
  2147483651: { n: "Behavior", t: VT_UI4 },
  /*::[*/
  1919054434: {}
};
var CountryEnum = {
  /*::[*/
  1: "US",
  // United States
  /*::[*/
  2: "CA",
  // Canada
  /*::[*/
  3: "",
  // Latin America (except Brazil)
  /*::[*/
  7: "RU",
  // Russia
  /*::[*/
  20: "EG",
  // Egypt
  /*::[*/
  30: "GR",
  // Greece
  /*::[*/
  31: "NL",
  // Netherlands
  /*::[*/
  32: "BE",
  // Belgium
  /*::[*/
  33: "FR",
  // France
  /*::[*/
  34: "ES",
  // Spain
  /*::[*/
  36: "HU",
  // Hungary
  /*::[*/
  39: "IT",
  // Italy
  /*::[*/
  41: "CH",
  // Switzerland
  /*::[*/
  43: "AT",
  // Austria
  /*::[*/
  44: "GB",
  // United Kingdom
  /*::[*/
  45: "DK",
  // Denmark
  /*::[*/
  46: "SE",
  // Sweden
  /*::[*/
  47: "NO",
  // Norway
  /*::[*/
  48: "PL",
  // Poland
  /*::[*/
  49: "DE",
  // Germany
  /*::[*/
  52: "MX",
  // Mexico
  /*::[*/
  55: "BR",
  // Brazil
  /*::[*/
  61: "AU",
  // Australia
  /*::[*/
  64: "NZ",
  // New Zealand
  /*::[*/
  66: "TH",
  // Thailand
  /*::[*/
  81: "JP",
  // Japan
  /*::[*/
  82: "KR",
  // Korea
  /*::[*/
  84: "VN",
  // Viet Nam
  /*::[*/
  86: "CN",
  // China
  /*::[*/
  90: "TR",
  // Turkey
  /*::[*/
  105: "JS",
  // Ramastan
  /*::[*/
  213: "DZ",
  // Algeria
  /*::[*/
  216: "MA",
  // Morocco
  /*::[*/
  218: "LY",
  // Libya
  /*::[*/
  351: "PT",
  // Portugal
  /*::[*/
  354: "IS",
  // Iceland
  /*::[*/
  358: "FI",
  // Finland
  /*::[*/
  420: "CZ",
  // Czech Republic
  /*::[*/
  886: "TW",
  // Taiwan
  /*::[*/
  961: "LB",
  // Lebanon
  /*::[*/
  962: "JO",
  // Jordan
  /*::[*/
  963: "SY",
  // Syria
  /*::[*/
  964: "IQ",
  // Iraq
  /*::[*/
  965: "KW",
  // Kuwait
  /*::[*/
  966: "SA",
  // Saudi Arabia
  /*::[*/
  971: "AE",
  // United Arab Emirates
  /*::[*/
  972: "IL",
  // Israel
  /*::[*/
  974: "QA",
  // Qatar
  /*::[*/
  981: "IR",
  // Iran
  /*::[*/
  65535: "US"
  // United States
};
var XLSFillPattern = [
  null,
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
function rgbify(arr) {
  return arr.map(function(x3) {
    return [x3 >> 16 & 255, x3 >> 8 & 255, x3 & 255];
  });
}
var _XLSIcv = /* @__PURE__ */ rgbify([
  /* Color Constants */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  /* Overridable Defaults */
  0,
  16777215,
  16711680,
  65280,
  255,
  16776960,
  16711935,
  65535,
  8388608,
  32768,
  128,
  8421376,
  8388736,
  32896,
  12632256,
  8421504,
  10066431,
  10040166,
  16777164,
  13434879,
  6684774,
  16744576,
  26316,
  13421823,
  128,
  16711935,
  16776960,
  65535,
  8388736,
  8388608,
  32896,
  255,
  52479,
  13434879,
  13434828,
  16777113,
  10079487,
  16751052,
  13408767,
  16764057,
  3368703,
  3394764,
  10079232,
  16763904,
  16750848,
  16737792,
  6710937,
  9868950,
  13158,
  3381606,
  13056,
  3355392,
  10040064,
  10040166,
  3355545,
  3355443,
  /* Other entries to appease BIFF8/12 */
  16777215,
  /* 0x40 icvForeground ?? */
  0,
  /* 0x41 icvBackground ?? */
  0,
  /* 0x42 icvFrame ?? */
  0,
  /* 0x43 icv3D ?? */
  0,
  /* 0x44 icv3DText ?? */
  0,
  /* 0x45 icv3DHilite ?? */
  0,
  /* 0x46 icv3DShadow ?? */
  0,
  /* 0x47 icvHilite ?? */
  0,
  /* 0x48 icvCtlText ?? */
  0,
  /* 0x49 icvCtlScrl ?? */
  0,
  /* 0x4A icvCtlInv ?? */
  0,
  /* 0x4B icvCtlBody ?? */
  0,
  /* 0x4C icvCtlFrame ?? */
  0,
  /* 0x4D icvCtlFore ?? */
  0,
  /* 0x4E icvCtlBack ?? */
  0,
  /* 0x4F icvCtlNeutral */
  0,
  /* 0x50 icvInfoBk ?? */
  0
  /* 0x51 icvInfoText ?? */
]);
var XLSIcv = /* @__PURE__ */ dup(_XLSIcv);
var BErr = {
  /*::[*/
  0: "#NULL!",
  /*::[*/
  7: "#DIV/0!",
  /*::[*/
  15: "#VALUE!",
  /*::[*/
  23: "#REF!",
  /*::[*/
  29: "#NAME?",
  /*::[*/
  36: "#NUM!",
  /*::[*/
  42: "#N/A",
  /*::[*/
  43: "#GETTING_DATA",
  /*::[*/
  255: "#WTF?"
};
var RBErr = {
  "#NULL!": 0,
  "#DIV/0!": 7,
  "#VALUE!": 15,
  "#REF!": 23,
  "#NAME?": 29,
  "#NUM!": 36,
  "#N/A": 42,
  "#GETTING_DATA": 43,
  "#WTF?": 255
};
var ct2type = {
  /* Workbook */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.macroEnabled.main+xml": "workbooks",
  "application/vnd.ms-excel.sheet.binary.macroEnabled.main": "workbooks",
  "application/vnd.ms-excel.addin.macroEnabled.main+xml": "workbooks",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": "workbooks",
  /* Worksheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": "sheets",
  "application/vnd.ms-excel.worksheet": "sheets",
  "application/vnd.ms-excel.binIndexWs": "TODO",
  /* Binary Index */
  /* Chartsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": "charts",
  "application/vnd.ms-excel.chartsheet": "charts",
  /* Macrosheet */
  "application/vnd.ms-excel.macrosheet+xml": "macros",
  "application/vnd.ms-excel.macrosheet": "macros",
  "application/vnd.ms-excel.intlmacrosheet": "TODO",
  "application/vnd.ms-excel.binIndexMs": "TODO",
  /* Binary Index */
  /* Dialogsheet */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": "dialogs",
  "application/vnd.ms-excel.dialogsheet": "dialogs",
  /* Shared Strings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml": "strs",
  "application/vnd.ms-excel.sharedStrings": "strs",
  /* Styles */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": "styles",
  "application/vnd.ms-excel.styles": "styles",
  /* File Properties */
  "application/vnd.openxmlformats-package.core-properties+xml": "coreprops",
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": "custprops",
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": "extprops",
  /* Custom Data Properties */
  "application/vnd.openxmlformats-officedocument.customXmlProperties+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.customProperty": "TODO",
  /* Comments */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": "comments",
  "application/vnd.ms-excel.comments": "comments",
  "application/vnd.ms-excel.threadedcomments+xml": "threadedcomments",
  "application/vnd.ms-excel.person+xml": "people",
  /* Metadata (Stock/Geography and Dynamic Array) */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml": "metadata",
  "application/vnd.ms-excel.sheetMetadata": "metadata",
  /* PivotTable */
  "application/vnd.ms-excel.pivotTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotTable+xml": "TODO",
  /* Chart Objects */
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": "TODO",
  /* Chart Colors */
  "application/vnd.ms-office.chartcolorstyle+xml": "TODO",
  /* Chart Style */
  "application/vnd.ms-office.chartstyle+xml": "TODO",
  /* Chart Advanced */
  "application/vnd.ms-office.chartex+xml": "TODO",
  /* Calculation Chain */
  "application/vnd.ms-excel.calcChain": "calcchains",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcChain+xml": "calcchains",
  /* Printer Settings */
  "application/vnd.openxmlformats-officedocument.spreadsheetml.printerSettings": "TODO",
  /* ActiveX */
  "application/vnd.ms-office.activeX": "TODO",
  "application/vnd.ms-office.activeX+xml": "TODO",
  /* Custom Toolbars */
  "application/vnd.ms-excel.attachedToolbars": "TODO",
  /* External Data Connections */
  "application/vnd.ms-excel.connections": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": "TODO",
  /* External Links */
  "application/vnd.ms-excel.externalLink": "links",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externalLink+xml": "links",
  /* PivotCache */
  "application/vnd.ms-excel.pivotCacheDefinition": "TODO",
  "application/vnd.ms-excel.pivotCacheRecords": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheDefinition+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotCacheRecords+xml": "TODO",
  /* Query Table */
  "application/vnd.ms-excel.queryTable": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.queryTable+xml": "TODO",
  /* Shared Workbook */
  "application/vnd.ms-excel.userNames": "TODO",
  "application/vnd.ms-excel.revisionHeaders": "TODO",
  "application/vnd.ms-excel.revisionLog": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionHeaders+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionLog+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.userNames+xml": "TODO",
  /* Single Cell Table */
  "application/vnd.ms-excel.tableSingleCells": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tableSingleCells+xml": "TODO",
  /* Slicer */
  "application/vnd.ms-excel.slicer": "TODO",
  "application/vnd.ms-excel.slicerCache": "TODO",
  "application/vnd.ms-excel.slicer+xml": "TODO",
  "application/vnd.ms-excel.slicerCache+xml": "TODO",
  /* Sort Map */
  "application/vnd.ms-excel.wsSortMap": "TODO",
  /* Table */
  "application/vnd.ms-excel.table": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": "TODO",
  /* Themes */
  "application/vnd.openxmlformats-officedocument.theme+xml": "themes",
  /* Theme Override */
  "application/vnd.openxmlformats-officedocument.themeOverride+xml": "TODO",
  /* Timeline */
  "application/vnd.ms-excel.Timeline+xml": "TODO",
  /* verify */
  "application/vnd.ms-excel.TimelineCache+xml": "TODO",
  /* verify */
  /* VBA */
  "application/vnd.ms-office.vbaProject": "vba",
  "application/vnd.ms-office.vbaProjectSignature": "TODO",
  /* Volatile Dependencies */
  "application/vnd.ms-office.volatileDependencies": "TODO",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatileDependencies+xml": "TODO",
  /* Control Properties */
  "application/vnd.ms-excel.controlproperties+xml": "TODO",
  /* Data Model */
  "application/vnd.openxmlformats-officedocument.model+data": "TODO",
  /* Survey */
  "application/vnd.ms-excel.Survey+xml": "TODO",
  /* Drawing */
  "application/vnd.openxmlformats-officedocument.drawing+xml": "drawings",
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramColors+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramData+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramLayout+xml": "TODO",
  "application/vnd.openxmlformats-officedocument.drawingml.diagramStyle+xml": "TODO",
  /* VML */
  "application/vnd.openxmlformats-officedocument.vmlDrawing": "TODO",
  "application/vnd.openxmlformats-package.relationships+xml": "rels",
  "application/vnd.openxmlformats-officedocument.oleObject": "TODO",
  /* Image */
  "image/png": "TODO",
  "sheet": "js"
};
var CT_LIST = {
  workbooks: {
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.main+xml",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.main",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.main+xml",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml"
  },
  strs: {
    /* Shared Strings */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml",
    xlsb: "application/vnd.ms-excel.sharedStrings"
  },
  comments: {
    /* Comments */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml",
    xlsb: "application/vnd.ms-excel.comments"
  },
  sheets: {
    /* Worksheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml",
    xlsb: "application/vnd.ms-excel.worksheet"
  },
  charts: {
    /* Chartsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml",
    xlsb: "application/vnd.ms-excel.chartsheet"
  },
  dialogs: {
    /* Dialogsheet */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml",
    xlsb: "application/vnd.ms-excel.dialogsheet"
  },
  macros: {
    /* Macrosheet (Excel 4.0 Macros) */
    xlsx: "application/vnd.ms-excel.macrosheet+xml",
    xlsb: "application/vnd.ms-excel.macrosheet"
  },
  metadata: {
    /* Metadata (Stock/Geography and Dynamic Array) */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetMetadata+xml",
    xlsb: "application/vnd.ms-excel.sheetMetadata"
  },
  styles: {
    /* Styles */
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml",
    xlsb: "application/vnd.ms-excel.styles"
  }
};
function new_ct() {
  return {
    workbooks: [],
    sheets: [],
    charts: [],
    dialogs: [],
    macros: [],
    rels: [],
    strs: [],
    comments: [],
    threadedcomments: [],
    links: [],
    coreprops: [],
    extprops: [],
    custprops: [],
    themes: [],
    styles: [],
    calcchains: [],
    vba: [],
    drawings: [],
    metadata: [],
    people: [],
    TODO: [],
    xmlns: ""
  };
}
function parse_ct(data) {
  var ct = new_ct();
  if (!data || !data.match) return ct;
  var ctext = {};
  (data.match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (y4[0].replace(nsregex, "<")) {
      case "<?xml":
        break;
      case "<Types":
        ct.xmlns = y4["xmlns" + (y4[0].match(/<(\w+):/) || ["", ""])[1]];
        break;
      case "<Default":
        ctext[y4.Extension] = y4.ContentType;
        break;
      case "<Override":
        if (ct[ct2type[y4.ContentType]] !== void 0) ct[ct2type[y4.ContentType]].push(y4.PartName);
        break;
    }
  });
  if (ct.xmlns !== XMLNS.CT) throw new Error("Unknown Namespace: " + ct.xmlns);
  ct.calcchain = ct.calcchains.length > 0 ? ct.calcchains[0] : "";
  ct.sst = ct.strs.length > 0 ? ct.strs[0] : "";
  ct.style = ct.styles.length > 0 ? ct.styles[0] : "";
  ct.defaults = ctext;
  delete ct.calcchains;
  return ct;
}
function write_ct(ct, opts) {
  var type2ct = evert_arr(ct2type);
  var o2 = [], v2;
  o2[o2.length] = XML_HEADER;
  o2[o2.length] = writextag("Types", null, {
    "xmlns": XMLNS.CT,
    "xmlns:xsd": XMLNS.xsd,
    "xmlns:xsi": XMLNS.xsi
  });
  o2 = o2.concat([
    ["xml", "application/xml"],
    ["bin", "application/vnd.ms-excel.sheet.binary.macroEnabled.main"],
    ["vml", "application/vnd.openxmlformats-officedocument.vmlDrawing"],
    ["data", "application/vnd.openxmlformats-officedocument.model+data"],
    /* from test files */
    ["bmp", "image/bmp"],
    ["png", "image/png"],
    ["gif", "image/gif"],
    ["emf", "image/x-emf"],
    ["wmf", "image/x-wmf"],
    ["jpg", "image/jpeg"],
    ["jpeg", "image/jpeg"],
    ["tif", "image/tiff"],
    ["tiff", "image/tiff"],
    ["pdf", "application/pdf"],
    ["rels", "application/vnd.openxmlformats-package.relationships+xml"]
  ].map(function(x3) {
    return writextag("Default", null, { "Extension": x3[0], "ContentType": x3[1] });
  }));
  var f1 = function(w3) {
    if (ct[w3] && ct[w3].length > 0) {
      v2 = ct[w3][0];
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v2[0] == "/" ? "" : "/") + v2,
        "ContentType": CT_LIST[w3][opts.bookType] || CT_LIST[w3]["xlsx"]
      });
    }
  };
  var f2 = function(w3) {
    (ct[w3] || []).forEach(function(v3) {
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v3[0] == "/" ? "" : "/") + v3,
        "ContentType": CT_LIST[w3][opts.bookType] || CT_LIST[w3]["xlsx"]
      });
    });
  };
  var f3 = function(t3) {
    (ct[t3] || []).forEach(function(v3) {
      o2[o2.length] = writextag("Override", null, {
        "PartName": (v3[0] == "/" ? "" : "/") + v3,
        "ContentType": type2ct[t3][0]
      });
    });
  };
  f1("workbooks");
  f2("sheets");
  f2("charts");
  f3("themes");
  ["strs", "styles"].forEach(f1);
  ["coreprops", "extprops", "custprops"].forEach(f3);
  f3("vba");
  f3("comments");
  f3("threadedcomments");
  f3("drawings");
  f2("metadata");
  f3("people");
  if (o2.length > 2) {
    o2[o2.length] = "</Types>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
var RELS = {
  WB: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  SHEET: "http://sheetjs.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
  HLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink",
  VML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing",
  XPATH: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLinkPath",
  XMISS: "http://schemas.microsoft.com/office/2006/relationships/xlExternalLinkPath/xlPathMissing",
  XLINK: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/externalLink",
  CXML: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXml",
  CXMLP: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/customXmlProps",
  CMNT: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments",
  CORE_PROPS: "http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties",
  EXT_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties",
  CUST_PROPS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/custom-properties",
  SST: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings",
  STY: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles",
  THEME: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/theme",
  CHART: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chart",
  CHARTEX: "http://schemas.microsoft.com/office/2014/relationships/chartEx",
  CS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/chartsheet",
  WS: [
    "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet",
    "http://purl.oclc.org/ooxml/officeDocument/relationships/worksheet"
  ],
  DS: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/dialogsheet",
  MS: "http://schemas.microsoft.com/office/2006/relationships/xlMacrosheet",
  IMG: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/image",
  DRAW: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing",
  XLMETA: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/sheetMetadata",
  TCMNT: "http://schemas.microsoft.com/office/2017/10/relationships/threadedComment",
  PEOPLE: "http://schemas.microsoft.com/office/2017/10/relationships/person",
  VBA: "http://schemas.microsoft.com/office/2006/relationships/vbaProject"
};
function get_rels_path(file) {
  var n2 = file.lastIndexOf("/");
  return file.slice(0, n2 + 1) + "_rels/" + file.slice(n2 + 1) + ".rels";
}
function parse_rels(data, currentFilePath) {
  var rels = { "!id": {} };
  if (!data) return rels;
  if (currentFilePath.charAt(0) !== "/") {
    currentFilePath = "/" + currentFilePath;
  }
  var hash = {};
  (data.match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    if (y4[0] === "<Relationship") {
      var rel = {};
      rel.Type = y4.Type;
      rel.Target = y4.Target;
      rel.Id = y4.Id;
      if (y4.TargetMode) rel.TargetMode = y4.TargetMode;
      var canonictarget = y4.TargetMode === "External" ? y4.Target : resolve_path(y4.Target, currentFilePath);
      rels[canonictarget] = rel;
      hash[y4.Id] = rel;
    }
  });
  rels["!id"] = hash;
  return rels;
}
function write_rels(rels) {
  var o2 = [XML_HEADER, writextag("Relationships", null, {
    //'xmlns:ns0': XMLNS.RELS,
    "xmlns": XMLNS.RELS
  })];
  keys(rels["!id"]).forEach(function(rid) {
    o2[o2.length] = writextag("Relationship", null, rels["!id"][rid]);
  });
  if (o2.length > 2) {
    o2[o2.length] = "</Relationships>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function add_rels(rels, rId, f2, type, relobj, targetmode) {
  if (!relobj) relobj = {};
  if (!rels["!id"]) rels["!id"] = {};
  if (!rels["!idx"]) rels["!idx"] = 1;
  if (rId < 0) for (rId = rels["!idx"]; rels["!id"]["rId" + rId]; ++rId) {
  }
  rels["!idx"] = rId + 1;
  relobj.Id = "rId" + rId;
  relobj.Type = type;
  relobj.Target = f2;
  if ([RELS.HLINK, RELS.XPATH, RELS.XMISS].indexOf(relobj.Type) > -1) relobj.TargetMode = "External";
  if (rels["!id"][relobj.Id]) throw new Error("Cannot rewrite rId " + rId);
  rels["!id"][relobj.Id] = relobj;
  rels[("/" + relobj.Target).replace("//", "/")] = relobj;
  return rId;
}
var CT_ODS = "application/vnd.oasis.opendocument.spreadsheet";
function parse_manifest(d4, opts) {
  var str = xlml_normalize(d4);
  var Rn;
  var FEtag;
  while (Rn = xlmlregex.exec(str)) switch (Rn[3]) {
    case "manifest":
      break;
    case "file-entry":
      FEtag = parsexmltag(Rn[0], false);
      if (FEtag.path == "/" && FEtag.type !== CT_ODS) throw new Error("This OpenDocument is not a spreadsheet");
      break;
    case "encryption-data":
    case "algorithm":
    case "start-key-generation":
    case "key-derivation":
      throw new Error("Unsupported ODS Encryption");
    default:
      if (opts && opts.WTF) throw Rn;
  }
}
function write_manifest(manifest) {
  var o2 = [XML_HEADER];
  o2.push('<manifest:manifest xmlns:manifest="urn:oasis:names:tc:opendocument:xmlns:manifest:1.0" manifest:version="1.2">\n');
  o2.push('  <manifest:file-entry manifest:full-path="/" manifest:version="1.2" manifest:media-type="application/vnd.oasis.opendocument.spreadsheet"/>\n');
  for (var i3 = 0; i3 < manifest.length; ++i3) o2.push('  <manifest:file-entry manifest:full-path="' + manifest[i3][0] + '" manifest:media-type="' + manifest[i3][1] + '"/>\n');
  o2.push("</manifest:manifest>");
  return o2.join("");
}
function write_rdf_type(file, res, tag) {
  return [
    '  <rdf:Description rdf:about="' + file + '">\n',
    '    <rdf:type rdf:resource="http://docs.oasis-open.org/ns/office/1.2/meta/' + (tag || "odf") + "#" + res + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf_has(base, file) {
  return [
    '  <rdf:Description rdf:about="' + base + '">\n',
    '    <ns0:hasPart xmlns:ns0="http://docs.oasis-open.org/ns/office/1.2/meta/pkg#" rdf:resource="' + file + '"/>\n',
    "  </rdf:Description>\n"
  ].join("");
}
function write_rdf(rdf) {
  var o2 = [XML_HEADER];
  o2.push('<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">\n');
  for (var i3 = 0; i3 != rdf.length; ++i3) {
    o2.push(write_rdf_type(rdf[i3][0], rdf[i3][1]));
    o2.push(write_rdf_has("", rdf[i3][0]));
  }
  o2.push(write_rdf_type("", "Document", "pkg"));
  o2.push("</rdf:RDF>");
  return o2.join("");
}
function write_meta_ods() {
  return '<office:document-meta xmlns:office="urn:oasis:names:tc:opendocument:xmlns:office:1.0" xmlns:meta="urn:oasis:names:tc:opendocument:xmlns:meta:1.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:xlink="http://www.w3.org/1999/xlink" office:version="1.2"><office:meta><meta:generator>SheetJS ' + XLSX.version + "</meta:generator></office:meta></office:document-meta>";
}
var CORE_PROPS = [
  ["cp:category", "Category"],
  ["cp:contentStatus", "ContentStatus"],
  ["cp:keywords", "Keywords"],
  ["cp:lastModifiedBy", "LastAuthor"],
  ["cp:lastPrinted", "LastPrinted"],
  ["cp:revision", "RevNumber"],
  ["cp:version", "Version"],
  ["dc:creator", "Author"],
  ["dc:description", "Comments"],
  ["dc:identifier", "Identifier"],
  ["dc:language", "Language"],
  ["dc:subject", "Subject"],
  ["dc:title", "Title"],
  ["dcterms:created", "CreatedDate", "date"],
  ["dcterms:modified", "ModifiedDate", "date"]
];
var CORE_PROPS_REGEX = /* @__PURE__ */ function() {
  var r2 = new Array(CORE_PROPS.length);
  for (var i3 = 0; i3 < CORE_PROPS.length; ++i3) {
    var f2 = CORE_PROPS[i3];
    var g2 = "(?:" + f2[0].slice(0, f2[0].indexOf(":")) + ":)" + f2[0].slice(f2[0].indexOf(":") + 1);
    r2[i3] = new RegExp("<" + g2 + "[^>]*>([\\s\\S]*?)</" + g2 + ">");
  }
  return r2;
}();
function parse_core_props(data) {
  var p2 = {};
  data = utf8read(data);
  for (var i3 = 0; i3 < CORE_PROPS.length; ++i3) {
    var f2 = CORE_PROPS[i3], cur = data.match(CORE_PROPS_REGEX[i3]);
    if (cur != null && cur.length > 0) p2[f2[1]] = unescapexml(cur[1]);
    if (f2[2] === "date" && p2[f2[1]]) p2[f2[1]] = parseDate(p2[f2[1]]);
  }
  return p2;
}
function cp_doit(f2, g2, h4, o2, p2) {
  if (p2[f2] != null || g2 == null || g2 === "") return;
  p2[f2] = g2;
  g2 = escapexml(g2);
  o2[o2.length] = h4 ? writextag(f2, g2, h4) : writetag(f2, g2);
}
function write_core_props(cp, _opts) {
  var opts = _opts || {};
  var o2 = [XML_HEADER, writextag("cp:coreProperties", null, {
    //'xmlns': XMLNS.CORE_PROPS,
    "xmlns:cp": XMLNS.CORE_PROPS,
    "xmlns:dc": XMLNS.dc,
    "xmlns:dcterms": XMLNS.dcterms,
    "xmlns:dcmitype": XMLNS.dcmitype,
    "xmlns:xsi": XMLNS.xsi
  })], p2 = {};
  if (!cp && !opts.Props) return o2.join("");
  if (cp) {
    if (cp.CreatedDate != null) cp_doit("dcterms:created", typeof cp.CreatedDate === "string" ? cp.CreatedDate : write_w3cdtf(cp.CreatedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o2, p2);
    if (cp.ModifiedDate != null) cp_doit("dcterms:modified", typeof cp.ModifiedDate === "string" ? cp.ModifiedDate : write_w3cdtf(cp.ModifiedDate, opts.WTF), { "xsi:type": "dcterms:W3CDTF" }, o2, p2);
  }
  for (var i3 = 0; i3 != CORE_PROPS.length; ++i3) {
    var f2 = CORE_PROPS[i3];
    var v2 = opts.Props && opts.Props[f2[1]] != null ? opts.Props[f2[1]] : cp ? cp[f2[1]] : null;
    if (v2 === true) v2 = "1";
    else if (v2 === false) v2 = "0";
    else if (typeof v2 == "number") v2 = String(v2);
    if (v2 != null) cp_doit(f2[0], v2, null, o2, p2);
  }
  if (o2.length > 2) {
    o2[o2.length] = "</cp:coreProperties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
var EXT_PROPS = [
  ["Application", "Application", "string"],
  ["AppVersion", "AppVersion", "string"],
  ["Company", "Company", "string"],
  ["DocSecurity", "DocSecurity", "string"],
  ["Manager", "Manager", "string"],
  ["HyperlinksChanged", "HyperlinksChanged", "bool"],
  ["SharedDoc", "SharedDoc", "bool"],
  ["LinksUpToDate", "LinksUpToDate", "bool"],
  ["ScaleCrop", "ScaleCrop", "bool"],
  ["HeadingPairs", "HeadingPairs", "raw"],
  ["TitlesOfParts", "TitlesOfParts", "raw"]
];
var PseudoPropsPairs = [
  "Worksheets",
  "SheetNames",
  "NamedRanges",
  "DefinedNames",
  "Chartsheets",
  "ChartNames"
];
function load_props_pairs(HP, TOP, props, opts) {
  var v2 = [];
  if (typeof HP == "string") v2 = parseVector(HP, opts);
  else for (var j2 = 0; j2 < HP.length; ++j2) v2 = v2.concat(HP[j2].map(function(hp) {
    return { v: hp };
  }));
  var parts = typeof TOP == "string" ? parseVector(TOP, opts).map(function(x3) {
    return x3.v;
  }) : TOP;
  var idx = 0, len = 0;
  if (parts.length > 0) for (var i3 = 0; i3 !== v2.length; i3 += 2) {
    len = +v2[i3 + 1].v;
    switch (v2[i3].v) {
      case "Worksheets":
      case "工作表":
      case "Листы":
      case "أوراق العمل":
      case "ワークシート":
      case "גליונות עבודה":
      case "Arbeitsblätter":
      case "Çalışma Sayfaları":
      case "Feuilles de calcul":
      case "Fogli di lavoro":
      case "Folhas de cálculo":
      case "Planilhas":
      case "Regneark":
      case "Hojas de cálculo":
      case "Werkbladen":
        props.Worksheets = len;
        props.SheetNames = parts.slice(idx, idx + len);
        break;
      case "Named Ranges":
      case "Rangos con nombre":
      case "名前付き一覧":
      case "Benannte Bereiche":
      case "Navngivne områder":
        props.NamedRanges = len;
        props.DefinedNames = parts.slice(idx, idx + len);
        break;
      case "Charts":
      case "Diagramme":
        props.Chartsheets = len;
        props.ChartNames = parts.slice(idx, idx + len);
        break;
    }
    idx += len;
  }
}
function parse_ext_props(data, p2, opts) {
  var q3 = {};
  if (!p2) p2 = {};
  data = utf8read(data);
  EXT_PROPS.forEach(function(f2) {
    var xml = (data.match(matchtag(f2[0])) || [])[1];
    switch (f2[2]) {
      case "string":
        if (xml) p2[f2[1]] = unescapexml(xml);
        break;
      case "bool":
        p2[f2[1]] = xml === "true";
        break;
      case "raw":
        var cur = data.match(new RegExp("<" + f2[0] + "[^>]*>([\\s\\S]*?)</" + f2[0] + ">"));
        if (cur && cur.length > 0) q3[f2[1]] = cur[1];
        break;
    }
  });
  if (q3.HeadingPairs && q3.TitlesOfParts) load_props_pairs(q3.HeadingPairs, q3.TitlesOfParts, p2, opts);
  return p2;
}
function write_ext_props(cp) {
  var o2 = [], W2 = writextag;
  if (!cp) cp = {};
  cp.Application = "SheetJS";
  o2[o2.length] = XML_HEADER;
  o2[o2.length] = writextag("Properties", null, {
    "xmlns": XMLNS.EXT_PROPS,
    "xmlns:vt": XMLNS.vt
  });
  EXT_PROPS.forEach(function(f2) {
    if (cp[f2[1]] === void 0) return;
    var v2;
    switch (f2[2]) {
      case "string":
        v2 = escapexml(String(cp[f2[1]]));
        break;
      case "bool":
        v2 = cp[f2[1]] ? "true" : "false";
        break;
    }
    if (v2 !== void 0) o2[o2.length] = W2(f2[0], v2);
  });
  o2[o2.length] = W2("HeadingPairs", W2("vt:vector", W2("vt:variant", "<vt:lpstr>Worksheets</vt:lpstr>") + W2("vt:variant", W2("vt:i4", String(cp.Worksheets))), { size: 2, baseType: "variant" }));
  o2[o2.length] = W2("TitlesOfParts", W2("vt:vector", cp.SheetNames.map(function(s4) {
    return "<vt:lpstr>" + escapexml(s4) + "</vt:lpstr>";
  }).join(""), { size: cp.Worksheets, baseType: "lpstr" }));
  if (o2.length > 2) {
    o2[o2.length] = "</Properties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
var custregex = /<[^>]+>[^<]*/g;
function parse_cust_props(data, opts) {
  var p2 = {}, name = "";
  var m4 = data.match(custregex);
  if (m4) for (var i3 = 0; i3 != m4.length; ++i3) {
    var x3 = m4[i3], y4 = parsexmltag(x3);
    switch (y4[0]) {
      case "<?xml":
        break;
      case "<Properties":
        break;
      case "<property":
        name = unescapexml(y4.name);
        break;
      case "</property>":
        name = null;
        break;
      default:
        if (x3.indexOf("<vt:") === 0) {
          var toks = x3.split(">");
          var type = toks[0].slice(4), text = toks[1];
          switch (type) {
            case "lpstr":
            case "bstr":
            case "lpwstr":
              p2[name] = unescapexml(text);
              break;
            case "bool":
              p2[name] = parsexmlbool(text);
              break;
            case "i1":
            case "i2":
            case "i4":
            case "i8":
            case "int":
            case "uint":
              p2[name] = parseInt(text, 10);
              break;
            case "r4":
            case "r8":
            case "decimal":
              p2[name] = parseFloat(text);
              break;
            case "filetime":
            case "date":
              p2[name] = parseDate(text);
              break;
            case "cy":
            case "error":
              p2[name] = unescapexml(text);
              break;
            default:
              if (type.slice(-1) == "/") break;
              if (opts.WTF && typeof console !== "undefined") console.warn("Unexpected", x3, type, toks);
          }
        } else if (x3.slice(0, 2) === "</") ;
        else if (opts.WTF) throw new Error(x3);
    }
  }
  return p2;
}
function write_cust_props(cp) {
  var o2 = [XML_HEADER, writextag("Properties", null, {
    "xmlns": XMLNS.CUST_PROPS,
    "xmlns:vt": XMLNS.vt
  })];
  if (!cp) return o2.join("");
  var pid = 1;
  keys(cp).forEach(function custprop(k3) {
    ++pid;
    o2[o2.length] = writextag("property", write_vt(cp[k3]), {
      "fmtid": "{D5CDD505-2E9C-101B-9397-08002B2CF9AE}",
      "pid": pid,
      "name": escapexml(k3)
    });
  });
  if (o2.length > 2) {
    o2[o2.length] = "</Properties>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
var XLMLDocPropsMap = {
  Title: "Title",
  Subject: "Subject",
  Author: "Author",
  Keywords: "Keywords",
  Comments: "Description",
  LastAuthor: "LastAuthor",
  RevNumber: "Revision",
  Application: "AppName",
  /* TotalTime: 'TotalTime', */
  LastPrinted: "LastPrinted",
  CreatedDate: "Created",
  ModifiedDate: "LastSaved",
  /* Pages */
  /* Words */
  /* Characters */
  Category: "Category",
  /* PresentationFormat */
  Manager: "Manager",
  Company: "Company",
  /* Guid */
  /* HyperlinkBase */
  /* Bytes */
  /* Lines */
  /* Paragraphs */
  /* CharactersWithSpaces */
  AppVersion: "Version",
  ContentStatus: "ContentStatus",
  /* NOTE: missing from schema */
  Identifier: "Identifier",
  /* NOTE: missing from schema */
  Language: "Language"
  /* NOTE: missing from schema */
};
var evert_XLMLDPM;
function xlml_set_prop(Props, tag, val) {
  if (!evert_XLMLDPM) evert_XLMLDPM = evert(XLMLDocPropsMap);
  tag = evert_XLMLDPM[tag] || tag;
  Props[tag] = val;
}
function xlml_write_docprops(Props, opts) {
  var o2 = [];
  keys(XLMLDocPropsMap).map(function(m4) {
    for (var i3 = 0; i3 < CORE_PROPS.length; ++i3) if (CORE_PROPS[i3][1] == m4) return CORE_PROPS[i3];
    for (i3 = 0; i3 < EXT_PROPS.length; ++i3) if (EXT_PROPS[i3][1] == m4) return EXT_PROPS[i3];
    throw m4;
  }).forEach(function(p2) {
    if (Props[p2[1]] == null) return;
    var m4 = opts && opts.Props && opts.Props[p2[1]] != null ? opts.Props[p2[1]] : Props[p2[1]];
    switch (p2[2]) {
      case "date":
        m4 = new Date(m4).toISOString().replace(/\.\d*Z/, "Z");
        break;
    }
    if (typeof m4 == "number") m4 = String(m4);
    else if (m4 === true || m4 === false) {
      m4 = m4 ? "1" : "0";
    } else if (m4 instanceof Date) m4 = new Date(m4).toISOString().replace(/\.\d*Z/, "");
    o2.push(writetag(XLMLDocPropsMap[p2[1]] || p2[1], m4));
  });
  return writextag("DocumentProperties", o2.join(""), { xmlns: XLMLNS.o });
}
function xlml_write_custprops(Props, Custprops) {
  var BLACKLIST = ["Worksheets", "SheetNames"];
  var T3 = "CustomDocumentProperties";
  var o2 = [];
  if (Props) keys(Props).forEach(function(k3) {
    if (!Object.prototype.hasOwnProperty.call(Props, k3)) return;
    for (var i3 = 0; i3 < CORE_PROPS.length; ++i3) if (k3 == CORE_PROPS[i3][1]) return;
    for (i3 = 0; i3 < EXT_PROPS.length; ++i3) if (k3 == EXT_PROPS[i3][1]) return;
    for (i3 = 0; i3 < BLACKLIST.length; ++i3) if (k3 == BLACKLIST[i3]) return;
    var m4 = Props[k3];
    var t3 = "string";
    if (typeof m4 == "number") {
      t3 = "float";
      m4 = String(m4);
    } else if (m4 === true || m4 === false) {
      t3 = "boolean";
      m4 = m4 ? "1" : "0";
    } else m4 = String(m4);
    o2.push(writextag(escapexmltag(k3), m4, { "dt:dt": t3 }));
  });
  if (Custprops) keys(Custprops).forEach(function(k3) {
    if (!Object.prototype.hasOwnProperty.call(Custprops, k3)) return;
    if (Props && Object.prototype.hasOwnProperty.call(Props, k3)) return;
    var m4 = Custprops[k3];
    var t3 = "string";
    if (typeof m4 == "number") {
      t3 = "float";
      m4 = String(m4);
    } else if (m4 === true || m4 === false) {
      t3 = "boolean";
      m4 = m4 ? "1" : "0";
    } else if (m4 instanceof Date) {
      t3 = "dateTime.tz";
      m4 = m4.toISOString();
    } else m4 = String(m4);
    o2.push(writextag(escapexmltag(k3), m4, { "dt:dt": t3 }));
  });
  return "<" + T3 + ' xmlns="' + XLMLNS.o + '">' + o2.join("") + "</" + T3 + ">";
}
function parse_FILETIME(blob) {
  var dwLowDateTime = blob.read_shift(4), dwHighDateTime = blob.read_shift(4);
  return new Date((dwHighDateTime / 1e7 * Math.pow(2, 32) + dwLowDateTime / 1e7 - 11644473600) * 1e3).toISOString().replace(/\.000/, "");
}
function write_FILETIME(time) {
  var date = typeof time == "string" ? new Date(Date.parse(time)) : time;
  var t3 = date.getTime() / 1e3 + 11644473600;
  var l2 = t3 % Math.pow(2, 32), h4 = (t3 - l2) / Math.pow(2, 32);
  l2 *= 1e7;
  h4 *= 1e7;
  var w3 = l2 / Math.pow(2, 32) | 0;
  if (w3 > 0) {
    l2 = l2 % Math.pow(2, 32);
    h4 += w3;
  }
  var o2 = new_buf(8);
  o2.write_shift(4, l2);
  o2.write_shift(4, h4);
  return o2;
}
function parse_lpstr(blob, type, pad) {
  var start = blob.l;
  var str = blob.read_shift(0, "lpstr-cp");
  if (pad) while (blob.l - start & 3) ++blob.l;
  return str;
}
function parse_lpwstr(blob, type, pad) {
  var str = blob.read_shift(0, "lpwstr");
  return str;
}
function parse_VtStringBase(blob, stringType2, pad) {
  if (stringType2 === 31) return parse_lpwstr(blob);
  return parse_lpstr(blob, stringType2, pad);
}
function parse_VtString(blob, t3, pad) {
  return parse_VtStringBase(blob, t3, pad === false ? 0 : 4);
}
function parse_VtUnalignedString(blob, t3) {
  if (!t3) throw new Error("VtUnalignedString must have positive length");
  return parse_VtStringBase(blob, t3, 0);
}
function parse_VtVecLpwstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i3 = 0; i3 != length; ++i3) {
    var start = blob.l;
    ret[i3] = blob.read_shift(0, "lpwstr").replace(chr0, "");
    if (blob.l - start & 2) blob.l += 2;
  }
  return ret;
}
function parse_VtVecUnalignedLpstrValue(blob) {
  var length = blob.read_shift(4);
  var ret = [];
  for (var i3 = 0; i3 != length; ++i3) ret[i3] = blob.read_shift(0, "lpstr-cp").replace(chr0, "");
  return ret;
}
function parse_VtHeadingPair(blob) {
  var start = blob.l;
  var headingString = parse_TypedPropertyValue(blob, VT_USTR);
  if (blob[blob.l] == 0 && blob[blob.l + 1] == 0 && blob.l - start & 2) blob.l += 2;
  var headerParts = parse_TypedPropertyValue(blob, VT_I4);
  return [headingString, headerParts];
}
function parse_VtVecHeadingPairValue(blob) {
  var cElements = blob.read_shift(4);
  var out = [];
  for (var i3 = 0; i3 < cElements / 2; ++i3) out.push(parse_VtHeadingPair(blob));
  return out;
}
function parse_dictionary(blob, CodePage) {
  var cnt = blob.read_shift(4);
  var dict = {};
  for (var j2 = 0; j2 != cnt; ++j2) {
    var pid = blob.read_shift(4);
    var len = blob.read_shift(4);
    dict[pid] = blob.read_shift(len, CodePage === 1200 ? "utf16le" : "utf8").replace(chr0, "").replace(chr1, "!");
    if (CodePage === 1200 && len % 2) blob.l += 2;
  }
  if (blob.l & 3) blob.l = blob.l >> 2 + 1 << 2;
  return dict;
}
function parse_BLOB(blob) {
  var size2 = blob.read_shift(4);
  var bytes = blob.slice(blob.l, blob.l + size2);
  blob.l += size2;
  if ((size2 & 3) > 0) blob.l += 4 - (size2 & 3) & 3;
  return bytes;
}
function parse_ClipboardData(blob) {
  var o2 = {};
  o2.Size = blob.read_shift(4);
  blob.l += o2.Size + 3 - (o2.Size - 1) % 4;
  return o2;
}
function parse_TypedPropertyValue(blob, type, _opts) {
  var t3 = blob.read_shift(2), ret, opts = _opts || {};
  blob.l += 2;
  if (type !== VT_VARIANT) {
    if (t3 !== type && VT_CUSTOM.indexOf(type) === -1 && !((type & 65534) == 4126 && (t3 & 65534) == 4126)) throw new Error("Expected type " + type + " saw " + t3);
  }
  switch (type === VT_VARIANT ? t3 : type) {
    case 2:
      ret = blob.read_shift(2, "i");
      if (!opts.raw) blob.l += 2;
      return ret;
    case 3:
      ret = blob.read_shift(4, "i");
      return ret;
    case 11:
      return blob.read_shift(4) !== 0;
    case 19:
      ret = blob.read_shift(4);
      return ret;
    case 30:
      return parse_lpstr(blob, t3, 4).replace(chr0, "");
    case 31:
      return parse_lpwstr(blob);
    case 64:
      return parse_FILETIME(blob);
    case 65:
      return parse_BLOB(blob);
    case 71:
      return parse_ClipboardData(blob);
    case 80:
      return parse_VtString(blob, t3, !opts.raw).replace(chr0, "");
    case 81:
      return parse_VtUnalignedString(
        blob,
        t3
        /*, 4*/
      ).replace(chr0, "");
    case 4108:
      return parse_VtVecHeadingPairValue(blob);
    case 4126:
    case 4127:
      return t3 == 4127 ? parse_VtVecLpwstrValue(blob) : parse_VtVecUnalignedLpstrValue(blob);
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + t3);
  }
}
function write_TypedPropertyValue(type, value) {
  var o2 = new_buf(4), p2 = new_buf(4);
  o2.write_shift(4, type == 80 ? 31 : type);
  switch (type) {
    case 3:
      p2.write_shift(-4, value);
      break;
    case 5:
      p2 = new_buf(8);
      p2.write_shift(8, value, "f");
      break;
    case 11:
      p2.write_shift(4, value ? 1 : 0);
      break;
    case 64:
      p2 = write_FILETIME(value);
      break;
    case 31:
    case 80:
      p2 = new_buf(4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      p2.write_shift(4, value.length + 1);
      p2.write_shift(0, value, "dbcs");
      while (p2.l != p2.length) p2.write_shift(1, 0);
      break;
    default:
      throw new Error("TypedPropertyValue unrecognized type " + type + " " + value);
  }
  return bconcat([o2, p2]);
}
function parse_PropertySet(blob, PIDSI) {
  var start_addr = blob.l;
  var size2 = blob.read_shift(4);
  var NumProps = blob.read_shift(4);
  var Props = [], i3 = 0;
  var CodePage = 0;
  var Dictionary = -1, DictObj = {};
  for (i3 = 0; i3 != NumProps; ++i3) {
    var PropID = blob.read_shift(4);
    var Offset = blob.read_shift(4);
    Props[i3] = [PropID, Offset + start_addr];
  }
  Props.sort(function(x3, y4) {
    return x3[1] - y4[1];
  });
  var PropH = {};
  for (i3 = 0; i3 != NumProps; ++i3) {
    if (blob.l !== Props[i3][1]) {
      var fail = true;
      if (i3 > 0 && PIDSI) switch (PIDSI[Props[i3 - 1][0]].t) {
        case 2:
          if (blob.l + 2 === Props[i3][1]) {
            blob.l += 2;
            fail = false;
          }
          break;
        case 80:
          if (blob.l <= Props[i3][1]) {
            blob.l = Props[i3][1];
            fail = false;
          }
          break;
        case 4108:
          if (blob.l <= Props[i3][1]) {
            blob.l = Props[i3][1];
            fail = false;
          }
          break;
      }
      if ((!PIDSI || i3 == 0) && blob.l <= Props[i3][1]) {
        fail = false;
        blob.l = Props[i3][1];
      }
      if (fail) throw new Error("Read Error: Expected address " + Props[i3][1] + " at " + blob.l + " :" + i3);
    }
    if (PIDSI) {
      var piddsi = PIDSI[Props[i3][0]];
      PropH[piddsi.n] = parse_TypedPropertyValue(blob, piddsi.t, { raw: true });
      if (piddsi.p === "version") PropH[piddsi.n] = String(PropH[piddsi.n] >> 16) + "." + ("0000" + String(PropH[piddsi.n] & 65535)).slice(-4);
      if (piddsi.n == "CodePage") switch (PropH[piddsi.n]) {
        case 0:
          PropH[piddsi.n] = 1252;
        case 874:
        case 932:
        case 936:
        case 949:
        case 950:
        case 1250:
        case 1251:
        case 1253:
        case 1254:
        case 1255:
        case 1256:
        case 1257:
        case 1258:
        case 1e4:
        case 1200:
        case 1201:
        case 1252:
        case 65e3:
        case -536:
        case 65001:
        case -535:
          set_cp(CodePage = PropH[piddsi.n] >>> 0 & 65535);
          break;
        default:
          throw new Error("Unsupported CodePage: " + PropH[piddsi.n]);
      }
    } else {
      if (Props[i3][0] === 1) {
        CodePage = PropH.CodePage = parse_TypedPropertyValue(blob, VT_I2);
        set_cp(CodePage);
        if (Dictionary !== -1) {
          var oldpos = blob.l;
          blob.l = Props[Dictionary][1];
          DictObj = parse_dictionary(blob, CodePage);
          blob.l = oldpos;
        }
      } else if (Props[i3][0] === 0) {
        if (CodePage === 0) {
          Dictionary = i3;
          blob.l = Props[i3 + 1][1];
          continue;
        }
        DictObj = parse_dictionary(blob, CodePage);
      } else {
        var name = DictObj[Props[i3][0]];
        var val;
        switch (blob[blob.l]) {
          case 65:
            blob.l += 4;
            val = parse_BLOB(blob);
            break;
          case 30:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 31:
            blob.l += 4;
            val = parse_VtString(blob, blob[blob.l - 4]).replace(/\u0000+$/, "");
            break;
          case 3:
            blob.l += 4;
            val = blob.read_shift(4, "i");
            break;
          case 19:
            blob.l += 4;
            val = blob.read_shift(4);
            break;
          case 5:
            blob.l += 4;
            val = blob.read_shift(8, "f");
            break;
          case 11:
            blob.l += 4;
            val = parsebool(blob, 4);
            break;
          case 64:
            blob.l += 4;
            val = parseDate(parse_FILETIME(blob));
            break;
          default:
            throw new Error("unparsed value: " + blob[blob.l]);
        }
        PropH[name] = val;
      }
    }
  }
  blob.l = start_addr + size2;
  return PropH;
}
var XLSPSSkip = ["CodePage", "Thumbnail", "_PID_LINKBASE", "_PID_HLINKS", "SystemIdentifier", "FMTID"];
function guess_property_type(val) {
  switch (typeof val) {
    case "boolean":
      return 11;
    case "number":
      return (val | 0) == val ? 3 : 5;
    case "string":
      return 31;
    case "object":
      if (val instanceof Date) return 64;
      break;
  }
  return -1;
}
function write_PropertySet(entries, RE, PIDSI) {
  var hdr = new_buf(8), piao = [], prop = [];
  var sz = 8, i3 = 0;
  var pr = new_buf(8), pio = new_buf(8);
  pr.write_shift(4, 2);
  pr.write_shift(4, 1200);
  pio.write_shift(4, 1);
  prop.push(pr);
  piao.push(pio);
  sz += 8 + pr.length;
  if (!RE) {
    pio = new_buf(8);
    pio.write_shift(4, 0);
    piao.unshift(pio);
    var bufs = [new_buf(4)];
    bufs[0].write_shift(4, entries.length);
    for (i3 = 0; i3 < entries.length; ++i3) {
      var value = entries[i3][0];
      pr = new_buf(4 + 4 + 2 * (value.length + 1) + (value.length % 2 ? 0 : 2));
      pr.write_shift(4, i3 + 2);
      pr.write_shift(4, value.length + 1);
      pr.write_shift(0, value, "dbcs");
      while (pr.l != pr.length) pr.write_shift(1, 0);
      bufs.push(pr);
    }
    pr = bconcat(bufs);
    prop.unshift(pr);
    sz += 8 + pr.length;
  }
  for (i3 = 0; i3 < entries.length; ++i3) {
    if (RE && !RE[entries[i3][0]]) continue;
    if (XLSPSSkip.indexOf(entries[i3][0]) > -1 || PseudoPropsPairs.indexOf(entries[i3][0]) > -1) continue;
    if (entries[i3][1] == null) continue;
    var val = entries[i3][1], idx = 0;
    if (RE) {
      idx = +RE[entries[i3][0]];
      var pinfo = PIDSI[idx];
      if (pinfo.p == "version" && typeof val == "string") {
        var arr = val.split(".");
        val = (+arr[0] << 16) + (+arr[1] || 0);
      }
      pr = write_TypedPropertyValue(pinfo.t, val);
    } else {
      var T3 = guess_property_type(val);
      if (T3 == -1) {
        T3 = 31;
        val = String(val);
      }
      pr = write_TypedPropertyValue(T3, val);
    }
    prop.push(pr);
    pio = new_buf(8);
    pio.write_shift(4, !RE ? 2 + i3 : idx);
    piao.push(pio);
    sz += 8 + pr.length;
  }
  var w3 = 8 * (prop.length + 1);
  for (i3 = 0; i3 < prop.length; ++i3) {
    piao[i3].write_shift(4, w3);
    w3 += prop[i3].length;
  }
  hdr.write_shift(4, sz);
  hdr.write_shift(4, prop.length);
  return bconcat([hdr].concat(piao).concat(prop));
}
function parse_PropertySetStream(file, PIDSI, clsid) {
  var blob = file.content;
  if (!blob) return {};
  prep_blob(blob, 0);
  var NumSets, FMTID0, FMTID1, Offset0, Offset1 = 0;
  blob.chk("feff", "Byte Order: ");
  blob.read_shift(2);
  var SystemIdentifier = blob.read_shift(4);
  var CLSID = blob.read_shift(16);
  if (CLSID !== CFB.utils.consts.HEADER_CLSID && CLSID !== clsid) throw new Error("Bad PropertySet CLSID " + CLSID);
  NumSets = blob.read_shift(4);
  if (NumSets !== 1 && NumSets !== 2) throw new Error("Unrecognized #Sets: " + NumSets);
  FMTID0 = blob.read_shift(16);
  Offset0 = blob.read_shift(4);
  if (NumSets === 1 && Offset0 !== blob.l) throw new Error("Length mismatch: " + Offset0 + " !== " + blob.l);
  else if (NumSets === 2) {
    FMTID1 = blob.read_shift(16);
    Offset1 = blob.read_shift(4);
  }
  var PSet0 = parse_PropertySet(blob, PIDSI);
  var rval = { SystemIdentifier };
  for (var y4 in PSet0) rval[y4] = PSet0[y4];
  rval.FMTID = FMTID0;
  if (NumSets === 1) return rval;
  if (Offset1 - blob.l == 2) blob.l += 2;
  if (blob.l !== Offset1) throw new Error("Length mismatch 2: " + blob.l + " !== " + Offset1);
  var PSet1;
  try {
    PSet1 = parse_PropertySet(blob, null);
  } catch (e3) {
  }
  for (y4 in PSet1) rval[y4] = PSet1[y4];
  rval.FMTID = [FMTID0, FMTID1];
  return rval;
}
function write_PropertySetStream(entries, clsid, RE, PIDSI, entries2, clsid2) {
  var hdr = new_buf(entries2 ? 68 : 48);
  var bufs = [hdr];
  hdr.write_shift(2, 65534);
  hdr.write_shift(2, 0);
  hdr.write_shift(4, 842412599);
  hdr.write_shift(16, CFB.utils.consts.HEADER_CLSID, "hex");
  hdr.write_shift(4, entries2 ? 2 : 1);
  hdr.write_shift(16, clsid, "hex");
  hdr.write_shift(4, entries2 ? 68 : 48);
  var ps0 = write_PropertySet(entries, RE, PIDSI);
  bufs.push(ps0);
  if (entries2) {
    var ps1 = write_PropertySet(entries2, null, null);
    hdr.write_shift(16, clsid2, "hex");
    hdr.write_shift(4, 68 + ps0.length);
    bufs.push(ps1);
  }
  return bconcat(bufs);
}
function parsenoop2(blob, length) {
  blob.read_shift(length);
  return null;
}
function writezeroes(n2, o2) {
  if (!o2) o2 = new_buf(n2);
  for (var j2 = 0; j2 < n2; ++j2) o2.write_shift(1, 0);
  return o2;
}
function parslurp(blob, length, cb2) {
  var arr = [], target = blob.l + length;
  while (blob.l < target) arr.push(cb2(blob, target - blob.l));
  if (target !== blob.l) throw new Error("Slurp error");
  return arr;
}
function parsebool(blob, length) {
  return blob.read_shift(length) === 1;
}
function writebool(v2, o2) {
  if (!o2) o2 = new_buf(2);
  o2.write_shift(2, +!!v2);
  return o2;
}
function parseuint16(blob) {
  return blob.read_shift(2, "u");
}
function writeuint16(v2, o2) {
  if (!o2) o2 = new_buf(2);
  o2.write_shift(2, v2);
  return o2;
}
function parseuint16a(blob, length) {
  return parslurp(blob, length, parseuint16);
}
function parse_Bes(blob) {
  var v2 = blob.read_shift(1), t3 = blob.read_shift(1);
  return t3 === 1 ? v2 : v2 === 1;
}
function write_Bes(v2, t3, o2) {
  if (!o2) o2 = new_buf(2);
  o2.write_shift(1, t3 == "e" ? +v2 : +!!v2);
  o2.write_shift(1, t3 == "e" ? 1 : 0);
  return o2;
}
function parse_ShortXLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff >= 12 ? 2 : 1);
  var encoding = "sbcs-cont";
  if (opts && opts.biff >= 8) ;
  if (!opts || opts.biff == 8) {
    var fHighByte = blob.read_shift(1);
    if (fHighByte) {
      encoding = "dbcs-cont";
    }
  } else if (opts.biff == 12) {
    encoding = "wstr";
  }
  if (opts.biff >= 2 && opts.biff <= 5) encoding = "cpstr";
  var o2 = cch ? blob.read_shift(cch, encoding) : "";
  return o2;
}
function parse_XLUnicodeRichExtendedString(blob) {
  var cch = blob.read_shift(2), flags = blob.read_shift(1);
  var fExtSt = flags & 4, fRichSt = flags & 8;
  var width = 1 + (flags & 1);
  var cRun = 0, cbExtRst;
  var z3 = {};
  if (fRichSt) cRun = blob.read_shift(2);
  if (fExtSt) cbExtRst = blob.read_shift(4);
  var encoding = width == 2 ? "dbcs-cont" : "sbcs-cont";
  var msg = cch === 0 ? "" : blob.read_shift(cch, encoding);
  if (fRichSt) blob.l += 4 * cRun;
  if (fExtSt) blob.l += cbExtRst;
  z3.t = msg;
  if (!fRichSt) {
    z3.raw = "<t>" + z3.t + "</t>";
    z3.r = z3.t;
  }
  return z3;
}
function write_XLUnicodeRichExtendedString(xlstr) {
  var str = xlstr.t || "";
  var hdr = new_buf(3 + 0);
  hdr.write_shift(2, str.length);
  hdr.write_shift(1, 0 | 1);
  var otext = new_buf(2 * str.length);
  otext.write_shift(2 * str.length, str, "utf16le");
  var out = [hdr, otext];
  return bconcat(out);
}
function parse_XLUnicodeStringNoCch(blob, cch, opts) {
  var retval;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return blob.read_shift(cch, "cpstr");
    if (opts.biff >= 12) return blob.read_shift(cch, "dbcs-cont");
  }
  var fHighByte = blob.read_shift(1);
  if (fHighByte === 0) {
    retval = blob.read_shift(cch, "sbcs-cont");
  } else {
    retval = blob.read_shift(cch, "dbcs-cont");
  }
  return retval;
}
function parse_XLUnicodeString(blob, length, opts) {
  var cch = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return parse_XLUnicodeStringNoCch(blob, cch, opts);
}
function parse_XLUnicodeString2(blob, length, opts) {
  if (opts.biff > 5) return parse_XLUnicodeString(blob, length, opts);
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, opts.biff <= 4 || !blob.lens ? "cpstr" : "sbcs-cont");
}
function write_XLUnicodeString(str, opts, o2) {
  if (!o2) o2 = new_buf(3 + 2 * str.length);
  o2.write_shift(2, str.length);
  o2.write_shift(1, 1);
  o2.write_shift(31, str, "utf16le");
  return o2;
}
function parse_ControlInfo(blob) {
  var flags = blob.read_shift(1);
  blob.l++;
  var accel = blob.read_shift(2);
  blob.l += 2;
  return [flags, accel];
}
function parse_URLMoniker(blob) {
  var len = blob.read_shift(4), start = blob.l;
  var extra = false;
  if (len > 24) {
    blob.l += len - 24;
    if (blob.read_shift(16) === "795881f43b1d7f48af2c825dc4852763") extra = true;
    blob.l = start;
  }
  var url2 = blob.read_shift((extra ? len - 24 : len) >> 1, "utf16le").replace(chr0, "");
  if (extra) blob.l += 24;
  return url2;
}
function parse_FileMoniker(blob) {
  var cAnti = blob.read_shift(2);
  var preamble = "";
  while (cAnti-- > 0) preamble += "../";
  var ansiPath = blob.read_shift(0, "lpstr-ansi");
  blob.l += 2;
  if (blob.read_shift(2) != 57005) throw new Error("Bad FileMoniker");
  var sz = blob.read_shift(4);
  if (sz === 0) return preamble + ansiPath.replace(/\\/g, "/");
  var bytes = blob.read_shift(4);
  if (blob.read_shift(2) != 3) throw new Error("Bad FileMoniker");
  var unicodePath = blob.read_shift(bytes >> 1, "utf16le").replace(chr0, "");
  return preamble + unicodePath;
}
function parse_HyperlinkMoniker(blob, length) {
  var clsid = blob.read_shift(16);
  switch (clsid) {
    case "e0c9ea79f9bace118c8200aa004ba90b":
      return parse_URLMoniker(blob);
    case "0303000000000000c000000000000046":
      return parse_FileMoniker(blob);
    default:
      throw new Error("Unsupported Moniker " + clsid);
  }
}
function parse_HyperlinkString(blob) {
  var len = blob.read_shift(4);
  var o2 = len > 0 ? blob.read_shift(len, "utf16le").replace(chr0, "") : "";
  return o2;
}
function write_HyperlinkString(str, o2) {
  if (!o2) o2 = new_buf(6 + str.length * 2);
  o2.write_shift(4, 1 + str.length);
  for (var i3 = 0; i3 < str.length; ++i3) o2.write_shift(2, str.charCodeAt(i3));
  o2.write_shift(2, 0);
  return o2;
}
function parse_Hyperlink(blob, length) {
  var end = blob.l + length;
  var sVer = blob.read_shift(4);
  if (sVer !== 2) throw new Error("Unrecognized streamVersion: " + sVer);
  var flags = blob.read_shift(2);
  blob.l += 2;
  var displayName, targetFrameName, moniker, oleMoniker, Loc = "", guid, fileTime;
  if (flags & 16) displayName = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 128) targetFrameName = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 257) moniker = parse_HyperlinkString(blob, end - blob.l);
  if ((flags & 257) === 1) oleMoniker = parse_HyperlinkMoniker(blob, end - blob.l);
  if (flags & 8) Loc = parse_HyperlinkString(blob, end - blob.l);
  if (flags & 32) guid = blob.read_shift(16);
  if (flags & 64) fileTime = parse_FILETIME(
    blob
    /*, 8*/
  );
  blob.l = end;
  var target = targetFrameName || moniker || oleMoniker || "";
  if (target && Loc) target += "#" + Loc;
  if (!target) target = "#" + Loc;
  if (flags & 2 && target.charAt(0) == "/" && target.charAt(1) != "/") target = "file://" + target;
  var out = { Target: target };
  if (guid) out.guid = guid;
  if (fileTime) out.time = fileTime;
  if (displayName) out.Tooltip = displayName;
  return out;
}
function write_Hyperlink(hl2) {
  var out = new_buf(512), i3 = 0;
  var Target = hl2.Target;
  if (Target.slice(0, 7) == "file://") Target = Target.slice(7);
  var hashidx = Target.indexOf("#");
  var F2 = hashidx > -1 ? 31 : 23;
  switch (Target.charAt(0)) {
    case "#":
      F2 = 28;
      break;
    case ".":
      F2 &= -3;
      break;
  }
  out.write_shift(4, 2);
  out.write_shift(4, F2);
  var data = [8, 6815827, 6619237, 4849780, 83];
  for (i3 = 0; i3 < data.length; ++i3) out.write_shift(4, data[i3]);
  if (F2 == 28) {
    Target = Target.slice(1);
    write_HyperlinkString(Target, out);
  } else if (F2 & 2) {
    data = "e0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
    for (i3 = 0; i3 < data.length; ++i3) out.write_shift(1, parseInt(data[i3], 16));
    var Pretarget = hashidx > -1 ? Target.slice(0, hashidx) : Target;
    out.write_shift(4, 2 * (Pretarget.length + 1));
    for (i3 = 0; i3 < Pretarget.length; ++i3) out.write_shift(2, Pretarget.charCodeAt(i3));
    out.write_shift(2, 0);
    if (F2 & 8) write_HyperlinkString(hashidx > -1 ? Target.slice(hashidx + 1) : "", out);
  } else {
    data = "03 03 00 00 00 00 00 00 c0 00 00 00 00 00 00 46".split(" ");
    for (i3 = 0; i3 < data.length; ++i3) out.write_shift(1, parseInt(data[i3], 16));
    var P2 = 0;
    while (Target.slice(P2 * 3, P2 * 3 + 3) == "../" || Target.slice(P2 * 3, P2 * 3 + 3) == "..\\") ++P2;
    out.write_shift(2, P2);
    out.write_shift(4, Target.length - 3 * P2 + 1);
    for (i3 = 0; i3 < Target.length - 3 * P2; ++i3) out.write_shift(1, Target.charCodeAt(i3 + 3 * P2) & 255);
    out.write_shift(1, 0);
    out.write_shift(2, 65535);
    out.write_shift(2, 57005);
    for (i3 = 0; i3 < 6; ++i3) out.write_shift(4, 0);
  }
  return out.slice(0, out.l);
}
function parse_LongRGBA(blob) {
  var r2 = blob.read_shift(1), g2 = blob.read_shift(1), b2 = blob.read_shift(1), a4 = blob.read_shift(1);
  return [r2, g2, b2, a4];
}
function parse_LongRGB(blob, length) {
  var x3 = parse_LongRGBA(blob);
  x3[3] = 0;
  return x3;
}
function parse_XLSCell(blob) {
  var rw = blob.read_shift(2);
  var col = blob.read_shift(2);
  var ixfe = blob.read_shift(2);
  return { r: rw, c: col, ixfe };
}
function write_XLSCell(R3, C2, ixfe, o2) {
  if (!o2) o2 = new_buf(6);
  o2.write_shift(2, R3);
  o2.write_shift(2, C2);
  o2.write_shift(2, ixfe || 0);
  return o2;
}
function parse_frtHeader(blob) {
  var rt = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 8;
  return { type: rt, flags };
}
function parse_OptXLUnicodeString(blob, length, opts) {
  return length === 0 ? "" : parse_XLUnicodeString2(blob, length, opts);
}
function parse_XTI(blob, length, opts) {
  var w3 = opts.biff > 8 ? 4 : 2;
  var iSupBook = blob.read_shift(w3), itabFirst = blob.read_shift(w3, "i"), itabLast = blob.read_shift(w3, "i");
  return [iSupBook, itabFirst, itabLast];
}
function parse_RkRec(blob) {
  var ixfe = blob.read_shift(2);
  var RK = parse_RkNumber(blob);
  return [ixfe, RK];
}
function parse_AddinUdf(blob, length, opts) {
  blob.l += 4;
  length -= 4;
  var l2 = blob.l + length;
  var udfName = parse_ShortXLUnicodeString(blob, length, opts);
  var cb2 = blob.read_shift(2);
  l2 -= blob.l;
  if (cb2 !== l2) throw new Error("Malformed AddinUdf: padding = " + l2 + " != " + cb2);
  blob.l += cb2;
  return udfName;
}
function parse_Ref8U(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(2);
  var colLast = blob.read_shift(2);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
function write_Ref8U(r2, o2) {
  if (!o2) o2 = new_buf(8);
  o2.write_shift(2, r2.s.r);
  o2.write_shift(2, r2.e.r);
  o2.write_shift(2, r2.s.c);
  o2.write_shift(2, r2.e.c);
  return o2;
}
function parse_RefU(blob) {
  var rwFirst = blob.read_shift(2);
  var rwLast = blob.read_shift(2);
  var colFirst = blob.read_shift(1);
  var colLast = blob.read_shift(1);
  return { s: { c: colFirst, r: rwFirst }, e: { c: colLast, r: rwLast } };
}
var parse_Ref = parse_RefU;
function parse_FtCmo(blob) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id2 = blob.read_shift(2);
  var flags = blob.read_shift(2);
  blob.l += 12;
  return [id2, ot, flags];
}
function parse_FtNts(blob) {
  var out = {};
  blob.l += 4;
  blob.l += 16;
  out.fSharedNote = blob.read_shift(2);
  blob.l += 4;
  return out;
}
function parse_FtCf(blob) {
  var out = {};
  blob.l += 4;
  blob.cf = blob.read_shift(2);
  return out;
}
function parse_FtSkip(blob) {
  blob.l += 2;
  blob.l += blob.read_shift(2);
}
var FtTab = {
  /*::[*/
  0: parse_FtSkip,
  /* FtEnd */
  /*::[*/
  4: parse_FtSkip,
  /* FtMacro */
  /*::[*/
  5: parse_FtSkip,
  /* FtButton */
  /*::[*/
  6: parse_FtSkip,
  /* FtGmo */
  /*::[*/
  7: parse_FtCf,
  /* FtCf */
  /*::[*/
  8: parse_FtSkip,
  /* FtPioGrbit */
  /*::[*/
  9: parse_FtSkip,
  /* FtPictFmla */
  /*::[*/
  10: parse_FtSkip,
  /* FtCbls */
  /*::[*/
  11: parse_FtSkip,
  /* FtRbo */
  /*::[*/
  12: parse_FtSkip,
  /* FtSbs */
  /*::[*/
  13: parse_FtNts,
  /* FtNts */
  /*::[*/
  14: parse_FtSkip,
  /* FtSbsFmla */
  /*::[*/
  15: parse_FtSkip,
  /* FtGboData */
  /*::[*/
  16: parse_FtSkip,
  /* FtEdoData */
  /*::[*/
  17: parse_FtSkip,
  /* FtRboData */
  /*::[*/
  18: parse_FtSkip,
  /* FtCblsData */
  /*::[*/
  19: parse_FtSkip,
  /* FtLbsData */
  /*::[*/
  20: parse_FtSkip,
  /* FtCblsFmla */
  /*::[*/
  21: parse_FtCmo
};
function parse_FtArray(blob, length) {
  var tgt = blob.l + length;
  var fts = [];
  while (blob.l < tgt) {
    var ft = blob.read_shift(2);
    blob.l -= 2;
    try {
      fts.push(FtTab[ft](blob, tgt - blob.l));
    } catch (e3) {
      blob.l = tgt;
      return fts;
    }
  }
  if (blob.l != tgt) blob.l = tgt;
  return fts;
}
function parse_BOF(blob, length) {
  var o2 = { BIFFVer: 0, dt: 0 };
  o2.BIFFVer = blob.read_shift(2);
  length -= 2;
  if (length >= 2) {
    o2.dt = blob.read_shift(2);
    blob.l -= 2;
  }
  switch (o2.BIFFVer) {
    case 1536:
    case 1280:
    case 1024:
    case 768:
    case 512:
    case 2:
    case 7:
      break;
    default:
      if (length > 6) throw new Error("Unexpected BIFF Ver " + o2.BIFFVer);
  }
  blob.read_shift(length);
  return o2;
}
function write_BOF(wb2, t3, o2) {
  var h4 = 1536, w3 = 16;
  switch (o2.bookType) {
    case "biff8":
      break;
    case "biff5":
      h4 = 1280;
      w3 = 8;
      break;
    case "biff4":
      h4 = 4;
      w3 = 6;
      break;
    case "biff3":
      h4 = 3;
      w3 = 6;
      break;
    case "biff2":
      h4 = 2;
      w3 = 4;
      break;
    case "xla":
      break;
    default:
      throw new Error("unsupported BIFF version");
  }
  var out = new_buf(w3);
  out.write_shift(2, h4);
  out.write_shift(2, t3);
  if (w3 > 4) out.write_shift(2, 29282);
  if (w3 > 6) out.write_shift(2, 1997);
  if (w3 > 8) {
    out.write_shift(2, 49161);
    out.write_shift(2, 1);
    out.write_shift(2, 1798);
    out.write_shift(2, 0);
  }
  return out;
}
function parse_InterfaceHdr(blob, length) {
  if (length === 0) return 1200;
  if (blob.read_shift(2) !== 1200) ;
  return 1200;
}
function parse_WriteAccess(blob, length, opts) {
  if (opts.enc) {
    blob.l += length;
    return "";
  }
  var l2 = blob.l;
  var UserName = parse_XLUnicodeString2(blob, 0, opts);
  blob.read_shift(length + l2 - blob.l);
  return UserName;
}
function write_WriteAccess(s4, opts) {
  var b8 = !opts || opts.biff == 8;
  var o2 = new_buf(b8 ? 112 : 54);
  o2.write_shift(opts.biff == 8 ? 2 : 1, 7);
  if (b8) o2.write_shift(1, 0);
  o2.write_shift(4, 859007059);
  o2.write_shift(4, 5458548 | (b8 ? 0 : 536870912));
  while (o2.l < o2.length) o2.write_shift(1, b8 ? 0 : 32);
  return o2;
}
function parse_WsBool(blob, length, opts) {
  var flags = opts && opts.biff == 8 || length == 2 ? blob.read_shift(2) : (blob.l += length, 0);
  return { fDialog: flags & 16, fBelow: flags & 64, fRight: flags & 128 };
}
function parse_BoundSheet8(blob, length, opts) {
  var pos = blob.read_shift(4);
  var hidden = blob.read_shift(1) & 3;
  var dt = blob.read_shift(1);
  switch (dt) {
    case 0:
      dt = "Worksheet";
      break;
    case 1:
      dt = "Macrosheet";
      break;
    case 2:
      dt = "Chartsheet";
      break;
    case 6:
      dt = "VBAModule";
      break;
  }
  var name = parse_ShortXLUnicodeString(blob, 0, opts);
  if (name.length === 0) name = "Sheet1";
  return { pos, hs: hidden, dt, name };
}
function write_BoundSheet8(data, opts) {
  var w3 = !opts || opts.biff >= 8 ? 2 : 1;
  var o2 = new_buf(8 + w3 * data.name.length);
  o2.write_shift(4, data.pos);
  o2.write_shift(1, data.hs || 0);
  o2.write_shift(1, data.dt);
  o2.write_shift(1, data.name.length);
  if (opts.biff >= 8) o2.write_shift(1, 1);
  o2.write_shift(w3 * data.name.length, data.name, opts.biff < 8 ? "sbcs" : "utf16le");
  var out = o2.slice(0, o2.l);
  out.l = o2.l;
  return out;
}
function parse_SST(blob, length) {
  var end = blob.l + length;
  var cnt = blob.read_shift(4);
  var ucnt = blob.read_shift(4);
  var strs2 = [];
  for (var i3 = 0; i3 != ucnt && blob.l < end; ++i3) {
    strs2.push(parse_XLUnicodeRichExtendedString(blob));
  }
  strs2.Count = cnt;
  strs2.Unique = ucnt;
  return strs2;
}
function write_SST(sst, opts) {
  var header = new_buf(8);
  header.write_shift(4, sst.Count);
  header.write_shift(4, sst.Unique);
  var strs2 = [];
  for (var j2 = 0; j2 < sst.length; ++j2) strs2[j2] = write_XLUnicodeRichExtendedString(sst[j2]);
  var o2 = bconcat([header].concat(strs2));
  o2.parts = [header.length].concat(strs2.map(function(str) {
    return str.length;
  }));
  return o2;
}
function parse_ExtSST(blob, length) {
  var extsst = {};
  extsst.dsst = blob.read_shift(2);
  blob.l += length - 2;
  return extsst;
}
function parse_Row(blob) {
  var z3 = {};
  z3.r = blob.read_shift(2);
  z3.c = blob.read_shift(2);
  z3.cnt = blob.read_shift(2) - z3.c;
  var miyRw = blob.read_shift(2);
  blob.l += 4;
  var flags = blob.read_shift(1);
  blob.l += 3;
  if (flags & 7) z3.level = flags & 7;
  if (flags & 32) z3.hidden = true;
  if (flags & 64) z3.hpt = miyRw / 20;
  return z3;
}
function parse_ForceFullCalculation(blob) {
  var header = parse_frtHeader(blob);
  if (header.type != 2211) throw new Error("Invalid Future Record " + header.type);
  var fullcalc = blob.read_shift(4);
  return fullcalc !== 0;
}
function parse_RecalcId(blob) {
  blob.read_shift(2);
  return blob.read_shift(4);
}
function parse_DefaultRowHeight(blob, length, opts) {
  var f2 = 0;
  if (!(opts && opts.biff == 2)) {
    f2 = blob.read_shift(2);
  }
  var miyRw = blob.read_shift(2);
  if (opts && opts.biff == 2) {
    f2 = 1 - (miyRw >> 15);
    miyRw &= 32767;
  }
  var fl2 = { Unsynced: f2 & 1, DyZero: (f2 & 2) >> 1, ExAsc: (f2 & 4) >> 2, ExDsc: (f2 & 8) >> 3 };
  return [fl2, miyRw];
}
function parse_Window1(blob) {
  var xWn = blob.read_shift(2), yWn = blob.read_shift(2), dxWn = blob.read_shift(2), dyWn = blob.read_shift(2);
  var flags = blob.read_shift(2), iTabCur = blob.read_shift(2), iTabFirst = blob.read_shift(2);
  var ctabSel = blob.read_shift(2), wTabRatio = blob.read_shift(2);
  return {
    Pos: [xWn, yWn],
    Dim: [dxWn, dyWn],
    Flags: flags,
    CurTab: iTabCur,
    FirstTab: iTabFirst,
    Selected: ctabSel,
    TabRatio: wTabRatio
  };
}
function write_Window1() {
  var o2 = new_buf(18);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 29280);
  o2.write_shift(2, 17600);
  o2.write_shift(2, 56);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 1);
  o2.write_shift(2, 500);
  return o2;
}
function parse_Window2(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff < 5) return {};
  var f2 = blob.read_shift(2);
  return { RTL: f2 & 64 };
}
function write_Window2(view) {
  var o2 = new_buf(18), f2 = 1718;
  if (view && view.RTL) f2 |= 64;
  o2.write_shift(2, f2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 64);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
function parse_Pane() {
}
function parse_Font(blob, length, opts) {
  var o2 = {
    dyHeight: blob.read_shift(2),
    fl: blob.read_shift(2)
  };
  switch (opts && opts.biff || 8) {
    case 2:
      break;
    case 3:
    case 4:
      blob.l += 2;
      break;
    default:
      blob.l += 10;
      break;
  }
  o2.name = parse_ShortXLUnicodeString(blob, 0, opts);
  return o2;
}
function write_Font(data, opts) {
  var name = data.name || "Arial";
  var b5 = opts && opts.biff == 5, w3 = b5 ? 15 + name.length : 16 + 2 * name.length;
  var o2 = new_buf(w3);
  o2.write_shift(2, data.sz * 20);
  o2.write_shift(4, 0);
  o2.write_shift(2, 400);
  o2.write_shift(4, 0);
  o2.write_shift(2, 0);
  o2.write_shift(1, name.length);
  if (!b5) o2.write_shift(1, 1);
  o2.write_shift((b5 ? 1 : 2) * name.length, name, b5 ? "sbcs" : "utf16le");
  return o2;
}
function parse_LabelSst(blob) {
  var cell = parse_XLSCell(blob);
  cell.isst = blob.read_shift(4);
  return cell;
}
function write_LabelSst(R3, C2, v2, os) {
  var o2 = new_buf(10);
  write_XLSCell(R3, C2, os, o2);
  o2.write_shift(4, v2);
  return o2;
}
function parse_Label(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var target = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2) blob.l++;
  var str = parse_XLUnicodeString(blob, target - blob.l, opts);
  cell.val = str;
  return cell;
}
function write_Label(R3, C2, v2, os, opts) {
  var b8 = !opts || opts.biff == 8;
  var o2 = new_buf(6 + 2 + +b8 + (1 + b8) * v2.length);
  write_XLSCell(R3, C2, os, o2);
  o2.write_shift(2, v2.length);
  if (b8) o2.write_shift(1, 1);
  o2.write_shift((1 + b8) * v2.length, v2, b8 ? "utf16le" : "sbcs");
  return o2;
}
function parse_Format(blob, length, opts) {
  var numFmtId = blob.read_shift(2);
  var fmtstr = parse_XLUnicodeString2(blob, 0, opts);
  return [numFmtId, fmtstr];
}
function write_Format(i3, f2, opts, o2) {
  var b5 = opts && opts.biff == 5;
  if (!o2) o2 = new_buf(b5 ? 3 + f2.length : 5 + 2 * f2.length);
  o2.write_shift(2, i3);
  o2.write_shift(b5 ? 1 : 2, f2.length);
  if (!b5) o2.write_shift(1, 1);
  o2.write_shift((b5 ? 1 : 2) * f2.length, f2, b5 ? "sbcs" : "utf16le");
  var out = o2.length > o2.l ? o2.slice(0, o2.l) : o2;
  if (out.l == null) out.l = out.length;
  return out;
}
var parse_BIFF2Format = parse_XLUnicodeString2;
function parse_Dimensions(blob, length, opts) {
  var end = blob.l + length;
  var w3 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var r2 = blob.read_shift(w3), R3 = blob.read_shift(w3);
  var c3 = blob.read_shift(2), C2 = blob.read_shift(2);
  blob.l = end;
  return { s: { r: r2, c: c3 }, e: { r: R3, c: C2 } };
}
function write_Dimensions(range, opts) {
  var w3 = opts.biff == 8 || !opts.biff ? 4 : 2;
  var o2 = new_buf(2 * w3 + 6);
  o2.write_shift(w3, range.s.r);
  o2.write_shift(w3, range.e.r + 1);
  o2.write_shift(2, range.s.c);
  o2.write_shift(2, range.e.c + 1);
  o2.write_shift(2, 0);
  return o2;
}
function parse_RK(blob) {
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrec = parse_RkRec(blob);
  return { r: rw, c: col, ixfe: rkrec[0], rknum: rkrec[1] };
}
function parse_MulRk(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var rkrecs = [];
  while (blob.l < target) rkrecs.push(parse_RkRec(blob));
  if (blob.l !== target) throw new Error("MulRK read error");
  var lastcol = blob.read_shift(2);
  if (rkrecs.length != lastcol - col + 1) throw new Error("MulRK length mismatch");
  return { r: rw, c: col, C: lastcol, rkrec: rkrecs };
}
function parse_MulBlank(blob, length) {
  var target = blob.l + length - 2;
  var rw = blob.read_shift(2), col = blob.read_shift(2);
  var ixfes = [];
  while (blob.l < target) ixfes.push(blob.read_shift(2));
  if (blob.l !== target) throw new Error("MulBlank read error");
  var lastcol = blob.read_shift(2);
  if (ixfes.length != lastcol - col + 1) throw new Error("MulBlank length mismatch");
  return { r: rw, c: col, C: lastcol, ixfe: ixfes };
}
function parse_CellStyleXF(blob, length, style, opts) {
  var o2 = {};
  var a4 = blob.read_shift(4), b2 = blob.read_shift(4);
  var c3 = blob.read_shift(4), d4 = blob.read_shift(2);
  o2.patternType = XLSFillPattern[c3 >> 26];
  if (!opts.cellStyles) return o2;
  o2.alc = a4 & 7;
  o2.fWrap = a4 >> 3 & 1;
  o2.alcV = a4 >> 4 & 7;
  o2.fJustLast = a4 >> 7 & 1;
  o2.trot = a4 >> 8 & 255;
  o2.cIndent = a4 >> 16 & 15;
  o2.fShrinkToFit = a4 >> 20 & 1;
  o2.iReadOrder = a4 >> 22 & 2;
  o2.fAtrNum = a4 >> 26 & 1;
  o2.fAtrFnt = a4 >> 27 & 1;
  o2.fAtrAlc = a4 >> 28 & 1;
  o2.fAtrBdr = a4 >> 29 & 1;
  o2.fAtrPat = a4 >> 30 & 1;
  o2.fAtrProt = a4 >> 31 & 1;
  o2.dgLeft = b2 & 15;
  o2.dgRight = b2 >> 4 & 15;
  o2.dgTop = b2 >> 8 & 15;
  o2.dgBottom = b2 >> 12 & 15;
  o2.icvLeft = b2 >> 16 & 127;
  o2.icvRight = b2 >> 23 & 127;
  o2.grbitDiag = b2 >> 30 & 3;
  o2.icvTop = c3 & 127;
  o2.icvBottom = c3 >> 7 & 127;
  o2.icvDiag = c3 >> 14 & 127;
  o2.dgDiag = c3 >> 21 & 15;
  o2.icvFore = d4 & 127;
  o2.icvBack = d4 >> 7 & 127;
  o2.fsxButton = d4 >> 14 & 1;
  return o2;
}
function parse_XF(blob, length, opts) {
  var o2 = {};
  o2.ifnt = blob.read_shift(2);
  o2.numFmtId = blob.read_shift(2);
  o2.flags = blob.read_shift(2);
  o2.fStyle = o2.flags >> 2 & 1;
  length -= 6;
  o2.data = parse_CellStyleXF(blob, length, o2.fStyle, opts);
  return o2;
}
function write_XF(data, ixfeP, opts, o2) {
  var b5 = opts && opts.biff == 5;
  if (!o2) o2 = new_buf(b5 ? 16 : 20);
  o2.write_shift(2, 0);
  if (data.style) {
    o2.write_shift(2, data.numFmtId || 0);
    o2.write_shift(2, 65524);
  } else {
    o2.write_shift(2, data.numFmtId || 0);
    o2.write_shift(2, ixfeP << 4);
  }
  var f2 = 0;
  if (data.numFmtId > 0 && b5) f2 |= 1024;
  o2.write_shift(4, f2);
  o2.write_shift(4, 0);
  if (!b5) o2.write_shift(4, 0);
  o2.write_shift(2, 0);
  return o2;
}
function parse_Guts(blob) {
  blob.l += 4;
  var out = [blob.read_shift(2), blob.read_shift(2)];
  if (out[0] !== 0) out[0]--;
  if (out[1] !== 0) out[1]--;
  if (out[0] > 7 || out[1] > 7) throw new Error("Bad Gutters: " + out.join("|"));
  return out;
}
function write_Guts(guts) {
  var o2 = new_buf(8);
  o2.write_shift(4, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  return o2;
}
function parse_BoolErr(blob, length, opts) {
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2 || length == 9) ++blob.l;
  var val = parse_Bes(blob);
  cell.val = val;
  cell.t = val === true || val === false ? "b" : "e";
  return cell;
}
function write_BoolErr(R3, C2, v2, os, opts, t3) {
  var o2 = new_buf(8);
  write_XLSCell(R3, C2, os, o2);
  write_Bes(v2, t3, o2);
  return o2;
}
function parse_Number(blob, length, opts) {
  if (opts.biffguess && opts.biff == 2) opts.biff = 5;
  var cell = parse_XLSCell(blob);
  var xnum = parse_Xnum(blob);
  cell.val = xnum;
  return cell;
}
function write_Number(R3, C2, v2, os) {
  var o2 = new_buf(14);
  write_XLSCell(R3, C2, os, o2);
  write_Xnum(v2, o2);
  return o2;
}
var parse_XLHeaderFooter = parse_OptXLUnicodeString;
function parse_SupBook(blob, length, opts) {
  var end = blob.l + length;
  var ctab = blob.read_shift(2);
  var cch = blob.read_shift(2);
  opts.sbcch = cch;
  if (cch == 1025 || cch == 14849) return [cch, ctab];
  if (cch < 1 || cch > 255) throw new Error("Unexpected SupBook type: " + cch);
  var virtPath = parse_XLUnicodeStringNoCch(blob, cch);
  var rgst = [];
  while (end > blob.l) rgst.push(parse_XLUnicodeString(blob));
  return [cch, ctab, virtPath, rgst];
}
function parse_ExternName(blob, length, opts) {
  var flags = blob.read_shift(2);
  var body;
  var o2 = {
    fBuiltIn: flags & 1,
    fWantAdvise: flags >>> 1 & 1,
    fWantPict: flags >>> 2 & 1,
    fOle: flags >>> 3 & 1,
    fOleLink: flags >>> 4 & 1,
    cf: flags >>> 5 & 1023,
    fIcon: flags >>> 15 & 1
  };
  if (opts.sbcch === 14849) body = parse_AddinUdf(blob, length - 2, opts);
  o2.body = body || blob.read_shift(length - 2);
  if (typeof body === "string") o2.Name = body;
  return o2;
}
var XLSLblBuiltIn = [
  "_xlnm.Consolidate_Area",
  "_xlnm.Auto_Open",
  "_xlnm.Auto_Close",
  "_xlnm.Extract",
  "_xlnm.Database",
  "_xlnm.Criteria",
  "_xlnm.Print_Area",
  "_xlnm.Print_Titles",
  "_xlnm.Recorder",
  "_xlnm.Data_Form",
  "_xlnm.Auto_Activate",
  "_xlnm.Auto_Deactivate",
  "_xlnm.Sheet_Title",
  "_xlnm._FilterDatabase"
];
function parse_Lbl(blob, length, opts) {
  var target = blob.l + length;
  var flags = blob.read_shift(2);
  var chKey = blob.read_shift(1);
  var cch = blob.read_shift(1);
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var itab = 0;
  if (!opts || opts.biff >= 5) {
    if (opts.biff != 5) blob.l += 2;
    itab = blob.read_shift(2);
    if (opts.biff == 5) blob.l += 2;
    blob.l += 4;
  }
  var name = parse_XLUnicodeStringNoCch(blob, cch, opts);
  if (flags & 32) name = XLSLblBuiltIn[name.charCodeAt(0)];
  var npflen = target - blob.l;
  if (opts && opts.biff == 2) --npflen;
  var rgce = target == blob.l || cce === 0 || !(npflen > 0) ? [] : parse_NameParsedFormula(blob, npflen, opts, cce);
  return {
    chKey,
    Name: name,
    itab,
    rgce
  };
}
function parse_ExternSheet(blob, length, opts) {
  if (opts.biff < 8) return parse_BIFF5ExternSheet(blob, length, opts);
  var o2 = [], target = blob.l + length, len = blob.read_shift(opts.biff > 8 ? 4 : 2);
  while (len-- !== 0) o2.push(parse_XTI(blob, opts.biff > 8 ? 12 : 6, opts));
  if (blob.l != target) throw new Error("Bad ExternSheet: " + blob.l + " != " + target);
  return o2;
}
function parse_BIFF5ExternSheet(blob, length, opts) {
  if (blob[blob.l + 1] == 3) blob[blob.l]++;
  var o2 = parse_ShortXLUnicodeString(blob, length, opts);
  return o2.charCodeAt(0) == 3 ? o2.slice(1) : o2;
}
function parse_NameCmt(blob, length, opts) {
  if (opts.biff < 8) {
    blob.l += length;
    return;
  }
  var cchName = blob.read_shift(2);
  var cchComment = blob.read_shift(2);
  var name = parse_XLUnicodeStringNoCch(blob, cchName, opts);
  var comment = parse_XLUnicodeStringNoCch(blob, cchComment, opts);
  return [name, comment];
}
function parse_ShrFmla(blob, length, opts) {
  var ref = parse_RefU(blob);
  blob.l++;
  var cUse = blob.read_shift(1);
  length -= 8;
  return [parse_SharedParsedFormula(blob, length, opts), cUse, ref];
}
function parse_Array(blob, length, opts) {
  var ref = parse_Ref(blob);
  switch (opts.biff) {
    case 2:
      blob.l++;
      length -= 7;
      break;
    case 3:
    case 4:
      blob.l += 2;
      length -= 8;
      break;
    default:
      blob.l += 6;
      length -= 12;
  }
  return [ref, parse_ArrayParsedFormula(blob, length, opts)];
}
function parse_MTRSettings(blob) {
  var fMTREnabled = blob.read_shift(4) !== 0;
  var fUserSetThreadCount = blob.read_shift(4) !== 0;
  var cUserThreadCount = blob.read_shift(4);
  return [fMTREnabled, fUserSetThreadCount, cUserThreadCount];
}
function parse_NoteSh(blob, length, opts) {
  if (opts.biff < 8) return;
  var row = blob.read_shift(2), col = blob.read_shift(2);
  var flags = blob.read_shift(2), idObj = blob.read_shift(2);
  var stAuthor = parse_XLUnicodeString2(blob, 0, opts);
  if (opts.biff < 8) blob.read_shift(1);
  return [{ r: row, c: col }, stAuthor, idObj, flags];
}
function parse_Note(blob, length, opts) {
  return parse_NoteSh(blob, length, opts);
}
function parse_MergeCells(blob, length) {
  var merges = [];
  var cmcs = blob.read_shift(2);
  while (cmcs--) merges.push(parse_Ref8U(blob));
  return merges;
}
function write_MergeCells(merges) {
  var o2 = new_buf(2 + merges.length * 8);
  o2.write_shift(2, merges.length);
  for (var i3 = 0; i3 < merges.length; ++i3) write_Ref8U(merges[i3], o2);
  return o2;
}
function parse_Obj(blob, length, opts) {
  if (opts && opts.biff < 8) return parse_BIFF5Obj(blob, length, opts);
  var cmo = parse_FtCmo(blob);
  var fts = parse_FtArray(blob, length - 22, cmo[1]);
  return { cmo, ft: fts };
}
var parse_BIFF5OT = {
  8: function(blob, length) {
    var tgt = blob.l + length;
    blob.l += 10;
    var cf2 = blob.read_shift(2);
    blob.l += 4;
    blob.l += 2;
    blob.l += 2;
    blob.l += 2;
    blob.l += 4;
    var cchName = blob.read_shift(1);
    blob.l += cchName;
    blob.l = tgt;
    return { fmt: cf2 };
  }
};
function parse_BIFF5Obj(blob, length, opts) {
  blob.l += 4;
  var ot = blob.read_shift(2);
  var id2 = blob.read_shift(2);
  var grbit = blob.read_shift(2);
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 2;
  blob.l += 6;
  length -= 36;
  var fts = [];
  fts.push((parse_BIFF5OT[ot] || parsenoop)(blob, length, opts));
  return { cmo: [id2, ot, grbit], ft: fts };
}
function parse_TxO(blob, length, opts) {
  var s4 = blob.l;
  var texts = "";
  try {
    blob.l += 4;
    var ot = (opts.lastobj || { cmo: [0, 0] }).cmo[1];
    var controlInfo;
    if ([0, 5, 7, 11, 12, 14].indexOf(ot) == -1) blob.l += 6;
    else controlInfo = parse_ControlInfo(blob, 6, opts);
    var cchText = blob.read_shift(2);
    blob.read_shift(2);
    parseuint16(blob, 2);
    var len = blob.read_shift(2);
    blob.l += len;
    for (var i3 = 1; i3 < blob.lens.length - 1; ++i3) {
      if (blob.l - s4 != blob.lens[i3]) throw new Error("TxO: bad continue record");
      var hdr = blob[blob.l];
      var t3 = parse_XLUnicodeStringNoCch(blob, blob.lens[i3 + 1] - blob.lens[i3] - 1);
      texts += t3;
      if (texts.length >= (hdr ? cchText : 2 * cchText)) break;
    }
    if (texts.length !== cchText && texts.length !== cchText * 2) {
      throw new Error("cchText: " + cchText + " != " + texts.length);
    }
    blob.l = s4 + length;
    return { t: texts };
  } catch (e3) {
    blob.l = s4 + length;
    return { t: texts };
  }
}
function parse_HLink(blob, length) {
  var ref = parse_Ref8U(blob);
  blob.l += 16;
  var hlink = parse_Hyperlink(blob, length - 24);
  return [ref, hlink];
}
function write_HLink(hl2) {
  var O3 = new_buf(24);
  var ref = decode_cell(hl2[0]);
  O3.write_shift(2, ref.r);
  O3.write_shift(2, ref.r);
  O3.write_shift(2, ref.c);
  O3.write_shift(2, ref.c);
  var clsid = "d0 c9 ea 79 f9 ba ce 11 8c 82 00 aa 00 4b a9 0b".split(" ");
  for (var i3 = 0; i3 < 16; ++i3) O3.write_shift(1, parseInt(clsid[i3], 16));
  return bconcat([O3, write_Hyperlink(hl2[1])]);
}
function parse_HLinkTooltip(blob, length) {
  blob.read_shift(2);
  var ref = parse_Ref8U(blob);
  var wzTooltip = blob.read_shift((length - 10) / 2, "dbcs-cont");
  wzTooltip = wzTooltip.replace(chr0, "");
  return [ref, wzTooltip];
}
function write_HLinkTooltip(hl2) {
  var TT = hl2[1].Tooltip;
  var O3 = new_buf(10 + 2 * (TT.length + 1));
  O3.write_shift(2, 2048);
  var ref = decode_cell(hl2[0]);
  O3.write_shift(2, ref.r);
  O3.write_shift(2, ref.r);
  O3.write_shift(2, ref.c);
  O3.write_shift(2, ref.c);
  for (var i3 = 0; i3 < TT.length; ++i3) O3.write_shift(2, TT.charCodeAt(i3));
  O3.write_shift(2, 0);
  return O3;
}
function parse_Country(blob) {
  var o2 = [0, 0], d4;
  d4 = blob.read_shift(2);
  o2[0] = CountryEnum[d4] || d4;
  d4 = blob.read_shift(2);
  o2[1] = CountryEnum[d4] || d4;
  return o2;
}
function write_Country(o2) {
  if (!o2) o2 = new_buf(4);
  o2.write_shift(2, 1);
  o2.write_shift(2, 1);
  return o2;
}
function parse_ClrtClient(blob) {
  var ccv = blob.read_shift(2);
  var o2 = [];
  while (ccv-- > 0) o2.push(parse_LongRGB(blob));
  return o2;
}
function parse_Palette(blob) {
  var ccv = blob.read_shift(2);
  var o2 = [];
  while (ccv-- > 0) o2.push(parse_LongRGB(blob));
  return o2;
}
function parse_XFCRC(blob) {
  blob.l += 2;
  var o2 = { cxfs: 0, crc: 0 };
  o2.cxfs = blob.read_shift(2);
  o2.crc = blob.read_shift(4);
  return o2;
}
function parse_ColInfo(blob, length, opts) {
  if (!opts.cellStyles) return parsenoop(blob, length);
  var w3 = opts && opts.biff >= 12 ? 4 : 2;
  var colFirst = blob.read_shift(w3);
  var colLast = blob.read_shift(w3);
  var coldx = blob.read_shift(w3);
  var ixfe = blob.read_shift(w3);
  var flags = blob.read_shift(2);
  if (w3 == 2) blob.l += 2;
  var o2 = { s: colFirst, e: colLast, w: coldx, ixfe, flags };
  if (opts.biff >= 5 || !opts.biff) o2.level = flags >> 8 & 7;
  return o2;
}
function write_ColInfo(col, idx) {
  var o2 = new_buf(12);
  o2.write_shift(2, idx);
  o2.write_shift(2, idx);
  o2.write_shift(2, col.width * 256);
  o2.write_shift(2, 0);
  var f2 = 0;
  if (col.hidden) f2 |= 1;
  o2.write_shift(1, f2);
  f2 = col.level || 0;
  o2.write_shift(1, f2);
  o2.write_shift(2, 0);
  return o2;
}
function parse_Setup(blob, length) {
  var o2 = {};
  if (length < 32) return o2;
  blob.l += 16;
  o2.header = parse_Xnum(blob);
  o2.footer = parse_Xnum(blob);
  blob.l += 2;
  return o2;
}
function parse_ShtProps(blob, length, opts) {
  var def = { area: false };
  if (opts.biff != 5) {
    blob.l += length;
    return def;
  }
  var d4 = blob.read_shift(1);
  blob.l += 3;
  if (d4 & 16) def.area = true;
  return def;
}
function write_RRTabId(n2) {
  var out = new_buf(2 * n2);
  for (var i3 = 0; i3 < n2; ++i3) out.write_shift(2, i3 + 1);
  return out;
}
var parse_Blank = parse_XLSCell;
var parse_Scl = parseuint16a;
var parse_String = parse_XLUnicodeString;
function parse_ImData(blob) {
  var cf2 = blob.read_shift(2);
  var env = blob.read_shift(2);
  var lcb = blob.read_shift(4);
  var o2 = { fmt: cf2, env, len: lcb, data: blob.slice(blob.l, blob.l + lcb) };
  blob.l += lcb;
  return o2;
}
function parse_BIFF2STR(blob, length, opts) {
  if (opts.biffguess && opts.biff == 5) opts.biff = 2;
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var str = parse_XLUnicodeString2(blob, length - 7, opts);
  cell.t = "str";
  cell.val = str;
  return cell;
}
function parse_BIFF2NUM(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = parse_Xnum(blob);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2NUM(r2, c3, val) {
  var out = new_buf(15);
  write_BIFF2Cell(out, r2, c3);
  out.write_shift(8, val, "f");
  return out;
}
function parse_BIFF2INT(blob) {
  var cell = parse_XLSCell(blob);
  ++blob.l;
  var num = blob.read_shift(2);
  cell.t = "n";
  cell.val = num;
  return cell;
}
function write_BIFF2INT(r2, c3, val) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r2, c3);
  out.write_shift(2, val);
  return out;
}
function parse_BIFF2STRING(blob) {
  var cch = blob.read_shift(1);
  if (cch === 0) {
    blob.l++;
    return "";
  }
  return blob.read_shift(cch, "sbcs-cont");
}
function parse_BIFF2FONTXTRA(blob, length) {
  blob.l += 6;
  blob.l += 2;
  blob.l += 1;
  blob.l += 3;
  blob.l += 1;
  blob.l += length - 13;
}
function parse_RString(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  var cch = blob.read_shift(2);
  var str = parse_XLUnicodeStringNoCch(blob, cch, opts);
  blob.l = end;
  cell.t = "str";
  cell.val = str;
  return cell;
}
var DBF_SUPPORTED_VERSIONS = [2, 3, 48, 49, 131, 139, 140, 245];
var DBF = /* @__PURE__ */ function() {
  var dbf_codepage_map = {
    /* Code Pages Supported by Visual FoxPro */
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /* shapefile DBF extension */
    /*::[*/
    0: 20127,
    /*::[*/
    8: 865,
    /*::[*/
    9: 437,
    /*::[*/
    10: 850,
    /*::[*/
    11: 437,
    /*::[*/
    13: 437,
    /*::[*/
    14: 850,
    /*::[*/
    15: 437,
    /*::[*/
    16: 850,
    /*::[*/
    17: 437,
    /*::[*/
    18: 850,
    /*::[*/
    19: 932,
    /*::[*/
    20: 850,
    /*::[*/
    21: 437,
    /*::[*/
    22: 850,
    /*::[*/
    23: 865,
    /*::[*/
    24: 437,
    /*::[*/
    25: 437,
    /*::[*/
    26: 850,
    /*::[*/
    27: 437,
    /*::[*/
    28: 863,
    /*::[*/
    29: 850,
    /*::[*/
    31: 852,
    /*::[*/
    34: 852,
    /*::[*/
    35: 852,
    /*::[*/
    36: 860,
    /*::[*/
    37: 850,
    /*::[*/
    38: 866,
    /*::[*/
    55: 850,
    /*::[*/
    64: 852,
    /*::[*/
    77: 936,
    /*::[*/
    78: 949,
    /*::[*/
    79: 950,
    /*::[*/
    80: 874,
    /*::[*/
    87: 1252,
    /*::[*/
    88: 1252,
    /*::[*/
    89: 1252,
    /*::[*/
    108: 863,
    /*::[*/
    134: 737,
    /*::[*/
    135: 852,
    /*::[*/
    136: 857,
    /*::[*/
    204: 1257,
    /*::[*/
    255: 16969
  };
  var dbf_reverse_map = evert({
    /*::[*/
    1: 437,
    /*::[*/
    2: 850,
    /*::[*/
    3: 1252,
    /*::[*/
    4: 1e4,
    /*::[*/
    100: 852,
    /*::[*/
    101: 866,
    /*::[*/
    102: 865,
    /*::[*/
    103: 861,
    /*::[*/
    104: 895,
    /*::[*/
    105: 620,
    /*::[*/
    106: 737,
    /*::[*/
    107: 857,
    /*::[*/
    120: 950,
    /*::[*/
    121: 949,
    /*::[*/
    122: 936,
    /*::[*/
    123: 932,
    /*::[*/
    124: 874,
    /*::[*/
    125: 1255,
    /*::[*/
    126: 1256,
    /*::[*/
    150: 10007,
    /*::[*/
    151: 10029,
    /*::[*/
    152: 10006,
    /*::[*/
    200: 1250,
    /*::[*/
    201: 1251,
    /*::[*/
    202: 1254,
    /*::[*/
    203: 1253,
    /*::[*/
    0: 20127
  });
  function dbf_to_aoa(buf, opts) {
    var out = [];
    var d4 = new_raw_buf(1);
    switch (opts.type) {
      case "base64":
        d4 = s2a(Base64_decode(buf));
        break;
      case "binary":
        d4 = s2a(buf);
        break;
      case "buffer":
      case "array":
        d4 = buf;
        break;
    }
    prep_blob(d4, 0);
    var ft = d4.read_shift(1);
    var memo = !!(ft & 136);
    var vfp = false, l7 = false;
    switch (ft) {
      case 2:
        break;
      case 3:
        break;
      case 48:
        vfp = true;
        memo = true;
        break;
      case 49:
        vfp = true;
        memo = true;
        break;
      case 131:
        break;
      case 139:
        break;
      case 140:
        l7 = true;
        break;
      case 245:
        break;
      default:
        throw new Error("DBF Unsupported Version: " + ft.toString(16));
    }
    var nrow = 0, fpos = 521;
    if (ft == 2) nrow = d4.read_shift(2);
    d4.l += 3;
    if (ft != 2) nrow = d4.read_shift(4);
    if (nrow > 1048576) nrow = 1e6;
    if (ft != 2) fpos = d4.read_shift(2);
    var rlen = d4.read_shift(2);
    var current_cp = opts.codepage || 1252;
    if (ft != 2) {
      d4.l += 16;
      d4.read_shift(1);
      if (d4[d4.l] !== 0) current_cp = dbf_codepage_map[d4[d4.l]];
      d4.l += 1;
      d4.l += 2;
    }
    if (l7) d4.l += 36;
    var fields = [], field = {};
    var hend = Math.min(d4.length, ft == 2 ? 521 : fpos - 10 - (vfp ? 264 : 0));
    var ww = l7 ? 32 : 11;
    while (d4.l < hend && d4[d4.l] != 13) {
      field = {};
      field.name = $cptable.utils.decode(current_cp, d4.slice(d4.l, d4.l + ww)).replace(/[\u0000\r\n].*$/g, "");
      d4.l += ww;
      field.type = String.fromCharCode(d4.read_shift(1));
      if (ft != 2 && !l7) field.offset = d4.read_shift(4);
      field.len = d4.read_shift(1);
      if (ft == 2) field.offset = d4.read_shift(2);
      field.dec = d4.read_shift(1);
      if (field.name.length) fields.push(field);
      if (ft != 2) d4.l += l7 ? 13 : 14;
      switch (field.type) {
        case "B":
          if ((!vfp || field.len != 8) && opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "G":
        case "P":
          if (opts.WTF) console.log("Skipping " + field.name + ":" + field.type);
          break;
        case "+":
        case "0":
        case "@":
        case "C":
        case "D":
        case "F":
        case "I":
        case "L":
        case "M":
        case "N":
        case "O":
        case "T":
        case "Y":
          break;
        default:
          throw new Error("Unknown Field Type: " + field.type);
      }
    }
    if (d4[d4.l] !== 13) d4.l = fpos - 1;
    if (d4.read_shift(1) !== 13) throw new Error("DBF Terminator not found " + d4.l + " " + d4[d4.l]);
    d4.l = fpos;
    var R3 = 0, C2 = 0;
    out[0] = [];
    for (C2 = 0; C2 != fields.length; ++C2) out[0][C2] = fields[C2].name;
    while (nrow-- > 0) {
      if (d4[d4.l] === 42) {
        d4.l += rlen;
        continue;
      }
      ++d4.l;
      out[++R3] = [];
      C2 = 0;
      for (C2 = 0; C2 != fields.length; ++C2) {
        var dd2 = d4.slice(d4.l, d4.l + fields[C2].len);
        d4.l += fields[C2].len;
        prep_blob(dd2, 0);
        var s4 = $cptable.utils.decode(current_cp, dd2);
        switch (fields[C2].type) {
          case "C":
            if (s4.trim().length) out[R3][C2] = s4.replace(/\s+$/, "");
            break;
          case "D":
            if (s4.length === 8) out[R3][C2] = new Date(+s4.slice(0, 4), +s4.slice(4, 6) - 1, +s4.slice(6, 8));
            else out[R3][C2] = s4;
            break;
          case "F":
            out[R3][C2] = parseFloat(s4.trim());
            break;
          case "+":
          case "I":
            out[R3][C2] = l7 ? dd2.read_shift(-4, "i") ^ 2147483648 : dd2.read_shift(4, "i");
            break;
          case "L":
            switch (s4.trim().toUpperCase()) {
              case "Y":
              case "T":
                out[R3][C2] = true;
                break;
              case "N":
              case "F":
                out[R3][C2] = false;
                break;
              case "":
              case "?":
                break;
              default:
                throw new Error("DBF Unrecognized L:|" + s4 + "|");
            }
            break;
          case "M":
            if (!memo) throw new Error("DBF Unexpected MEMO for type " + ft.toString(16));
            out[R3][C2] = "##MEMO##" + (l7 ? parseInt(s4.trim(), 10) : dd2.read_shift(4));
            break;
          case "N":
            s4 = s4.replace(/\u0000/g, "").trim();
            if (s4 && s4 != ".") out[R3][C2] = +s4 || 0;
            break;
          case "@":
            out[R3][C2] = new Date(dd2.read_shift(-8, "f") - 621356832e5);
            break;
          case "T":
            out[R3][C2] = new Date((dd2.read_shift(4) - 2440588) * 864e5 + dd2.read_shift(4));
            break;
          case "Y":
            out[R3][C2] = dd2.read_shift(4, "i") / 1e4 + dd2.read_shift(4, "i") / 1e4 * Math.pow(2, 32);
            break;
          case "O":
            out[R3][C2] = -dd2.read_shift(-8, "f");
            break;
          case "B":
            if (vfp && fields[C2].len == 8) {
              out[R3][C2] = dd2.read_shift(8, "f");
              break;
            }
          case "G":
          case "P":
            dd2.l += fields[C2].len;
            break;
          case "0":
            if (fields[C2].name === "_NullFlags") break;
          default:
            throw new Error("DBF Unsupported data type " + fields[C2].type);
        }
      }
    }
    if (ft != 2) {
      if (d4.l < d4.length && d4[d4.l++] != 26) throw new Error("DBF EOF Marker missing " + (d4.l - 1) + " of " + d4.length + " " + d4[d4.l - 1].toString(16));
    }
    if (opts && opts.sheetRows) out = out.slice(0, opts.sheetRows);
    opts.DBF = fields;
    return out;
  }
  function dbf_to_sheet(buf, opts) {
    var o2 = opts || {};
    if (!o2.dateNF) o2.dateNF = "yyyymmdd";
    var ws = aoa_to_sheet(dbf_to_aoa(buf, o2), o2);
    ws["!cols"] = o2.DBF.map(function(field) {
      return {
        wch: field.len,
        DBF: field
      };
    });
    delete o2.DBF;
    return ws;
  }
  function dbf_to_workbook(buf, opts) {
    try {
      return sheet_to_workbook(dbf_to_sheet(buf, opts), opts);
    } catch (e3) {
      if (opts && opts.WTF) throw e3;
    }
    return { SheetNames: [], Sheets: {} };
  }
  var _RLEN = { "B": 8, "C": 250, "L": 1, "D": 8, "?": 0, "": 0 };
  function sheet_to_dbf(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write DBF to JS string");
    var ba = buf_array();
    var aoa = sheet_to_json(ws, { header: 1, raw: true, cellDates: true });
    var headers = aoa[0], data = aoa.slice(1), cols = ws["!cols"] || [];
    var i3 = 0, j2 = 0, hcnt = 0, rlen = 1;
    for (i3 = 0; i3 < headers.length; ++i3) {
      if (((cols[i3] || {}).DBF || {}).name) {
        headers[i3] = cols[i3].DBF.name;
        ++hcnt;
        continue;
      }
      if (headers[i3] == null) continue;
      ++hcnt;
      if (typeof headers[i3] === "number") headers[i3] = headers[i3].toString(10);
      if (typeof headers[i3] !== "string") throw new Error("DBF Invalid column name " + headers[i3] + " |" + typeof headers[i3] + "|");
      if (headers.indexOf(headers[i3]) !== i3) {
        for (j2 = 0; j2 < 1024; ++j2)
          if (headers.indexOf(headers[i3] + "_" + j2) == -1) {
            headers[i3] += "_" + j2;
            break;
          }
      }
    }
    var range = safe_decode_range(ws["!ref"]);
    var coltypes = [];
    var colwidths = [];
    var coldecimals = [];
    for (i3 = 0; i3 <= range.e.c - range.s.c; ++i3) {
      var guess = "", _guess = "", maxlen = 0;
      var col = [];
      for (j2 = 0; j2 < data.length; ++j2) {
        if (data[j2][i3] != null) col.push(data[j2][i3]);
      }
      if (col.length == 0 || headers[i3] == null) {
        coltypes[i3] = "?";
        continue;
      }
      for (j2 = 0; j2 < col.length; ++j2) {
        switch (typeof col[j2]) {
          case "number":
            _guess = "B";
            break;
          case "string":
            _guess = "C";
            break;
          case "boolean":
            _guess = "L";
            break;
          case "object":
            _guess = col[j2] instanceof Date ? "D" : "C";
            break;
          default:
            _guess = "C";
        }
        maxlen = Math.max(maxlen, String(col[j2]).length);
        guess = guess && guess != _guess ? "C" : _guess;
      }
      if (maxlen > 250) maxlen = 250;
      _guess = ((cols[i3] || {}).DBF || {}).type;
      if (_guess == "C") {
        if (cols[i3].DBF.len > maxlen) maxlen = cols[i3].DBF.len;
      }
      if (guess == "B" && _guess == "N") {
        guess = "N";
        coldecimals[i3] = cols[i3].DBF.dec;
        maxlen = cols[i3].DBF.len;
      }
      colwidths[i3] = guess == "C" || _guess == "N" ? maxlen : _RLEN[guess] || 0;
      rlen += colwidths[i3];
      coltypes[i3] = guess;
    }
    var h4 = ba.next(32);
    h4.write_shift(4, 318902576);
    h4.write_shift(4, data.length);
    h4.write_shift(2, 296 + 32 * hcnt);
    h4.write_shift(2, rlen);
    for (i3 = 0; i3 < 4; ++i3) h4.write_shift(4, 0);
    h4.write_shift(4, 0 | (+dbf_reverse_map[
      /*::String(*/
      current_ansi
      /*::)*/
    ] || 3) << 8);
    for (i3 = 0, j2 = 0; i3 < headers.length; ++i3) {
      if (headers[i3] == null) continue;
      var hf = ba.next(32);
      var _f = (headers[i3].slice(-10) + "\0\0\0\0\0\0\0\0\0\0\0").slice(0, 11);
      hf.write_shift(1, _f, "sbcs");
      hf.write_shift(1, coltypes[i3] == "?" ? "C" : coltypes[i3], "sbcs");
      hf.write_shift(4, j2);
      hf.write_shift(1, colwidths[i3] || _RLEN[coltypes[i3]] || 0);
      hf.write_shift(1, coldecimals[i3] || 0);
      hf.write_shift(1, 2);
      hf.write_shift(4, 0);
      hf.write_shift(1, 0);
      hf.write_shift(4, 0);
      hf.write_shift(4, 0);
      j2 += colwidths[i3] || _RLEN[coltypes[i3]] || 0;
    }
    var hb2 = ba.next(264);
    hb2.write_shift(4, 13);
    for (i3 = 0; i3 < 65; ++i3) hb2.write_shift(4, 0);
    for (i3 = 0; i3 < data.length; ++i3) {
      var rout = ba.next(rlen);
      rout.write_shift(1, 0);
      for (j2 = 0; j2 < headers.length; ++j2) {
        if (headers[j2] == null) continue;
        switch (coltypes[j2]) {
          case "L":
            rout.write_shift(1, data[i3][j2] == null ? 63 : data[i3][j2] ? 84 : 70);
            break;
          case "B":
            rout.write_shift(8, data[i3][j2] || 0, "f");
            break;
          case "N":
            var _n = "0";
            if (typeof data[i3][j2] == "number") _n = data[i3][j2].toFixed(coldecimals[j2] || 0);
            for (hcnt = 0; hcnt < colwidths[j2] - _n.length; ++hcnt) rout.write_shift(1, 32);
            rout.write_shift(1, _n, "sbcs");
            break;
          case "D":
            if (!data[i3][j2]) rout.write_shift(8, "00000000", "sbcs");
            else {
              rout.write_shift(4, ("0000" + data[i3][j2].getFullYear()).slice(-4), "sbcs");
              rout.write_shift(2, ("00" + (data[i3][j2].getMonth() + 1)).slice(-2), "sbcs");
              rout.write_shift(2, ("00" + data[i3][j2].getDate()).slice(-2), "sbcs");
            }
            break;
          case "C":
            var _s = String(data[i3][j2] != null ? data[i3][j2] : "").slice(0, colwidths[j2]);
            rout.write_shift(1, _s, "sbcs");
            for (hcnt = 0; hcnt < colwidths[j2] - _s.length; ++hcnt) rout.write_shift(1, 32);
            break;
        }
      }
    }
    ba.next(1).write_shift(1, 26);
    return ba.end();
  }
  return {
    to_workbook: dbf_to_workbook,
    to_sheet: dbf_to_sheet,
    from_sheet: sheet_to_dbf
  };
}();
var SYLK = /* @__PURE__ */ function() {
  var sylk_escapes = {
    AA: "À",
    BA: "Á",
    CA: "Â",
    DA: 195,
    HA: "Ä",
    JA: 197,
    AE: "È",
    BE: "É",
    CE: "Ê",
    HE: "Ë",
    AI: "Ì",
    BI: "Í",
    CI: "Î",
    HI: "Ï",
    AO: "Ò",
    BO: "Ó",
    CO: "Ô",
    DO: 213,
    HO: "Ö",
    AU: "Ù",
    BU: "Ú",
    CU: "Û",
    HU: "Ü",
    Aa: "à",
    Ba: "á",
    Ca: "â",
    Da: 227,
    Ha: "ä",
    Ja: 229,
    Ae: "è",
    Be: "é",
    Ce: "ê",
    He: "ë",
    Ai: "ì",
    Bi: "í",
    Ci: "î",
    Hi: "ï",
    Ao: "ò",
    Bo: "ó",
    Co: "ô",
    Do: 245,
    Ho: "ö",
    Au: "ù",
    Bu: "ú",
    Cu: "û",
    Hu: "ü",
    KC: "Ç",
    Kc: "ç",
    q: "æ",
    z: "œ",
    a: "Æ",
    j: "Œ",
    DN: 209,
    Dn: 241,
    Hy: 255,
    S: 169,
    c: 170,
    R: 174,
    "B ": 180,
    /*::[*/
    0: 176,
    /*::[*/
    1: 177,
    /*::[*/
    2: 178,
    /*::[*/
    3: 179,
    /*::[*/
    5: 181,
    /*::[*/
    6: 182,
    /*::[*/
    7: 183,
    Q: 185,
    k: 186,
    b: 208,
    i: 216,
    l: 222,
    s: 240,
    y: 248,
    "!": 161,
    '"': 162,
    "#": 163,
    "(": 164,
    "%": 165,
    "'": 167,
    "H ": 168,
    "+": 171,
    ";": 187,
    "<": 188,
    "=": 189,
    ">": 190,
    "?": 191,
    "{": 223
  };
  var sylk_char_regex = new RegExp("\x1BN(" + keys(sylk_escapes).join("|").replace(/\|\|\|/, "|\\||").replace(/([?()+])/g, "\\$1") + "|\\|)", "gm");
  var sylk_char_fn = function(_2, $1) {
    var o2 = sylk_escapes[$1];
    return typeof o2 == "number" ? _getansi(o2) : o2;
  };
  var decode_sylk_char = function($$, $1, $2) {
    var newcc = $1.charCodeAt(0) - 32 << 4 | $2.charCodeAt(0) - 48;
    return newcc == 59 ? $$ : _getansi(newcc);
  };
  sylk_escapes["|"] = 254;
  function sylk_to_aoa(d4, opts) {
    switch (opts.type) {
      case "base64":
        return sylk_to_aoa_str(Base64_decode(d4), opts);
      case "binary":
        return sylk_to_aoa_str(d4, opts);
      case "buffer":
        return sylk_to_aoa_str(has_buf && Buffer.isBuffer(d4) ? d4.toString("binary") : a2s(d4), opts);
      case "array":
        return sylk_to_aoa_str(cc2str(d4), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function sylk_to_aoa_str(str, opts) {
    var records = str.split(/[\n\r]+/), R3 = -1, C2 = -1, ri2 = 0, rj2 = 0, arr = [];
    var formats = [];
    var next_cell_format = null;
    var sht = {}, rowinfo = [], colinfo = [], cw = [];
    var Mval = 0, j2;
    if (+opts.codepage >= 0) set_cp(+opts.codepage);
    for (; ri2 !== records.length; ++ri2) {
      Mval = 0;
      var rstr = records[ri2].trim().replace(/\x1B([\x20-\x2F])([\x30-\x3F])/g, decode_sylk_char).replace(sylk_char_regex, sylk_char_fn);
      var record = rstr.replace(/;;/g, "\0").split(";").map(function(x3) {
        return x3.replace(/\u0000/g, ";");
      });
      var RT = record[0], val;
      if (rstr.length > 0) switch (RT) {
        case "ID":
          break;
        case "E":
          break;
        case "B":
          break;
        case "O":
          break;
        case "W":
          break;
        case "P":
          if (record[1].charAt(0) == "P")
            formats.push(rstr.slice(3).replace(/;;/g, ";"));
          break;
        case "C":
          var C_seen_K = false, C_seen_X = false, C_seen_S = false, C_seen_E = false, _R = -1, _C = -1;
          for (rj2 = 1; rj2 < record.length; ++rj2) switch (record[rj2].charAt(0)) {
            case "A":
              break;
            case "X":
              C2 = parseInt(record[rj2].slice(1)) - 1;
              C_seen_X = true;
              break;
            case "Y":
              R3 = parseInt(record[rj2].slice(1)) - 1;
              if (!C_seen_X) C2 = 0;
              for (j2 = arr.length; j2 <= R3; ++j2) arr[j2] = [];
              break;
            case "K":
              val = record[rj2].slice(1);
              if (val.charAt(0) === '"') val = val.slice(1, val.length - 1);
              else if (val === "TRUE") val = true;
              else if (val === "FALSE") val = false;
              else if (!isNaN(fuzzynum(val))) {
                val = fuzzynum(val);
                if (next_cell_format !== null && fmt_is_date(next_cell_format)) val = numdate(val);
              } else if (!isNaN(fuzzydate(val).getDate())) {
                val = parseDate(val);
              }
              C_seen_K = true;
              break;
            case "E":
              C_seen_E = true;
              var formula = rc_to_a1(record[rj2].slice(1), { r: R3, c: C2 });
              arr[R3][C2] = [arr[R3][C2], formula];
              break;
            case "S":
              C_seen_S = true;
              arr[R3][C2] = [arr[R3][C2], "S5S"];
              break;
            case "G":
              break;
            case "R":
              _R = parseInt(record[rj2].slice(1)) - 1;
              break;
            case "C":
              _C = parseInt(record[rj2].slice(1)) - 1;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (C_seen_K) {
            if (arr[R3][C2] && arr[R3][C2].length == 2) arr[R3][C2][0] = val;
            else arr[R3][C2] = val;
            next_cell_format = null;
          }
          if (C_seen_S) {
            if (C_seen_E) throw new Error("SYLK shared formula cannot have own formula");
            var shrbase = _R > -1 && arr[_R][_C];
            if (!shrbase || !shrbase[1]) throw new Error("SYLK shared formula cannot find base");
            arr[R3][C2][1] = shift_formula_str(shrbase[1], { r: R3 - _R, c: C2 - _C });
          }
          break;
        case "F":
          var F_seen = 0;
          for (rj2 = 1; rj2 < record.length; ++rj2) switch (record[rj2].charAt(0)) {
            case "X":
              C2 = parseInt(record[rj2].slice(1)) - 1;
              ++F_seen;
              break;
            case "Y":
              R3 = parseInt(record[rj2].slice(1)) - 1;
              for (j2 = arr.length; j2 <= R3; ++j2) arr[j2] = [];
              break;
            case "M":
              Mval = parseInt(record[rj2].slice(1)) / 20;
              break;
            case "F":
              break;
            case "G":
              break;
            case "P":
              next_cell_format = formats[parseInt(record[rj2].slice(1))];
              break;
            case "S":
              break;
            case "D":
              break;
            case "N":
              break;
            case "W":
              cw = record[rj2].slice(1).split(" ");
              for (j2 = parseInt(cw[0], 10); j2 <= parseInt(cw[1], 10); ++j2) {
                Mval = parseInt(cw[2], 10);
                colinfo[j2 - 1] = Mval === 0 ? { hidden: true } : { wch: Mval };
                process_col(colinfo[j2 - 1]);
              }
              break;
            case "C":
              C2 = parseInt(record[rj2].slice(1)) - 1;
              if (!colinfo[C2]) colinfo[C2] = {};
              break;
            case "R":
              R3 = parseInt(record[rj2].slice(1)) - 1;
              if (!rowinfo[R3]) rowinfo[R3] = {};
              if (Mval > 0) {
                rowinfo[R3].hpt = Mval;
                rowinfo[R3].hpx = pt2px(Mval);
              } else if (Mval === 0) rowinfo[R3].hidden = true;
              break;
            default:
              if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
          }
          if (F_seen < 1) next_cell_format = null;
          break;
        default:
          if (opts && opts.WTF) throw new Error("SYLK bad record " + rstr);
      }
    }
    if (rowinfo.length > 0) sht["!rows"] = rowinfo;
    if (colinfo.length > 0) sht["!cols"] = colinfo;
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return [arr, sht];
  }
  function sylk_to_sheet(d4, opts) {
    var aoasht = sylk_to_aoa(d4, opts);
    var aoa = aoasht[0], ws = aoasht[1];
    var o2 = aoa_to_sheet(aoa, opts);
    keys(ws).forEach(function(k3) {
      o2[k3] = ws[k3];
    });
    return o2;
  }
  function sylk_to_workbook(d4, opts) {
    return sheet_to_workbook(sylk_to_sheet(d4, opts), opts);
  }
  function write_ws_cell_sylk(cell, ws, R3, C2) {
    var o2 = "C;Y" + (R3 + 1) + ";X" + (C2 + 1) + ";K";
    switch (cell.t) {
      case "n":
        o2 += cell.v || 0;
        if (cell.f && !cell.F) o2 += ";E" + a1_to_rc(cell.f, { r: R3, c: C2 });
        break;
      case "b":
        o2 += cell.v ? "TRUE" : "FALSE";
        break;
      case "e":
        o2 += cell.w || cell.v;
        break;
      case "d":
        o2 += '"' + (cell.w || cell.v) + '"';
        break;
      case "s":
        o2 += '"' + cell.v.replace(/"/g, "").replace(/;/g, ";;") + '"';
        break;
    }
    return o2;
  }
  function write_ws_cols_sylk(out, cols) {
    cols.forEach(function(col, i3) {
      var rec = "F;W" + (i3 + 1) + " " + (i3 + 1) + " ";
      if (col.hidden) rec += "0";
      else {
        if (typeof col.width == "number" && !col.wpx) col.wpx = width2px(col.width);
        if (typeof col.wpx == "number" && !col.wch) col.wch = px2char(col.wpx);
        if (typeof col.wch == "number") rec += Math.round(col.wch);
      }
      if (rec.charAt(rec.length - 1) != " ") out.push(rec);
    });
  }
  function write_ws_rows_sylk(out, rows) {
    rows.forEach(function(row, i3) {
      var rec = "F;";
      if (row.hidden) rec += "M0;";
      else if (row.hpt) rec += "M" + 20 * row.hpt + ";";
      else if (row.hpx) rec += "M" + 20 * px2pt(row.hpx) + ";";
      if (rec.length > 2) out.push(rec + "R" + (i3 + 1));
    });
  }
  function sheet_to_sylk(ws, opts) {
    var preamble = ["ID;PWXL;N;E"], o2 = [];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    var RS = "\r\n";
    preamble.push("P;PGeneral");
    preamble.push("F;P0;DG0G8;M255");
    if (ws["!cols"]) write_ws_cols_sylk(preamble, ws["!cols"]);
    if (ws["!rows"]) write_ws_rows_sylk(preamble, ws["!rows"]);
    preamble.push("B;Y" + (r2.e.r - r2.s.r + 1) + ";X" + (r2.e.c - r2.s.c + 1) + ";D" + [r2.s.c, r2.s.r, r2.e.c, r2.e.r].join(" "));
    for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R3, c: C2 });
        cell = dense ? (ws[R3] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
        o2.push(write_ws_cell_sylk(cell, ws, R3, C2));
      }
    }
    return preamble.join(RS) + RS + o2.join(RS) + RS + "E" + RS;
  }
  return {
    to_workbook: sylk_to_workbook,
    to_sheet: sylk_to_sheet,
    from_sheet: sheet_to_sylk
  };
}();
var DIF = /* @__PURE__ */ function() {
  function dif_to_aoa(d4, opts) {
    switch (opts.type) {
      case "base64":
        return dif_to_aoa_str(Base64_decode(d4), opts);
      case "binary":
        return dif_to_aoa_str(d4, opts);
      case "buffer":
        return dif_to_aoa_str(has_buf && Buffer.isBuffer(d4) ? d4.toString("binary") : a2s(d4), opts);
      case "array":
        return dif_to_aoa_str(cc2str(d4), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function dif_to_aoa_str(str, opts) {
    var records = str.split("\n"), R3 = -1, C2 = -1, ri2 = 0, arr = [];
    for (; ri2 !== records.length; ++ri2) {
      if (records[ri2].trim() === "BOT") {
        arr[++R3] = [];
        C2 = 0;
        continue;
      }
      if (R3 < 0) continue;
      var metadata = records[ri2].trim().split(",");
      var type = metadata[0], value = metadata[1];
      ++ri2;
      var data = records[ri2] || "";
      while ((data.match(/["]/g) || []).length & 1 && ri2 < records.length - 1) data += "\n" + records[++ri2];
      data = data.trim();
      switch (+type) {
        case -1:
          if (data === "BOT") {
            arr[++R3] = [];
            C2 = 0;
            continue;
          } else if (data !== "EOD") throw new Error("Unrecognized DIF special command " + data);
          break;
        case 0:
          if (data === "TRUE") arr[R3][C2] = true;
          else if (data === "FALSE") arr[R3][C2] = false;
          else if (!isNaN(fuzzynum(value))) arr[R3][C2] = fuzzynum(value);
          else if (!isNaN(fuzzydate(value).getDate())) arr[R3][C2] = parseDate(value);
          else arr[R3][C2] = value;
          ++C2;
          break;
        case 1:
          data = data.slice(1, data.length - 1);
          data = data.replace(/""/g, '"');
          if (data && data.match(/^=".*"$/)) data = data.slice(2, -1);
          arr[R3][C2++] = data !== "" ? data : null;
          break;
      }
      if (data === "EOD") break;
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function dif_to_sheet(str, opts) {
    return aoa_to_sheet(dif_to_aoa(str, opts), opts);
  }
  function dif_to_workbook(str, opts) {
    return sheet_to_workbook(dif_to_sheet(str, opts), opts);
  }
  var sheet_to_dif = /* @__PURE__ */ function() {
    var push_field = function pf2(o2, topic, v2, n2, s4) {
      o2.push(topic);
      o2.push(v2 + "," + n2);
      o2.push('"' + s4.replace(/"/g, '""') + '"');
    };
    var push_value = function po(o2, type, v2, s4) {
      o2.push(type + "," + v2);
      o2.push(type == 1 ? '"' + s4.replace(/"/g, '""') + '"' : s4);
    };
    return function sheet_to_dif2(ws) {
      var o2 = [];
      var r2 = safe_decode_range(ws["!ref"]), cell;
      var dense = Array.isArray(ws);
      push_field(o2, "TABLE", 0, 1, "sheetjs");
      push_field(o2, "VECTORS", 0, r2.e.r - r2.s.r + 1, "");
      push_field(o2, "TUPLES", 0, r2.e.c - r2.s.c + 1, "");
      push_field(o2, "DATA", 0, 0, "");
      for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
        push_value(o2, -1, 0, "BOT");
        for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
          var coord = encode_cell({ r: R3, c: C2 });
          cell = dense ? (ws[R3] || [])[C2] : ws[coord];
          if (!cell) {
            push_value(o2, 1, 0, "");
            continue;
          }
          switch (cell.t) {
            case "n":
              var val = cell.w;
              if (!val && cell.v != null) val = cell.v;
              if (val == null) {
                if (cell.f && !cell.F) push_value(o2, 1, 0, "=" + cell.f);
                else push_value(o2, 1, 0, "");
              } else push_value(o2, 0, val, "V");
              break;
            case "b":
              push_value(o2, 0, cell.v ? 1 : 0, cell.v ? "TRUE" : "FALSE");
              break;
            case "s":
              push_value(o2, 1, 0, isNaN(cell.v) ? cell.v : '="' + cell.v + '"');
              break;
            case "d":
              if (!cell.w) cell.w = SSF_format(cell.z || table_fmt[14], datenum(parseDate(cell.v)));
              push_value(o2, 0, cell.w, "V");
              break;
            default:
              push_value(o2, 1, 0, "");
          }
        }
      }
      push_value(o2, -1, 0, "EOD");
      var RS = "\r\n";
      var oo = o2.join(RS);
      return oo;
    };
  }();
  return {
    to_workbook: dif_to_workbook,
    to_sheet: dif_to_sheet,
    from_sheet: sheet_to_dif
  };
}();
var ETH = /* @__PURE__ */ function() {
  function decode(s4) {
    return s4.replace(/\\b/g, "\\").replace(/\\c/g, ":").replace(/\\n/g, "\n");
  }
  function encode(s4) {
    return s4.replace(/\\/g, "\\b").replace(/:/g, "\\c").replace(/\n/g, "\\n");
  }
  function eth_to_aoa(str, opts) {
    var records = str.split("\n"), R3 = -1, C2 = -1, ri2 = 0, arr = [];
    for (; ri2 !== records.length; ++ri2) {
      var record = records[ri2].trim().split(":");
      if (record[0] !== "cell") continue;
      var addr = decode_cell(record[1]);
      if (arr.length <= addr.r) {
        for (R3 = arr.length; R3 <= addr.r; ++R3) if (!arr[R3]) arr[R3] = [];
      }
      R3 = addr.r;
      C2 = addr.c;
      switch (record[2]) {
        case "t":
          arr[R3][C2] = decode(record[3]);
          break;
        case "v":
          arr[R3][C2] = +record[3];
          break;
        case "vtf":
          var _f = record[record.length - 1];
        case "vtc":
          switch (record[3]) {
            case "nl":
              arr[R3][C2] = +record[4] ? true : false;
              break;
            default:
              arr[R3][C2] = +record[4];
              break;
          }
          if (record[2] == "vtf") arr[R3][C2] = [arr[R3][C2], _f];
      }
    }
    if (opts && opts.sheetRows) arr = arr.slice(0, opts.sheetRows);
    return arr;
  }
  function eth_to_sheet(d4, opts) {
    return aoa_to_sheet(eth_to_aoa(d4, opts), opts);
  }
  function eth_to_workbook(d4, opts) {
    return sheet_to_workbook(eth_to_sheet(d4, opts), opts);
  }
  var header = [
    "socialcalc:version:1.5",
    "MIME-Version: 1.0",
    "Content-Type: multipart/mixed; boundary=SocialCalcSpreadsheetControlSave"
  ].join("\n");
  var sep = [
    "--SocialCalcSpreadsheetControlSave",
    "Content-type: text/plain; charset=UTF-8"
  ].join("\n") + "\n";
  var meta = [
    "# SocialCalc Spreadsheet Control Save",
    "part:sheet"
  ].join("\n");
  var end = "--SocialCalcSpreadsheetControlSave--";
  function sheet_to_eth_data(ws) {
    if (!ws || !ws["!ref"]) return "";
    var o2 = [], oo = [], cell, coord = "";
    var r2 = decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        coord = encode_cell({ r: R3, c: C2 });
        cell = dense ? (ws[R3] || [])[C2] : ws[coord];
        if (!cell || cell.v == null || cell.t === "z") continue;
        oo = ["cell", coord, "t"];
        switch (cell.t) {
          case "s":
          case "str":
            oo.push(encode(cell.v));
            break;
          case "n":
            if (!cell.f) {
              oo[2] = "v";
              oo[3] = cell.v;
            } else {
              oo[2] = "vtf";
              oo[3] = "n";
              oo[4] = cell.v;
              oo[5] = encode(cell.f);
            }
            break;
          case "b":
            oo[2] = "vt" + (cell.f ? "f" : "c");
            oo[3] = "nl";
            oo[4] = cell.v ? "1" : "0";
            oo[5] = encode(cell.f || (cell.v ? "TRUE" : "FALSE"));
            break;
          case "d":
            var t3 = datenum(parseDate(cell.v));
            oo[2] = "vtc";
            oo[3] = "nd";
            oo[4] = "" + t3;
            oo[5] = cell.w || SSF_format(cell.z || table_fmt[14], t3);
            break;
          case "e":
            continue;
        }
        o2.push(oo.join(":"));
      }
    }
    o2.push("sheet:c:" + (r2.e.c - r2.s.c + 1) + ":r:" + (r2.e.r - r2.s.r + 1) + ":tvf:1");
    o2.push("valueformat:1:text-wiki");
    return o2.join("\n");
  }
  function sheet_to_eth(ws) {
    return [header, sep, meta, sep, sheet_to_eth_data(ws), end].join("\n");
  }
  return {
    to_workbook: eth_to_workbook,
    to_sheet: eth_to_sheet,
    from_sheet: sheet_to_eth
  };
}();
var PRN = /* @__PURE__ */ function() {
  function set_text_arr(data, arr, R3, C2, o2) {
    if (o2.raw) arr[R3][C2] = data;
    else if (data === "") ;
    else if (data === "TRUE") arr[R3][C2] = true;
    else if (data === "FALSE") arr[R3][C2] = false;
    else if (!isNaN(fuzzynum(data))) arr[R3][C2] = fuzzynum(data);
    else if (!isNaN(fuzzydate(data).getDate())) arr[R3][C2] = parseDate(data);
    else arr[R3][C2] = data;
  }
  function prn_to_aoa_str(f2, opts) {
    var o2 = opts || {};
    var arr = [];
    if (!f2 || f2.length === 0) return arr;
    var lines = f2.split(/[\r\n]/);
    var L3 = lines.length - 1;
    while (L3 >= 0 && lines[L3].length === 0) --L3;
    var start = 10, idx = 0;
    var R3 = 0;
    for (; R3 <= L3; ++R3) {
      idx = lines[R3].indexOf(" ");
      if (idx == -1) idx = lines[R3].length;
      else idx++;
      start = Math.max(start, idx);
    }
    for (R3 = 0; R3 <= L3; ++R3) {
      arr[R3] = [];
      var C2 = 0;
      set_text_arr(lines[R3].slice(0, start).trim(), arr, R3, C2, o2);
      for (C2 = 1; C2 <= (lines[R3].length - start) / 10 + 1; ++C2)
        set_text_arr(lines[R3].slice(start + (C2 - 1) * 10, start + C2 * 10).trim(), arr, R3, C2, o2);
    }
    if (o2.sheetRows) arr = arr.slice(0, o2.sheetRows);
    return arr;
  }
  var guess_seps = {
    /*::[*/
    44: ",",
    /*::[*/
    9: "	",
    /*::[*/
    59: ";",
    /*::[*/
    124: "|"
  };
  var guess_sep_weights = {
    /*::[*/
    44: 3,
    /*::[*/
    9: 2,
    /*::[*/
    59: 1,
    /*::[*/
    124: 0
  };
  function guess_sep(str) {
    var cnt = {}, instr = false, end = 0, cc2 = 0;
    for (; end < str.length; ++end) {
      if ((cc2 = str.charCodeAt(end)) == 34) instr = !instr;
      else if (!instr && cc2 in guess_seps) cnt[cc2] = (cnt[cc2] || 0) + 1;
    }
    cc2 = [];
    for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
      cc2.push([cnt[end], end]);
    }
    if (!cc2.length) {
      cnt = guess_sep_weights;
      for (end in cnt) if (Object.prototype.hasOwnProperty.call(cnt, end)) {
        cc2.push([cnt[end], end]);
      }
    }
    cc2.sort(function(a4, b2) {
      return a4[0] - b2[0] || guess_sep_weights[a4[1]] - guess_sep_weights[b2[1]];
    });
    return guess_seps[cc2.pop()[1]] || 44;
  }
  function dsv_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var sep = "";
    var ws = o2.dense ? [] : {};
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (str.slice(0, 4) == "sep=") {
      if (str.charCodeAt(5) == 13 && str.charCodeAt(6) == 10) {
        sep = str.charAt(4);
        str = str.slice(7);
      } else if (str.charCodeAt(5) == 13 || str.charCodeAt(5) == 10) {
        sep = str.charAt(4);
        str = str.slice(6);
      } else sep = guess_sep(str.slice(0, 1024));
    } else if (o2 && o2.FS) sep = o2.FS;
    else sep = guess_sep(str.slice(0, 1024));
    var R3 = 0, C2 = 0, v2 = 0;
    var start = 0, end = 0, sepcc = sep.charCodeAt(0), instr = false, cc2 = 0, startcc = str.charCodeAt(0);
    str = str.replace(/\r\n/mg, "\n");
    var _re = o2.dateNF != null ? dateNF_regex(o2.dateNF) : null;
    function finish_cell() {
      var s4 = str.slice(start, end);
      var cell = {};
      if (s4.charAt(0) == '"' && s4.charAt(s4.length - 1) == '"') s4 = s4.slice(1, -1).replace(/""/g, '"');
      if (s4.length === 0) cell.t = "z";
      else if (o2.raw) {
        cell.t = "s";
        cell.v = s4;
      } else if (s4.trim().length === 0) {
        cell.t = "s";
        cell.v = s4;
      } else if (s4.charCodeAt(0) == 61) {
        if (s4.charCodeAt(1) == 34 && s4.charCodeAt(s4.length - 1) == 34) {
          cell.t = "s";
          cell.v = s4.slice(2, -1).replace(/""/g, '"');
        } else if (fuzzyfmla(s4)) {
          cell.t = "n";
          cell.f = s4.slice(1);
        } else {
          cell.t = "s";
          cell.v = s4;
        }
      } else if (s4 == "TRUE") {
        cell.t = "b";
        cell.v = true;
      } else if (s4 == "FALSE") {
        cell.t = "b";
        cell.v = false;
      } else if (!isNaN(v2 = fuzzynum(s4))) {
        cell.t = "n";
        if (o2.cellText !== false) cell.w = s4;
        cell.v = v2;
      } else if (!isNaN(fuzzydate(s4).getDate()) || _re && s4.match(_re)) {
        cell.z = o2.dateNF || table_fmt[14];
        var k3 = 0;
        if (_re && s4.match(_re)) {
          s4 = dateNF_fix(s4, o2.dateNF, s4.match(_re) || []);
          k3 = 1;
        }
        if (o2.cellDates) {
          cell.t = "d";
          cell.v = parseDate(s4, k3);
        } else {
          cell.t = "n";
          cell.v = datenum(parseDate(s4, k3));
        }
        if (o2.cellText !== false) cell.w = SSF_format(cell.z, cell.v instanceof Date ? datenum(cell.v) : cell.v);
        if (!o2.cellNF) delete cell.z;
      } else {
        cell.t = "s";
        cell.v = s4;
      }
      if (cell.t == "z") ;
      else if (o2.dense) {
        if (!ws[R3]) ws[R3] = [];
        ws[R3][C2] = cell;
      } else ws[encode_cell({ c: C2, r: R3 })] = cell;
      start = end + 1;
      startcc = str.charCodeAt(start);
      if (range.e.c < C2) range.e.c = C2;
      if (range.e.r < R3) range.e.r = R3;
      if (cc2 == sepcc) ++C2;
      else {
        C2 = 0;
        ++R3;
        if (o2.sheetRows && o2.sheetRows <= R3) return true;
      }
    }
    outer: for (; end < str.length; ++end) switch (cc2 = str.charCodeAt(end)) {
      case 34:
        if (startcc === 34) instr = !instr;
        break;
      case sepcc:
      case 10:
      case 13:
        if (!instr && finish_cell()) break outer;
        break;
    }
    if (end - start > 0) finish_cell();
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function prn_to_sheet_str(str, opts) {
    if (!(opts && opts.PRN)) return dsv_to_sheet_str(str, opts);
    if (opts.FS) return dsv_to_sheet_str(str, opts);
    if (str.slice(0, 4) == "sep=") return dsv_to_sheet_str(str, opts);
    if (str.indexOf("	") >= 0 || str.indexOf(",") >= 0 || str.indexOf(";") >= 0) return dsv_to_sheet_str(str, opts);
    return aoa_to_sheet(prn_to_aoa_str(str, opts), opts);
  }
  function prn_to_sheet(d4, opts) {
    var str = "", bytes = opts.type == "string" ? [0, 0, 0, 0] : firstbyte(d4, opts);
    switch (opts.type) {
      case "base64":
        str = Base64_decode(d4);
        break;
      case "binary":
        str = d4;
        break;
      case "buffer":
        if (opts.codepage == 65001) str = d4.toString("utf8");
        else if (opts.codepage && false) ;
        else str = has_buf && Buffer.isBuffer(d4) ? d4.toString("binary") : a2s(d4);
        break;
      case "array":
        str = cc2str(d4);
        break;
      case "string":
        str = d4;
        break;
      default:
        throw new Error("Unrecognized type " + opts.type);
    }
    if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str.slice(3));
    else if (opts.type != "string" && opts.type != "buffer" && opts.codepage == 65001) str = utf8read(str);
    else if (opts.type == "binary" && false) ;
    if (str.slice(0, 19) == "socialcalc:version:") return ETH.to_sheet(opts.type == "string" ? str : utf8read(str), opts);
    return prn_to_sheet_str(str, opts);
  }
  function prn_to_workbook(d4, opts) {
    return sheet_to_workbook(prn_to_sheet(d4, opts), opts);
  }
  function sheet_to_prn(ws) {
    var o2 = [];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
      var oo = [];
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R3, c: C2 });
        cell = dense ? (ws[R3] || [])[C2] : ws[coord];
        if (!cell || cell.v == null) {
          oo.push("          ");
          continue;
        }
        var w3 = (cell.w || (format_cell(cell), cell.w) || "").slice(0, 10);
        while (w3.length < 10) w3 += " ";
        oo.push(w3 + (C2 === 0 ? " " : ""));
      }
      o2.push(oo.join(""));
    }
    return o2.join("\n");
  }
  return {
    to_workbook: prn_to_workbook,
    to_sheet: prn_to_sheet,
    from_sheet: sheet_to_prn
  };
}();
function read_wb_ID(d4, opts) {
  var o2 = opts || {}, OLD_WTF = !!o2.WTF;
  o2.WTF = true;
  try {
    var out = SYLK.to_workbook(d4, o2);
    o2.WTF = OLD_WTF;
    return out;
  } catch (e3) {
    o2.WTF = OLD_WTF;
    if (!e3.message.match(/SYLK bad record ID/) && OLD_WTF) throw e3;
    return PRN.to_workbook(d4, opts);
  }
}
var WK_ = /* @__PURE__ */ function() {
  function lotushopper(data, cb2, opts) {
    if (!data) return;
    prep_blob(data, data.l || 0);
    var Enum = opts.Enum || WK1Enum;
    while (data.l < data.length) {
      var RT = data.read_shift(2);
      var R3 = Enum[RT] || Enum[65535];
      var length = data.read_shift(2);
      var tgt = data.l + length;
      var d4 = R3.f && R3.f(data, length, opts);
      data.l = tgt;
      if (cb2(d4, R3, RT)) return;
    }
  }
  function lotus_to_workbook(d4, opts) {
    switch (opts.type) {
      case "base64":
        return lotus_to_workbook_buf(s2a(Base64_decode(d4)), opts);
      case "binary":
        return lotus_to_workbook_buf(s2a(d4), opts);
      case "buffer":
      case "array":
        return lotus_to_workbook_buf(d4, opts);
    }
    throw "Unsupported type " + opts.type;
  }
  function lotus_to_workbook_buf(d4, opts) {
    if (!d4) return d4;
    var o2 = opts || {};
    var s4 = o2.dense ? [] : {}, n2 = "Sheet1", next_n = "", sidx = 0;
    var sheets = {}, snames = [], realnames = [];
    var refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    var sheetRows = o2.sheetRows || 0;
    if (d4[2] == 0) {
      if (d4[3] == 8 || d4[3] == 9) {
        if (d4.length >= 16 && d4[14] == 5 && d4[15] === 108) throw new Error("Unsupported Works 3 for Mac file");
      }
    }
    if (d4[2] == 2) {
      o2.Enum = WK1Enum;
      lotushopper(d4, function(val, R3, RT) {
        switch (RT) {
          case 0:
            o2.vers = val;
            if (val >= 4096) o2.qpro = true;
            break;
          case 6:
            refguess = val;
            break;
          case 204:
            if (val) next_n = val;
            break;
          case 222:
            next_n = val;
            break;
          case 15:
          case 51:
            if (!o2.qpro) val[1].v = val[1].v.slice(1);
          case 13:
          case 14:
          case 16:
            if (RT == 14 && (val[2] & 112) == 112 && (val[2] & 15) > 1 && (val[2] & 15) < 15) {
              val[1].z = o2.dateNF || table_fmt[14];
              if (o2.cellDates) {
                val[1].t = "d";
                val[1].v = numdate(val[1].v);
              }
            }
            if (o2.qpro) {
              if (val[3] > sidx) {
                s4["!ref"] = encode_range(refguess);
                sheets[n2] = s4;
                snames.push(n2);
                s4 = o2.dense ? [] : {};
                refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
                sidx = val[3];
                n2 = next_n || "Sheet" + (sidx + 1);
                next_n = "";
              }
            }
            var tmpcell = o2.dense ? (s4[val[0].r] || [])[val[0].c] : s4[encode_cell(val[0])];
            if (tmpcell) {
              tmpcell.t = val[1].t;
              tmpcell.v = val[1].v;
              if (val[1].z != null) tmpcell.z = val[1].z;
              if (val[1].f != null) tmpcell.f = val[1].f;
              break;
            }
            if (o2.dense) {
              if (!s4[val[0].r]) s4[val[0].r] = [];
              s4[val[0].r][val[0].c] = val[1];
            } else s4[encode_cell(val[0])] = val[1];
            break;
        }
      }, o2);
    } else if (d4[2] == 26 || d4[2] == 14) {
      o2.Enum = WK3Enum;
      if (d4[2] == 14) {
        o2.qpro = true;
        d4.l = 0;
      }
      lotushopper(d4, function(val, R3, RT) {
        switch (RT) {
          case 204:
            n2 = val;
            break;
          case 22:
            val[1].v = val[1].v.slice(1);
          case 23:
          case 24:
          case 25:
          case 37:
          case 39:
          case 40:
            if (val[3] > sidx) {
              s4["!ref"] = encode_range(refguess);
              sheets[n2] = s4;
              snames.push(n2);
              s4 = o2.dense ? [] : {};
              refguess = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              sidx = val[3];
              n2 = "Sheet" + (sidx + 1);
            }
            if (sheetRows > 0 && val[0].r >= sheetRows) break;
            if (o2.dense) {
              if (!s4[val[0].r]) s4[val[0].r] = [];
              s4[val[0].r][val[0].c] = val[1];
            } else s4[encode_cell(val[0])] = val[1];
            if (refguess.e.c < val[0].c) refguess.e.c = val[0].c;
            if (refguess.e.r < val[0].r) refguess.e.r = val[0].r;
            break;
          case 27:
            if (val[14e3]) realnames[val[14e3][0]] = val[14e3][1];
            break;
          case 1537:
            realnames[val[0]] = val[1];
            if (val[0] == sidx) n2 = val[1];
            break;
        }
      }, o2);
    } else throw new Error("Unrecognized LOTUS BOF " + d4[2]);
    s4["!ref"] = encode_range(refguess);
    sheets[next_n || n2] = s4;
    snames.push(next_n || n2);
    if (!realnames.length) return { SheetNames: snames, Sheets: sheets };
    var osheets = {}, rnames = [];
    for (var i3 = 0; i3 < realnames.length; ++i3) if (sheets[snames[i3]]) {
      rnames.push(realnames[i3] || snames[i3]);
      osheets[realnames[i3]] = sheets[realnames[i3]] || sheets[snames[i3]];
    } else {
      rnames.push(realnames[i3]);
      osheets[realnames[i3]] = { "!ref": "A1" };
    }
    return { SheetNames: rnames, Sheets: osheets };
  }
  function sheet_to_wk1(ws, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write WK1 to JS string");
    var ba = buf_array();
    var range = safe_decode_range(ws["!ref"]);
    var dense = Array.isArray(ws);
    var cols = [];
    write_biff_rec(ba, 0, write_BOF_WK1(1030));
    write_biff_rec(ba, 6, write_RANGE(range));
    var max_R = Math.min(range.e.r, 8191);
    for (var R3 = range.s.r; R3 <= max_R; ++R3) {
      var rr = encode_row(R3);
      for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
        if (R3 === range.s.r) cols[C2] = encode_col(C2);
        var ref = cols[C2] + rr;
        var cell = dense ? (ws[R3] || [])[C2] : ws[ref];
        if (!cell || cell.t == "z") continue;
        if (cell.t == "n") {
          if ((cell.v | 0) == cell.v && cell.v >= -32768 && cell.v <= 32767) write_biff_rec(ba, 13, write_INTEGER(R3, C2, cell.v));
          else write_biff_rec(ba, 14, write_NUMBER(R3, C2, cell.v));
        } else {
          var str = format_cell(cell);
          write_biff_rec(ba, 15, write_LABEL(R3, C2, str.slice(0, 239)));
        }
      }
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function book_to_wk3(wb2, opts) {
    var o2 = opts || {};
    if (+o2.codepage >= 0) set_cp(+o2.codepage);
    if (o2.type == "string") throw new Error("Cannot write WK3 to JS string");
    var ba = buf_array();
    write_biff_rec(ba, 0, write_BOF_WK3(wb2));
    for (var i3 = 0, cnt = 0; i3 < wb2.SheetNames.length; ++i3) if ((wb2.Sheets[wb2.SheetNames[i3]] || {})["!ref"]) write_biff_rec(ba, 27, write_XFORMAT_SHEETNAME(wb2.SheetNames[i3], cnt++));
    var wsidx = 0;
    for (i3 = 0; i3 < wb2.SheetNames.length; ++i3) {
      var ws = wb2.Sheets[wb2.SheetNames[i3]];
      if (!ws || !ws["!ref"]) continue;
      var range = safe_decode_range(ws["!ref"]);
      var dense = Array.isArray(ws);
      var cols = [];
      var max_R = Math.min(range.e.r, 8191);
      for (var R3 = range.s.r; R3 <= max_R; ++R3) {
        var rr = encode_row(R3);
        for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
          if (R3 === range.s.r) cols[C2] = encode_col(C2);
          var ref = cols[C2] + rr;
          var cell = dense ? (ws[R3] || [])[C2] : ws[ref];
          if (!cell || cell.t == "z") continue;
          if (cell.t == "n") {
            write_biff_rec(ba, 23, write_NUMBER_17(R3, C2, wsidx, cell.v));
          } else {
            var str = format_cell(cell);
            write_biff_rec(ba, 22, write_LABEL_16(R3, C2, wsidx, str.slice(0, 239)));
          }
        }
      }
      ++wsidx;
    }
    write_biff_rec(ba, 1);
    return ba.end();
  }
  function write_BOF_WK1(v2) {
    var out = new_buf(2);
    out.write_shift(2, v2);
    return out;
  }
  function write_BOF_WK3(wb2) {
    var out = new_buf(26);
    out.write_shift(2, 4096);
    out.write_shift(2, 4);
    out.write_shift(4, 0);
    var rows = 0, cols = 0, wscnt = 0;
    for (var i3 = 0; i3 < wb2.SheetNames.length; ++i3) {
      var name = wb2.SheetNames[i3];
      var ws = wb2.Sheets[name];
      if (!ws || !ws["!ref"]) continue;
      ++wscnt;
      var range = decode_range(ws["!ref"]);
      if (rows < range.e.r) rows = range.e.r;
      if (cols < range.e.c) cols = range.e.c;
    }
    if (rows > 8191) rows = 8191;
    out.write_shift(2, rows);
    out.write_shift(1, wscnt);
    out.write_shift(1, cols);
    out.write_shift(2, 0);
    out.write_shift(2, 0);
    out.write_shift(1, 1);
    out.write_shift(1, 2);
    out.write_shift(4, 0);
    out.write_shift(4, 0);
    return out;
  }
  function parse_RANGE(blob, length, opts) {
    var o2 = { s: { c: 0, r: 0 }, e: { c: 0, r: 0 } };
    if (length == 8 && opts.qpro) {
      o2.s.c = blob.read_shift(1);
      blob.l++;
      o2.s.r = blob.read_shift(2);
      o2.e.c = blob.read_shift(1);
      blob.l++;
      o2.e.r = blob.read_shift(2);
      return o2;
    }
    o2.s.c = blob.read_shift(2);
    o2.s.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    o2.e.c = blob.read_shift(2);
    o2.e.r = blob.read_shift(2);
    if (length == 12 && opts.qpro) blob.l += 2;
    if (o2.s.c == 65535) o2.s.c = o2.e.c = o2.s.r = o2.e.r = 0;
    return o2;
  }
  function write_RANGE(range) {
    var out = new_buf(8);
    out.write_shift(2, range.s.c);
    out.write_shift(2, range.s.r);
    out.write_shift(2, range.e.c);
    out.write_shift(2, range.e.r);
    return out;
  }
  function parse_cell(blob, length, opts) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0, 0];
    if (opts.qpro && opts.vers != 20768) {
      o2[0].c = blob.read_shift(1);
      o2[3] = blob.read_shift(1);
      o2[0].r = blob.read_shift(2);
      blob.l += 2;
    } else {
      o2[2] = blob.read_shift(1);
      o2[0].c = blob.read_shift(2);
      o2[0].r = blob.read_shift(2);
    }
    return o2;
  }
  function parse_LABEL(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].t = "s";
    if (opts.vers == 20768) {
      blob.l++;
      var len = blob.read_shift(1);
      o2[1].v = blob.read_shift(len, "utf8");
      return o2;
    }
    if (opts.qpro) blob.l++;
    o2[1].v = blob.read_shift(tgt - blob.l, "cstr");
    return o2;
  }
  function write_LABEL(R3, C2, s4) {
    var o2 = new_buf(7 + s4.length);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R3);
    o2.write_shift(1, 39);
    for (var i3 = 0; i3 < o2.length; ++i3) {
      var cc2 = s4.charCodeAt(i3);
      o2.write_shift(1, cc2 >= 128 ? 95 : cc2);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  function parse_INTEGER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(2, "i");
    return o2;
  }
  function write_INTEGER(R3, C2, v2) {
    var o2 = new_buf(7);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R3);
    o2.write_shift(2, v2, "i");
    return o2;
  }
  function parse_NUMBER(blob, length, opts) {
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    return o2;
  }
  function write_NUMBER(R3, C2, v2) {
    var o2 = new_buf(13);
    o2.write_shift(1, 255);
    o2.write_shift(2, C2);
    o2.write_shift(2, R3);
    o2.write_shift(8, v2, "f");
    return o2;
  }
  function parse_FORMULA(blob, length, opts) {
    var tgt = blob.l + length;
    var o2 = parse_cell(blob, length, opts);
    o2[1].v = blob.read_shift(8, "f");
    if (opts.qpro) blob.l = tgt;
    else {
      var flen = blob.read_shift(2);
      wk1_fmla_to_csf(blob.slice(blob.l, blob.l + flen), o2);
      blob.l += flen;
    }
    return o2;
  }
  function wk1_parse_rc(B3, V2, col) {
    var rel = V2 & 32768;
    V2 &= -32769;
    V2 = (rel ? B3 : 0) + (V2 >= 8192 ? V2 - 16384 : V2);
    return (rel ? "" : "$") + (col ? encode_col(V2) : encode_row(V2));
  }
  var FuncTab = {
    51: ["FALSE", 0],
    52: ["TRUE", 0],
    70: ["LEN", 1],
    80: ["SUM", 69],
    81: ["AVERAGEA", 69],
    82: ["COUNTA", 69],
    83: ["MINA", 69],
    84: ["MAXA", 69],
    111: ["T", 1]
  };
  var BinOpTab = [
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "",
    "+",
    "-",
    "*",
    "/",
    "^",
    "=",
    "<>",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "<=",
    ">=",
    "<",
    ">",
    "",
    "",
    "",
    "",
    // eslint-disable-line no-mixed-spaces-and-tabs
    "&",
    "",
    "",
    "",
    "",
    "",
    "",
    ""
    // eslint-disable-line no-mixed-spaces-and-tabs
  ];
  function wk1_fmla_to_csf(blob, o2) {
    prep_blob(blob, 0);
    var out = [], argc = 0, R3 = "", C2 = "", argL = "", argR = "";
    while (blob.l < blob.length) {
      var cc2 = blob[blob.l++];
      switch (cc2) {
        case 0:
          out.push(blob.read_shift(8, "f"));
          break;
        case 1:
          {
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R3 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(C2 + R3);
          }
          break;
        case 2:
          {
            var c3 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            var r2 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            C2 = wk1_parse_rc(o2[0].c, blob.read_shift(2), true);
            R3 = wk1_parse_rc(o2[0].r, blob.read_shift(2), false);
            out.push(c3 + r2 + ":" + C2 + R3);
          }
          break;
        case 3:
          if (blob.l < blob.length) {
            console.error("WK1 premature formula end");
            return;
          }
          break;
        case 4:
          out.push("(" + out.pop() + ")");
          break;
        case 5:
          out.push(blob.read_shift(2));
          break;
        case 6:
          {
            var Z2 = "";
            while (cc2 = blob[blob.l++]) Z2 += String.fromCharCode(cc2);
            out.push('"' + Z2.replace(/"/g, '""') + '"');
          }
          break;
        case 8:
          out.push("-" + out.pop());
          break;
        case 23:
          out.push("+" + out.pop());
          break;
        case 22:
          out.push("NOT(" + out.pop() + ")");
          break;
        case 20:
        case 21:
          {
            argR = out.pop();
            argL = out.pop();
            out.push(["AND", "OR"][cc2 - 20] + "(" + argL + "," + argR + ")");
          }
          break;
        default:
          if (cc2 < 32 && BinOpTab[cc2]) {
            argR = out.pop();
            argL = out.pop();
            out.push(argL + BinOpTab[cc2] + argR);
          } else if (FuncTab[cc2]) {
            argc = FuncTab[cc2][1];
            if (argc == 69) argc = blob[blob.l++];
            if (argc > out.length) {
              console.error("WK1 bad formula parse 0x" + cc2.toString(16) + ":|" + out.join("|") + "|");
              return;
            }
            var args = out.slice(-argc);
            out.length -= argc;
            out.push(FuncTab[cc2][0] + "(" + args.join(",") + ")");
          } else if (cc2 <= 7) return console.error("WK1 invalid opcode " + cc2.toString(16));
          else if (cc2 <= 24) return console.error("WK1 unsupported op " + cc2.toString(16));
          else if (cc2 <= 30) return console.error("WK1 invalid opcode " + cc2.toString(16));
          else if (cc2 <= 115) return console.error("WK1 unsupported function opcode " + cc2.toString(16));
          else return console.error("WK1 unrecognized opcode " + cc2.toString(16));
      }
    }
    if (out.length == 1) o2[1].f = "" + out[0];
    else console.error("WK1 bad formula parse |" + out.join("|") + "|");
  }
  function parse_cell_3(blob) {
    var o2 = [{ c: 0, r: 0 }, { t: "n", v: 0 }, 0];
    o2[0].r = blob.read_shift(2);
    o2[3] = blob[blob.l++];
    o2[0].c = blob[blob.l++];
    return o2;
  }
  function parse_LABEL_16(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].t = "s";
    o2[1].v = blob.read_shift(length - 4, "cstr");
    return o2;
  }
  function write_LABEL_16(R3, C2, wsidx, s4) {
    var o2 = new_buf(6 + s4.length);
    o2.write_shift(2, R3);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    o2.write_shift(1, 39);
    for (var i3 = 0; i3 < s4.length; ++i3) {
      var cc2 = s4.charCodeAt(i3);
      o2.write_shift(1, cc2 >= 128 ? 95 : cc2);
    }
    o2.write_shift(1, 0);
    return o2;
  }
  function parse_NUMBER_18(blob, length) {
    var o2 = parse_cell_3(blob);
    o2[1].v = blob.read_shift(2);
    var v2 = o2[1].v >> 1;
    if (o2[1].v & 1) {
      switch (v2 & 7) {
        case 0:
          v2 = (v2 >> 3) * 5e3;
          break;
        case 1:
          v2 = (v2 >> 3) * 500;
          break;
        case 2:
          v2 = (v2 >> 3) / 20;
          break;
        case 3:
          v2 = (v2 >> 3) / 200;
          break;
        case 4:
          v2 = (v2 >> 3) / 2e3;
          break;
        case 5:
          v2 = (v2 >> 3) / 2e4;
          break;
        case 6:
          v2 = (v2 >> 3) / 16;
          break;
        case 7:
          v2 = (v2 >> 3) / 64;
          break;
      }
    }
    o2[1].v = v2;
    return o2;
  }
  function parse_NUMBER_17(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    var v2 = blob.read_shift(4);
    var e3 = blob.read_shift(2);
    if (e3 == 65535) {
      if (v1 === 0 && v2 === 3221225472) {
        o2[1].t = "e";
        o2[1].v = 15;
      } else if (v1 === 0 && v2 === 3489660928) {
        o2[1].t = "e";
        o2[1].v = 42;
      } else o2[1].v = 0;
      return o2;
    }
    var s4 = e3 & 32768;
    e3 = (e3 & 32767) - 16446;
    o2[1].v = (1 - s4 * 2) * (v2 * Math.pow(2, e3 + 32) + v1 * Math.pow(2, e3));
    return o2;
  }
  function write_NUMBER_17(R3, C2, wsidx, v2) {
    var o2 = new_buf(14);
    o2.write_shift(2, R3);
    o2.write_shift(1, wsidx);
    o2.write_shift(1, C2);
    if (v2 == 0) {
      o2.write_shift(4, 0);
      o2.write_shift(4, 0);
      o2.write_shift(2, 65535);
      return o2;
    }
    var s4 = 0, e3 = 0, v1 = 0, v22 = 0;
    if (v2 < 0) {
      s4 = 1;
      v2 = -v2;
    }
    e3 = Math.log2(v2) | 0;
    v2 /= Math.pow(2, e3 - 31);
    v22 = v2 >>> 0;
    if ((v22 & 2147483648) == 0) {
      v2 /= 2;
      ++e3;
      v22 = v2 >>> 0;
    }
    v2 -= v22;
    v22 |= 2147483648;
    v22 >>>= 0;
    v2 *= Math.pow(2, 32);
    v1 = v2 >>> 0;
    o2.write_shift(4, v1);
    o2.write_shift(4, v22);
    e3 += 16383 + (s4 ? 32768 : 0);
    o2.write_shift(2, e3);
    return o2;
  }
  function parse_FORMULA_19(blob, length) {
    var o2 = parse_NUMBER_17(blob);
    blob.l += length - 14;
    return o2;
  }
  function parse_NUMBER_25(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(4);
    o2[1].v = v1 >> 6;
    return o2;
  }
  function parse_NUMBER_27(blob, length) {
    var o2 = parse_cell_3(blob);
    var v1 = blob.read_shift(8, "f");
    o2[1].v = v1;
    return o2;
  }
  function parse_FORMULA_28(blob, length) {
    var o2 = parse_NUMBER_27(blob);
    blob.l += length - 10;
    return o2;
  }
  function parse_SHEETNAMECS(blob, length) {
    return blob[blob.l + length - 1] == 0 ? blob.read_shift(length, "cstr") : "";
  }
  function parse_SHEETNAMELP(blob, length) {
    var len = blob[blob.l++];
    if (len > length - 1) len = length - 1;
    var o2 = "";
    while (o2.length < len) o2 += String.fromCharCode(blob[blob.l++]);
    return o2;
  }
  function parse_SHEETINFOQP(blob, length, opts) {
    if (!opts.qpro || length < 21) return;
    var id2 = blob.read_shift(1);
    blob.l += 17;
    blob.l += 1;
    blob.l += 2;
    var nm = blob.read_shift(length - 21, "cstr");
    return [id2, nm];
  }
  function parse_XFORMAT(blob, length) {
    var o2 = {}, tgt = blob.l + length;
    while (blob.l < tgt) {
      var dt = blob.read_shift(2);
      if (dt == 14e3) {
        o2[dt] = [0, ""];
        o2[dt][0] = blob.read_shift(2);
        while (blob[blob.l]) {
          o2[dt][1] += String.fromCharCode(blob[blob.l]);
          blob.l++;
        }
        blob.l++;
      }
    }
    return o2;
  }
  function write_XFORMAT_SHEETNAME(name, wsidx) {
    var out = new_buf(5 + name.length);
    out.write_shift(2, 14e3);
    out.write_shift(2, wsidx);
    for (var i3 = 0; i3 < name.length; ++i3) {
      var cc2 = name.charCodeAt(i3);
      out[out.l++] = cc2 > 127 ? 95 : cc2;
    }
    out[out.l++] = 0;
    return out;
  }
  var WK1Enum = {
    /*::[*/
    0: { n: "BOF", f: parseuint16 },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "CALCMODE" },
    /*::[*/
    3: { n: "CALCORDER" },
    /*::[*/
    4: { n: "SPLIT" },
    /*::[*/
    5: { n: "SYNC" },
    /*::[*/
    6: { n: "RANGE", f: parse_RANGE },
    /*::[*/
    7: { n: "WINDOW1" },
    /*::[*/
    8: { n: "COLW1" },
    /*::[*/
    9: { n: "WINTWO" },
    /*::[*/
    10: { n: "COLW2" },
    /*::[*/
    11: { n: "NAME" },
    /*::[*/
    12: { n: "BLANK" },
    /*::[*/
    13: { n: "INTEGER", f: parse_INTEGER },
    /*::[*/
    14: { n: "NUMBER", f: parse_NUMBER },
    /*::[*/
    15: { n: "LABEL", f: parse_LABEL },
    /*::[*/
    16: { n: "FORMULA", f: parse_FORMULA },
    /*::[*/
    24: { n: "TABLE" },
    /*::[*/
    25: { n: "ORANGE" },
    /*::[*/
    26: { n: "PRANGE" },
    /*::[*/
    27: { n: "SRANGE" },
    /*::[*/
    28: { n: "FRANGE" },
    /*::[*/
    29: { n: "KRANGE1" },
    /*::[*/
    32: { n: "HRANGE" },
    /*::[*/
    35: { n: "KRANGE2" },
    /*::[*/
    36: { n: "PROTEC" },
    /*::[*/
    37: { n: "FOOTER" },
    /*::[*/
    38: { n: "HEADER" },
    /*::[*/
    39: { n: "SETUP" },
    /*::[*/
    40: { n: "MARGINS" },
    /*::[*/
    41: { n: "LABELFMT" },
    /*::[*/
    42: { n: "TITLES" },
    /*::[*/
    43: { n: "SHEETJS" },
    /*::[*/
    45: { n: "GRAPH" },
    /*::[*/
    46: { n: "NGRAPH" },
    /*::[*/
    47: { n: "CALCCOUNT" },
    /*::[*/
    48: { n: "UNFORMATTED" },
    /*::[*/
    49: { n: "CURSORW12" },
    /*::[*/
    50: { n: "WINDOW" },
    /*::[*/
    51: { n: "STRING", f: parse_LABEL },
    /*::[*/
    55: { n: "PASSWORD" },
    /*::[*/
    56: { n: "LOCKED" },
    /*::[*/
    60: { n: "QUERY" },
    /*::[*/
    61: { n: "QUERYNAME" },
    /*::[*/
    62: { n: "PRINT" },
    /*::[*/
    63: { n: "PRINTNAME" },
    /*::[*/
    64: { n: "GRAPH2" },
    /*::[*/
    65: { n: "GRAPHNAME" },
    /*::[*/
    66: { n: "ZOOM" },
    /*::[*/
    67: { n: "SYMSPLIT" },
    /*::[*/
    68: { n: "NSROWS" },
    /*::[*/
    69: { n: "NSCOLS" },
    /*::[*/
    70: { n: "RULER" },
    /*::[*/
    71: { n: "NNAME" },
    /*::[*/
    72: { n: "ACOMM" },
    /*::[*/
    73: { n: "AMACRO" },
    /*::[*/
    74: { n: "PARSE" },
    /*::[*/
    102: { n: "PRANGES??" },
    /*::[*/
    103: { n: "RRANGES??" },
    /*::[*/
    104: { n: "FNAME??" },
    /*::[*/
    105: { n: "MRANGES??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    222: { n: "SHEETNAMELP", f: parse_SHEETNAMELP },
    /*::[*/
    65535: { n: "" }
  };
  var WK3Enum = {
    /*::[*/
    0: { n: "BOF" },
    /*::[*/
    1: { n: "EOF" },
    /*::[*/
    2: { n: "PASSWORD" },
    /*::[*/
    3: { n: "CALCSET" },
    /*::[*/
    4: { n: "WINDOWSET" },
    /*::[*/
    5: { n: "SHEETCELLPTR" },
    /*::[*/
    6: { n: "SHEETLAYOUT" },
    /*::[*/
    7: { n: "COLUMNWIDTH" },
    /*::[*/
    8: { n: "HIDDENCOLUMN" },
    /*::[*/
    9: { n: "USERRANGE" },
    /*::[*/
    10: { n: "SYSTEMRANGE" },
    /*::[*/
    11: { n: "ZEROFORCE" },
    /*::[*/
    12: { n: "SORTKEYDIR" },
    /*::[*/
    13: { n: "FILESEAL" },
    /*::[*/
    14: { n: "DATAFILLNUMS" },
    /*::[*/
    15: { n: "PRINTMAIN" },
    /*::[*/
    16: { n: "PRINTSTRING" },
    /*::[*/
    17: { n: "GRAPHMAIN" },
    /*::[*/
    18: { n: "GRAPHSTRING" },
    /*::[*/
    19: { n: "??" },
    /*::[*/
    20: { n: "ERRCELL" },
    /*::[*/
    21: { n: "NACELL" },
    /*::[*/
    22: { n: "LABEL16", f: parse_LABEL_16 },
    /*::[*/
    23: { n: "NUMBER17", f: parse_NUMBER_17 },
    /*::[*/
    24: { n: "NUMBER18", f: parse_NUMBER_18 },
    /*::[*/
    25: { n: "FORMULA19", f: parse_FORMULA_19 },
    /*::[*/
    26: { n: "FORMULA1A" },
    /*::[*/
    27: { n: "XFORMAT", f: parse_XFORMAT },
    /*::[*/
    28: { n: "DTLABELMISC" },
    /*::[*/
    29: { n: "DTLABELCELL" },
    /*::[*/
    30: { n: "GRAPHWINDOW" },
    /*::[*/
    31: { n: "CPA" },
    /*::[*/
    32: { n: "LPLAUTO" },
    /*::[*/
    33: { n: "QUERY" },
    /*::[*/
    34: { n: "HIDDENSHEET" },
    /*::[*/
    35: { n: "??" },
    /*::[*/
    37: { n: "NUMBER25", f: parse_NUMBER_25 },
    /*::[*/
    38: { n: "??" },
    /*::[*/
    39: { n: "NUMBER27", f: parse_NUMBER_27 },
    /*::[*/
    40: { n: "FORMULA28", f: parse_FORMULA_28 },
    /*::[*/
    142: { n: "??" },
    /*::[*/
    147: { n: "??" },
    /*::[*/
    150: { n: "??" },
    /*::[*/
    151: { n: "??" },
    /*::[*/
    152: { n: "??" },
    /*::[*/
    153: { n: "??" },
    /*::[*/
    154: { n: "??" },
    /*::[*/
    155: { n: "??" },
    /*::[*/
    156: { n: "??" },
    /*::[*/
    163: { n: "??" },
    /*::[*/
    174: { n: "??" },
    /*::[*/
    175: { n: "??" },
    /*::[*/
    176: { n: "??" },
    /*::[*/
    177: { n: "??" },
    /*::[*/
    184: { n: "??" },
    /*::[*/
    185: { n: "??" },
    /*::[*/
    186: { n: "??" },
    /*::[*/
    187: { n: "??" },
    /*::[*/
    188: { n: "??" },
    /*::[*/
    195: { n: "??" },
    /*::[*/
    201: { n: "??" },
    /*::[*/
    204: { n: "SHEETNAMECS", f: parse_SHEETNAMECS },
    /*::[*/
    205: { n: "??" },
    /*::[*/
    206: { n: "??" },
    /*::[*/
    207: { n: "??" },
    /*::[*/
    208: { n: "??" },
    /*::[*/
    256: { n: "??" },
    /*::[*/
    259: { n: "??" },
    /*::[*/
    260: { n: "??" },
    /*::[*/
    261: { n: "??" },
    /*::[*/
    262: { n: "??" },
    /*::[*/
    263: { n: "??" },
    /*::[*/
    265: { n: "??" },
    /*::[*/
    266: { n: "??" },
    /*::[*/
    267: { n: "??" },
    /*::[*/
    268: { n: "??" },
    /*::[*/
    270: { n: "??" },
    /*::[*/
    271: { n: "??" },
    /*::[*/
    384: { n: "??" },
    /*::[*/
    389: { n: "??" },
    /*::[*/
    390: { n: "??" },
    /*::[*/
    393: { n: "??" },
    /*::[*/
    396: { n: "??" },
    /*::[*/
    512: { n: "??" },
    /*::[*/
    514: { n: "??" },
    /*::[*/
    513: { n: "??" },
    /*::[*/
    516: { n: "??" },
    /*::[*/
    517: { n: "??" },
    /*::[*/
    640: { n: "??" },
    /*::[*/
    641: { n: "??" },
    /*::[*/
    642: { n: "??" },
    /*::[*/
    643: { n: "??" },
    /*::[*/
    644: { n: "??" },
    /*::[*/
    645: { n: "??" },
    /*::[*/
    646: { n: "??" },
    /*::[*/
    647: { n: "??" },
    /*::[*/
    648: { n: "??" },
    /*::[*/
    658: { n: "??" },
    /*::[*/
    659: { n: "??" },
    /*::[*/
    660: { n: "??" },
    /*::[*/
    661: { n: "??" },
    /*::[*/
    662: { n: "??" },
    /*::[*/
    665: { n: "??" },
    /*::[*/
    666: { n: "??" },
    /*::[*/
    768: { n: "??" },
    /*::[*/
    772: { n: "??" },
    /*::[*/
    1537: { n: "SHEETINFOQP", f: parse_SHEETINFOQP },
    /*::[*/
    1600: { n: "??" },
    /*::[*/
    1602: { n: "??" },
    /*::[*/
    1793: { n: "??" },
    /*::[*/
    1794: { n: "??" },
    /*::[*/
    1795: { n: "??" },
    /*::[*/
    1796: { n: "??" },
    /*::[*/
    1920: { n: "??" },
    /*::[*/
    2048: { n: "??" },
    /*::[*/
    2049: { n: "??" },
    /*::[*/
    2052: { n: "??" },
    /*::[*/
    2688: { n: "??" },
    /*::[*/
    10998: { n: "??" },
    /*::[*/
    12849: { n: "??" },
    /*::[*/
    28233: { n: "??" },
    /*::[*/
    28484: { n: "??" },
    /*::[*/
    65535: { n: "" }
  };
  return {
    sheet_to_wk1,
    book_to_wk3,
    to_workbook: lotus_to_workbook
  };
}();
function parse_rpr(rpr) {
  var font = {}, m4 = rpr.match(tagregex), i3 = 0;
  var pass = false;
  if (m4) for (; i3 != m4.length; ++i3) {
    var y4 = parsexmltag(m4[i3]);
    switch (y4[0].replace(/\w*:/g, "")) {
      case "<condense":
        break;
      case "<extend":
        break;
      case "<shadow":
        if (!y4.val) break;
      case "<shadow>":
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "</shadow>":
        break;
      case "<charset":
        if (y4.val == "1") break;
        font.cp = CS2CP[parseInt(y4.val, 10)];
        break;
      case "<outline":
        if (!y4.val) break;
      case "<outline>":
      case "<outline/>":
        font.outline = 1;
        break;
      case "</outline>":
        break;
      case "<rFont":
        font.name = y4.val;
        break;
      case "<sz":
        font.sz = y4.val;
        break;
      case "<strike":
        if (!y4.val) break;
      case "<strike>":
      case "<strike/>":
        font.strike = 1;
        break;
      case "</strike>":
        break;
      case "<u":
        if (!y4.val) break;
        switch (y4.val) {
          case "double":
            font.uval = "double";
            break;
          case "singleAccounting":
            font.uval = "single-accounting";
            break;
          case "doubleAccounting":
            font.uval = "double-accounting";
            break;
        }
      case "<u>":
      case "<u/>":
        font.u = 1;
        break;
      case "</u>":
        break;
      case "<b":
        if (y4.val == "0") break;
      case "<b>":
      case "<b/>":
        font.b = 1;
        break;
      case "</b>":
        break;
      case "<i":
        if (y4.val == "0") break;
      case "<i>":
      case "<i/>":
        font.i = 1;
        break;
      case "</i>":
        break;
      case "<color":
        if (y4.rgb) font.color = y4.rgb.slice(2, 8);
        break;
      case "<color>":
      case "<color/>":
      case "</color>":
        break;
      case "<family":
        font.family = y4.val;
        break;
      case "<family>":
      case "<family/>":
      case "</family>":
        break;
      case "<vertAlign":
        font.valign = y4.val;
        break;
      case "<vertAlign>":
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<scheme":
        break;
      case "<scheme>":
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (y4[0].charCodeAt(1) !== 47 && !pass) throw new Error("Unrecognized rich format " + y4[0]);
    }
  }
  return font;
}
var parse_rs = /* @__PURE__ */ function() {
  var tregex = matchtag("t"), rpregex = matchtag("rPr");
  function parse_r(r2) {
    var t3 = r2.match(tregex);
    if (!t3) return { t: "s", v: "" };
    var o2 = { t: "s", v: unescapexml(t3[1]) };
    var rpr = r2.match(rpregex);
    if (rpr) o2.s = parse_rpr(rpr[1]);
    return o2;
  }
  var rregex = /<(?:\w+:)?r>/g, rend = /<\/(?:\w+:)?r>/;
  return function parse_rs2(rs) {
    return rs.replace(rregex, "").split(rend).map(parse_r).filter(function(r2) {
      return r2.v;
    });
  };
}();
var rs_to_html = /* @__PURE__ */ function parse_rs_factory() {
  var nlregex = /(\r\n|\n)/g;
  function parse_rpr2(font, intro, outro) {
    var style = [];
    if (font.u) style.push("text-decoration: underline;");
    if (font.uval) style.push("text-underline-style:" + font.uval + ";");
    if (font.sz) style.push("font-size:" + font.sz + "pt;");
    if (font.outline) style.push("text-effect: outline;");
    if (font.shadow) style.push("text-shadow: auto;");
    intro.push('<span style="' + style.join("") + '">');
    if (font.b) {
      intro.push("<b>");
      outro.push("</b>");
    }
    if (font.i) {
      intro.push("<i>");
      outro.push("</i>");
    }
    if (font.strike) {
      intro.push("<s>");
      outro.push("</s>");
    }
    var align = font.valign || "";
    if (align == "superscript" || align == "super") align = "sup";
    else if (align == "subscript") align = "sub";
    if (align != "") {
      intro.push("<" + align + ">");
      outro.push("</" + align + ">");
    }
    outro.push("</span>");
    return font;
  }
  function r_to_html(r2) {
    var terms = [[], r2.v, []];
    if (!r2.v) return "";
    if (r2.s) parse_rpr2(r2.s, terms[0], terms[2]);
    return terms[0].join("") + terms[1].replace(nlregex, "<br/>") + terms[2].join("");
  }
  return function parse_rs2(rs) {
    return rs.map(r_to_html).join("");
  };
}();
var sitregex = /<(?:\w+:)?t[^>]*>([^<]*)<\/(?:\w+:)?t>/g, sirregex = /<(?:\w+:)?r>/;
var sirphregex = /<(?:\w+:)?rPh.*?>([\s\S]*?)<\/(?:\w+:)?rPh>/g;
function parse_si(x3, opts) {
  var html = opts ? opts.cellHTML : true;
  var z3 = {};
  if (!x3) return { t: "" };
  if (x3.match(/^\s*<(?:\w+:)?t[^>]*>/)) {
    z3.t = unescapexml(utf8read(x3.slice(x3.indexOf(">") + 1).split(/<\/(?:\w+:)?t>/)[0] || ""));
    z3.r = utf8read(x3);
    if (html) z3.h = escapehtml(z3.t);
  } else if (
    /*y = */
    x3.match(sirregex)
  ) {
    z3.r = utf8read(x3);
    z3.t = unescapexml(utf8read((x3.replace(sirphregex, "").match(sitregex) || []).join("").replace(tagregex, "")));
    if (html) z3.h = rs_to_html(parse_rs(z3.r));
  }
  return z3;
}
var sstr0 = /<(?:\w+:)?sst([^>]*)>([\s\S]*)<\/(?:\w+:)?sst>/;
var sstr1 = /<(?:\w+:)?(?:si|sstItem)>/g;
var sstr2 = /<\/(?:\w+:)?(?:si|sstItem)>/;
function parse_sst_xml(data, opts) {
  var s4 = [], ss = "";
  if (!data) return s4;
  var sst = data.match(sstr0);
  if (sst) {
    ss = sst[2].replace(sstr1, "").split(sstr2);
    for (var i3 = 0; i3 != ss.length; ++i3) {
      var o2 = parse_si(ss[i3].trim(), opts);
      if (o2 != null) s4[s4.length] = o2;
    }
    sst = parsexmltag(sst[1]);
    s4.Count = sst.count;
    s4.Unique = sst.uniqueCount;
  }
  return s4;
}
var straywsregex = /^\s|\s$|[\t\n\r]/;
function write_sst_xml(sst, opts) {
  if (!opts.bookSST) return "";
  var o2 = [XML_HEADER];
  o2[o2.length] = writextag("sst", null, {
    xmlns: XMLNS_main[0],
    count: sst.Count,
    uniqueCount: sst.Unique
  });
  for (var i3 = 0; i3 != sst.length; ++i3) {
    if (sst[i3] == null) continue;
    var s4 = sst[i3];
    var sitag = "<si>";
    if (s4.r) sitag += s4.r;
    else {
      sitag += "<t";
      if (!s4.t) s4.t = "";
      if (s4.t.match(straywsregex)) sitag += ' xml:space="preserve"';
      sitag += ">" + escapexml(s4.t) + "</t>";
    }
    sitag += "</si>";
    o2[o2.length] = sitag;
  }
  if (o2.length > 2) {
    o2[o2.length] = "</sst>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function parse_BrtBeginSst(data) {
  return [data.read_shift(4), data.read_shift(4)];
}
function parse_sst_bin(data, opts) {
  var s4 = [];
  var pass = false;
  recordhopper(data, function hopper_sst(val, R3, RT) {
    switch (RT) {
      case 159:
        s4.Count = val[0];
        s4.Unique = val[1];
        break;
      case 19:
        s4.push(val);
        break;
      case 160:
        return true;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R3.T) ;
        if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return s4;
}
function write_BrtBeginSst(sst, o2) {
  if (!o2) o2 = new_buf(8);
  o2.write_shift(4, sst.Count);
  o2.write_shift(4, sst.Unique);
  return o2;
}
var write_BrtSSTItem = write_RichStr;
function write_sst_bin(sst) {
  var ba = buf_array();
  write_record(ba, 159, write_BrtBeginSst(sst));
  for (var i3 = 0; i3 < sst.length; ++i3) write_record(ba, 19, write_BrtSSTItem(sst[i3]));
  write_record(
    ba,
    160
    /* BrtEndSst */
  );
  return ba.end();
}
function _JS2ANSI(str) {
  var o2 = [], oo = str.split("");
  for (var i3 = 0; i3 < oo.length; ++i3) o2[i3] = oo[i3].charCodeAt(0);
  return o2;
}
function parse_CRYPTOVersion(blob, length) {
  var o2 = {};
  o2.Major = blob.read_shift(2);
  o2.Minor = blob.read_shift(2);
  if (length >= 4) blob.l += length - 4;
  return o2;
}
function parse_DataSpaceVersionInfo(blob) {
  var o2 = {};
  o2.id = blob.read_shift(0, "lpp4");
  o2.R = parse_CRYPTOVersion(blob, 4);
  o2.U = parse_CRYPTOVersion(blob, 4);
  o2.W = parse_CRYPTOVersion(blob, 4);
  return o2;
}
function parse_DataSpaceMapEntry(blob) {
  var len = blob.read_shift(4);
  var end = blob.l + len - 4;
  var o2 = {};
  var cnt = blob.read_shift(4);
  var comps = [];
  while (cnt-- > 0) comps.push({ t: blob.read_shift(4), v: blob.read_shift(0, "lpp4") });
  o2.name = blob.read_shift(0, "lpp4");
  o2.comps = comps;
  if (blob.l != end) throw new Error("Bad DataSpaceMapEntry: " + blob.l + " != " + end);
  return o2;
}
function parse_DataSpaceMap(blob) {
  var o2 = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o2.push(parse_DataSpaceMapEntry(blob));
  return o2;
}
function parse_DataSpaceDefinition(blob) {
  var o2 = [];
  blob.l += 4;
  var cnt = blob.read_shift(4);
  while (cnt-- > 0) o2.push(blob.read_shift(0, "lpp4"));
  return o2;
}
function parse_TransformInfoHeader(blob) {
  var o2 = {};
  blob.read_shift(4);
  blob.l += 4;
  o2.id = blob.read_shift(0, "lpp4");
  o2.name = blob.read_shift(0, "lpp4");
  o2.R = parse_CRYPTOVersion(blob, 4);
  o2.U = parse_CRYPTOVersion(blob, 4);
  o2.W = parse_CRYPTOVersion(blob, 4);
  return o2;
}
function parse_Primary(blob) {
  var hdr = parse_TransformInfoHeader(blob);
  hdr.ename = blob.read_shift(0, "8lpp4");
  hdr.blksz = blob.read_shift(4);
  hdr.cmode = blob.read_shift(4);
  if (blob.read_shift(4) != 4) throw new Error("Bad !Primary record");
  return hdr;
}
function parse_EncryptionHeader(blob, length) {
  var tgt = blob.l + length;
  var o2 = {};
  o2.Flags = blob.read_shift(4) & 63;
  blob.l += 4;
  o2.AlgID = blob.read_shift(4);
  var valid = false;
  switch (o2.AlgID) {
    case 26126:
    case 26127:
    case 26128:
      valid = o2.Flags == 36;
      break;
    case 26625:
      valid = o2.Flags == 4;
      break;
    case 0:
      valid = o2.Flags == 16 || o2.Flags == 4 || o2.Flags == 36;
      break;
    default:
      throw "Unrecognized encryption algorithm: " + o2.AlgID;
  }
  if (!valid) throw new Error("Encryption Flags/AlgID mismatch");
  o2.AlgIDHash = blob.read_shift(4);
  o2.KeySize = blob.read_shift(4);
  o2.ProviderType = blob.read_shift(4);
  blob.l += 8;
  o2.CSPName = blob.read_shift(tgt - blob.l >> 1, "utf16le");
  blob.l = tgt;
  return o2;
}
function parse_EncryptionVerifier(blob, length) {
  var o2 = {}, tgt = blob.l + length;
  blob.l += 4;
  o2.Salt = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  o2.Verifier = blob.slice(blob.l, blob.l + 16);
  blob.l += 16;
  blob.read_shift(4);
  o2.VerifierHash = blob.slice(blob.l, tgt);
  blob.l = tgt;
  return o2;
}
function parse_EncryptionInfo(blob) {
  var vers = parse_CRYPTOVersion(blob);
  switch (vers.Minor) {
    case 2:
      return [vers.Minor, parse_EncInfoStd(blob)];
    case 3:
      return [vers.Minor, parse_EncInfoExt()];
    case 4:
      return [vers.Minor, parse_EncInfoAgl(blob)];
  }
  throw new Error("ECMA-376 Encrypted file unrecognized Version: " + vers.Minor);
}
function parse_EncInfoStd(blob) {
  var flags = blob.read_shift(4);
  if ((flags & 63) != 36) throw new Error("EncryptionInfo mismatch");
  var sz = blob.read_shift(4);
  var hdr = parse_EncryptionHeader(blob, sz);
  var verifier = parse_EncryptionVerifier(blob, blob.length - blob.l);
  return { t: "Std", h: hdr, v: verifier };
}
function parse_EncInfoExt() {
  throw new Error("File is password-protected: ECMA-376 Extensible");
}
function parse_EncInfoAgl(blob) {
  var KeyData = ["saltSize", "blockSize", "keyBits", "hashSize", "cipherAlgorithm", "cipherChaining", "hashAlgorithm", "saltValue"];
  blob.l += 4;
  var xml = blob.read_shift(blob.length - blob.l, "utf8");
  var o2 = {};
  xml.replace(tagregex, function xml_agile(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<?xml":
        break;
      case "<encryption":
      case "</encryption>":
        break;
      case "<keyData":
        KeyData.forEach(function(k3) {
          o2[k3] = y4[k3];
        });
        break;
      case "<dataIntegrity":
        o2.encryptedHmacKey = y4.encryptedHmacKey;
        o2.encryptedHmacValue = y4.encryptedHmacValue;
        break;
      case "<keyEncryptors>":
      case "<keyEncryptors":
        o2.encs = [];
        break;
      case "</keyEncryptors>":
        break;
      case "<keyEncryptor":
        o2.uri = y4.uri;
        break;
      case "</keyEncryptor>":
        break;
      case "<encryptedKey":
        o2.encs.push(y4);
        break;
      default:
        throw y4[0];
    }
  });
  return o2;
}
function parse_RC4CryptoHeader(blob, length) {
  var o2 = {};
  var vers = o2.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  length -= 4;
  if (vers.Minor != 2) throw new Error("unrecognized minor version code: " + vers.Minor);
  if (vers.Major > 4 || vers.Major < 2) throw new Error("unrecognized major version code: " + vers.Major);
  o2.Flags = blob.read_shift(4);
  length -= 4;
  var sz = blob.read_shift(4);
  length -= 4;
  o2.EncryptionHeader = parse_EncryptionHeader(blob, sz);
  length -= sz;
  o2.EncryptionVerifier = parse_EncryptionVerifier(blob, length);
  return o2;
}
function parse_RC4Header(blob) {
  var o2 = {};
  var vers = o2.EncryptionVersionInfo = parse_CRYPTOVersion(blob, 4);
  if (vers.Major != 1 || vers.Minor != 1) throw "unrecognized version code " + vers.Major + " : " + vers.Minor;
  o2.Salt = blob.read_shift(16);
  o2.EncryptedVerifier = blob.read_shift(16);
  o2.EncryptedVerifierHash = blob.read_shift(16);
  return o2;
}
function crypto_CreatePasswordVerifier_Method1(Password) {
  var Verifier = 0, PasswordArray;
  var PasswordDecoded = _JS2ANSI(Password);
  var len = PasswordDecoded.length + 1, i3, PasswordByte;
  var Intermediate1, Intermediate2, Intermediate3;
  PasswordArray = new_raw_buf(len);
  PasswordArray[0] = PasswordDecoded.length;
  for (i3 = 1; i3 != len; ++i3) PasswordArray[i3] = PasswordDecoded[i3 - 1];
  for (i3 = len - 1; i3 >= 0; --i3) {
    PasswordByte = PasswordArray[i3];
    Intermediate1 = (Verifier & 16384) === 0 ? 0 : 1;
    Intermediate2 = Verifier << 1 & 32767;
    Intermediate3 = Intermediate1 | Intermediate2;
    Verifier = Intermediate3 ^ PasswordByte;
  }
  return Verifier ^ 52811;
}
var crypto_CreateXorArray_Method1 = /* @__PURE__ */ function() {
  var PadArray = [187, 255, 255, 186, 255, 255, 185, 128, 0, 190, 15, 0, 191, 15, 0];
  var InitialCode = [57840, 7439, 52380, 33984, 4364, 3600, 61902, 12606, 6258, 57657, 54287, 34041, 10252, 43370, 20163];
  var XorMatrix = [44796, 19929, 39858, 10053, 20106, 40212, 10761, 31585, 63170, 64933, 60267, 50935, 40399, 11199, 17763, 35526, 1453, 2906, 5812, 11624, 23248, 885, 1770, 3540, 7080, 14160, 28320, 56640, 55369, 41139, 20807, 41614, 21821, 43642, 17621, 28485, 56970, 44341, 19019, 38038, 14605, 29210, 60195, 50791, 40175, 10751, 21502, 43004, 24537, 18387, 36774, 3949, 7898, 15796, 31592, 63184, 47201, 24803, 49606, 37805, 14203, 28406, 56812, 17824, 35648, 1697, 3394, 6788, 13576, 27152, 43601, 17539, 35078, 557, 1114, 2228, 4456, 30388, 60776, 51953, 34243, 7079, 14158, 28316, 14128, 28256, 56512, 43425, 17251, 34502, 7597, 13105, 26210, 52420, 35241, 883, 1766, 3532, 4129, 8258, 16516, 33032, 4657, 9314, 18628];
  var Ror = function(Byte) {
    return (Byte / 2 | Byte * 128) & 255;
  };
  var XorRor = function(byte1, byte2) {
    return Ror(byte1 ^ byte2);
  };
  var CreateXorKey_Method1 = function(Password) {
    var XorKey = InitialCode[Password.length - 1];
    var CurrentElement = 104;
    for (var i3 = Password.length - 1; i3 >= 0; --i3) {
      var Char = Password[i3];
      for (var j2 = 0; j2 != 7; ++j2) {
        if (Char & 64) XorKey ^= XorMatrix[CurrentElement];
        Char *= 2;
        --CurrentElement;
      }
    }
    return XorKey;
  };
  return function(password) {
    var Password = _JS2ANSI(password);
    var XorKey = CreateXorKey_Method1(Password);
    var Index = Password.length;
    var ObfuscationArray = new_raw_buf(16);
    for (var i3 = 0; i3 != 16; ++i3) ObfuscationArray[i3] = 0;
    var Temp, PasswordLastChar, PadIndex;
    if ((Index & 1) === 1) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[0], Temp);
      --Index;
      Temp = XorKey & 255;
      PasswordLastChar = Password[Password.length - 1];
      ObfuscationArray[Index] = XorRor(PasswordLastChar, Temp);
    }
    while (Index > 0) {
      --Index;
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
    }
    Index = 15;
    PadIndex = 15 - Password.length;
    while (PadIndex > 0) {
      Temp = XorKey >> 8;
      ObfuscationArray[Index] = XorRor(PadArray[PadIndex], Temp);
      --Index;
      --PadIndex;
      Temp = XorKey & 255;
      ObfuscationArray[Index] = XorRor(Password[Index], Temp);
      --Index;
      --PadIndex;
    }
    return ObfuscationArray;
  };
}();
var crypto_DecryptData_Method1 = function(password, Data, XorArrayIndex, XorArray, O3) {
  if (!O3) O3 = Data;
  if (!XorArray) XorArray = crypto_CreateXorArray_Method1(password);
  var Index, Value2;
  for (Index = 0; Index != Data.length; ++Index) {
    Value2 = Data[Index];
    Value2 ^= XorArray[XorArrayIndex];
    Value2 = (Value2 >> 5 | Value2 << 3) & 255;
    O3[Index] = Value2;
    ++XorArrayIndex;
  }
  return [O3, XorArrayIndex, XorArray];
};
var crypto_MakeXorDecryptor = function(password) {
  var XorArrayIndex = 0, XorArray = crypto_CreateXorArray_Method1(password);
  return function(Data) {
    var O3 = crypto_DecryptData_Method1("", Data, XorArrayIndex, XorArray);
    XorArrayIndex = O3[1];
    return O3[0];
  };
};
function parse_XORObfuscation(blob, length, opts, out) {
  var o2 = { key: parseuint16(blob), verificationBytes: parseuint16(blob) };
  if (opts.password) o2.verifier = crypto_CreatePasswordVerifier_Method1(opts.password);
  out.valid = o2.verificationBytes === o2.verifier;
  if (out.valid) out.insitu = crypto_MakeXorDecryptor(opts.password);
  return o2;
}
function parse_FilePassHeader(blob, length, oo) {
  var o2 = oo || {};
  o2.Info = blob.read_shift(2);
  blob.l -= 2;
  if (o2.Info === 1) o2.Data = parse_RC4Header(blob);
  else o2.Data = parse_RC4CryptoHeader(blob, length);
  return o2;
}
function parse_FilePass(blob, length, opts) {
  var o2 = { Type: opts.biff >= 8 ? blob.read_shift(2) : 0 };
  if (o2.Type) parse_FilePassHeader(blob, length - 2, o2);
  else parse_XORObfuscation(blob, opts.biff >= 8 ? length : length - 2, opts, o2);
  return o2;
}
var RTF = /* @__PURE__ */ function() {
  function rtf_to_sheet(d4, opts) {
    switch (opts.type) {
      case "base64":
        return rtf_to_sheet_str(Base64_decode(d4), opts);
      case "binary":
        return rtf_to_sheet_str(d4, opts);
      case "buffer":
        return rtf_to_sheet_str(has_buf && Buffer.isBuffer(d4) ? d4.toString("binary") : a2s(d4), opts);
      case "array":
        return rtf_to_sheet_str(cc2str(d4), opts);
    }
    throw new Error("Unrecognized type " + opts.type);
  }
  function rtf_to_sheet_str(str, opts) {
    var o2 = opts || {};
    var ws = o2.dense ? [] : {};
    var rows = str.match(/\\trowd.*?\\row\b/g);
    if (!rows.length) throw new Error("RTF missing table");
    var range = { s: { c: 0, r: 0 }, e: { c: 0, r: rows.length - 1 } };
    rows.forEach(function(rowtf, R3) {
      if (Array.isArray(ws)) ws[R3] = [];
      var rtfre = /\\\w+\b/g;
      var last_index = 0;
      var res;
      var C2 = -1;
      while (res = rtfre.exec(rowtf)) {
        switch (res[0]) {
          case "\\cell":
            var data = rowtf.slice(last_index, rtfre.lastIndex - res[0].length);
            if (data[0] == " ") data = data.slice(1);
            ++C2;
            if (data.length) {
              var cell = { v: data, t: "s" };
              if (Array.isArray(ws)) ws[R3][C2] = cell;
              else ws[encode_cell({ r: R3, c: C2 })] = cell;
            }
            break;
        }
        last_index = rtfre.lastIndex;
      }
      if (C2 > range.e.c) range.e.c = C2;
    });
    ws["!ref"] = encode_range(range);
    return ws;
  }
  function rtf_to_workbook(d4, opts) {
    return sheet_to_workbook(rtf_to_sheet(d4, opts), opts);
  }
  function sheet_to_rtf(ws) {
    var o2 = ["{\\rtf1\\ansi"];
    var r2 = safe_decode_range(ws["!ref"]), cell;
    var dense = Array.isArray(ws);
    for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
      o2.push("\\trowd\\trautofit1");
      for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) o2.push("\\cellx" + (C2 + 1));
      o2.push("\\pard\\intbl");
      for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
        var coord = encode_cell({ r: R3, c: C2 });
        cell = dense ? (ws[R3] || [])[C2] : ws[coord];
        if (!cell || cell.v == null && (!cell.f || cell.F)) continue;
        o2.push(" " + (cell.w || (format_cell(cell), cell.w)));
        o2.push("\\cell");
      }
      o2.push("\\pard\\intbl\\row");
    }
    return o2.join("") + "}";
  }
  return {
    to_workbook: rtf_to_workbook,
    to_sheet: rtf_to_sheet,
    from_sheet: sheet_to_rtf
  };
}();
function hex2RGB(h4) {
  var o2 = h4.slice(h4[0] === "#" ? 1 : 0).slice(0, 6);
  return [parseInt(o2.slice(0, 2), 16), parseInt(o2.slice(2, 4), 16), parseInt(o2.slice(4, 6), 16)];
}
function rgb2Hex(rgb) {
  for (var i3 = 0, o2 = 1; i3 != 3; ++i3) o2 = o2 * 256 + (rgb[i3] > 255 ? 255 : rgb[i3] < 0 ? 0 : rgb[i3]);
  return o2.toString(16).toUpperCase().slice(1);
}
function rgb2HSL(rgb) {
  var R3 = rgb[0] / 255, G3 = rgb[1] / 255, B3 = rgb[2] / 255;
  var M4 = Math.max(R3, G3, B3), m4 = Math.min(R3, G3, B3), C2 = M4 - m4;
  if (C2 === 0) return [0, 0, R3];
  var H6 = 0, S4 = 0, L22 = M4 + m4;
  S4 = C2 / (L22 > 1 ? 2 - L22 : L22);
  switch (M4) {
    case R3:
      H6 = ((G3 - B3) / C2 + 6) % 6;
      break;
    case G3:
      H6 = (B3 - R3) / C2 + 2;
      break;
    case B3:
      H6 = (R3 - G3) / C2 + 4;
      break;
  }
  return [H6 / 6, S4, L22 / 2];
}
function hsl2RGB(hsl) {
  var H4 = hsl[0], S4 = hsl[1], L3 = hsl[2];
  var C2 = S4 * 2 * (L3 < 0.5 ? L3 : 1 - L3), m4 = L3 - C2 / 2;
  var rgb = [m4, m4, m4], h6 = 6 * H4;
  var X3;
  if (S4 !== 0) switch (h6 | 0) {
    case 0:
    case 6:
      X3 = C2 * h6;
      rgb[0] += C2;
      rgb[1] += X3;
      break;
    case 1:
      X3 = C2 * (2 - h6);
      rgb[0] += X3;
      rgb[1] += C2;
      break;
    case 2:
      X3 = C2 * (h6 - 2);
      rgb[1] += C2;
      rgb[2] += X3;
      break;
    case 3:
      X3 = C2 * (4 - h6);
      rgb[1] += X3;
      rgb[2] += C2;
      break;
    case 4:
      X3 = C2 * (h6 - 4);
      rgb[2] += C2;
      rgb[0] += X3;
      break;
    case 5:
      X3 = C2 * (6 - h6);
      rgb[2] += X3;
      rgb[0] += C2;
      break;
  }
  for (var i3 = 0; i3 != 3; ++i3) rgb[i3] = Math.round(rgb[i3] * 255);
  return rgb;
}
function rgb_tint(hex, tint) {
  if (tint === 0) return hex;
  var hsl = rgb2HSL(hex2RGB(hex));
  if (tint < 0) hsl[2] = hsl[2] * (1 + tint);
  else hsl[2] = 1 - (1 - hsl[2]) * (1 - tint);
  return rgb2Hex(hsl2RGB(hsl));
}
var DEF_MDW = 6, MAX_MDW = 15, MIN_MDW = 1, MDW = DEF_MDW;
function width2px(width) {
  return Math.floor((width + Math.round(128 / MDW) / 256) * MDW);
}
function px2char(px) {
  return Math.floor((px - 5) / MDW * 100 + 0.5) / 100;
}
function char2width(chr) {
  return Math.round((chr * MDW + 5) / MDW * 256) / 256;
}
function cycle_width(collw) {
  return char2width(px2char(width2px(collw)));
}
function find_mdw_colw(collw) {
  var delta = Math.abs(collw - cycle_width(collw)), _MDW = MDW;
  if (delta > 5e-3) {
    for (MDW = MIN_MDW; MDW < MAX_MDW; ++MDW) if (Math.abs(collw - cycle_width(collw)) <= delta) {
      delta = Math.abs(collw - cycle_width(collw));
      _MDW = MDW;
    }
  }
  MDW = _MDW;
}
function process_col(coll) {
  if (coll.width) {
    coll.wpx = width2px(coll.width);
    coll.wch = px2char(coll.wpx);
    coll.MDW = MDW;
  } else if (coll.wpx) {
    coll.wch = px2char(coll.wpx);
    coll.width = char2width(coll.wch);
    coll.MDW = MDW;
  } else if (typeof coll.wch == "number") {
    coll.width = char2width(coll.wch);
    coll.wpx = width2px(coll.width);
    coll.MDW = MDW;
  }
  if (coll.customWidth) delete coll.customWidth;
}
var DEF_PPI = 96, PPI = DEF_PPI;
function px2pt(px) {
  return px * 96 / PPI;
}
function pt2px(pt) {
  return pt * PPI / 96;
}
var XLMLPatternTypeMap = {
  "None": "none",
  "Solid": "solid",
  "Gray50": "mediumGray",
  "Gray75": "darkGray",
  "Gray25": "lightGray",
  "HorzStripe": "darkHorizontal",
  "VertStripe": "darkVertical",
  "ReverseDiagStripe": "darkDown",
  "DiagStripe": "darkUp",
  "DiagCross": "darkGrid",
  "ThickDiagCross": "darkTrellis",
  "ThinHorzStripe": "lightHorizontal",
  "ThinVertStripe": "lightVertical",
  "ThinReverseDiagStripe": "lightDown",
  "ThinHorzCross": "lightGrid"
};
function parse_borders(t3, styles, themes, opts) {
  styles.Borders = [];
  var border = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<borders":
      case "<borders>":
      case "</borders>":
        break;
      case "<border":
      case "<border>":
      case "<border/>":
        border = /*::(*/
        {};
        if (y4.diagonalUp) border.diagonalUp = parsexmlbool(y4.diagonalUp);
        if (y4.diagonalDown) border.diagonalDown = parsexmlbool(y4.diagonalDown);
        styles.Borders.push(border);
        break;
      case "</border>":
        break;
      case "<left/>":
        break;
      case "<left":
      case "<left>":
        break;
      case "</left>":
        break;
      case "<right/>":
        break;
      case "<right":
      case "<right>":
        break;
      case "</right>":
        break;
      case "<top/>":
        break;
      case "<top":
      case "<top>":
        break;
      case "</top>":
        break;
      case "<bottom/>":
        break;
      case "<bottom":
      case "<bottom>":
        break;
      case "</bottom>":
        break;
      case "<diagonal":
      case "<diagonal>":
      case "<diagonal/>":
        break;
      case "</diagonal>":
        break;
      case "<horizontal":
      case "<horizontal>":
      case "<horizontal/>":
        break;
      case "</horizontal>":
        break;
      case "<vertical":
      case "<vertical>":
      case "<vertical/>":
        break;
      case "</vertical>":
        break;
      case "<start":
      case "<start>":
      case "<start/>":
        break;
      case "</start>":
        break;
      case "<end":
      case "<end>":
      case "<end/>":
        break;
      case "</end>":
        break;
      case "<color":
      case "<color>":
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y4[0] + " in borders");
        }
    }
  });
}
function parse_fills(t3, styles, themes, opts) {
  styles.Fills = [];
  var fill2 = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<fills":
      case "<fills>":
      case "</fills>":
        break;
      case "<fill>":
      case "<fill":
      case "<fill/>":
        fill2 = {};
        styles.Fills.push(fill2);
        break;
      case "</fill>":
        break;
      case "<gradientFill>":
        break;
      case "<gradientFill":
      case "</gradientFill>":
        styles.Fills.push(fill2);
        fill2 = {};
        break;
      case "<patternFill":
      case "<patternFill>":
        if (y4.patternType) fill2.patternType = y4.patternType;
        break;
      case "<patternFill/>":
      case "</patternFill>":
        break;
      case "<bgColor":
        if (!fill2.bgColor) fill2.bgColor = {};
        if (y4.indexed) fill2.bgColor.indexed = parseInt(y4.indexed, 10);
        if (y4.theme) fill2.bgColor.theme = parseInt(y4.theme, 10);
        if (y4.tint) fill2.bgColor.tint = parseFloat(y4.tint);
        if (y4.rgb) fill2.bgColor.rgb = y4.rgb.slice(-6);
        break;
      case "<bgColor/>":
      case "</bgColor>":
        break;
      case "<fgColor":
        if (!fill2.fgColor) fill2.fgColor = {};
        if (y4.theme) fill2.fgColor.theme = parseInt(y4.theme, 10);
        if (y4.tint) fill2.fgColor.tint = parseFloat(y4.tint);
        if (y4.rgb != null) fill2.fgColor.rgb = y4.rgb.slice(-6);
        break;
      case "<fgColor/>":
      case "</fgColor>":
        break;
      case "<stop":
      case "<stop/>":
        break;
      case "</stop>":
        break;
      case "<color":
      case "<color/>":
        break;
      case "</color>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y4[0] + " in fills");
        }
    }
  });
}
function parse_fonts(t3, styles, themes, opts) {
  styles.Fonts = [];
  var font = {};
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<fonts":
      case "<fonts>":
      case "</fonts>":
        break;
      case "<font":
      case "<font>":
        break;
      case "</font>":
      case "<font/>":
        styles.Fonts.push(font);
        font = {};
        break;
      case "<name":
        if (y4.val) font.name = utf8read(y4.val);
        break;
      case "<name/>":
      case "</name>":
        break;
      case "<b":
        font.bold = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<b/>":
        font.bold = 1;
        break;
      case "<i":
        font.italic = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<i/>":
        font.italic = 1;
        break;
      case "<u":
        switch (y4.val) {
          case "none":
            font.underline = 0;
            break;
          case "single":
            font.underline = 1;
            break;
          case "double":
            font.underline = 2;
            break;
          case "singleAccounting":
            font.underline = 33;
            break;
          case "doubleAccounting":
            font.underline = 34;
            break;
        }
        break;
      case "<u/>":
        font.underline = 1;
        break;
      case "<strike":
        font.strike = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<strike/>":
        font.strike = 1;
        break;
      case "<outline":
        font.outline = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<outline/>":
        font.outline = 1;
        break;
      case "<shadow":
        font.shadow = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<shadow/>":
        font.shadow = 1;
        break;
      case "<condense":
        font.condense = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<condense/>":
        font.condense = 1;
        break;
      case "<extend":
        font.extend = y4.val ? parsexmlbool(y4.val) : 1;
        break;
      case "<extend/>":
        font.extend = 1;
        break;
      case "<sz":
        if (y4.val) font.sz = +y4.val;
        break;
      case "<sz/>":
      case "</sz>":
        break;
      case "<vertAlign":
        if (y4.val) font.vertAlign = y4.val;
        break;
      case "<vertAlign/>":
      case "</vertAlign>":
        break;
      case "<family":
        if (y4.val) font.family = parseInt(y4.val, 10);
        break;
      case "<family/>":
      case "</family>":
        break;
      case "<scheme":
        if (y4.val) font.scheme = y4.val;
        break;
      case "<scheme/>":
      case "</scheme>":
        break;
      case "<charset":
        if (y4.val == "1") break;
        y4.codepage = CS2CP[parseInt(y4.val, 10)];
        break;
      case "<color":
        if (!font.color) font.color = {};
        if (y4.auto) font.color.auto = parsexmlbool(y4.auto);
        if (y4.rgb) font.color.rgb = y4.rgb.slice(-6);
        else if (y4.indexed) {
          font.color.index = parseInt(y4.indexed, 10);
          var icv = XLSIcv[font.color.index];
          if (font.color.index == 81) icv = XLSIcv[1];
          if (!icv) icv = XLSIcv[1];
          font.color.rgb = icv[0].toString(16) + icv[1].toString(16) + icv[2].toString(16);
        } else if (y4.theme) {
          font.color.theme = parseInt(y4.theme, 10);
          if (y4.tint) font.color.tint = parseFloat(y4.tint);
          if (y4.theme && themes.themeElements && themes.themeElements.clrScheme) {
            font.color.rgb = rgb_tint(themes.themeElements.clrScheme[font.color.theme].rgb, font.color.tint || 0);
          }
        }
        break;
      case "<color/>":
      case "</color>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y4[0] + " in fonts");
        }
    }
  });
}
function parse_numFmts(t3, styles, opts) {
  styles.NumberFmt = [];
  var k3 = keys(table_fmt);
  for (var i3 = 0; i3 < k3.length; ++i3) styles.NumberFmt[k3[i3]] = table_fmt[k3[i3]];
  var m4 = t3[0].match(tagregex);
  if (!m4) return;
  for (i3 = 0; i3 < m4.length; ++i3) {
    var y4 = parsexmltag(m4[i3]);
    switch (strip_ns(y4[0])) {
      case "<numFmts":
      case "</numFmts>":
      case "<numFmts/>":
      case "<numFmts>":
        break;
      case "<numFmt":
        {
          var f2 = unescapexml(utf8read(y4.formatCode)), j2 = parseInt(y4.numFmtId, 10);
          styles.NumberFmt[j2] = f2;
          if (j2 > 0) {
            if (j2 > 392) {
              for (j2 = 392; j2 > 60; --j2) if (styles.NumberFmt[j2] == null) break;
              styles.NumberFmt[j2] = f2;
            }
            SSF_load(f2, j2);
          }
        }
        break;
      case "</numFmt>":
        break;
      default:
        if (opts.WTF) throw new Error("unrecognized " + y4[0] + " in numFmts");
    }
  }
}
function write_numFmts(NF) {
  var o2 = ["<numFmts>"];
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r2) {
    for (var i3 = r2[0]; i3 <= r2[1]; ++i3) if (NF[i3] != null) o2[o2.length] = writextag("numFmt", null, { numFmtId: i3, formatCode: escapexml(NF[i3]) });
  });
  if (o2.length === 1) return "";
  o2[o2.length] = "</numFmts>";
  o2[0] = writextag("numFmts", null, { count: o2.length - 2 }).replace("/>", ">");
  return o2.join("");
}
var cellXF_uint = ["numFmtId", "fillId", "fontId", "borderId", "xfId"];
var cellXF_bool = ["applyAlignment", "applyBorder", "applyFill", "applyFont", "applyNumberFormat", "applyProtection", "pivotButton", "quotePrefix"];
function parse_cellXfs(t3, styles, opts) {
  styles.CellXf = [];
  var xf2;
  var pass = false;
  (t3[0].match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3), i3 = 0;
    switch (strip_ns(y4[0])) {
      case "<cellXfs":
      case "<cellXfs>":
      case "<cellXfs/>":
      case "</cellXfs>":
        break;
      case "<xf":
      case "<xf/>":
        xf2 = y4;
        delete xf2[0];
        for (i3 = 0; i3 < cellXF_uint.length; ++i3) if (xf2[cellXF_uint[i3]])
          xf2[cellXF_uint[i3]] = parseInt(xf2[cellXF_uint[i3]], 10);
        for (i3 = 0; i3 < cellXF_bool.length; ++i3) if (xf2[cellXF_bool[i3]])
          xf2[cellXF_bool[i3]] = parsexmlbool(xf2[cellXF_bool[i3]]);
        if (styles.NumberFmt && xf2.numFmtId > 392) {
          for (i3 = 392; i3 > 60; --i3) if (styles.NumberFmt[xf2.numFmtId] == styles.NumberFmt[i3]) {
            xf2.numFmtId = i3;
            break;
          }
        }
        styles.CellXf.push(xf2);
        break;
      case "</xf>":
        break;
      case "<alignment":
      case "<alignment/>":
        var alignment = {};
        if (y4.vertical) alignment.vertical = y4.vertical;
        if (y4.horizontal) alignment.horizontal = y4.horizontal;
        if (y4.textRotation != null) alignment.textRotation = y4.textRotation;
        if (y4.indent) alignment.indent = y4.indent;
        if (y4.wrapText) alignment.wrapText = parsexmlbool(y4.wrapText);
        xf2.alignment = alignment;
        break;
      case "</alignment>":
        break;
      case "<protection":
        break;
      case "</protection>":
      case "<protection/>":
        break;
      case "<AlternateContent":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (opts && opts.WTF) {
          if (!pass) throw new Error("unrecognized " + y4[0] + " in cellXfs");
        }
    }
  });
}
function write_cellXfs(cellXfs) {
  var o2 = [];
  o2[o2.length] = writextag("cellXfs", null);
  cellXfs.forEach(function(c3) {
    o2[o2.length] = writextag("xf", null, c3);
  });
  o2[o2.length] = "</cellXfs>";
  if (o2.length === 2) return "";
  o2[0] = writextag("cellXfs", null, { count: o2.length - 2 }).replace("/>", ">");
  return o2.join("");
}
var parse_sty_xml = /* @__PURE__ */ function make_pstyx() {
  var numFmtRegex = /<(?:\w+:)?numFmts([^>]*)>[\S\s]*?<\/(?:\w+:)?numFmts>/;
  var cellXfRegex = /<(?:\w+:)?cellXfs([^>]*)>[\S\s]*?<\/(?:\w+:)?cellXfs>/;
  var fillsRegex = /<(?:\w+:)?fills([^>]*)>[\S\s]*?<\/(?:\w+:)?fills>/;
  var fontsRegex = /<(?:\w+:)?fonts([^>]*)>[\S\s]*?<\/(?:\w+:)?fonts>/;
  var bordersRegex = /<(?:\w+:)?borders([^>]*)>[\S\s]*?<\/(?:\w+:)?borders>/;
  return function parse_sty_xml2(data, themes, opts) {
    var styles = {};
    if (!data) return styles;
    data = data.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
    var t3;
    if (t3 = data.match(numFmtRegex)) parse_numFmts(t3, styles, opts);
    if (t3 = data.match(fontsRegex)) parse_fonts(t3, styles, themes, opts);
    if (t3 = data.match(fillsRegex)) parse_fills(t3, styles, themes, opts);
    if (t3 = data.match(bordersRegex)) parse_borders(t3, styles, themes, opts);
    if (t3 = data.match(cellXfRegex)) parse_cellXfs(t3, styles, opts);
    return styles;
  };
}();
function write_sty_xml(wb2, opts) {
  var o2 = [XML_HEADER, writextag("styleSheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:vt": XMLNS.vt
  })], w3;
  if (wb2.SSF && (w3 = write_numFmts(wb2.SSF)) != null) o2[o2.length] = w3;
  o2[o2.length] = '<fonts count="1"><font><sz val="12"/><color theme="1"/><name val="Calibri"/><family val="2"/><scheme val="minor"/></font></fonts>';
  o2[o2.length] = '<fills count="2"><fill><patternFill patternType="none"/></fill><fill><patternFill patternType="gray125"/></fill></fills>';
  o2[o2.length] = '<borders count="1"><border><left/><right/><top/><bottom/><diagonal/></border></borders>';
  o2[o2.length] = '<cellStyleXfs count="1"><xf numFmtId="0" fontId="0" fillId="0" borderId="0"/></cellStyleXfs>';
  if (w3 = write_cellXfs(opts.cellXfs)) o2[o2.length] = w3;
  o2[o2.length] = '<cellStyles count="1"><cellStyle name="Normal" xfId="0" builtinId="0"/></cellStyles>';
  o2[o2.length] = '<dxfs count="0"/>';
  o2[o2.length] = '<tableStyles count="0" defaultTableStyle="TableStyleMedium9" defaultPivotStyle="PivotStyleMedium4"/>';
  if (o2.length > 2) {
    o2[o2.length] = "</styleSheet>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function parse_BrtFmt(data, length) {
  var numFmtId = data.read_shift(2);
  var stFmtCode = parse_XLWideString(data);
  return [numFmtId, stFmtCode];
}
function write_BrtFmt(i3, f2, o2) {
  if (!o2) o2 = new_buf(6 + 4 * f2.length);
  o2.write_shift(2, i3);
  write_XLWideString(f2, o2);
  var out = o2.length > o2.l ? o2.slice(0, o2.l) : o2;
  if (o2.l == null) o2.l = o2.length;
  return out;
}
function parse_BrtFont(data, length, opts) {
  var out = {};
  out.sz = data.read_shift(2) / 20;
  var grbit = parse_FontFlags(data);
  if (grbit.fItalic) out.italic = 1;
  if (grbit.fCondense) out.condense = 1;
  if (grbit.fExtend) out.extend = 1;
  if (grbit.fShadow) out.shadow = 1;
  if (grbit.fOutline) out.outline = 1;
  if (grbit.fStrikeout) out.strike = 1;
  var bls = data.read_shift(2);
  if (bls === 700) out.bold = 1;
  switch (data.read_shift(2)) {
    case 1:
      out.vertAlign = "superscript";
      break;
    case 2:
      out.vertAlign = "subscript";
      break;
  }
  var underline = data.read_shift(1);
  if (underline != 0) out.underline = underline;
  var family = data.read_shift(1);
  if (family > 0) out.family = family;
  var bCharSet = data.read_shift(1);
  if (bCharSet > 0) out.charset = bCharSet;
  data.l++;
  out.color = parse_BrtColor(data);
  switch (data.read_shift(1)) {
    case 1:
      out.scheme = "major";
      break;
    case 2:
      out.scheme = "minor";
      break;
  }
  out.name = parse_XLWideString(data);
  return out;
}
function write_BrtFont(font, o2) {
  if (!o2) o2 = new_buf(25 + 4 * 32);
  o2.write_shift(2, font.sz * 20);
  write_FontFlags(font, o2);
  o2.write_shift(2, font.bold ? 700 : 400);
  var sss = 0;
  if (font.vertAlign == "superscript") sss = 1;
  else if (font.vertAlign == "subscript") sss = 2;
  o2.write_shift(2, sss);
  o2.write_shift(1, font.underline || 0);
  o2.write_shift(1, font.family || 0);
  o2.write_shift(1, font.charset || 0);
  o2.write_shift(1, 0);
  write_BrtColor(font.color, o2);
  var scheme = 0;
  scheme = 2;
  o2.write_shift(1, scheme);
  write_XLWideString(font.name, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
var XLSBFillPTNames = [
  "none",
  "solid",
  "mediumGray",
  "darkGray",
  "lightGray",
  "darkHorizontal",
  "darkVertical",
  "darkDown",
  "darkUp",
  "darkGrid",
  "darkTrellis",
  "lightHorizontal",
  "lightVertical",
  "lightDown",
  "lightUp",
  "lightGrid",
  "lightTrellis",
  "gray125",
  "gray0625"
];
var rev_XLSBFillPTNames;
var parse_BrtFill = parsenoop;
function write_BrtFill(fill2, o2) {
  if (!o2) o2 = new_buf(4 * 3 + 8 * 7 + 16 * 1);
  if (!rev_XLSBFillPTNames) rev_XLSBFillPTNames = evert(XLSBFillPTNames);
  var fls = rev_XLSBFillPTNames[fill2.patternType];
  if (fls == null) fls = 40;
  o2.write_shift(4, fls);
  var j2 = 0;
  if (fls != 40) {
    write_BrtColor({ auto: 1 }, o2);
    write_BrtColor({ auto: 1 }, o2);
    for (; j2 < 12; ++j2) o2.write_shift(4, 0);
  } else {
    for (; j2 < 4; ++j2) o2.write_shift(4, 0);
    for (; j2 < 12; ++j2) o2.write_shift(4, 0);
  }
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function parse_BrtXF(data, length) {
  var tgt = data.l + length;
  var ixfeParent = data.read_shift(2);
  var ifmt = data.read_shift(2);
  data.l = tgt;
  return { ixfe: ixfeParent, numFmtId: ifmt };
}
function write_BrtXF(data, ixfeP, o2) {
  if (!o2) o2 = new_buf(16);
  o2.write_shift(2, ixfeP || 0);
  o2.write_shift(2, data.numFmtId || 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  var flow = 0;
  o2.write_shift(1, flow);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  return o2;
}
function write_Blxf(data, o2) {
  if (!o2) o2 = new_buf(10);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
var parse_BrtBorder = parsenoop;
function write_BrtBorder(border, o2) {
  if (!o2) o2 = new_buf(51);
  o2.write_shift(1, 0);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  write_Blxf(null, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function write_BrtStyle(style, o2) {
  if (!o2) o2 = new_buf(12 + 4 * 10);
  o2.write_shift(4, style.xfId);
  o2.write_shift(2, 1);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  write_XLNullableWideString(style.name || "", o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function write_BrtBeginTableStyles(cnt, defTableStyle, defPivotStyle) {
  var o2 = new_buf(4 + 256 * 2 * 4);
  o2.write_shift(4, cnt);
  write_XLNullableWideString(defTableStyle, o2);
  write_XLNullableWideString(defPivotStyle, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function parse_sty_bin(data, themes, opts) {
  var styles = {};
  styles.NumberFmt = [];
  for (var y4 in table_fmt) styles.NumberFmt[y4] = table_fmt[y4];
  styles.CellXf = [];
  styles.Fonts = [];
  var state = [];
  var pass = false;
  recordhopper(data, function hopper_sty(val, R3, RT) {
    switch (RT) {
      case 44:
        styles.NumberFmt[val[0]] = val[1];
        SSF_load(val[1], val[0]);
        break;
      case 43:
        styles.Fonts.push(val);
        if (val.color.theme != null && themes && themes.themeElements && themes.themeElements.clrScheme) {
          val.color.rgb = rgb_tint(themes.themeElements.clrScheme[val.color.theme].rgb, val.color.tint || 0);
        }
        break;
      case 1025:
        break;
      case 45:
        break;
      case 46:
        break;
      case 47:
        if (state[state.length - 1] == 617) {
          styles.CellXf.push(val);
        }
        break;
      case 48:
      case 507:
      case 572:
      case 475:
        break;
      case 1171:
      case 2102:
      case 1130:
      case 512:
      case 2095:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      default:
        if (R3.T > 0) state.push(RT);
        else if (R3.T < 0) state.pop();
        else if (!pass || opts.WTF && state[state.length - 1] != 37) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return styles;
}
function write_FMTS_bin(ba, NF) {
  if (!NF) return;
  var cnt = 0;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r2) {
    for (var i3 = r2[0]; i3 <= r2[1]; ++i3) if (NF[i3] != null) ++cnt;
  });
  if (cnt == 0) return;
  write_record(ba, 615, write_UInt32LE(cnt));
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r2) {
    for (var i3 = r2[0]; i3 <= r2[1]; ++i3) if (NF[i3] != null) write_record(ba, 44, write_BrtFmt(i3, NF[i3]));
  });
  write_record(
    ba,
    616
    /* BrtEndFmts */
  );
}
function write_FONTS_bin(ba) {
  var cnt = 1;
  write_record(ba, 611, write_UInt32LE(cnt));
  write_record(ba, 43, write_BrtFont({
    sz: 12,
    color: { theme: 1 },
    name: "Calibri",
    family: 2
  }));
  write_record(
    ba,
    612
    /* BrtEndFonts */
  );
}
function write_FILLS_bin(ba) {
  var cnt = 2;
  write_record(ba, 603, write_UInt32LE(cnt));
  write_record(ba, 45, write_BrtFill({ patternType: "none" }));
  write_record(ba, 45, write_BrtFill({ patternType: "gray125" }));
  write_record(
    ba,
    604
    /* BrtEndFills */
  );
}
function write_BORDERS_bin(ba) {
  var cnt = 1;
  write_record(ba, 613, write_UInt32LE(cnt));
  write_record(ba, 46, write_BrtBorder());
  write_record(
    ba,
    614
    /* BrtEndBorders */
  );
}
function write_CELLSTYLEXFS_bin(ba) {
  var cnt = 1;
  write_record(ba, 626, write_UInt32LE(cnt));
  write_record(ba, 47, write_BrtXF({
    numFmtId: 0
  }, 65535));
  write_record(
    ba,
    627
    /* BrtEndCellStyleXFs */
  );
}
function write_CELLXFS_bin(ba, data) {
  write_record(ba, 617, write_UInt32LE(data.length));
  data.forEach(function(c3) {
    write_record(ba, 47, write_BrtXF(c3, 0));
  });
  write_record(
    ba,
    618
    /* BrtEndCellXFs */
  );
}
function write_STYLES_bin(ba) {
  var cnt = 1;
  write_record(ba, 619, write_UInt32LE(cnt));
  write_record(ba, 48, write_BrtStyle({
    xfId: 0,
    name: "Normal"
  }));
  write_record(
    ba,
    620
    /* BrtEndStyles */
  );
}
function write_DXFS_bin(ba) {
  var cnt = 0;
  write_record(ba, 505, write_UInt32LE(cnt));
  write_record(
    ba,
    506
    /* BrtEndDXFs */
  );
}
function write_TABLESTYLES_bin(ba) {
  var cnt = 0;
  write_record(ba, 508, write_BrtBeginTableStyles(cnt, "TableStyleMedium9", "PivotStyleMedium4"));
  write_record(
    ba,
    509
    /* BrtEndTableStyles */
  );
}
function write_sty_bin(wb2, opts) {
  var ba = buf_array();
  write_record(
    ba,
    278
    /* BrtBeginStyleSheet */
  );
  write_FMTS_bin(ba, wb2.SSF);
  write_FONTS_bin(ba);
  write_FILLS_bin(ba);
  write_BORDERS_bin(ba);
  write_CELLSTYLEXFS_bin(ba);
  write_CELLXFS_bin(ba, opts.cellXfs);
  write_STYLES_bin(ba);
  write_DXFS_bin(ba);
  write_TABLESTYLES_bin(ba);
  write_record(
    ba,
    279
    /* BrtEndStyleSheet */
  );
  return ba.end();
}
var XLSXThemeClrScheme = [
  "</a:lt1>",
  "</a:dk1>",
  "</a:lt2>",
  "</a:dk2>",
  "</a:accent1>",
  "</a:accent2>",
  "</a:accent3>",
  "</a:accent4>",
  "</a:accent5>",
  "</a:accent6>",
  "</a:hlink>",
  "</a:folHlink>"
];
function parse_clrScheme(t3, themes, opts) {
  themes.themeElements.clrScheme = [];
  var color = {};
  (t3[0].match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (y4[0]) {
      case "<a:clrScheme":
      case "</a:clrScheme>":
        break;
      case "<a:srgbClr":
        color.rgb = y4.val;
        break;
      case "<a:sysClr":
        color.rgb = y4.lastClr;
        break;
      case "<a:dk1>":
      case "</a:dk1>":
      case "<a:lt1>":
      case "</a:lt1>":
      case "<a:dk2>":
      case "</a:dk2>":
      case "<a:lt2>":
      case "</a:lt2>":
      case "<a:accent1>":
      case "</a:accent1>":
      case "<a:accent2>":
      case "</a:accent2>":
      case "<a:accent3>":
      case "</a:accent3>":
      case "<a:accent4>":
      case "</a:accent4>":
      case "<a:accent5>":
      case "</a:accent5>":
      case "<a:accent6>":
      case "</a:accent6>":
      case "<a:hlink>":
      case "</a:hlink>":
      case "<a:folHlink>":
      case "</a:folHlink>":
        if (y4[0].charAt(1) === "/") {
          themes.themeElements.clrScheme[XLSXThemeClrScheme.indexOf(y4[0])] = color;
          color = {};
        } else {
          color.name = y4[0].slice(3, y4[0].length - 1);
        }
        break;
      default:
        if (opts && opts.WTF) throw new Error("Unrecognized " + y4[0] + " in clrScheme");
    }
  });
}
function parse_fontScheme() {
}
function parse_fmtScheme() {
}
var clrsregex = /<a:clrScheme([^>]*)>[\s\S]*<\/a:clrScheme>/;
var fntsregex = /<a:fontScheme([^>]*)>[\s\S]*<\/a:fontScheme>/;
var fmtsregex = /<a:fmtScheme([^>]*)>[\s\S]*<\/a:fmtScheme>/;
function parse_themeElements(data, themes, opts) {
  themes.themeElements = {};
  var t3;
  [
    /* clrScheme CT_ColorScheme */
    ["clrScheme", clrsregex, parse_clrScheme],
    /* fontScheme CT_FontScheme */
    ["fontScheme", fntsregex, parse_fontScheme],
    /* fmtScheme CT_StyleMatrix */
    ["fmtScheme", fmtsregex, parse_fmtScheme]
  ].forEach(function(m4) {
    if (!(t3 = data.match(m4[1]))) throw new Error(m4[0] + " not found in themeElements");
    m4[2](t3, themes, opts);
  });
}
var themeltregex = /<a:themeElements([^>]*)>[\s\S]*<\/a:themeElements>/;
function parse_theme_xml(data, opts) {
  if (!data || data.length === 0) data = write_theme();
  var t3;
  var themes = {};
  if (!(t3 = data.match(themeltregex))) throw new Error("themeElements not found in theme");
  parse_themeElements(t3[0], themes, opts);
  themes.raw = data;
  return themes;
}
function write_theme(Themes, opts) {
  if (opts && opts.themeXLSX) return opts.themeXLSX;
  if (Themes && typeof Themes.raw == "string") return Themes.raw;
  var o2 = [XML_HEADER];
  o2[o2.length] = '<a:theme xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main" name="Office Theme">';
  o2[o2.length] = "<a:themeElements>";
  o2[o2.length] = '<a:clrScheme name="Office">';
  o2[o2.length] = '<a:dk1><a:sysClr val="windowText" lastClr="000000"/></a:dk1>';
  o2[o2.length] = '<a:lt1><a:sysClr val="window" lastClr="FFFFFF"/></a:lt1>';
  o2[o2.length] = '<a:dk2><a:srgbClr val="1F497D"/></a:dk2>';
  o2[o2.length] = '<a:lt2><a:srgbClr val="EEECE1"/></a:lt2>';
  o2[o2.length] = '<a:accent1><a:srgbClr val="4F81BD"/></a:accent1>';
  o2[o2.length] = '<a:accent2><a:srgbClr val="C0504D"/></a:accent2>';
  o2[o2.length] = '<a:accent3><a:srgbClr val="9BBB59"/></a:accent3>';
  o2[o2.length] = '<a:accent4><a:srgbClr val="8064A2"/></a:accent4>';
  o2[o2.length] = '<a:accent5><a:srgbClr val="4BACC6"/></a:accent5>';
  o2[o2.length] = '<a:accent6><a:srgbClr val="F79646"/></a:accent6>';
  o2[o2.length] = '<a:hlink><a:srgbClr val="0000FF"/></a:hlink>';
  o2[o2.length] = '<a:folHlink><a:srgbClr val="800080"/></a:folHlink>';
  o2[o2.length] = "</a:clrScheme>";
  o2[o2.length] = '<a:fontScheme name="Office">';
  o2[o2.length] = "<a:majorFont>";
  o2[o2.length] = '<a:latin typeface="Cambria"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
  o2[o2.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
  o2[o2.length] = '<a:font script="Hans" typeface="宋体"/>';
  o2[o2.length] = '<a:font script="Hant" typeface="新細明體"/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="MoolBoran"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Times New Roman"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:majorFont>";
  o2[o2.length] = "<a:minorFont>";
  o2[o2.length] = '<a:latin typeface="Calibri"/>';
  o2[o2.length] = '<a:ea typeface=""/>';
  o2[o2.length] = '<a:cs typeface=""/>';
  o2[o2.length] = '<a:font script="Jpan" typeface="ＭＳ Ｐゴシック"/>';
  o2[o2.length] = '<a:font script="Hang" typeface="맑은 고딕"/>';
  o2[o2.length] = '<a:font script="Hans" typeface="宋体"/>';
  o2[o2.length] = '<a:font script="Hant" typeface="新細明體"/>';
  o2[o2.length] = '<a:font script="Arab" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Hebr" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Thai" typeface="Tahoma"/>';
  o2[o2.length] = '<a:font script="Ethi" typeface="Nyala"/>';
  o2[o2.length] = '<a:font script="Beng" typeface="Vrinda"/>';
  o2[o2.length] = '<a:font script="Gujr" typeface="Shruti"/>';
  o2[o2.length] = '<a:font script="Khmr" typeface="DaunPenh"/>';
  o2[o2.length] = '<a:font script="Knda" typeface="Tunga"/>';
  o2[o2.length] = '<a:font script="Guru" typeface="Raavi"/>';
  o2[o2.length] = '<a:font script="Cans" typeface="Euphemia"/>';
  o2[o2.length] = '<a:font script="Cher" typeface="Plantagenet Cherokee"/>';
  o2[o2.length] = '<a:font script="Yiii" typeface="Microsoft Yi Baiti"/>';
  o2[o2.length] = '<a:font script="Tibt" typeface="Microsoft Himalaya"/>';
  o2[o2.length] = '<a:font script="Thaa" typeface="MV Boli"/>';
  o2[o2.length] = '<a:font script="Deva" typeface="Mangal"/>';
  o2[o2.length] = '<a:font script="Telu" typeface="Gautami"/>';
  o2[o2.length] = '<a:font script="Taml" typeface="Latha"/>';
  o2[o2.length] = '<a:font script="Syrc" typeface="Estrangelo Edessa"/>';
  o2[o2.length] = '<a:font script="Orya" typeface="Kalinga"/>';
  o2[o2.length] = '<a:font script="Mlym" typeface="Kartika"/>';
  o2[o2.length] = '<a:font script="Laoo" typeface="DokChampa"/>';
  o2[o2.length] = '<a:font script="Sinh" typeface="Iskoola Pota"/>';
  o2[o2.length] = '<a:font script="Mong" typeface="Mongolian Baiti"/>';
  o2[o2.length] = '<a:font script="Viet" typeface="Arial"/>';
  o2[o2.length] = '<a:font script="Uigh" typeface="Microsoft Uighur"/>';
  o2[o2.length] = '<a:font script="Geor" typeface="Sylfaen"/>';
  o2[o2.length] = "</a:minorFont>";
  o2[o2.length] = "</a:fontScheme>";
  o2[o2.length] = '<a:fmtScheme name="Office">';
  o2[o2.length] = "<a:fillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="50000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="35000"><a:schemeClr val="phClr"><a:tint val="37000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="15000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="1"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="100000"/><a:shade val="100000"/><a:satMod val="130000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:tint val="50000"/><a:shade val="100000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:lin ang="16200000" scaled="0"/>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:fillStyleLst>";
  o2[o2.length] = "<a:lnStyleLst>";
  o2[o2.length] = '<a:ln w="9525" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"><a:shade val="95000"/><a:satMod val="105000"/></a:schemeClr></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="25400" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = '<a:ln w="38100" cap="flat" cmpd="sng" algn="ctr"><a:solidFill><a:schemeClr val="phClr"/></a:solidFill><a:prstDash val="solid"/></a:ln>';
  o2[o2.length] = "</a:lnStyleLst>";
  o2[o2.length] = "<a:effectStyleLst>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="20000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="38000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "<a:effectStyle>";
  o2[o2.length] = "<a:effectLst>";
  o2[o2.length] = '<a:outerShdw blurRad="40000" dist="23000" dir="5400000" rotWithShape="0"><a:srgbClr val="000000"><a:alpha val="35000"/></a:srgbClr></a:outerShdw>';
  o2[o2.length] = "</a:effectLst>";
  o2[o2.length] = '<a:scene3d><a:camera prst="orthographicFront"><a:rot lat="0" lon="0" rev="0"/></a:camera><a:lightRig rig="threePt" dir="t"><a:rot lat="0" lon="0" rev="1200000"/></a:lightRig></a:scene3d>';
  o2[o2.length] = '<a:sp3d><a:bevelT w="63500" h="25400"/></a:sp3d>';
  o2[o2.length] = "</a:effectStyle>";
  o2[o2.length] = "</a:effectStyleLst>";
  o2[o2.length] = "<a:bgFillStyleLst>";
  o2[o2.length] = '<a:solidFill><a:schemeClr val="phClr"/></a:solidFill>';
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="40000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="40000"><a:schemeClr val="phClr"><a:tint val="45000"/><a:shade val="99000"/><a:satMod val="350000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="20000"/><a:satMod val="255000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="-80000" r="50000" b="180000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = '<a:gradFill rotWithShape="1">';
  o2[o2.length] = "<a:gsLst>";
  o2[o2.length] = '<a:gs pos="0"><a:schemeClr val="phClr"><a:tint val="80000"/><a:satMod val="300000"/></a:schemeClr></a:gs>';
  o2[o2.length] = '<a:gs pos="100000"><a:schemeClr val="phClr"><a:shade val="30000"/><a:satMod val="200000"/></a:schemeClr></a:gs>';
  o2[o2.length] = "</a:gsLst>";
  o2[o2.length] = '<a:path path="circle"><a:fillToRect l="50000" t="50000" r="50000" b="50000"/></a:path>';
  o2[o2.length] = "</a:gradFill>";
  o2[o2.length] = "</a:bgFillStyleLst>";
  o2[o2.length] = "</a:fmtScheme>";
  o2[o2.length] = "</a:themeElements>";
  o2[o2.length] = "<a:objectDefaults>";
  o2[o2.length] = "<a:spDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="1"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="3"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="2"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="lt1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:spDef>";
  o2[o2.length] = "<a:lnDef>";
  o2[o2.length] = '<a:spPr/><a:bodyPr/><a:lstStyle/><a:style><a:lnRef idx="2"><a:schemeClr val="accent1"/></a:lnRef><a:fillRef idx="0"><a:schemeClr val="accent1"/></a:fillRef><a:effectRef idx="1"><a:schemeClr val="accent1"/></a:effectRef><a:fontRef idx="minor"><a:schemeClr val="tx1"/></a:fontRef></a:style>';
  o2[o2.length] = "</a:lnDef>";
  o2[o2.length] = "</a:objectDefaults>";
  o2[o2.length] = "<a:extraClrSchemeLst/>";
  o2[o2.length] = "</a:theme>";
  return o2.join("");
}
function parse_Theme(blob, length, opts) {
  var end = blob.l + length;
  var dwThemeVersion = blob.read_shift(4);
  if (dwThemeVersion === 124226) return;
  if (!opts.cellStyles) {
    blob.l = end;
    return;
  }
  var data = blob.slice(blob.l);
  blob.l = end;
  var zip;
  try {
    zip = zip_read(data, { type: "array" });
  } catch (e3) {
    return;
  }
  var themeXML = getzipstr(zip, "theme/theme/theme1.xml", true);
  if (!themeXML) return;
  return parse_theme_xml(themeXML, opts);
}
function parse_ColorTheme(blob) {
  return blob.read_shift(4);
}
function parse_FullColorExt(blob) {
  var o2 = {};
  o2.xclrType = blob.read_shift(2);
  o2.nTintShade = blob.read_shift(2);
  switch (o2.xclrType) {
    case 0:
      blob.l += 4;
      break;
    case 1:
      o2.xclrValue = parse_IcvXF(blob, 4);
      break;
    case 2:
      o2.xclrValue = parse_LongRGBA(blob);
      break;
    case 3:
      o2.xclrValue = parse_ColorTheme(blob);
      break;
    case 4:
      blob.l += 4;
      break;
  }
  blob.l += 8;
  return o2;
}
function parse_IcvXF(blob, length) {
  return parsenoop(blob, length);
}
function parse_XFExtGradient(blob, length) {
  return parsenoop(blob, length);
}
function parse_ExtProp(blob) {
  var extType = blob.read_shift(2);
  var cb2 = blob.read_shift(2) - 4;
  var o2 = [extType];
  switch (extType) {
    case 4:
    case 5:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 13:
      o2[1] = parse_FullColorExt(blob);
      break;
    case 6:
      o2[1] = parse_XFExtGradient(blob, cb2);
      break;
    case 14:
    case 15:
      o2[1] = blob.read_shift(cb2 === 1 ? 1 : 2);
      break;
    default:
      throw new Error("Unrecognized ExtProp type: " + extType + " " + cb2);
  }
  return o2;
}
function parse_XFExt(blob, length) {
  var end = blob.l + length;
  blob.l += 2;
  var ixfe = blob.read_shift(2);
  blob.l += 2;
  var cexts = blob.read_shift(2);
  var ext = [];
  while (cexts-- > 0) ext.push(parse_ExtProp(blob, end - blob.l));
  return { ixfe, ext };
}
function update_xfext(xf2, xfext) {
  xfext.forEach(function(xfe) {
    switch (xfe[0]) {
    }
  });
}
function parse_BrtMdtinfo(data, length) {
  return {
    flags: data.read_shift(4),
    version: data.read_shift(4),
    name: parse_XLWideString(data)
  };
}
function write_BrtMdtinfo(data) {
  var o2 = new_buf(12 + 2 * data.name.length);
  o2.write_shift(4, data.flags);
  o2.write_shift(4, data.version);
  write_XLWideString(data.name, o2);
  return o2.slice(0, o2.l);
}
function parse_BrtMdb(data) {
  var out = [];
  var cnt = data.read_shift(4);
  while (cnt-- > 0)
    out.push([data.read_shift(4), data.read_shift(4)]);
  return out;
}
function write_BrtMdb(mdb) {
  var o2 = new_buf(4 + 8 * mdb.length);
  o2.write_shift(4, mdb.length);
  for (var i3 = 0; i3 < mdb.length; ++i3) {
    o2.write_shift(4, mdb[i3][0]);
    o2.write_shift(4, mdb[i3][1]);
  }
  return o2;
}
function write_BrtBeginEsfmd(cnt, name) {
  var o2 = new_buf(8 + 2 * name.length);
  o2.write_shift(4, cnt);
  write_XLWideString(name, o2);
  return o2.slice(0, o2.l);
}
function parse_BrtBeginEsmdb(data) {
  data.l += 4;
  return data.read_shift(4) != 0;
}
function write_BrtBeginEsmdb(cnt, cm) {
  var o2 = new_buf(8);
  o2.write_shift(4, cnt);
  o2.write_shift(4, 1);
  return o2;
}
function parse_xlmeta_bin(data, name, _opts) {
  var out = { Types: [], Cell: [], Value: [] };
  var opts = _opts || {};
  var state = [];
  var pass = false;
  var metatype = 2;
  recordhopper(data, function(val, R3, RT) {
    switch (RT) {
      case 335:
        out.Types.push({ name: val.name });
        break;
      case 51:
        val.forEach(function(r2) {
          if (metatype == 1)
            out.Cell.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
          else if (metatype == 0)
            out.Value.push({ type: out.Types[r2[0] - 1].name, index: r2[1] });
        });
        break;
      case 337:
        metatype = val ? 1 : 0;
        break;
      case 338:
        metatype = 2;
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      default:
        if (R3.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 35)
          throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_xlmeta_bin() {
  var ba = buf_array();
  write_record(ba, 332);
  write_record(ba, 334, write_UInt32LE(1));
  write_record(ba, 335, write_BrtMdtinfo({
    name: "XLDAPR",
    version: 12e4,
    flags: 3496657072
  }));
  write_record(ba, 336);
  write_record(ba, 339, write_BrtBeginEsfmd(1, "XLDAPR"));
  write_record(ba, 52);
  write_record(ba, 35, write_UInt32LE(514));
  write_record(ba, 4096, write_UInt32LE(0));
  write_record(ba, 4097, writeuint16(1));
  write_record(ba, 36);
  write_record(ba, 53);
  write_record(ba, 340);
  write_record(ba, 337, write_BrtBeginEsmdb(1));
  write_record(ba, 51, write_BrtMdb([[1, 0]]));
  write_record(ba, 338);
  write_record(ba, 333);
  return ba.end();
}
function parse_xlmeta_xml(data, name, opts) {
  var out = { Types: [], Cell: [], Value: [] };
  if (!data)
    return out;
  var pass = false;
  var metatype = 2;
  var lastmeta;
  data.replace(tagregex, function(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<?xml":
        break;
      case "<metadata":
      case "</metadata>":
        break;
      case "<metadataTypes":
      case "</metadataTypes>":
        break;
      case "<metadataType":
        out.Types.push({ name: y4.name });
        break;
      case "</metadataType>":
        break;
      case "<futureMetadata":
        for (var j2 = 0; j2 < out.Types.length; ++j2)
          if (out.Types[j2].name == y4.name)
            lastmeta = out.Types[j2];
        break;
      case "</futureMetadata>":
        break;
      case "<bk>":
        break;
      case "</bk>":
        break;
      case "<rc":
        if (metatype == 1)
          out.Cell.push({ type: out.Types[y4.t - 1].name, index: +y4.v });
        else if (metatype == 0)
          out.Value.push({ type: out.Types[y4.t - 1].name, index: +y4.v });
        break;
      case "</rc>":
        break;
      case "<cellMetadata":
        metatype = 1;
        break;
      case "</cellMetadata>":
        metatype = 2;
        break;
      case "<valueMetadata":
        metatype = 0;
        break;
      case "</valueMetadata>":
        metatype = 2;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<rvb":
        if (!lastmeta)
          break;
        if (!lastmeta.offsets)
          lastmeta.offsets = [];
        lastmeta.offsets.push(+y4.i);
        break;
      default:
        if (!pass && opts.WTF)
          throw new Error("unrecognized " + y4[0] + " in metadata");
    }
    return x3;
  });
  return out;
}
function write_xlmeta_xml() {
  var o2 = [XML_HEADER];
  o2.push('<metadata xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:xlrd="http://schemas.microsoft.com/office/spreadsheetml/2017/richdata" xmlns:xda="http://schemas.microsoft.com/office/spreadsheetml/2017/dynamicarray">\n  <metadataTypes count="1">\n    <metadataType name="XLDAPR" minSupportedVersion="120000" copy="1" pasteAll="1" pasteValues="1" merge="1" splitFirst="1" rowColShift="1" clearFormats="1" clearComments="1" assign="1" coerce="1" cellMeta="1"/>\n  </metadataTypes>\n  <futureMetadata name="XLDAPR" count="1">\n    <bk>\n      <extLst>\n        <ext uri="{bdbb8cdc-fa1e-496e-a857-3c3f30c029c3}">\n          <xda:dynamicArrayProperties fDynamic="1" fCollapsed="0"/>\n        </ext>\n      </extLst>\n    </bk>\n  </futureMetadata>\n  <cellMetadata count="1">\n    <bk>\n      <rc t="1" v="0"/>\n    </bk>\n  </cellMetadata>\n</metadata>');
  return o2.join("");
}
function parse_cc_xml(data) {
  var d4 = [];
  if (!data) return d4;
  var i3 = 1;
  (data.match(tagregex) || []).forEach(function(x3) {
    var y4 = parsexmltag(x3);
    switch (y4[0]) {
      case "<?xml":
        break;
      case "<calcChain":
      case "<calcChain>":
      case "</calcChain>":
        break;
      case "<c":
        delete y4[0];
        if (y4.i) i3 = y4.i;
        else y4.i = i3;
        d4.push(y4);
        break;
    }
  });
  return d4;
}
function parse_BrtCalcChainItem$(data) {
  var out = {};
  out.i = data.read_shift(4);
  var cell = {};
  cell.r = data.read_shift(4);
  cell.c = data.read_shift(4);
  out.r = encode_cell(cell);
  var flags = data.read_shift(1);
  if (flags & 2) out.l = "1";
  if (flags & 8) out.a = "1";
  return out;
}
function parse_cc_bin(data, name, opts) {
  var out = [];
  recordhopper(data, function hopper_cc(val, R3, RT) {
    switch (RT) {
      case 63:
        out.push(val);
        break;
      default:
        if (R3.T) ;
        else throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function parse_xlink_xml() {
}
function parse_xlink_bin(data, rel, name, _opts) {
  if (!data) return data;
  var opts = _opts || {};
  var pass = false;
  recordhopper(data, function xlink_parse(val, R3, RT) {
    switch (RT) {
      case 359:
      case 363:
      case 364:
      case 366:
      case 367:
      case 368:
      case 369:
      case 370:
      case 371:
      case 472:
      case 577:
      case 578:
      case 579:
      case 580:
      case 581:
      case 582:
      case 583:
      case 584:
      case 585:
      case 586:
      case 587:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      default:
        if (R3.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
}
function parse_drawing(data, rels) {
  if (!data) return "??";
  var id2 = (data.match(/<c:chart [^>]*r:id="([^"]*)"/) || ["", ""])[1];
  return rels["!id"][id2].Target;
}
var _shapeid = 1024;
function write_comments_vml(rId, comments) {
  var csize = [21600, 21600];
  var bbox = ["m0,0l0", csize[1], csize[0], csize[1], csize[0], "0xe"].join(",");
  var o2 = [
    writextag("xml", null, { "xmlns:v": XLMLNS.v, "xmlns:o": XLMLNS.o, "xmlns:x": XLMLNS.x, "xmlns:mv": XLMLNS.mv }).replace(/\/>/, ">"),
    writextag("o:shapelayout", writextag("o:idmap", null, { "v:ext": "edit", "data": rId }), { "v:ext": "edit" }),
    writextag("v:shapetype", [
      writextag("v:stroke", null, { joinstyle: "miter" }),
      writextag("v:path", null, { gradientshapeok: "t", "o:connecttype": "rect" })
    ].join(""), { id: "_x0000_t202", "o:spt": 202, coordsize: csize.join(","), path: bbox })
  ];
  while (_shapeid < rId * 1e3) _shapeid += 1e3;
  comments.forEach(function(x3) {
    var c3 = decode_cell(x3[0]);
    var fillopts = (
      /*::(*/
      { "color2": "#BEFF82", "type": "gradient" }
    );
    if (fillopts.type == "gradient") fillopts.angle = "-180";
    var fillparm = fillopts.type == "gradient" ? writextag("o:fill", null, { type: "gradientUnscaled", "v:ext": "view" }) : null;
    var fillxml = writextag("v:fill", fillparm, fillopts);
    var shadata = { on: "t", "obscured": "t" };
    ++_shapeid;
    o2 = o2.concat([
      "<v:shape" + wxt_helper({
        id: "_x0000_s" + _shapeid,
        type: "#_x0000_t202",
        style: "position:absolute; margin-left:80pt;margin-top:5pt;width:104pt;height:64pt;z-index:10" + (x3[1].hidden ? ";visibility:hidden" : ""),
        fillcolor: "#ECFAD4",
        strokecolor: "#edeaa1"
      }) + ">",
      fillxml,
      writextag("v:shadow", null, shadata),
      writextag("v:path", null, { "o:connecttype": "none" }),
      '<v:textbox><div style="text-align:left"></div></v:textbox>',
      '<x:ClientData ObjectType="Note">',
      "<x:MoveWithCells/>",
      "<x:SizeWithCells/>",
      /* Part 4 19.4.2.3 Anchor (Anchor) */
      writetag("x:Anchor", [c3.c + 1, 0, c3.r + 1, 0, c3.c + 3, 20, c3.r + 5, 20].join(",")),
      writetag("x:AutoFill", "False"),
      writetag("x:Row", String(c3.r)),
      writetag("x:Column", String(c3.c)),
      x3[1].hidden ? "" : "<x:Visible/>",
      "</x:ClientData>",
      "</v:shape>"
    ]);
  });
  o2.push("</xml>");
  return o2.join("");
}
function sheet_insert_comments(sheet, comments, threaded, people) {
  var dense = Array.isArray(sheet);
  var cell;
  comments.forEach(function(comment) {
    var r2 = decode_cell(comment.ref);
    if (dense) {
      if (!sheet[r2.r]) sheet[r2.r] = [];
      cell = sheet[r2.r][r2.c];
    } else cell = sheet[comment.ref];
    if (!cell) {
      cell = { t: "z" };
      if (dense) sheet[r2.r][r2.c] = cell;
      else sheet[comment.ref] = cell;
      var range = safe_decode_range(sheet["!ref"] || "BDWGO1000001:A1");
      if (range.s.r > r2.r) range.s.r = r2.r;
      if (range.e.r < r2.r) range.e.r = r2.r;
      if (range.s.c > r2.c) range.s.c = r2.c;
      if (range.e.c < r2.c) range.e.c = r2.c;
      var encoded = encode_range(range);
      if (encoded !== sheet["!ref"]) sheet["!ref"] = encoded;
    }
    if (!cell.c) cell.c = [];
    var o2 = { a: comment.author, t: comment.t, r: comment.r, T: threaded };
    if (comment.h) o2.h = comment.h;
    for (var i3 = cell.c.length - 1; i3 >= 0; --i3) {
      if (!threaded && cell.c[i3].T) return;
      if (threaded && !cell.c[i3].T) cell.c.splice(i3, 1);
    }
    if (threaded && people) for (i3 = 0; i3 < people.length; ++i3) {
      if (o2.a == people[i3].id) {
        o2.a = people[i3].name || o2.a;
        break;
      }
    }
    cell.c.push(o2);
  });
}
function parse_comments_xml(data, opts) {
  if (data.match(/<(?:\w+:)?comments *\/>/)) return [];
  var authors = [];
  var commentList = [];
  var authtag = data.match(/<(?:\w+:)?authors>([\s\S]*)<\/(?:\w+:)?authors>/);
  if (authtag && authtag[1]) authtag[1].split(/<\/\w*:?author>/).forEach(function(x3) {
    if (x3 === "" || x3.trim() === "") return;
    var a4 = x3.match(/<(?:\w+:)?author[^>]*>(.*)/);
    if (a4) authors.push(a4[1]);
  });
  var cmnttag = data.match(/<(?:\w+:)?commentList>([\s\S]*)<\/(?:\w+:)?commentList>/);
  if (cmnttag && cmnttag[1]) cmnttag[1].split(/<\/\w*:?comment>/).forEach(function(x3) {
    if (x3 === "" || x3.trim() === "") return;
    var cm = x3.match(/<(?:\w+:)?comment[^>]*>/);
    if (!cm) return;
    var y4 = parsexmltag(cm[0]);
    var comment = { author: y4.authorId && authors[y4.authorId] || "sheetjsghost", ref: y4.ref, guid: y4.guid };
    var cell = decode_cell(y4.ref);
    if (opts.sheetRows && opts.sheetRows <= cell.r) return;
    var textMatch = x3.match(/<(?:\w+:)?text>([\s\S]*)<\/(?:\w+:)?text>/);
    var rt = !!textMatch && !!textMatch[1] && parse_si(textMatch[1]) || { r: "", t: "", h: "" };
    comment.r = rt.r;
    if (rt.r == "<t></t>") rt.t = rt.h = "";
    comment.t = (rt.t || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    if (opts.cellHTML) comment.h = rt.h;
    commentList.push(comment);
  });
  return commentList;
}
function write_comments_xml(data) {
  var o2 = [XML_HEADER, writextag("comments", null, { "xmlns": XMLNS_main[0] })];
  var iauthor = [];
  o2.push("<authors>");
  data.forEach(function(x3) {
    x3[1].forEach(function(w3) {
      var a4 = escapexml(w3.a);
      if (iauthor.indexOf(a4) == -1) {
        iauthor.push(a4);
        o2.push("<author>" + a4 + "</author>");
      }
      if (w3.T && w3.ID && iauthor.indexOf("tc=" + w3.ID) == -1) {
        iauthor.push("tc=" + w3.ID);
        o2.push("<author>tc=" + w3.ID + "</author>");
      }
    });
  });
  if (iauthor.length == 0) {
    iauthor.push("SheetJ5");
    o2.push("<author>SheetJ5</author>");
  }
  o2.push("</authors>");
  o2.push("<commentList>");
  data.forEach(function(d4) {
    var lastauthor = 0, ts = [];
    if (d4[1][0] && d4[1][0].T && d4[1][0].ID) lastauthor = iauthor.indexOf("tc=" + d4[1][0].ID);
    else d4[1].forEach(function(c3) {
      if (c3.a) lastauthor = iauthor.indexOf(escapexml(c3.a));
      ts.push(c3.t || "");
    });
    o2.push('<comment ref="' + d4[0] + '" authorId="' + lastauthor + '"><text>');
    if (ts.length <= 1) o2.push(writetag("t", escapexml(ts[0] || "")));
    else {
      var t3 = "Comment:\n    " + ts[0] + "\n";
      for (var i3 = 1; i3 < ts.length; ++i3) t3 += "Reply:\n    " + ts[i3] + "\n";
      o2.push(writetag("t", escapexml(t3)));
    }
    o2.push("</text></comment>");
  });
  o2.push("</commentList>");
  if (o2.length > 2) {
    o2[o2.length] = "</comments>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function parse_tcmnt_xml(data, opts) {
  var out = [];
  var pass = false, comment = {}, tidx = 0;
  data.replace(tagregex, function xml_tcmnt(x3, idx) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<?xml":
        break;
      case "<ThreadedComments":
        break;
      case "</ThreadedComments>":
        break;
      case "<threadedComment":
        comment = { author: y4.personId, guid: y4.id, ref: y4.ref, T: 1 };
        break;
      case "</threadedComment>":
        if (comment.t != null) out.push(comment);
        break;
      case "<text>":
      case "<text":
        tidx = idx + x3.length;
        break;
      case "</text>":
        comment.t = data.slice(tidx, idx).replace(/\r\n/g, "\n").replace(/\r/g, "\n");
        break;
      case "<mentions":
      case "<mentions>":
        pass = true;
        break;
      case "</mentions>":
        pass = false;
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y4[0] + " in threaded comments");
    }
    return x3;
  });
  return out;
}
function write_tcmnt_xml(comments, people, opts) {
  var o2 = [XML_HEADER, writextag("ThreadedComments", null, { "xmlns": XMLNS.TCMNT }).replace(/[\/]>/, ">")];
  comments.forEach(function(carr) {
    var rootid = "";
    (carr[1] || []).forEach(function(c3, idx) {
      if (!c3.T) {
        delete c3.ID;
        return;
      }
      if (c3.a && people.indexOf(c3.a) == -1) people.push(c3.a);
      var tcopts = {
        ref: carr[0],
        id: "{54EE7951-7262-4200-6969-" + ("000000000000" + opts.tcid++).slice(-12) + "}"
      };
      if (idx == 0) rootid = tcopts.id;
      else tcopts.parentId = rootid;
      c3.ID = tcopts.id;
      if (c3.a) tcopts.personId = "{54EE7950-7262-4200-6969-" + ("000000000000" + people.indexOf(c3.a)).slice(-12) + "}";
      o2.push(writextag("threadedComment", writetag("text", c3.t || ""), tcopts));
    });
  });
  o2.push("</ThreadedComments>");
  return o2.join("");
}
function parse_people_xml(data, opts) {
  var out = [];
  var pass = false;
  data.replace(tagregex, function xml_tcmnt(x3) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<?xml":
        break;
      case "<personList":
        break;
      case "</personList>":
        break;
      case "<person":
        out.push({ name: y4.displayname, id: y4.id });
        break;
      case "</person>":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y4[0] + " in threaded comments");
    }
    return x3;
  });
  return out;
}
function write_people_xml(people) {
  var o2 = [XML_HEADER, writextag("personList", null, {
    "xmlns": XMLNS.TCMNT,
    "xmlns:x": XMLNS_main[0]
  }).replace(/[\/]>/, ">")];
  people.forEach(function(person, idx) {
    o2.push(writextag("person", null, {
      displayName: person,
      id: "{54EE7950-7262-4200-6969-" + ("000000000000" + idx).slice(-12) + "}",
      userId: person,
      providerId: "None"
    }));
  });
  o2.push("</personList>");
  return o2.join("");
}
function parse_BrtBeginComment(data) {
  var out = {};
  out.iauthor = data.read_shift(4);
  var rfx = parse_UncheckedRfX(data);
  out.rfx = rfx.s;
  out.ref = encode_cell(rfx.s);
  data.l += 16;
  return out;
}
function write_BrtBeginComment(data, o2) {
  if (o2 == null) o2 = new_buf(36);
  o2.write_shift(4, data[1].iauthor);
  write_UncheckedRfX(data[0], o2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  return o2;
}
var parse_BrtCommentAuthor = parse_XLWideString;
function write_BrtCommentAuthor(data) {
  return write_XLWideString(data.slice(0, 54));
}
function parse_comments_bin(data, opts) {
  var out = [];
  var authors = [];
  var c3 = {};
  var pass = false;
  recordhopper(data, function hopper_cmnt(val, R3, RT) {
    switch (RT) {
      case 632:
        authors.push(val);
        break;
      case 635:
        c3 = val;
        break;
      case 637:
        c3.t = val.t;
        c3.h = val.h;
        c3.r = val.r;
        break;
      case 636:
        c3.author = authors[c3.iauthor];
        delete c3.iauthor;
        if (opts.sheetRows && c3.rfx && opts.sheetRows <= c3.rfx.r) break;
        if (!c3.t) c3.t = "";
        delete c3.rfx;
        out.push(c3);
        break;
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R3.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  });
  return out;
}
function write_comments_bin(data) {
  var ba = buf_array();
  var iauthor = [];
  write_record(
    ba,
    628
    /* BrtBeginComments */
  );
  write_record(
    ba,
    630
    /* BrtBeginCommentAuthors */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c3) {
      if (iauthor.indexOf(c3.a) > -1) return;
      iauthor.push(c3.a.slice(0, 54));
      write_record(ba, 632, write_BrtCommentAuthor(c3.a));
    });
  });
  write_record(
    ba,
    631
    /* BrtEndCommentAuthors */
  );
  write_record(
    ba,
    633
    /* BrtBeginCommentList */
  );
  data.forEach(function(comment) {
    comment[1].forEach(function(c3) {
      c3.iauthor = iauthor.indexOf(c3.a);
      var range = { s: decode_cell(comment[0]), e: decode_cell(comment[0]) };
      write_record(ba, 635, write_BrtBeginComment([range, c3]));
      if (c3.t && c3.t.length > 0) write_record(ba, 637, write_BrtCommentText(c3));
      write_record(
        ba,
        636
        /* BrtEndComment */
      );
      delete c3.iauthor;
    });
  });
  write_record(
    ba,
    634
    /* BrtEndCommentList */
  );
  write_record(
    ba,
    629
    /* BrtEndComments */
  );
  return ba.end();
}
var CT_VBA = "application/vnd.ms-office.vbaProject";
function make_vba_xls(cfb) {
  var newcfb = CFB.utils.cfb_new({ root: "R" });
  cfb.FullPaths.forEach(function(p2, i3) {
    if (p2.slice(-1) === "/" || !p2.match(/_VBA_PROJECT_CUR/))
      return;
    var newpath = p2.replace(/^[^\/]*/, "R").replace(/\/_VBA_PROJECT_CUR\u0000*/, "");
    CFB.utils.cfb_add(newcfb, newpath, cfb.FileIndex[i3].content);
  });
  return CFB.write(newcfb);
}
function fill_vba_xls(cfb, vba) {
  vba.FullPaths.forEach(function(p2, i3) {
    if (i3 == 0)
      return;
    var newpath = p2.replace(/[^\/]*[\/]/, "/_VBA_PROJECT_CUR/");
    if (newpath.slice(-1) !== "/")
      CFB.utils.cfb_add(cfb, newpath, vba.FileIndex[i3].content);
  });
}
var VBAFMTS = ["xlsb", "xlsm", "xlam", "biff8", "xla"];
function parse_ds_bin() {
  return { "!type": "dialog" };
}
function parse_ds_xml() {
  return { "!type": "dialog" };
}
function parse_ms_bin() {
  return { "!type": "macro" };
}
function parse_ms_xml() {
  return { "!type": "macro" };
}
var rc_to_a1 = /* @__PURE__ */ function() {
  var rcregex = /(^|[^A-Za-z_])R(\[?-?\d+\]|[1-9]\d*|)C(\[?-?\d+\]|[1-9]\d*|)(?![A-Za-z0-9_])/g;
  var rcbase = { r: 0, c: 0 };
  function rcfunc($$, $1, $2, $3) {
    var cRel = false, rRel = false;
    if ($2.length == 0) rRel = true;
    else if ($2.charAt(0) == "[") {
      rRel = true;
      $2 = $2.slice(1, -1);
    }
    if ($3.length == 0) cRel = true;
    else if ($3.charAt(0) == "[") {
      cRel = true;
      $3 = $3.slice(1, -1);
    }
    var R3 = $2.length > 0 ? parseInt($2, 10) | 0 : 0, C2 = $3.length > 0 ? parseInt($3, 10) | 0 : 0;
    if (cRel) C2 += rcbase.c;
    else --C2;
    if (rRel) R3 += rcbase.r;
    else --R3;
    return $1 + (cRel ? "" : "$") + encode_col(C2) + (rRel ? "" : "$") + encode_row(R3);
  }
  return function rc_to_a12(fstr, base) {
    rcbase = base;
    return fstr.replace(rcregex, rcfunc);
  };
}();
var crefregex = /(^|[^._A-Z0-9])([$]?)([A-Z]{1,2}|[A-W][A-Z]{2}|X[A-E][A-Z]|XF[A-D])([$]?)(10[0-3]\d{4}|104[0-7]\d{3}|1048[0-4]\d{2}|10485[0-6]\d|104857[0-6]|[1-9]\d{0,5})(?![_.\(A-Za-z0-9])/g;
var a1_to_rc = /* @__PURE__ */ function() {
  return function a1_to_rc2(fstr, base) {
    return fstr.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
      var c3 = decode_col($3) - ($2 ? 0 : base.c);
      var r2 = decode_row($5) - ($4 ? 0 : base.r);
      var R3 = r2 == 0 ? "" : !$4 ? "[" + r2 + "]" : r2 + 1;
      var C2 = c3 == 0 ? "" : !$2 ? "[" + c3 + "]" : c3 + 1;
      return $1 + "R" + R3 + "C" + C2;
    });
  };
}();
function shift_formula_str(f2, delta) {
  return f2.replace(crefregex, function($0, $1, $2, $3, $4, $5) {
    return $1 + ($2 == "$" ? $2 + $3 : encode_col(decode_col($3) + delta.c)) + ($4 == "$" ? $4 + $5 : encode_row(decode_row($5) + delta.r));
  });
}
function shift_formula_xlsx(f2, range, cell) {
  var r2 = decode_range(range), s4 = r2.s, c3 = decode_cell(cell);
  var delta = { r: c3.r - s4.r, c: c3.c - s4.c };
  return shift_formula_str(f2, delta);
}
function fuzzyfmla(f2) {
  if (f2.length == 1) return false;
  return true;
}
function _xlfn(f2) {
  return f2.replace(/_xlfn\./g, "");
}
function parseread1(blob) {
  blob.l += 1;
  return;
}
function parse_ColRelU(blob, length) {
  var c3 = blob.read_shift(2);
  return [c3 & 16383, c3 >> 14 & 1, c3 >> 15 & 1];
}
function parse_RgceArea(blob, length, opts) {
  var w3 = 2;
  if (opts) {
    if (opts.biff >= 2 && opts.biff <= 5) return parse_RgceArea_BIFF2(blob);
    else if (opts.biff == 12) w3 = 4;
  }
  var r2 = blob.read_shift(w3), R3 = blob.read_shift(w3);
  var c3 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r: r2, c: c3[0], cRel: c3[1], rRel: c3[2] }, e: { r: R3, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceArea_BIFF2(blob) {
  var r2 = parse_ColRelU(blob), R3 = parse_ColRelU(blob);
  var c3 = blob.read_shift(1);
  var C2 = blob.read_shift(1);
  return { s: { r: r2[0], c: c3, cRel: r2[1], rRel: r2[2] }, e: { r: R3[0], c: C2, cRel: R3[1], rRel: R3[2] } };
}
function parse_RgceAreaRel(blob, length, opts) {
  if (opts.biff < 8) return parse_RgceArea_BIFF2(blob);
  var r2 = blob.read_shift(opts.biff == 12 ? 4 : 2), R3 = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var c3 = parse_ColRelU(blob);
  var C2 = parse_ColRelU(blob);
  return { s: { r: r2, c: c3[0], cRel: c3[1], rRel: c3[2] }, e: { r: R3, c: C2[0], cRel: C2[1], rRel: C2[2] } };
}
function parse_RgceLoc(blob, length, opts) {
  if (opts && opts.biff >= 2 && opts.biff <= 5) return parse_RgceLoc_BIFF2(blob);
  var r2 = blob.read_shift(opts && opts.biff == 12 ? 4 : 2);
  var c3 = parse_ColRelU(blob);
  return { r: r2, c: c3[0], cRel: c3[1], rRel: c3[2] };
}
function parse_RgceLoc_BIFF2(blob) {
  var r2 = parse_ColRelU(blob);
  var c3 = blob.read_shift(1);
  return { r: r2[0], c: c3, cRel: r2[1], rRel: r2[2] };
}
function parse_RgceElfLoc(blob) {
  var r2 = blob.read_shift(2);
  var c3 = blob.read_shift(2);
  return { r: r2, c: c3 & 255, fQuoted: !!(c3 & 16384), cRel: c3 >> 15, rRel: c3 >> 15 };
}
function parse_RgceLocRel(blob, length, opts) {
  var biff = opts && opts.biff ? opts.biff : 8;
  if (biff >= 2 && biff <= 5) return parse_RgceLocRel_BIFF2(blob);
  var r2 = blob.read_shift(biff >= 12 ? 4 : 2);
  var cl2 = blob.read_shift(2);
  var cRel = (cl2 & 16384) >> 14, rRel = (cl2 & 32768) >> 15;
  cl2 &= 16383;
  if (rRel == 1) while (r2 > 524287) r2 -= 1048576;
  if (cRel == 1) while (cl2 > 8191) cl2 = cl2 - 16384;
  return { r: r2, c: cl2, cRel, rRel };
}
function parse_RgceLocRel_BIFF2(blob) {
  var rl2 = blob.read_shift(2);
  var c3 = blob.read_shift(1);
  var rRel = (rl2 & 32768) >> 15, cRel = (rl2 & 16384) >> 14;
  rl2 &= 16383;
  if (rRel == 1 && rl2 >= 8192) rl2 = rl2 - 16384;
  if (cRel == 1 && c3 >= 128) c3 = c3 - 256;
  return { r: rl2, c: c3, cRel, rRel };
}
function parse_PtgArea(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceArea(blob, opts.biff >= 2 && opts.biff <= 5 ? 6 : 8, opts);
  return [type, area];
}
function parse_PtgArea3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2, "i");
  var w3 = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w3 = 6;
      break;
    case 12:
      w3 = 12;
      break;
  }
  var area = parse_RgceArea(blob, w3, opts);
  return [type, ixti, area];
}
function parse_PtgAreaErr(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts && opts.biff > 8 ? 12 : opts.biff < 8 ? 6 : 8;
  return [type];
}
function parse_PtgAreaErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w3 = 8;
  if (opts) switch (opts.biff) {
    case 5:
      blob.l += 12;
      w3 = 6;
      break;
    case 12:
      w3 = 12;
      break;
  }
  blob.l += w3;
  return [type, ixti];
}
function parse_PtgAreaN(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var area = parse_RgceAreaRel(blob, length - 1, opts);
  return [type, area];
}
function parse_PtgArray(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  blob.l += opts.biff == 2 ? 6 : opts.biff == 12 ? 14 : 7;
  return [type];
}
function parse_PtgAttrBaxcel(blob) {
  var bitSemi = blob[blob.l + 1] & 1;
  var bitBaxcel = 1;
  blob.l += 4;
  return [bitSemi, bitBaxcel];
}
function parse_PtgAttrChoose(blob, length, opts) {
  blob.l += 2;
  var offset2 = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  var o2 = [];
  for (var i3 = 0; i3 <= offset2; ++i3) o2.push(blob.read_shift(opts && opts.biff == 2 ? 1 : 2));
  return o2;
}
function parse_PtgAttrGoto(blob, length, opts) {
  var bitGoto = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitGoto, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIf(blob, length, opts) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(opts && opts.biff == 2 ? 1 : 2)];
}
function parse_PtgAttrIfError(blob) {
  var bitIf = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += 2;
  return [bitIf, blob.read_shift(2)];
}
function parse_PtgAttrSemi(blob, length, opts) {
  var bitSemi = blob[blob.l + 1] & 255 ? 1 : 0;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return [bitSemi];
}
function parse_PtgAttrSpaceType(blob) {
  var type = blob.read_shift(1), cch = blob.read_shift(1);
  return [type, cch];
}
function parse_PtgAttrSpace(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgAttrSpaceSemi(blob) {
  blob.read_shift(2);
  return parse_PtgAttrSpaceType(blob);
}
function parse_PtgRef(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRefN(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var loc = parse_RgceLocRel(blob, 0, opts);
  return [type, loc];
}
function parse_PtgRef3d(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var ixti = blob.read_shift(2);
  if (opts && opts.biff == 5) blob.l += 12;
  var loc = parse_RgceLoc(blob, 0, opts);
  return [type, ixti, loc];
}
function parse_PtgFunc(blob, length, opts) {
  var type = (blob[blob.l] & 96) >> 5;
  blob.l += 1;
  var iftab = blob.read_shift(opts && opts.biff <= 3 ? 1 : 2);
  return [FtabArgc[iftab], Ftab[iftab], type];
}
function parse_PtgFuncVar(blob, length, opts) {
  var type = blob[blob.l++];
  var cparams = blob.read_shift(1), tab = opts && opts.biff <= 3 ? [type == 88 ? -1 : 0, blob.read_shift(1)] : parsetab(blob);
  return [cparams, (tab[0] === 0 ? Ftab : Cetab)[tab[1]]];
}
function parsetab(blob) {
  return [blob[blob.l + 1] >> 7, blob.read_shift(2) & 32767];
}
function parse_PtgAttrSum(blob, length, opts) {
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  return;
}
function parse_PtgExp(blob, length, opts) {
  blob.l++;
  if (opts && opts.biff == 12) return [blob.read_shift(4, "i"), 0];
  var row = blob.read_shift(2);
  var col = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [row, col];
}
function parse_PtgErr(blob) {
  blob.l++;
  return BErr[blob.read_shift(1)];
}
function parse_PtgInt(blob) {
  blob.l++;
  return blob.read_shift(2);
}
function parse_PtgBool(blob) {
  blob.l++;
  return blob.read_shift(1) !== 0;
}
function parse_PtgNum(blob) {
  blob.l++;
  return parse_Xnum(blob);
}
function parse_PtgStr(blob, length, opts) {
  blob.l++;
  return parse_ShortXLUnicodeString(blob, length - 1, opts);
}
function parse_SerAr(blob, biff) {
  var val = [blob.read_shift(1)];
  if (biff == 12) switch (val[0]) {
    case 2:
      val[0] = 4;
      break;
    case 4:
      val[0] = 16;
      break;
    case 0:
      val[0] = 1;
      break;
    case 1:
      val[0] = 2;
      break;
  }
  switch (val[0]) {
    case 4:
      val[1] = parsebool(blob, 1) ? "TRUE" : "FALSE";
      if (biff != 12) blob.l += 7;
      break;
    case 37:
    case 16:
      val[1] = BErr[blob[blob.l]];
      blob.l += biff == 12 ? 4 : 8;
      break;
    case 0:
      blob.l += 8;
      break;
    case 1:
      val[1] = parse_Xnum(blob);
      break;
    case 2:
      val[1] = parse_XLUnicodeString2(blob, 0, { biff: biff > 0 && biff < 8 ? 2 : biff });
      break;
    default:
      throw new Error("Bad SerAr: " + val[0]);
  }
  return val;
}
function parse_PtgExtraMem(blob, cce, opts) {
  var count2 = blob.read_shift(opts.biff == 12 ? 4 : 2);
  var out = [];
  for (var i3 = 0; i3 != count2; ++i3) out.push((opts.biff == 12 ? parse_UncheckedRfX : parse_Ref8U)(blob));
  return out;
}
function parse_PtgExtraArray(blob, length, opts) {
  var rows = 0, cols = 0;
  if (opts.biff == 12) {
    rows = blob.read_shift(4);
    cols = blob.read_shift(4);
  } else {
    cols = 1 + blob.read_shift(1);
    rows = 1 + blob.read_shift(2);
  }
  if (opts.biff >= 2 && opts.biff < 8) {
    --rows;
    if (--cols == 0) cols = 256;
  }
  for (var i3 = 0, o2 = []; i3 != rows && (o2[i3] = []); ++i3)
    for (var j2 = 0; j2 != cols; ++j2) o2[i3][j2] = parse_SerAr(blob, opts.biff);
  return o2;
}
function parse_PtgName(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var w3 = !opts || opts.biff >= 8 ? 4 : 2;
  var nameindex = blob.read_shift(w3);
  switch (opts.biff) {
    case 2:
      blob.l += 5;
      break;
    case 3:
    case 4:
      blob.l += 8;
      break;
    case 5:
      blob.l += 12;
      break;
  }
  return [type, 0, nameindex];
}
function parse_PtgNameX(blob, length, opts) {
  if (opts.biff == 5) return parse_PtgNameX_BIFF5(blob);
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2);
  var nameindex = blob.read_shift(4);
  return [type, ixti, nameindex];
}
function parse_PtgNameX_BIFF5(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var ixti = blob.read_shift(2, "i");
  blob.l += 8;
  var nameindex = blob.read_shift(2);
  blob.l += 12;
  return [type, ixti, nameindex];
}
function parse_PtgMemArea(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += opts && opts.biff == 2 ? 3 : 4;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgMemFunc(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(opts && opts.biff == 2 ? 1 : 2);
  return [type, cce];
}
function parse_PtgRefErr(blob, length, opts) {
  var type = blob.read_shift(1) >>> 5 & 3;
  blob.l += 4;
  if (opts.biff < 8) blob.l--;
  if (opts.biff == 12) blob.l += 2;
  return [type];
}
function parse_PtgRefErr3d(blob, length, opts) {
  var type = (blob[blob.l++] & 96) >> 5;
  var ixti = blob.read_shift(2);
  var w3 = 4;
  if (opts) switch (opts.biff) {
    case 5:
      w3 = 15;
      break;
    case 12:
      w3 = 6;
      break;
  }
  blob.l += w3;
  return [type, ixti];
}
var parse_PtgMemErr = parsenoop;
var parse_PtgMemNoMem = parsenoop;
var parse_PtgTbl = parsenoop;
function parse_PtgElfLoc(blob, length, opts) {
  blob.l += 2;
  return [parse_RgceElfLoc(blob)];
}
function parse_PtgElfNoop(blob) {
  blob.l += 6;
  return [];
}
var parse_PtgElfCol = parse_PtgElfLoc;
var parse_PtgElfColS = parse_PtgElfNoop;
var parse_PtgElfColSV = parse_PtgElfNoop;
var parse_PtgElfColV = parse_PtgElfLoc;
function parse_PtgElfLel(blob) {
  blob.l += 2;
  return [parseuint16(blob), blob.read_shift(2) & 1];
}
var parse_PtgElfRadical = parse_PtgElfLoc;
var parse_PtgElfRadicalLel = parse_PtgElfLel;
var parse_PtgElfRadicalS = parse_PtgElfNoop;
var parse_PtgElfRw = parse_PtgElfLoc;
var parse_PtgElfRwV = parse_PtgElfLoc;
var PtgListRT = [
  "Data",
  "All",
  "Headers",
  "??",
  "?Data2",
  "??",
  "?DataHeaders",
  "??",
  "Totals",
  "??",
  "??",
  "??",
  "?DataTotals",
  "??",
  "??",
  "??",
  "?Current"
];
function parse_PtgList(blob) {
  blob.l += 2;
  var ixti = blob.read_shift(2);
  var flags = blob.read_shift(2);
  var idx = blob.read_shift(4);
  var c3 = blob.read_shift(2);
  var C2 = blob.read_shift(2);
  var rt = PtgListRT[flags >> 2 & 31];
  return { ixti, coltype: flags & 3, rt, idx, c: c3, C: C2 };
}
function parse_PtgSxName(blob) {
  blob.l += 2;
  return [blob.read_shift(4)];
}
function parse_PtgSheet(blob, length, opts) {
  blob.l += 5;
  blob.l += 2;
  blob.l += opts.biff == 2 ? 1 : 4;
  return ["PTGSHEET"];
}
function parse_PtgEndSheet(blob, length, opts) {
  blob.l += opts.biff == 2 ? 4 : 5;
  return ["PTGENDSHEET"];
}
function parse_PtgMemAreaN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgMemNoMemN(blob) {
  var type = blob.read_shift(1) >>> 5 & 3;
  var cce = blob.read_shift(2);
  return [type, cce];
}
function parse_PtgAttrNoop(blob) {
  blob.l += 4;
  return [0, 0];
}
var PtgTypes = {
  /*::[*/
  1: { n: "PtgExp", f: parse_PtgExp },
  /*::[*/
  2: { n: "PtgTbl", f: parse_PtgTbl },
  /*::[*/
  3: { n: "PtgAdd", f: parseread1 },
  /*::[*/
  4: { n: "PtgSub", f: parseread1 },
  /*::[*/
  5: { n: "PtgMul", f: parseread1 },
  /*::[*/
  6: { n: "PtgDiv", f: parseread1 },
  /*::[*/
  7: { n: "PtgPower", f: parseread1 },
  /*::[*/
  8: { n: "PtgConcat", f: parseread1 },
  /*::[*/
  9: { n: "PtgLt", f: parseread1 },
  /*::[*/
  10: { n: "PtgLe", f: parseread1 },
  /*::[*/
  11: { n: "PtgEq", f: parseread1 },
  /*::[*/
  12: { n: "PtgGe", f: parseread1 },
  /*::[*/
  13: { n: "PtgGt", f: parseread1 },
  /*::[*/
  14: { n: "PtgNe", f: parseread1 },
  /*::[*/
  15: { n: "PtgIsect", f: parseread1 },
  /*::[*/
  16: { n: "PtgUnion", f: parseread1 },
  /*::[*/
  17: { n: "PtgRange", f: parseread1 },
  /*::[*/
  18: { n: "PtgUplus", f: parseread1 },
  /*::[*/
  19: { n: "PtgUminus", f: parseread1 },
  /*::[*/
  20: { n: "PtgPercent", f: parseread1 },
  /*::[*/
  21: { n: "PtgParen", f: parseread1 },
  /*::[*/
  22: { n: "PtgMissArg", f: parseread1 },
  /*::[*/
  23: { n: "PtgStr", f: parse_PtgStr },
  /*::[*/
  26: { n: "PtgSheet", f: parse_PtgSheet },
  /*::[*/
  27: { n: "PtgEndSheet", f: parse_PtgEndSheet },
  /*::[*/
  28: { n: "PtgErr", f: parse_PtgErr },
  /*::[*/
  29: { n: "PtgBool", f: parse_PtgBool },
  /*::[*/
  30: { n: "PtgInt", f: parse_PtgInt },
  /*::[*/
  31: { n: "PtgNum", f: parse_PtgNum },
  /*::[*/
  32: { n: "PtgArray", f: parse_PtgArray },
  /*::[*/
  33: { n: "PtgFunc", f: parse_PtgFunc },
  /*::[*/
  34: { n: "PtgFuncVar", f: parse_PtgFuncVar },
  /*::[*/
  35: { n: "PtgName", f: parse_PtgName },
  /*::[*/
  36: { n: "PtgRef", f: parse_PtgRef },
  /*::[*/
  37: { n: "PtgArea", f: parse_PtgArea },
  /*::[*/
  38: { n: "PtgMemArea", f: parse_PtgMemArea },
  /*::[*/
  39: { n: "PtgMemErr", f: parse_PtgMemErr },
  /*::[*/
  40: { n: "PtgMemNoMem", f: parse_PtgMemNoMem },
  /*::[*/
  41: { n: "PtgMemFunc", f: parse_PtgMemFunc },
  /*::[*/
  42: { n: "PtgRefErr", f: parse_PtgRefErr },
  /*::[*/
  43: { n: "PtgAreaErr", f: parse_PtgAreaErr },
  /*::[*/
  44: { n: "PtgRefN", f: parse_PtgRefN },
  /*::[*/
  45: { n: "PtgAreaN", f: parse_PtgAreaN },
  /*::[*/
  46: { n: "PtgMemAreaN", f: parse_PtgMemAreaN },
  /*::[*/
  47: { n: "PtgMemNoMemN", f: parse_PtgMemNoMemN },
  /*::[*/
  57: { n: "PtgNameX", f: parse_PtgNameX },
  /*::[*/
  58: { n: "PtgRef3d", f: parse_PtgRef3d },
  /*::[*/
  59: { n: "PtgArea3d", f: parse_PtgArea3d },
  /*::[*/
  60: { n: "PtgRefErr3d", f: parse_PtgRefErr3d },
  /*::[*/
  61: { n: "PtgAreaErr3d", f: parse_PtgAreaErr3d },
  /*::[*/
  255: {}
};
var PtgDupes = {
  /*::[*/
  64: 32,
  /*::[*/
  96: 32,
  /*::[*/
  65: 33,
  /*::[*/
  97: 33,
  /*::[*/
  66: 34,
  /*::[*/
  98: 34,
  /*::[*/
  67: 35,
  /*::[*/
  99: 35,
  /*::[*/
  68: 36,
  /*::[*/
  100: 36,
  /*::[*/
  69: 37,
  /*::[*/
  101: 37,
  /*::[*/
  70: 38,
  /*::[*/
  102: 38,
  /*::[*/
  71: 39,
  /*::[*/
  103: 39,
  /*::[*/
  72: 40,
  /*::[*/
  104: 40,
  /*::[*/
  73: 41,
  /*::[*/
  105: 41,
  /*::[*/
  74: 42,
  /*::[*/
  106: 42,
  /*::[*/
  75: 43,
  /*::[*/
  107: 43,
  /*::[*/
  76: 44,
  /*::[*/
  108: 44,
  /*::[*/
  77: 45,
  /*::[*/
  109: 45,
  /*::[*/
  78: 46,
  /*::[*/
  110: 46,
  /*::[*/
  79: 47,
  /*::[*/
  111: 47,
  /*::[*/
  88: 34,
  /*::[*/
  120: 34,
  /*::[*/
  89: 57,
  /*::[*/
  121: 57,
  /*::[*/
  90: 58,
  /*::[*/
  122: 58,
  /*::[*/
  91: 59,
  /*::[*/
  123: 59,
  /*::[*/
  92: 60,
  /*::[*/
  124: 60,
  /*::[*/
  93: 61,
  /*::[*/
  125: 61
};
var Ptg18 = {
  /*::[*/
  1: { n: "PtgElfLel", f: parse_PtgElfLel },
  /*::[*/
  2: { n: "PtgElfRw", f: parse_PtgElfRw },
  /*::[*/
  3: { n: "PtgElfCol", f: parse_PtgElfCol },
  /*::[*/
  6: { n: "PtgElfRwV", f: parse_PtgElfRwV },
  /*::[*/
  7: { n: "PtgElfColV", f: parse_PtgElfColV },
  /*::[*/
  10: { n: "PtgElfRadical", f: parse_PtgElfRadical },
  /*::[*/
  11: { n: "PtgElfRadicalS", f: parse_PtgElfRadicalS },
  /*::[*/
  13: { n: "PtgElfColS", f: parse_PtgElfColS },
  /*::[*/
  15: { n: "PtgElfColSV", f: parse_PtgElfColSV },
  /*::[*/
  16: { n: "PtgElfRadicalLel", f: parse_PtgElfRadicalLel },
  /*::[*/
  25: { n: "PtgList", f: parse_PtgList },
  /*::[*/
  29: { n: "PtgSxName", f: parse_PtgSxName },
  /*::[*/
  255: {}
};
var Ptg19 = {
  /*::[*/
  0: { n: "PtgAttrNoop", f: parse_PtgAttrNoop },
  /*::[*/
  1: { n: "PtgAttrSemi", f: parse_PtgAttrSemi },
  /*::[*/
  2: { n: "PtgAttrIf", f: parse_PtgAttrIf },
  /*::[*/
  4: { n: "PtgAttrChoose", f: parse_PtgAttrChoose },
  /*::[*/
  8: { n: "PtgAttrGoto", f: parse_PtgAttrGoto },
  /*::[*/
  16: { n: "PtgAttrSum", f: parse_PtgAttrSum },
  /*::[*/
  32: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  33: { n: "PtgAttrBaxcel", f: parse_PtgAttrBaxcel },
  /*::[*/
  64: { n: "PtgAttrSpace", f: parse_PtgAttrSpace },
  /*::[*/
  65: { n: "PtgAttrSpaceSemi", f: parse_PtgAttrSpaceSemi },
  /*::[*/
  128: { n: "PtgAttrIfError", f: parse_PtgAttrIfError },
  /*::[*/
  255: {}
};
function parse_RgbExtra(blob, length, rgce, opts) {
  if (opts.biff < 8) return parsenoop(blob, length);
  var target = blob.l + length;
  var o2 = [];
  for (var i3 = 0; i3 !== rgce.length; ++i3) {
    switch (rgce[i3][0]) {
      case "PtgArray":
        rgce[i3][1] = parse_PtgExtraArray(blob, 0, opts);
        o2.push(rgce[i3][1]);
        break;
      case "PtgMemArea":
        rgce[i3][2] = parse_PtgExtraMem(blob, rgce[i3][1], opts);
        o2.push(rgce[i3][2]);
        break;
      case "PtgExp":
        if (opts && opts.biff == 12) {
          rgce[i3][1][1] = blob.read_shift(4);
          o2.push(rgce[i3][1]);
        }
        break;
      case "PtgList":
      case "PtgElfRadicalS":
      case "PtgElfColS":
      case "PtgElfColSV":
        throw "Unsupported " + rgce[i3][0];
    }
  }
  length = target - blob.l;
  if (length !== 0) o2.push(parsenoop(blob, length));
  return o2;
}
function parse_Rgce(blob, length, opts) {
  var target = blob.l + length;
  var R3, id2, ptgs = [];
  while (target != blob.l) {
    length = target - blob.l;
    id2 = blob[blob.l];
    R3 = PtgTypes[id2] || PtgTypes[PtgDupes[id2]];
    if (id2 === 24 || id2 === 25) R3 = (id2 === 24 ? Ptg18 : Ptg19)[blob[blob.l + 1]];
    if (!R3 || !R3.f) {
      parsenoop(blob, length);
    } else {
      ptgs.push([R3.n, R3.f(blob, length, opts)]);
    }
  }
  return ptgs;
}
function stringify_array(f2) {
  var o2 = [];
  for (var i3 = 0; i3 < f2.length; ++i3) {
    var x3 = f2[i3], r2 = [];
    for (var j2 = 0; j2 < x3.length; ++j2) {
      var y4 = x3[j2];
      if (y4) switch (y4[0]) {
        case 2:
          r2.push('"' + y4[1].replace(/"/g, '""') + '"');
          break;
        default:
          r2.push(y4[1]);
      }
      else r2.push("");
    }
    o2.push(r2.join(","));
  }
  return o2.join(";");
}
var PtgBinOp = {
  PtgAdd: "+",
  PtgConcat: "&",
  PtgDiv: "/",
  PtgEq: "=",
  PtgGe: ">=",
  PtgGt: ">",
  PtgLe: "<=",
  PtgLt: "<",
  PtgMul: "*",
  PtgNe: "<>",
  PtgPower: "^",
  PtgSub: "-"
};
function formula_quote_sheet_name(sname, opts) {
  if (!sname && !(opts && opts.biff <= 5 && opts.biff >= 2)) throw new Error("empty sheet name");
  if (/[^\w\u4E00-\u9FFF\u3040-\u30FF]/.test(sname)) return "'" + sname + "'";
  return sname;
}
function get_ixti_raw(supbooks, ixti, opts) {
  if (!supbooks) return "SH33TJSERR0";
  if (opts.biff > 8 && (!supbooks.XTI || !supbooks.XTI[ixti])) return supbooks.SheetNames[ixti];
  if (!supbooks.XTI) return "SH33TJSERR6";
  var XTI = supbooks.XTI[ixti];
  if (opts.biff < 8) {
    if (ixti > 1e4) ixti -= 65536;
    if (ixti < 0) ixti = -ixti;
    return ixti == 0 ? "" : supbooks.XTI[ixti - 1];
  }
  if (!XTI) return "SH33TJSERR1";
  var o2 = "";
  if (opts.biff > 8) switch (supbooks[XTI[0]][0]) {
    case 357:
      o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]];
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
    case 358:
      if (opts.SID != null) return supbooks.SheetNames[opts.SID];
      return "SH33TJSSAME" + supbooks[XTI[0]][0];
    case 355:
    default:
      return "SH33TJSSRC" + supbooks[XTI[0]][0];
  }
  switch (supbooks[XTI[0]][0][0]) {
    case 1025:
      o2 = XTI[1] == -1 ? "#REF" : supbooks.SheetNames[XTI[1]] || "SH33TJSERR3";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks.SheetNames[XTI[2]];
    case 14849:
      return supbooks[XTI[0]].slice(1).map(function(name) {
        return name.Name;
      }).join(";;");
    default:
      if (!supbooks[XTI[0]][0][3]) return "SH33TJSERR2";
      o2 = XTI[1] == -1 ? "#REF" : supbooks[XTI[0]][0][3][XTI[1]] || "SH33TJSERR4";
      return XTI[1] == XTI[2] ? o2 : o2 + ":" + supbooks[XTI[0]][0][3][XTI[2]];
  }
}
function get_ixti(supbooks, ixti, opts) {
  var ixtiraw = get_ixti_raw(supbooks, ixti, opts);
  return ixtiraw == "#REF" ? ixtiraw : formula_quote_sheet_name(ixtiraw, opts);
}
function stringify_formula(formula, range, cell, supbooks, opts) {
  var biff = opts && opts.biff || 8;
  var _range = (
    /*range != null ? range :*/
    { s: { c: 0, r: 0 } }
  );
  var stack = [], e1, e22, c3, ixti = 0, nameidx = 0, r2, sname = "";
  if (!formula[0] || !formula[0][0]) return "";
  var last_sp = -1, sp = "";
  for (var ff2 = 0, fflen = formula[0].length; ff2 < fflen; ++ff2) {
    var f2 = formula[0][ff2];
    switch (f2[0]) {
      case "PtgUminus":
        stack.push("-" + stack.pop());
        break;
      case "PtgUplus":
        stack.push("+" + stack.pop());
        break;
      case "PtgPercent":
        stack.push(stack.pop() + "%");
        break;
      case "PtgAdd":
      case "PtgConcat":
      case "PtgDiv":
      case "PtgEq":
      case "PtgGe":
      case "PtgGt":
      case "PtgLe":
      case "PtgLt":
      case "PtgMul":
      case "PtgNe":
      case "PtgPower":
      case "PtgSub":
        e1 = stack.pop();
        e22 = stack.pop();
        if (last_sp >= 0) {
          switch (formula[0][last_sp][1][0]) {
            case 0:
              sp = fill(" ", formula[0][last_sp][1][1]);
              break;
            case 1:
              sp = fill("\r", formula[0][last_sp][1][1]);
              break;
            default:
              sp = "";
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          e22 = e22 + sp;
          last_sp = -1;
        }
        stack.push(e22 + PtgBinOp[f2[0]] + e1);
        break;
      case "PtgIsect":
        e1 = stack.pop();
        e22 = stack.pop();
        stack.push(e22 + " " + e1);
        break;
      case "PtgUnion":
        e1 = stack.pop();
        e22 = stack.pop();
        stack.push(e22 + "," + e1);
        break;
      case "PtgRange":
        e1 = stack.pop();
        e22 = stack.pop();
        stack.push(e22 + ":" + e1);
        break;
      case "PtgAttrChoose":
        break;
      case "PtgAttrGoto":
        break;
      case "PtgAttrIf":
        break;
      case "PtgAttrIfError":
        break;
      case "PtgRef":
        c3 = shift_cell_xls(f2[1][1], _range, opts);
        stack.push(encode_cell_xls(c3, biff));
        break;
      case "PtgRefN":
        c3 = cell ? shift_cell_xls(f2[1][1], cell, opts) : f2[1][1];
        stack.push(encode_cell_xls(c3, biff));
        break;
      case "PtgRef3d":
        ixti = /*::Number(*/
        f2[1][1];
        c3 = shift_cell_xls(f2[1][2], _range, opts);
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_cell_xls(c3, biff));
        break;
      case "PtgFunc":
      case "PtgFuncVar":
        var argc = f2[1][0], func = f2[1][1];
        if (!argc) argc = 0;
        argc &= 127;
        var args = argc == 0 ? [] : stack.slice(-argc);
        stack.length -= argc;
        if (func === "User") func = args.shift();
        stack.push(func + "(" + args.join(",") + ")");
        break;
      case "PtgBool":
        stack.push(f2[1] ? "TRUE" : "FALSE");
        break;
      case "PtgInt":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgNum":
        stack.push(String(f2[1]));
        break;
      case "PtgStr":
        stack.push('"' + f2[1].replace(/"/g, '""') + '"');
        break;
      case "PtgErr":
        stack.push(
          /*::String(*/
          f2[1]
          /*::)*/
        );
        break;
      case "PtgAreaN":
        r2 = shift_range_xls(f2[1][1], cell ? { s: cell } : _range, opts);
        stack.push(encode_range_xls(r2, opts));
        break;
      case "PtgArea":
        r2 = shift_range_xls(f2[1][1], _range, opts);
        stack.push(encode_range_xls(r2, opts));
        break;
      case "PtgArea3d":
        ixti = /*::Number(*/
        f2[1][1];
        r2 = f2[1][2];
        sname = get_ixti(supbooks, ixti, opts);
        stack.push(sname + "!" + encode_range_xls(r2, opts));
        break;
      case "PtgAttrSum":
        stack.push("SUM(" + stack.pop() + ")");
        break;
      case "PtgAttrBaxcel":
      case "PtgAttrSemi":
        break;
      case "PtgName":
        nameidx = f2[1][2];
        var lbl = (supbooks.names || [])[nameidx - 1] || (supbooks[0] || [])[nameidx];
        var name = lbl ? lbl.Name : "SH33TJSNAME" + String(nameidx);
        if (name && name.slice(0, 6) == "_xlfn." && !opts.xlfn) name = name.slice(6);
        stack.push(name);
        break;
      case "PtgNameX":
        var bookidx = f2[1][1];
        nameidx = f2[1][2];
        var externbook;
        if (opts.biff <= 5) {
          if (bookidx < 0) bookidx = -bookidx;
          if (supbooks[bookidx]) externbook = supbooks[bookidx][nameidx];
        } else {
          var o2 = "";
          if (((supbooks[bookidx] || [])[0] || [])[0] == 14849) ;
          else if (((supbooks[bookidx] || [])[0] || [])[0] == 1025) {
            if (supbooks[bookidx][nameidx] && supbooks[bookidx][nameidx].itab > 0) {
              o2 = supbooks.SheetNames[supbooks[bookidx][nameidx].itab - 1] + "!";
            }
          } else o2 = supbooks.SheetNames[nameidx - 1] + "!";
          if (supbooks[bookidx] && supbooks[bookidx][nameidx]) o2 += supbooks[bookidx][nameidx].Name;
          else if (supbooks[0] && supbooks[0][nameidx]) o2 += supbooks[0][nameidx].Name;
          else {
            var ixtidata = (get_ixti_raw(supbooks, bookidx, opts) || "").split(";;");
            if (ixtidata[nameidx - 1]) o2 = ixtidata[nameidx - 1];
            else o2 += "SH33TJSERRX";
          }
          stack.push(o2);
          break;
        }
        if (!externbook) externbook = { Name: "SH33TJSERRY" };
        stack.push(externbook.Name);
        break;
      case "PtgParen":
        var lp = "(", rp = ")";
        if (last_sp >= 0) {
          sp = "";
          switch (formula[0][last_sp][1][0]) {
            case 2:
              lp = fill(" ", formula[0][last_sp][1][1]) + lp;
              break;
            case 3:
              lp = fill("\r", formula[0][last_sp][1][1]) + lp;
              break;
            case 4:
              rp = fill(" ", formula[0][last_sp][1][1]) + rp;
              break;
            case 5:
              rp = fill("\r", formula[0][last_sp][1][1]) + rp;
              break;
            default:
              if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + formula[0][last_sp][1][0]);
          }
          last_sp = -1;
        }
        stack.push(lp + stack.pop() + rp);
        break;
      case "PtgRefErr":
        stack.push("#REF!");
        break;
      case "PtgRefErr3d":
        stack.push("#REF!");
        break;
      case "PtgExp":
        c3 = { c: f2[1][1], r: f2[1][0] };
        var q3 = { c: cell.c, r: cell.r };
        if (supbooks.sharedf[encode_cell(c3)]) {
          var parsedf = supbooks.sharedf[encode_cell(c3)];
          stack.push(stringify_formula(parsedf, _range, q3, supbooks, opts));
        } else {
          var fnd = false;
          for (e1 = 0; e1 != supbooks.arrayf.length; ++e1) {
            e22 = supbooks.arrayf[e1];
            if (c3.c < e22[0].s.c || c3.c > e22[0].e.c) continue;
            if (c3.r < e22[0].s.r || c3.r > e22[0].e.r) continue;
            stack.push(stringify_formula(e22[1], _range, q3, supbooks, opts));
            fnd = true;
            break;
          }
          if (!fnd) stack.push(
            /*::String(*/
            f2[1]
            /*::)*/
          );
        }
        break;
      case "PtgArray":
        stack.push("{" + stringify_array(
          /*::(*/
          f2[1]
          /*:: :any)*/
        ) + "}");
        break;
      case "PtgMemArea":
        break;
      case "PtgAttrSpace":
      case "PtgAttrSpaceSemi":
        last_sp = ff2;
        break;
      case "PtgTbl":
        break;
      case "PtgMemErr":
        break;
      case "PtgMissArg":
        stack.push("");
        break;
      case "PtgAreaErr":
        stack.push("#REF!");
        break;
      case "PtgAreaErr3d":
        stack.push("#REF!");
        break;
      case "PtgList":
        stack.push("Table" + f2[1].idx + "[#" + f2[1].rt + "]");
        break;
      case "PtgMemAreaN":
      case "PtgMemNoMemN":
      case "PtgAttrNoop":
      case "PtgSheet":
      case "PtgEndSheet":
        break;
      case "PtgMemFunc":
        break;
      case "PtgMemNoMem":
        break;
      case "PtgElfCol":
      case "PtgElfColS":
      case "PtgElfColSV":
      case "PtgElfColV":
      case "PtgElfLel":
      case "PtgElfRadical":
      case "PtgElfRadicalLel":
      case "PtgElfRadicalS":
      case "PtgElfRw":
      case "PtgElfRwV":
        throw new Error("Unsupported ELFs");
      case "PtgSxName":
        throw new Error("Unrecognized Formula Token: " + String(f2));
      default:
        throw new Error("Unrecognized Formula Token: " + String(f2));
    }
    var PtgNonDisp = ["PtgAttrSpace", "PtgAttrSpaceSemi", "PtgAttrGoto"];
    if (opts.biff != 3) {
      if (last_sp >= 0 && PtgNonDisp.indexOf(formula[0][ff2][0]) == -1) {
        f2 = formula[0][last_sp];
        var _left = true;
        switch (f2[1][0]) {
          case 4:
            _left = false;
          case 0:
            sp = fill(" ", f2[1][1]);
            break;
          case 5:
            _left = false;
          case 1:
            sp = fill("\r", f2[1][1]);
            break;
          default:
            sp = "";
            if (opts.WTF) throw new Error("Unexpected PtgAttrSpaceType " + f2[1][0]);
        }
        stack.push((_left ? sp : "") + stack.pop() + (_left ? "" : sp));
        last_sp = -1;
      }
    }
  }
  if (stack.length > 1 && opts.WTF) throw new Error("bad formula stack");
  return stack[0];
}
function parse_ArrayParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_XLSCellParsedFormula(blob, length, opts) {
  var target = blob.l + length, len = opts.biff == 2 ? 1 : 2;
  var rgcb, cce = blob.read_shift(len);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  var rgce = parse_Rgce(blob, cce, opts);
  if (length !== cce + len) rgcb = parse_RgbExtra(blob, length - cce - len, rgce, opts);
  blob.l = target;
  return [rgce, rgcb];
}
function parse_NameParsedFormula(blob, length, opts, cce) {
  var target = blob.l + length;
  var rgce = parse_Rgce(blob, cce, opts);
  var rgcb;
  if (target !== blob.l) rgcb = parse_RgbExtra(blob, target - blob.l, rgce, opts);
  return [rgce, rgcb];
}
function parse_SharedParsedFormula(blob, length, opts) {
  var target = blob.l + length;
  var rgcb, cce = blob.read_shift(2);
  var rgce = parse_Rgce(blob, cce, opts);
  if (cce == 65535) return [[], parsenoop(blob, length - 2)];
  if (length !== cce + 2) rgcb = parse_RgbExtra(blob, target - cce - 2, rgce, opts);
  return [rgce, rgcb];
}
function parse_FormulaValue(blob) {
  var b2;
  if (__readUInt16LE(blob, blob.l + 6) !== 65535) return [parse_Xnum(blob), "n"];
  switch (blob[blob.l]) {
    case 0:
      blob.l += 8;
      return ["String", "s"];
    case 1:
      b2 = blob[blob.l + 2] === 1;
      blob.l += 8;
      return [b2, "b"];
    case 2:
      b2 = blob[blob.l + 2];
      blob.l += 8;
      return [b2, "e"];
    case 3:
      blob.l += 8;
      return ["", "s"];
  }
  return [];
}
function write_FormulaValue(value) {
  if (value == null) {
    var o2 = new_buf(8);
    o2.write_shift(1, 3);
    o2.write_shift(1, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, 0);
    o2.write_shift(2, 65535);
    return o2;
  } else if (typeof value == "number") return write_Xnum(value);
  return write_Xnum(0);
}
function parse_Formula(blob, length, opts) {
  var end = blob.l + length;
  var cell = parse_XLSCell(blob);
  if (opts.biff == 2) ++blob.l;
  var val = parse_FormulaValue(blob);
  var flags = blob.read_shift(1);
  if (opts.biff != 2) {
    blob.read_shift(1);
    if (opts.biff >= 5) {
      blob.read_shift(4);
    }
  }
  var cbf = parse_XLSCellParsedFormula(blob, end - blob.l, opts);
  return { cell, val: val[0], formula: cbf, shared: flags >> 3 & 1, tt: val[1] };
}
function write_Formula(cell, R3, C2, opts, os) {
  var o1 = write_XLSCell(R3, C2, os);
  var o2 = write_FormulaValue(cell.v);
  var o3 = new_buf(6);
  var flags = 1 | 32;
  o3.write_shift(2, flags);
  o3.write_shift(4, 0);
  var bf2 = new_buf(cell.bf.length);
  for (var i3 = 0; i3 < cell.bf.length; ++i3) bf2[i3] = cell.bf[i3];
  var out = bconcat([o1, o2, o3, bf2]);
  return out;
}
function parse_XLSBParsedFormula(data, length, opts) {
  var cce = data.read_shift(4);
  var rgce = parse_Rgce(data, cce, opts);
  var cb2 = data.read_shift(4);
  var rgcb = cb2 > 0 ? parse_RgbExtra(data, cb2, rgce, opts) : null;
  return [rgce, rgcb];
}
var parse_XLSBArrayParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBCellParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBNameParsedFormula = parse_XLSBParsedFormula;
var parse_XLSBSharedParsedFormula = parse_XLSBParsedFormula;
var Cetab = {
  0: "BEEP",
  1: "OPEN",
  2: "OPEN.LINKS",
  3: "CLOSE.ALL",
  4: "SAVE",
  5: "SAVE.AS",
  6: "FILE.DELETE",
  7: "PAGE.SETUP",
  8: "PRINT",
  9: "PRINTER.SETUP",
  10: "QUIT",
  11: "NEW.WINDOW",
  12: "ARRANGE.ALL",
  13: "WINDOW.SIZE",
  14: "WINDOW.MOVE",
  15: "FULL",
  16: "CLOSE",
  17: "RUN",
  22: "SET.PRINT.AREA",
  23: "SET.PRINT.TITLES",
  24: "SET.PAGE.BREAK",
  25: "REMOVE.PAGE.BREAK",
  26: "FONT",
  27: "DISPLAY",
  28: "PROTECT.DOCUMENT",
  29: "PRECISION",
  30: "A1.R1C1",
  31: "CALCULATE.NOW",
  32: "CALCULATION",
  34: "DATA.FIND",
  35: "EXTRACT",
  36: "DATA.DELETE",
  37: "SET.DATABASE",
  38: "SET.CRITERIA",
  39: "SORT",
  40: "DATA.SERIES",
  41: "TABLE",
  42: "FORMAT.NUMBER",
  43: "ALIGNMENT",
  44: "STYLE",
  45: "BORDER",
  46: "CELL.PROTECTION",
  47: "COLUMN.WIDTH",
  48: "UNDO",
  49: "CUT",
  50: "COPY",
  51: "PASTE",
  52: "CLEAR",
  53: "PASTE.SPECIAL",
  54: "EDIT.DELETE",
  55: "INSERT",
  56: "FILL.RIGHT",
  57: "FILL.DOWN",
  61: "DEFINE.NAME",
  62: "CREATE.NAMES",
  63: "FORMULA.GOTO",
  64: "FORMULA.FIND",
  65: "SELECT.LAST.CELL",
  66: "SHOW.ACTIVE.CELL",
  67: "GALLERY.AREA",
  68: "GALLERY.BAR",
  69: "GALLERY.COLUMN",
  70: "GALLERY.LINE",
  71: "GALLERY.PIE",
  72: "GALLERY.SCATTER",
  73: "COMBINATION",
  74: "PREFERRED",
  75: "ADD.OVERLAY",
  76: "GRIDLINES",
  77: "SET.PREFERRED",
  78: "AXES",
  79: "LEGEND",
  80: "ATTACH.TEXT",
  81: "ADD.ARROW",
  82: "SELECT.CHART",
  83: "SELECT.PLOT.AREA",
  84: "PATTERNS",
  85: "MAIN.CHART",
  86: "OVERLAY",
  87: "SCALE",
  88: "FORMAT.LEGEND",
  89: "FORMAT.TEXT",
  90: "EDIT.REPEAT",
  91: "PARSE",
  92: "JUSTIFY",
  93: "HIDE",
  94: "UNHIDE",
  95: "WORKSPACE",
  96: "FORMULA",
  97: "FORMULA.FILL",
  98: "FORMULA.ARRAY",
  99: "DATA.FIND.NEXT",
  100: "DATA.FIND.PREV",
  101: "FORMULA.FIND.NEXT",
  102: "FORMULA.FIND.PREV",
  103: "ACTIVATE",
  104: "ACTIVATE.NEXT",
  105: "ACTIVATE.PREV",
  106: "UNLOCKED.NEXT",
  107: "UNLOCKED.PREV",
  108: "COPY.PICTURE",
  109: "SELECT",
  110: "DELETE.NAME",
  111: "DELETE.FORMAT",
  112: "VLINE",
  113: "HLINE",
  114: "VPAGE",
  115: "HPAGE",
  116: "VSCROLL",
  117: "HSCROLL",
  118: "ALERT",
  119: "NEW",
  120: "CANCEL.COPY",
  121: "SHOW.CLIPBOARD",
  122: "MESSAGE",
  124: "PASTE.LINK",
  125: "APP.ACTIVATE",
  126: "DELETE.ARROW",
  127: "ROW.HEIGHT",
  128: "FORMAT.MOVE",
  129: "FORMAT.SIZE",
  130: "FORMULA.REPLACE",
  131: "SEND.KEYS",
  132: "SELECT.SPECIAL",
  133: "APPLY.NAMES",
  134: "REPLACE.FONT",
  135: "FREEZE.PANES",
  136: "SHOW.INFO",
  137: "SPLIT",
  138: "ON.WINDOW",
  139: "ON.DATA",
  140: "DISABLE.INPUT",
  142: "OUTLINE",
  143: "LIST.NAMES",
  144: "FILE.CLOSE",
  145: "SAVE.WORKBOOK",
  146: "DATA.FORM",
  147: "COPY.CHART",
  148: "ON.TIME",
  149: "WAIT",
  150: "FORMAT.FONT",
  151: "FILL.UP",
  152: "FILL.LEFT",
  153: "DELETE.OVERLAY",
  155: "SHORT.MENUS",
  159: "SET.UPDATE.STATUS",
  161: "COLOR.PALETTE",
  162: "DELETE.STYLE",
  163: "WINDOW.RESTORE",
  164: "WINDOW.MAXIMIZE",
  166: "CHANGE.LINK",
  167: "CALCULATE.DOCUMENT",
  168: "ON.KEY",
  169: "APP.RESTORE",
  170: "APP.MOVE",
  171: "APP.SIZE",
  172: "APP.MINIMIZE",
  173: "APP.MAXIMIZE",
  174: "BRING.TO.FRONT",
  175: "SEND.TO.BACK",
  185: "MAIN.CHART.TYPE",
  186: "OVERLAY.CHART.TYPE",
  187: "SELECT.END",
  188: "OPEN.MAIL",
  189: "SEND.MAIL",
  190: "STANDARD.FONT",
  191: "CONSOLIDATE",
  192: "SORT.SPECIAL",
  193: "GALLERY.3D.AREA",
  194: "GALLERY.3D.COLUMN",
  195: "GALLERY.3D.LINE",
  196: "GALLERY.3D.PIE",
  197: "VIEW.3D",
  198: "GOAL.SEEK",
  199: "WORKGROUP",
  200: "FILL.GROUP",
  201: "UPDATE.LINK",
  202: "PROMOTE",
  203: "DEMOTE",
  204: "SHOW.DETAIL",
  206: "UNGROUP",
  207: "OBJECT.PROPERTIES",
  208: "SAVE.NEW.OBJECT",
  209: "SHARE",
  210: "SHARE.NAME",
  211: "DUPLICATE",
  212: "APPLY.STYLE",
  213: "ASSIGN.TO.OBJECT",
  214: "OBJECT.PROTECTION",
  215: "HIDE.OBJECT",
  216: "SET.EXTRACT",
  217: "CREATE.PUBLISHER",
  218: "SUBSCRIBE.TO",
  219: "ATTRIBUTES",
  220: "SHOW.TOOLBAR",
  222: "PRINT.PREVIEW",
  223: "EDIT.COLOR",
  224: "SHOW.LEVELS",
  225: "FORMAT.MAIN",
  226: "FORMAT.OVERLAY",
  227: "ON.RECALC",
  228: "EDIT.SERIES",
  229: "DEFINE.STYLE",
  240: "LINE.PRINT",
  243: "ENTER.DATA",
  249: "GALLERY.RADAR",
  250: "MERGE.STYLES",
  251: "EDITION.OPTIONS",
  252: "PASTE.PICTURE",
  253: "PASTE.PICTURE.LINK",
  254: "SPELLING",
  256: "ZOOM",
  259: "INSERT.OBJECT",
  260: "WINDOW.MINIMIZE",
  265: "SOUND.NOTE",
  266: "SOUND.PLAY",
  267: "FORMAT.SHAPE",
  268: "EXTEND.POLYGON",
  269: "FORMAT.AUTO",
  272: "GALLERY.3D.BAR",
  273: "GALLERY.3D.SURFACE",
  274: "FILL.AUTO",
  276: "CUSTOMIZE.TOOLBAR",
  277: "ADD.TOOL",
  278: "EDIT.OBJECT",
  279: "ON.DOUBLECLICK",
  280: "ON.ENTRY",
  281: "WORKBOOK.ADD",
  282: "WORKBOOK.MOVE",
  283: "WORKBOOK.COPY",
  284: "WORKBOOK.OPTIONS",
  285: "SAVE.WORKSPACE",
  288: "CHART.WIZARD",
  289: "DELETE.TOOL",
  290: "MOVE.TOOL",
  291: "WORKBOOK.SELECT",
  292: "WORKBOOK.ACTIVATE",
  293: "ASSIGN.TO.TOOL",
  295: "COPY.TOOL",
  296: "RESET.TOOL",
  297: "CONSTRAIN.NUMERIC",
  298: "PASTE.TOOL",
  302: "WORKBOOK.NEW",
  305: "SCENARIO.CELLS",
  306: "SCENARIO.DELETE",
  307: "SCENARIO.ADD",
  308: "SCENARIO.EDIT",
  309: "SCENARIO.SHOW",
  310: "SCENARIO.SHOW.NEXT",
  311: "SCENARIO.SUMMARY",
  312: "PIVOT.TABLE.WIZARD",
  313: "PIVOT.FIELD.PROPERTIES",
  314: "PIVOT.FIELD",
  315: "PIVOT.ITEM",
  316: "PIVOT.ADD.FIELDS",
  318: "OPTIONS.CALCULATION",
  319: "OPTIONS.EDIT",
  320: "OPTIONS.VIEW",
  321: "ADDIN.MANAGER",
  322: "MENU.EDITOR",
  323: "ATTACH.TOOLBARS",
  324: "VBAActivate",
  325: "OPTIONS.CHART",
  328: "VBA.INSERT.FILE",
  330: "VBA.PROCEDURE.DEFINITION",
  336: "ROUTING.SLIP",
  338: "ROUTE.DOCUMENT",
  339: "MAIL.LOGON",
  342: "INSERT.PICTURE",
  343: "EDIT.TOOL",
  344: "GALLERY.DOUGHNUT",
  350: "CHART.TREND",
  352: "PIVOT.ITEM.PROPERTIES",
  354: "WORKBOOK.INSERT",
  355: "OPTIONS.TRANSITION",
  356: "OPTIONS.GENERAL",
  370: "FILTER.ADVANCED",
  373: "MAIL.ADD.MAILER",
  374: "MAIL.DELETE.MAILER",
  375: "MAIL.REPLY",
  376: "MAIL.REPLY.ALL",
  377: "MAIL.FORWARD",
  378: "MAIL.NEXT.LETTER",
  379: "DATA.LABEL",
  380: "INSERT.TITLE",
  381: "FONT.PROPERTIES",
  382: "MACRO.OPTIONS",
  383: "WORKBOOK.HIDE",
  384: "WORKBOOK.UNHIDE",
  385: "WORKBOOK.DELETE",
  386: "WORKBOOK.NAME",
  388: "GALLERY.CUSTOM",
  390: "ADD.CHART.AUTOFORMAT",
  391: "DELETE.CHART.AUTOFORMAT",
  392: "CHART.ADD.DATA",
  393: "AUTO.OUTLINE",
  394: "TAB.ORDER",
  395: "SHOW.DIALOG",
  396: "SELECT.ALL",
  397: "UNGROUP.SHEETS",
  398: "SUBTOTAL.CREATE",
  399: "SUBTOTAL.REMOVE",
  400: "RENAME.OBJECT",
  412: "WORKBOOK.SCROLL",
  413: "WORKBOOK.NEXT",
  414: "WORKBOOK.PREV",
  415: "WORKBOOK.TAB.SPLIT",
  416: "FULL.SCREEN",
  417: "WORKBOOK.PROTECT",
  420: "SCROLLBAR.PROPERTIES",
  421: "PIVOT.SHOW.PAGES",
  422: "TEXT.TO.COLUMNS",
  423: "FORMAT.CHARTTYPE",
  424: "LINK.FORMAT",
  425: "TRACER.DISPLAY",
  430: "TRACER.NAVIGATE",
  431: "TRACER.CLEAR",
  432: "TRACER.ERROR",
  433: "PIVOT.FIELD.GROUP",
  434: "PIVOT.FIELD.UNGROUP",
  435: "CHECKBOX.PROPERTIES",
  436: "LABEL.PROPERTIES",
  437: "LISTBOX.PROPERTIES",
  438: "EDITBOX.PROPERTIES",
  439: "PIVOT.REFRESH",
  440: "LINK.COMBO",
  441: "OPEN.TEXT",
  442: "HIDE.DIALOG",
  443: "SET.DIALOG.FOCUS",
  444: "ENABLE.OBJECT",
  445: "PUSHBUTTON.PROPERTIES",
  446: "SET.DIALOG.DEFAULT",
  447: "FILTER",
  448: "FILTER.SHOW.ALL",
  449: "CLEAR.OUTLINE",
  450: "FUNCTION.WIZARD",
  451: "ADD.LIST.ITEM",
  452: "SET.LIST.ITEM",
  453: "REMOVE.LIST.ITEM",
  454: "SELECT.LIST.ITEM",
  455: "SET.CONTROL.VALUE",
  456: "SAVE.COPY.AS",
  458: "OPTIONS.LISTS.ADD",
  459: "OPTIONS.LISTS.DELETE",
  460: "SERIES.AXES",
  461: "SERIES.X",
  462: "SERIES.Y",
  463: "ERRORBAR.X",
  464: "ERRORBAR.Y",
  465: "FORMAT.CHART",
  466: "SERIES.ORDER",
  467: "MAIL.LOGOFF",
  468: "CLEAR.ROUTING.SLIP",
  469: "APP.ACTIVATE.MICROSOFT",
  470: "MAIL.EDIT.MAILER",
  471: "ON.SHEET",
  472: "STANDARD.WIDTH",
  473: "SCENARIO.MERGE",
  474: "SUMMARY.INFO",
  475: "FIND.FILE",
  476: "ACTIVE.CELL.FONT",
  477: "ENABLE.TIPWIZARD",
  478: "VBA.MAKE.ADDIN",
  480: "INSERTDATATABLE",
  481: "WORKGROUP.OPTIONS",
  482: "MAIL.SEND.MAILER",
  485: "AUTOCORRECT",
  489: "POST.DOCUMENT",
  491: "PICKLIST",
  493: "VIEW.SHOW",
  494: "VIEW.DEFINE",
  495: "VIEW.DELETE",
  509: "SHEET.BACKGROUND",
  510: "INSERT.MAP.OBJECT",
  511: "OPTIONS.MENONO",
  517: "MSOCHECKS",
  518: "NORMAL",
  519: "LAYOUT",
  520: "RM.PRINT.AREA",
  521: "CLEAR.PRINT.AREA",
  522: "ADD.PRINT.AREA",
  523: "MOVE.BRK",
  545: "HIDECURR.NOTE",
  546: "HIDEALL.NOTES",
  547: "DELETE.NOTE",
  548: "TRAVERSE.NOTES",
  549: "ACTIVATE.NOTES",
  620: "PROTECT.REVISIONS",
  621: "UNPROTECT.REVISIONS",
  647: "OPTIONS.ME",
  653: "WEB.PUBLISH",
  667: "NEWWEBQUERY",
  673: "PIVOT.TABLE.CHART",
  753: "OPTIONS.SAVE",
  755: "OPTIONS.SPELL",
  808: "HIDEALL.INKANNOTS"
};
var Ftab = {
  0: "COUNT",
  1: "IF",
  2: "ISNA",
  3: "ISERROR",
  4: "SUM",
  5: "AVERAGE",
  6: "MIN",
  7: "MAX",
  8: "ROW",
  9: "COLUMN",
  10: "NA",
  11: "NPV",
  12: "STDEV",
  13: "DOLLAR",
  14: "FIXED",
  15: "SIN",
  16: "COS",
  17: "TAN",
  18: "ATAN",
  19: "PI",
  20: "SQRT",
  21: "EXP",
  22: "LN",
  23: "LOG10",
  24: "ABS",
  25: "INT",
  26: "SIGN",
  27: "ROUND",
  28: "LOOKUP",
  29: "INDEX",
  30: "REPT",
  31: "MID",
  32: "LEN",
  33: "VALUE",
  34: "TRUE",
  35: "FALSE",
  36: "AND",
  37: "OR",
  38: "NOT",
  39: "MOD",
  40: "DCOUNT",
  41: "DSUM",
  42: "DAVERAGE",
  43: "DMIN",
  44: "DMAX",
  45: "DSTDEV",
  46: "VAR",
  47: "DVAR",
  48: "TEXT",
  49: "LINEST",
  50: "TREND",
  51: "LOGEST",
  52: "GROWTH",
  53: "GOTO",
  54: "HALT",
  55: "RETURN",
  56: "PV",
  57: "FV",
  58: "NPER",
  59: "PMT",
  60: "RATE",
  61: "MIRR",
  62: "IRR",
  63: "RAND",
  64: "MATCH",
  65: "DATE",
  66: "TIME",
  67: "DAY",
  68: "MONTH",
  69: "YEAR",
  70: "WEEKDAY",
  71: "HOUR",
  72: "MINUTE",
  73: "SECOND",
  74: "NOW",
  75: "AREAS",
  76: "ROWS",
  77: "COLUMNS",
  78: "OFFSET",
  79: "ABSREF",
  80: "RELREF",
  81: "ARGUMENT",
  82: "SEARCH",
  83: "TRANSPOSE",
  84: "ERROR",
  85: "STEP",
  86: "TYPE",
  87: "ECHO",
  88: "SET.NAME",
  89: "CALLER",
  90: "DEREF",
  91: "WINDOWS",
  92: "SERIES",
  93: "DOCUMENTS",
  94: "ACTIVE.CELL",
  95: "SELECTION",
  96: "RESULT",
  97: "ATAN2",
  98: "ASIN",
  99: "ACOS",
  100: "CHOOSE",
  101: "HLOOKUP",
  102: "VLOOKUP",
  103: "LINKS",
  104: "INPUT",
  105: "ISREF",
  106: "GET.FORMULA",
  107: "GET.NAME",
  108: "SET.VALUE",
  109: "LOG",
  110: "EXEC",
  111: "CHAR",
  112: "LOWER",
  113: "UPPER",
  114: "PROPER",
  115: "LEFT",
  116: "RIGHT",
  117: "EXACT",
  118: "TRIM",
  119: "REPLACE",
  120: "SUBSTITUTE",
  121: "CODE",
  122: "NAMES",
  123: "DIRECTORY",
  124: "FIND",
  125: "CELL",
  126: "ISERR",
  127: "ISTEXT",
  128: "ISNUMBER",
  129: "ISBLANK",
  130: "T",
  131: "N",
  132: "FOPEN",
  133: "FCLOSE",
  134: "FSIZE",
  135: "FREADLN",
  136: "FREAD",
  137: "FWRITELN",
  138: "FWRITE",
  139: "FPOS",
  140: "DATEVALUE",
  141: "TIMEVALUE",
  142: "SLN",
  143: "SYD",
  144: "DDB",
  145: "GET.DEF",
  146: "REFTEXT",
  147: "TEXTREF",
  148: "INDIRECT",
  149: "REGISTER",
  150: "CALL",
  151: "ADD.BAR",
  152: "ADD.MENU",
  153: "ADD.COMMAND",
  154: "ENABLE.COMMAND",
  155: "CHECK.COMMAND",
  156: "RENAME.COMMAND",
  157: "SHOW.BAR",
  158: "DELETE.MENU",
  159: "DELETE.COMMAND",
  160: "GET.CHART.ITEM",
  161: "DIALOG.BOX",
  162: "CLEAN",
  163: "MDETERM",
  164: "MINVERSE",
  165: "MMULT",
  166: "FILES",
  167: "IPMT",
  168: "PPMT",
  169: "COUNTA",
  170: "CANCEL.KEY",
  171: "FOR",
  172: "WHILE",
  173: "BREAK",
  174: "NEXT",
  175: "INITIATE",
  176: "REQUEST",
  177: "POKE",
  178: "EXECUTE",
  179: "TERMINATE",
  180: "RESTART",
  181: "HELP",
  182: "GET.BAR",
  183: "PRODUCT",
  184: "FACT",
  185: "GET.CELL",
  186: "GET.WORKSPACE",
  187: "GET.WINDOW",
  188: "GET.DOCUMENT",
  189: "DPRODUCT",
  190: "ISNONTEXT",
  191: "GET.NOTE",
  192: "NOTE",
  193: "STDEVP",
  194: "VARP",
  195: "DSTDEVP",
  196: "DVARP",
  197: "TRUNC",
  198: "ISLOGICAL",
  199: "DCOUNTA",
  200: "DELETE.BAR",
  201: "UNREGISTER",
  204: "USDOLLAR",
  205: "FINDB",
  206: "SEARCHB",
  207: "REPLACEB",
  208: "LEFTB",
  209: "RIGHTB",
  210: "MIDB",
  211: "LENB",
  212: "ROUNDUP",
  213: "ROUNDDOWN",
  214: "ASC",
  215: "DBCS",
  216: "RANK",
  219: "ADDRESS",
  220: "DAYS360",
  221: "TODAY",
  222: "VDB",
  223: "ELSE",
  224: "ELSE.IF",
  225: "END.IF",
  226: "FOR.CELL",
  227: "MEDIAN",
  228: "SUMPRODUCT",
  229: "SINH",
  230: "COSH",
  231: "TANH",
  232: "ASINH",
  233: "ACOSH",
  234: "ATANH",
  235: "DGET",
  236: "CREATE.OBJECT",
  237: "VOLATILE",
  238: "LAST.ERROR",
  239: "CUSTOM.UNDO",
  240: "CUSTOM.REPEAT",
  241: "FORMULA.CONVERT",
  242: "GET.LINK.INFO",
  243: "TEXT.BOX",
  244: "INFO",
  245: "GROUP",
  246: "GET.OBJECT",
  247: "DB",
  248: "PAUSE",
  251: "RESUME",
  252: "FREQUENCY",
  253: "ADD.TOOLBAR",
  254: "DELETE.TOOLBAR",
  255: "User",
  256: "RESET.TOOLBAR",
  257: "EVALUATE",
  258: "GET.TOOLBAR",
  259: "GET.TOOL",
  260: "SPELLING.CHECK",
  261: "ERROR.TYPE",
  262: "APP.TITLE",
  263: "WINDOW.TITLE",
  264: "SAVE.TOOLBAR",
  265: "ENABLE.TOOL",
  266: "PRESS.TOOL",
  267: "REGISTER.ID",
  268: "GET.WORKBOOK",
  269: "AVEDEV",
  270: "BETADIST",
  271: "GAMMALN",
  272: "BETAINV",
  273: "BINOMDIST",
  274: "CHIDIST",
  275: "CHIINV",
  276: "COMBIN",
  277: "CONFIDENCE",
  278: "CRITBINOM",
  279: "EVEN",
  280: "EXPONDIST",
  281: "FDIST",
  282: "FINV",
  283: "FISHER",
  284: "FISHERINV",
  285: "FLOOR",
  286: "GAMMADIST",
  287: "GAMMAINV",
  288: "CEILING",
  289: "HYPGEOMDIST",
  290: "LOGNORMDIST",
  291: "LOGINV",
  292: "NEGBINOMDIST",
  293: "NORMDIST",
  294: "NORMSDIST",
  295: "NORMINV",
  296: "NORMSINV",
  297: "STANDARDIZE",
  298: "ODD",
  299: "PERMUT",
  300: "POISSON",
  301: "TDIST",
  302: "WEIBULL",
  303: "SUMXMY2",
  304: "SUMX2MY2",
  305: "SUMX2PY2",
  306: "CHITEST",
  307: "CORREL",
  308: "COVAR",
  309: "FORECAST",
  310: "FTEST",
  311: "INTERCEPT",
  312: "PEARSON",
  313: "RSQ",
  314: "STEYX",
  315: "SLOPE",
  316: "TTEST",
  317: "PROB",
  318: "DEVSQ",
  319: "GEOMEAN",
  320: "HARMEAN",
  321: "SUMSQ",
  322: "KURT",
  323: "SKEW",
  324: "ZTEST",
  325: "LARGE",
  326: "SMALL",
  327: "QUARTILE",
  328: "PERCENTILE",
  329: "PERCENTRANK",
  330: "MODE",
  331: "TRIMMEAN",
  332: "TINV",
  334: "MOVIE.COMMAND",
  335: "GET.MOVIE",
  336: "CONCATENATE",
  337: "POWER",
  338: "PIVOT.ADD.DATA",
  339: "GET.PIVOT.TABLE",
  340: "GET.PIVOT.FIELD",
  341: "GET.PIVOT.ITEM",
  342: "RADIANS",
  343: "DEGREES",
  344: "SUBTOTAL",
  345: "SUMIF",
  346: "COUNTIF",
  347: "COUNTBLANK",
  348: "SCENARIO.GET",
  349: "OPTIONS.LISTS.GET",
  350: "ISPMT",
  351: "DATEDIF",
  352: "DATESTRING",
  353: "NUMBERSTRING",
  354: "ROMAN",
  355: "OPEN.DIALOG",
  356: "SAVE.DIALOG",
  357: "VIEW.GET",
  358: "GETPIVOTDATA",
  359: "HYPERLINK",
  360: "PHONETIC",
  361: "AVERAGEA",
  362: "MAXA",
  363: "MINA",
  364: "STDEVPA",
  365: "VARPA",
  366: "STDEVA",
  367: "VARA",
  368: "BAHTTEXT",
  369: "THAIDAYOFWEEK",
  370: "THAIDIGIT",
  371: "THAIMONTHOFYEAR",
  372: "THAINUMSOUND",
  373: "THAINUMSTRING",
  374: "THAISTRINGLENGTH",
  375: "ISTHAIDIGIT",
  376: "ROUNDBAHTDOWN",
  377: "ROUNDBAHTUP",
  378: "THAIYEAR",
  379: "RTD",
  380: "CUBEVALUE",
  381: "CUBEMEMBER",
  382: "CUBEMEMBERPROPERTY",
  383: "CUBERANKEDMEMBER",
  384: "HEX2BIN",
  385: "HEX2DEC",
  386: "HEX2OCT",
  387: "DEC2BIN",
  388: "DEC2HEX",
  389: "DEC2OCT",
  390: "OCT2BIN",
  391: "OCT2HEX",
  392: "OCT2DEC",
  393: "BIN2DEC",
  394: "BIN2OCT",
  395: "BIN2HEX",
  396: "IMSUB",
  397: "IMDIV",
  398: "IMPOWER",
  399: "IMABS",
  400: "IMSQRT",
  401: "IMLN",
  402: "IMLOG2",
  403: "IMLOG10",
  404: "IMSIN",
  405: "IMCOS",
  406: "IMEXP",
  407: "IMARGUMENT",
  408: "IMCONJUGATE",
  409: "IMAGINARY",
  410: "IMREAL",
  411: "COMPLEX",
  412: "IMSUM",
  413: "IMPRODUCT",
  414: "SERIESSUM",
  415: "FACTDOUBLE",
  416: "SQRTPI",
  417: "QUOTIENT",
  418: "DELTA",
  419: "GESTEP",
  420: "ISEVEN",
  421: "ISODD",
  422: "MROUND",
  423: "ERF",
  424: "ERFC",
  425: "BESSELJ",
  426: "BESSELK",
  427: "BESSELY",
  428: "BESSELI",
  429: "XIRR",
  430: "XNPV",
  431: "PRICEMAT",
  432: "YIELDMAT",
  433: "INTRATE",
  434: "RECEIVED",
  435: "DISC",
  436: "PRICEDISC",
  437: "YIELDDISC",
  438: "TBILLEQ",
  439: "TBILLPRICE",
  440: "TBILLYIELD",
  441: "PRICE",
  442: "YIELD",
  443: "DOLLARDE",
  444: "DOLLARFR",
  445: "NOMINAL",
  446: "EFFECT",
  447: "CUMPRINC",
  448: "CUMIPMT",
  449: "EDATE",
  450: "EOMONTH",
  451: "YEARFRAC",
  452: "COUPDAYBS",
  453: "COUPDAYS",
  454: "COUPDAYSNC",
  455: "COUPNCD",
  456: "COUPNUM",
  457: "COUPPCD",
  458: "DURATION",
  459: "MDURATION",
  460: "ODDLPRICE",
  461: "ODDLYIELD",
  462: "ODDFPRICE",
  463: "ODDFYIELD",
  464: "RANDBETWEEN",
  465: "WEEKNUM",
  466: "AMORDEGRC",
  467: "AMORLINC",
  468: "CONVERT",
  724: "SHEETJS",
  469: "ACCRINT",
  470: "ACCRINTM",
  471: "WORKDAY",
  472: "NETWORKDAYS",
  473: "GCD",
  474: "MULTINOMIAL",
  475: "LCM",
  476: "FVSCHEDULE",
  477: "CUBEKPIMEMBER",
  478: "CUBESET",
  479: "CUBESETCOUNT",
  480: "IFERROR",
  481: "COUNTIFS",
  482: "SUMIFS",
  483: "AVERAGEIF",
  484: "AVERAGEIFS"
};
var FtabArgc = {
  2: 1,
  3: 1,
  10: 0,
  15: 1,
  16: 1,
  17: 1,
  18: 1,
  19: 0,
  20: 1,
  21: 1,
  22: 1,
  23: 1,
  24: 1,
  25: 1,
  26: 1,
  27: 2,
  30: 2,
  31: 3,
  32: 1,
  33: 1,
  34: 0,
  35: 0,
  38: 1,
  39: 2,
  40: 3,
  41: 3,
  42: 3,
  43: 3,
  44: 3,
  45: 3,
  47: 3,
  48: 2,
  53: 1,
  61: 3,
  63: 0,
  65: 3,
  66: 3,
  67: 1,
  68: 1,
  69: 1,
  70: 1,
  71: 1,
  72: 1,
  73: 1,
  74: 0,
  75: 1,
  76: 1,
  77: 1,
  79: 2,
  80: 2,
  83: 1,
  85: 0,
  86: 1,
  89: 0,
  90: 1,
  94: 0,
  95: 0,
  97: 2,
  98: 1,
  99: 1,
  101: 3,
  102: 3,
  105: 1,
  106: 1,
  108: 2,
  111: 1,
  112: 1,
  113: 1,
  114: 1,
  117: 2,
  118: 1,
  119: 4,
  121: 1,
  126: 1,
  127: 1,
  128: 1,
  129: 1,
  130: 1,
  131: 1,
  133: 1,
  134: 1,
  135: 1,
  136: 2,
  137: 2,
  138: 2,
  140: 1,
  141: 1,
  142: 3,
  143: 4,
  144: 4,
  161: 1,
  162: 1,
  163: 1,
  164: 1,
  165: 2,
  172: 1,
  175: 2,
  176: 2,
  177: 3,
  178: 2,
  179: 1,
  184: 1,
  186: 1,
  189: 3,
  190: 1,
  195: 3,
  196: 3,
  197: 1,
  198: 1,
  199: 3,
  201: 1,
  207: 4,
  210: 3,
  211: 1,
  212: 2,
  213: 2,
  214: 1,
  215: 1,
  225: 0,
  229: 1,
  230: 1,
  231: 1,
  232: 1,
  233: 1,
  234: 1,
  235: 3,
  244: 1,
  247: 4,
  252: 2,
  257: 1,
  261: 1,
  271: 1,
  273: 4,
  274: 2,
  275: 2,
  276: 2,
  277: 3,
  278: 3,
  279: 1,
  280: 3,
  281: 3,
  282: 3,
  283: 1,
  284: 1,
  285: 2,
  286: 4,
  287: 3,
  288: 2,
  289: 4,
  290: 3,
  291: 3,
  292: 3,
  293: 4,
  294: 1,
  295: 3,
  296: 1,
  297: 3,
  298: 1,
  299: 2,
  300: 3,
  301: 3,
  302: 4,
  303: 2,
  304: 2,
  305: 2,
  306: 2,
  307: 2,
  308: 2,
  309: 3,
  310: 2,
  311: 2,
  312: 2,
  313: 2,
  314: 2,
  315: 2,
  316: 4,
  325: 2,
  326: 2,
  327: 2,
  328: 2,
  331: 2,
  332: 2,
  337: 2,
  342: 1,
  343: 1,
  346: 2,
  347: 1,
  350: 4,
  351: 3,
  352: 1,
  353: 2,
  360: 1,
  368: 1,
  369: 1,
  370: 1,
  371: 1,
  372: 1,
  373: 1,
  374: 1,
  375: 1,
  376: 1,
  377: 1,
  378: 1,
  382: 3,
  385: 1,
  392: 1,
  393: 1,
  396: 2,
  397: 2,
  398: 2,
  399: 1,
  400: 1,
  401: 1,
  402: 1,
  403: 1,
  404: 1,
  405: 1,
  406: 1,
  407: 1,
  408: 1,
  409: 1,
  410: 1,
  414: 4,
  415: 1,
  416: 1,
  417: 2,
  420: 1,
  421: 1,
  422: 2,
  424: 1,
  425: 2,
  426: 2,
  427: 2,
  428: 2,
  430: 3,
  438: 3,
  439: 3,
  440: 3,
  443: 2,
  444: 2,
  445: 2,
  446: 2,
  447: 6,
  448: 6,
  449: 2,
  450: 2,
  464: 2,
  468: 3,
  476: 2,
  479: 1,
  480: 2,
  65535: 0
};
function ods_to_csf_formula(f2) {
  if (f2.slice(0, 3) == "of:") f2 = f2.slice(3);
  if (f2.charCodeAt(0) == 61) {
    f2 = f2.slice(1);
    if (f2.charCodeAt(0) == 61) f2 = f2.slice(1);
  }
  f2 = f2.replace(/COM\.MICROSOFT\./g, "");
  f2 = f2.replace(/\[((?:\.[A-Z]+[0-9]+)(?::\.[A-Z]+[0-9]+)?)\]/g, function($$, $1) {
    return $1.replace(/\./g, "");
  });
  f2 = f2.replace(/\[.(#[A-Z]*[?!])\]/g, "$1");
  return f2.replace(/[;~]/g, ",").replace(/\|/g, ";");
}
function csf_to_ods_formula(f2) {
  var o2 = "of:=" + f2.replace(crefregex, "$1[.$2$3$4$5]").replace(/\]:\[/g, ":");
  return o2.replace(/;/g, "|").replace(/,/g, ";");
}
function ods_to_csf_3D(r2) {
  var a4 = r2.split(":");
  var s4 = a4[0].split(".")[0];
  return [s4, a4[0].split(".")[1] + (a4.length > 1 ? ":" + (a4[1].split(".")[1] || a4[1].split(".")[0]) : "")];
}
function csf_to_ods_3D(r2) {
  return r2.replace(/\./, "!");
}
var strs = {};
var _ssfopts = {};
var browser_has_Map = typeof Map !== "undefined";
function get_sst_id(sst, str, rev) {
  var i3 = 0, len = sst.length;
  if (rev) {
    if (browser_has_Map ? rev.has(str) : Object.prototype.hasOwnProperty.call(rev, str)) {
      var revarr = browser_has_Map ? rev.get(str) : rev[str];
      for (; i3 < revarr.length; ++i3) {
        if (sst[revarr[i3]].t === str) {
          sst.Count++;
          return revarr[i3];
        }
      }
    }
  } else for (; i3 < len; ++i3) {
    if (sst[i3].t === str) {
      sst.Count++;
      return i3;
    }
  }
  sst[len] = { t: str };
  sst.Count++;
  sst.Unique++;
  if (rev) {
    if (browser_has_Map) {
      if (!rev.has(str)) rev.set(str, []);
      rev.get(str).push(len);
    } else {
      if (!Object.prototype.hasOwnProperty.call(rev, str)) rev[str] = [];
      rev[str].push(len);
    }
  }
  return len;
}
function col_obj_w(C2, col) {
  var p2 = { min: C2 + 1, max: C2 + 1 };
  var wch = -1;
  if (col.MDW) MDW = col.MDW;
  if (col.width != null) p2.customWidth = 1;
  else if (col.wpx != null) wch = px2char(col.wpx);
  else if (col.wch != null) wch = col.wch;
  if (wch > -1) {
    p2.width = char2width(wch);
    p2.customWidth = 1;
  } else if (col.width != null) p2.width = col.width;
  if (col.hidden) p2.hidden = true;
  if (col.level != null) {
    p2.outlineLevel = p2.level = col.level;
  }
  return p2;
}
function default_margins(margins, mode) {
  if (!margins) return;
  var defs = [0.7, 0.7, 0.75, 0.75, 0.3, 0.3];
  if (mode == "xlml") defs = [1, 1, 1, 1, 0.5, 0.5];
  if (margins.left == null) margins.left = defs[0];
  if (margins.right == null) margins.right = defs[1];
  if (margins.top == null) margins.top = defs[2];
  if (margins.bottom == null) margins.bottom = defs[3];
  if (margins.header == null) margins.header = defs[4];
  if (margins.footer == null) margins.footer = defs[5];
}
function get_cell_style(styles, cell, opts) {
  var z3 = opts.revssf[cell.z != null ? cell.z : "General"];
  var i3 = 60, len = styles.length;
  if (z3 == null && opts.ssf) {
    for (; i3 < 392; ++i3) if (opts.ssf[i3] == null) {
      SSF_load(cell.z, i3);
      opts.ssf[i3] = cell.z;
      opts.revssf[cell.z] = z3 = i3;
      break;
    }
  }
  for (i3 = 0; i3 != len; ++i3) if (styles[i3].numFmtId === z3) return i3;
  styles[len] = {
    numFmtId: z3,
    fontId: 0,
    fillId: 0,
    borderId: 0,
    xfId: 0,
    applyNumberFormat: 1
  };
  return len;
}
function safe_format(p2, fmtid, fillid, opts, themes, styles) {
  try {
    if (opts.cellNF) p2.z = table_fmt[fmtid];
  } catch (e3) {
    if (opts.WTF) throw e3;
  }
  if (p2.t === "z" && !opts.cellStyles) return;
  if (p2.t === "d" && typeof p2.v === "string") p2.v = parseDate(p2.v);
  if ((!opts || opts.cellText !== false) && p2.t !== "z") try {
    if (table_fmt[fmtid] == null) SSF_load(SSFImplicit[fmtid] || "General", fmtid);
    if (p2.t === "e") p2.w = p2.w || BErr[p2.v];
    else if (fmtid === 0) {
      if (p2.t === "n") {
        if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
        else p2.w = SSF_general_num(p2.v);
      } else if (p2.t === "d") {
        var dd2 = datenum(p2.v);
        if ((dd2 | 0) === dd2) p2.w = dd2.toString(10);
        else p2.w = SSF_general_num(dd2);
      } else if (p2.v === void 0) return "";
      else p2.w = SSF_general(p2.v, _ssfopts);
    } else if (p2.t === "d") p2.w = SSF_format(fmtid, datenum(p2.v), _ssfopts);
    else p2.w = SSF_format(fmtid, p2.v, _ssfopts);
  } catch (e3) {
    if (opts.WTF) throw e3;
  }
  if (!opts.cellStyles) return;
  if (fillid != null) try {
    p2.s = styles.Fills[fillid];
    if (p2.s.fgColor && p2.s.fgColor.theme && !p2.s.fgColor.rgb) {
      p2.s.fgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb, p2.s.fgColor.tint || 0);
      if (opts.WTF) p2.s.fgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.fgColor.theme].rgb;
    }
    if (p2.s.bgColor && p2.s.bgColor.theme) {
      p2.s.bgColor.rgb = rgb_tint(themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb, p2.s.bgColor.tint || 0);
      if (opts.WTF) p2.s.bgColor.raw_rgb = themes.themeElements.clrScheme[p2.s.bgColor.theme].rgb;
    }
  } catch (e3) {
    if (opts.WTF && styles.Fills) throw e3;
  }
}
function check_ws(ws, sname, i3) {
  if (ws && ws["!ref"]) {
    var range = safe_decode_range(ws["!ref"]);
    if (range.e.c < range.s.c || range.e.r < range.s.r) throw new Error("Bad range (" + i3 + "): " + ws["!ref"]);
  }
}
function parse_ws_xml_dim(ws, s4) {
  var d4 = safe_decode_range(s4);
  if (d4.s.r <= d4.e.r && d4.s.c <= d4.e.c && d4.s.r >= 0 && d4.s.c >= 0) ws["!ref"] = encode_range(d4);
}
var mergecregex = /<(?:\w:)?mergeCell ref="[A-Z0-9:]+"\s*[\/]?>/g;
var sheetdataregex = /<(?:\w+:)?sheetData[^>]*>([\s\S]*)<\/(?:\w+:)?sheetData>/;
var hlinkregex = /<(?:\w:)?hyperlink [^>]*>/mg;
var dimregex = /"(\w*:\w*)"/;
var colregex = /<(?:\w:)?col\b[^>]*[\/]?>/g;
var afregex = /<(?:\w:)?autoFilter[^>]*([\/]|>([\s\S]*)<\/(?:\w:)?autoFilter)>/g;
var marginregex = /<(?:\w:)?pageMargins[^>]*\/>/g;
var sheetprregex = /<(?:\w:)?sheetPr\b(?:[^>a-z][^>]*)?\/>/;
var sheetprregex2 = /<(?:\w:)?sheetPr[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetPr)>/;
var svsregex = /<(?:\w:)?sheetViews[^>]*(?:[\/]|>([\s\S]*)<\/(?:\w:)?sheetViews)>/;
function parse_ws_xml(data, opts, idx, rels, wb2, themes, styles) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s4 = opts.dense ? [] : {};
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var data1 = "", data2 = "";
  var mtch = data.match(sheetdataregex);
  if (mtch) {
    data1 = data.slice(0, mtch.index);
    data2 = data.slice(mtch.index + mtch[0].length);
  } else data1 = data2 = data;
  var sheetPr = data1.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s4, wb2, idx);
  else if (sheetPr = data1.match(sheetprregex2)) parse_ws_xml_sheetpr2(sheetPr[0], sheetPr[1] || "", s4, wb2, idx);
  var ridx = (data1.match(/<(?:\w*:)?dimension/) || { index: -1 }).index;
  if (ridx > 0) {
    var ref = data1.slice(ridx, ridx + 50).match(dimregex);
    if (ref) parse_ws_xml_dim(s4, ref[1]);
  }
  var svs = data1.match(svsregex);
  if (svs && svs[1]) parse_ws_xml_sheetviews(svs[1], wb2);
  var columns = [];
  if (opts.cellStyles) {
    var cols = data1.match(colregex);
    if (cols) parse_ws_xml_cols(columns, cols);
  }
  if (mtch) parse_ws_xml_data(mtch[1], s4, opts, refguess, themes, styles);
  var afilter = data2.match(afregex);
  if (afilter) s4["!autofilter"] = parse_ws_xml_autofilter(afilter[0]);
  var merges = [];
  var _merge = data2.match(mergecregex);
  if (_merge) for (ridx = 0; ridx != _merge.length; ++ridx)
    merges[ridx] = safe_decode_range(_merge[ridx].slice(_merge[ridx].indexOf('"') + 1));
  var hlink = data2.match(hlinkregex);
  if (hlink) parse_ws_xml_hlinks(s4, hlink, rels);
  var margins = data2.match(marginregex);
  if (margins) s4["!margins"] = parse_ws_xml_margins(parsexmltag(margins[0]));
  if (!s4["!ref"] && refguess.e.c >= refguess.s.c && refguess.e.r >= refguess.s.r) s4["!ref"] = encode_range(refguess);
  if (opts.sheetRows > 0 && s4["!ref"]) {
    var tmpref = safe_decode_range(s4["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s4["!fullref"] = s4["!ref"];
      s4["!ref"] = encode_range(tmpref);
    }
  }
  if (columns.length > 0) s4["!cols"] = columns;
  if (merges.length > 0) s4["!merges"] = merges;
  return s4;
}
function write_ws_xml_merges(merges) {
  if (merges.length === 0) return "";
  var o2 = '<mergeCells count="' + merges.length + '">';
  for (var i3 = 0; i3 != merges.length; ++i3) o2 += '<mergeCell ref="' + encode_range(merges[i3]) + '"/>';
  return o2 + "</mergeCells>";
}
function parse_ws_xml_sheetpr(sheetPr, s4, wb2, idx) {
  var data = parsexmltag(sheetPr);
  if (!wb2.Sheets[idx]) wb2.Sheets[idx] = {};
  if (data.codeName) wb2.Sheets[idx].CodeName = unescapexml(utf8read(data.codeName));
}
function parse_ws_xml_sheetpr2(sheetPr, body, s4, wb2, idx) {
  parse_ws_xml_sheetpr(sheetPr.slice(0, sheetPr.indexOf(">")), s4, wb2, idx);
}
function write_ws_xml_sheetpr(ws, wb2, idx, opts, o2) {
  var needed = false;
  var props = {}, payload = null;
  if (opts.bookType !== "xlsx" && wb2.vbaraw) {
    var cname = wb2.SheetNames[idx];
    try {
      if (wb2.Workbook) cname = wb2.Workbook.Sheets[idx].CodeName || cname;
    } catch (e3) {
    }
    needed = true;
    props.codeName = utf8write(escapexml(cname));
  }
  if (ws && ws["!outline"]) {
    var outlineprops = { summaryBelow: 1, summaryRight: 1 };
    if (ws["!outline"].above) outlineprops.summaryBelow = 0;
    if (ws["!outline"].left) outlineprops.summaryRight = 0;
    payload = (payload || "") + writextag("outlinePr", null, outlineprops);
  }
  if (!needed && !payload) return;
  o2[o2.length] = writextag("sheetPr", payload, props);
}
var sheetprot_deffalse = ["objects", "scenarios", "selectLockedCells", "selectUnlockedCells"];
var sheetprot_deftrue = [
  "formatColumns",
  "formatRows",
  "formatCells",
  "insertColumns",
  "insertRows",
  "insertHyperlinks",
  "deleteColumns",
  "deleteRows",
  "sort",
  "autoFilter",
  "pivotTables"
];
function write_ws_xml_protection(sp) {
  var o2 = { sheet: 1 };
  sheetprot_deffalse.forEach(function(n2) {
    if (sp[n2] != null && sp[n2]) o2[n2] = "1";
  });
  sheetprot_deftrue.forEach(function(n2) {
    if (sp[n2] != null && !sp[n2]) o2[n2] = "0";
  });
  if (sp.password) o2.password = crypto_CreatePasswordVerifier_Method1(sp.password).toString(16).toUpperCase();
  return writextag("sheetProtection", null, o2);
}
function parse_ws_xml_hlinks(s4, data, rels) {
  var dense = Array.isArray(s4);
  for (var i3 = 0; i3 != data.length; ++i3) {
    var val = parsexmltag(utf8read(data[i3]), true);
    if (!val.ref) return;
    var rel = ((rels || {})["!id"] || [])[val.id];
    if (rel) {
      val.Target = rel.Target;
      if (val.location) val.Target += "#" + unescapexml(val.location);
    } else {
      val.Target = "#" + unescapexml(val.location);
      rel = { Target: val.Target, TargetMode: "Internal" };
    }
    val.Rel = rel;
    if (val.tooltip) {
      val.Tooltip = val.tooltip;
      delete val.tooltip;
    }
    var rng2 = safe_decode_range(val.ref);
    for (var R3 = rng2.s.r; R3 <= rng2.e.r; ++R3) for (var C2 = rng2.s.c; C2 <= rng2.e.c; ++C2) {
      var addr = encode_cell({ c: C2, r: R3 });
      if (dense) {
        if (!s4[R3]) s4[R3] = [];
        if (!s4[R3][C2]) s4[R3][C2] = { t: "z", v: void 0 };
        s4[R3][C2].l = val;
      } else {
        if (!s4[addr]) s4[addr] = { t: "z", v: void 0 };
        s4[addr].l = val;
      }
    }
  }
}
function parse_ws_xml_margins(margin) {
  var o2 = {};
  ["left", "right", "top", "bottom", "header", "footer"].forEach(function(k3) {
    if (margin[k3]) o2[k3] = parseFloat(margin[k3]);
  });
  return o2;
}
function write_ws_xml_margins(margin) {
  default_margins(margin);
  return writextag("pageMargins", null, margin);
}
function parse_ws_xml_cols(columns, cols) {
  var seencol = false;
  for (var coli = 0; coli != cols.length; ++coli) {
    var coll = parsexmltag(cols[coli], true);
    if (coll.hidden) coll.hidden = parsexmlbool(coll.hidden);
    var colm = parseInt(coll.min, 10) - 1, colM = parseInt(coll.max, 10) - 1;
    if (coll.outlineLevel) coll.level = +coll.outlineLevel || 0;
    delete coll.min;
    delete coll.max;
    coll.width = +coll.width;
    if (!seencol && coll.width) {
      seencol = true;
      find_mdw_colw(coll.width);
    }
    process_col(coll);
    while (colm <= colM) columns[colm++] = dup(coll);
  }
}
function write_ws_xml_cols(ws, cols) {
  var o2 = ["<cols>"], col;
  for (var i3 = 0; i3 != cols.length; ++i3) {
    if (!(col = cols[i3])) continue;
    o2[o2.length] = writextag("col", null, col_obj_w(i3, col));
  }
  o2[o2.length] = "</cols>";
  return o2.join("");
}
function parse_ws_xml_autofilter(data) {
  var o2 = { ref: (data.match(/ref="([^"]*)"/) || [])[1] };
  return o2;
}
function write_ws_xml_autofilter(data, ws, wb2, idx) {
  var ref = typeof data.ref == "string" ? data.ref : encode_range(data.ref);
  if (!wb2.Workbook) wb2.Workbook = { Sheets: [] };
  if (!wb2.Workbook.Names) wb2.Workbook.Names = [];
  var names = wb2.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i3 = 0; i3 < names.length; ++i3) {
    var name = names[i3];
    if (name.Name != "_xlnm._FilterDatabase") continue;
    if (name.Sheet != idx) continue;
    name.Ref = "'" + wb2.SheetNames[idx] + "'!" + ref;
    break;
  }
  if (i3 == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb2.SheetNames[idx] + "'!" + ref });
  return writextag("autoFilter", null, { ref });
}
var sviewregex = /<(?:\w:)?sheetView(?:[^>a-z][^>]*)?\/?>/;
function parse_ws_xml_sheetviews(data, wb2) {
  if (!wb2.Views) wb2.Views = [{}];
  (data.match(sviewregex) || []).forEach(function(r2, i3) {
    var tag = parsexmltag(r2);
    if (!wb2.Views[i3]) wb2.Views[i3] = {};
    if (+tag.zoomScale) wb2.Views[i3].zoom = +tag.zoomScale;
    if (parsexmlbool(tag.rightToLeft)) wb2.Views[i3].RTL = true;
  });
}
function write_ws_xml_sheetviews(ws, opts, idx, wb2) {
  var sview = { workbookViewId: "0" };
  if ((((wb2 || {}).Workbook || {}).Views || [])[0]) sview.rightToLeft = wb2.Workbook.Views[0].RTL ? "1" : "0";
  return writextag("sheetViews", writextag("sheetView", null, sview), {});
}
function write_ws_xml_cell(cell, ref, ws, opts) {
  if (cell.c) ws["!comments"].push([ref, cell.c]);
  if (cell.v === void 0 && typeof cell.f !== "string" || cell.t === "z" && !cell.f) return "";
  var vv = "";
  var oldt = cell.t, oldv = cell.v;
  if (cell.t !== "z") switch (cell.t) {
    case "b":
      vv = cell.v ? "1" : "0";
      break;
    case "n":
      vv = "" + cell.v;
      break;
    case "e":
      vv = BErr[cell.v];
      break;
    case "d":
      if (opts && opts.cellDates) vv = parseDate(cell.v, -1).toISOString();
      else {
        cell = dup(cell);
        cell.t = "n";
        vv = "" + (cell.v = datenum(parseDate(cell.v)));
      }
      if (typeof cell.z === "undefined") cell.z = table_fmt[14];
      break;
    default:
      vv = cell.v;
      break;
  }
  var v2 = writetag("v", escapexml(vv)), o2 = { r: ref };
  var os = get_cell_style(opts.cellXfs, cell, opts);
  if (os !== 0) o2.s = os;
  switch (cell.t) {
    case "n":
      break;
    case "d":
      o2.t = "d";
      break;
    case "b":
      o2.t = "b";
      break;
    case "e":
      o2.t = "e";
      break;
    case "z":
      break;
    default:
      if (cell.v == null) {
        delete cell.t;
        break;
      }
      if (cell.v.length > 32767) throw new Error("Text length must not exceed 32767 characters");
      if (opts && opts.bookSST) {
        v2 = writetag("v", "" + get_sst_id(opts.Strings, cell.v, opts.revStrings));
        o2.t = "s";
        break;
      }
      o2.t = "str";
      break;
  }
  if (cell.t != oldt) {
    cell.t = oldt;
    cell.v = oldv;
  }
  if (typeof cell.f == "string" && cell.f) {
    var ff2 = cell.F && cell.F.slice(0, ref.length) == ref ? { t: "array", ref: cell.F } : null;
    v2 = writextag("f", escapexml(cell.f), ff2) + (cell.v != null ? v2 : "");
  }
  if (cell.l) ws["!links"].push([ref, cell.l]);
  if (cell.D) o2.cm = 1;
  return writextag("c", v2, o2);
}
var parse_ws_xml_data = /* @__PURE__ */ function() {
  var cellregex = /<(?:\w+:)?c[ \/>]/, rowregex = /<\/(?:\w+:)?row>/;
  var rregex = /r=["']([^"']*)["']/, isregex = /<(?:\w+:)?is>([\S\s]*?)<\/(?:\w+:)?is>/;
  var refregex = /ref=["']([^"']*)["']/;
  var match_v = matchtag("v"), match_f = matchtag("f");
  return function parse_ws_xml_data2(sdata, s4, opts, guess, themes, styles) {
    var ri2 = 0, x3 = "", cells = [], cref = [], idx = 0, i3 = 0, cc2 = 0, d4 = "", p2;
    var tag, tagr = 0, tagc = 0;
    var sstr, ftag;
    var fmtid = 0, fillid = 0;
    var do_format = Array.isArray(styles.CellXf), cf2;
    var arrayf = [];
    var sharedf = [];
    var dense = Array.isArray(s4);
    var rows = [], rowobj = {}, rowrite = false;
    var sheetStubs = !!opts.sheetStubs;
    for (var marr = sdata.split(rowregex), mt = 0, marrlen = marr.length; mt != marrlen; ++mt) {
      x3 = marr[mt].trim();
      var xlen = x3.length;
      if (xlen === 0) continue;
      var rstarti = 0;
      outa: for (ri2 = 0; ri2 < xlen; ++ri2) switch (
        /*x.charCodeAt(ri)*/
        x3[ri2]
      ) {
        case ">":
          if (
            /*x.charCodeAt(ri-1) != 47*/
            x3[ri2 - 1] != "/"
          ) {
            ++ri2;
            break outa;
          }
          if (opts && opts.cellStyles) {
            tag = parsexmltag(x3.slice(rstarti, ri2), true);
            tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
            tagc = -1;
            if (opts.sheetRows && opts.sheetRows < tagr) continue;
            rowobj = {};
            rowrite = false;
            if (tag.ht) {
              rowrite = true;
              rowobj.hpt = parseFloat(tag.ht);
              rowobj.hpx = pt2px(rowobj.hpt);
            }
            if (tag.hidden == "1") {
              rowrite = true;
              rowobj.hidden = true;
            }
            if (tag.outlineLevel != null) {
              rowrite = true;
              rowobj.level = +tag.outlineLevel;
            }
            if (rowrite) rows[tagr - 1] = rowobj;
          }
          break;
        case "<":
          rstarti = ri2;
          break;
      }
      if (rstarti >= ri2) break;
      tag = parsexmltag(x3.slice(rstarti, ri2), true);
      tagr = tag.r != null ? parseInt(tag.r, 10) : tagr + 1;
      tagc = -1;
      if (opts.sheetRows && opts.sheetRows < tagr) continue;
      if (guess.s.r > tagr - 1) guess.s.r = tagr - 1;
      if (guess.e.r < tagr - 1) guess.e.r = tagr - 1;
      if (opts && opts.cellStyles) {
        rowobj = {};
        rowrite = false;
        if (tag.ht) {
          rowrite = true;
          rowobj.hpt = parseFloat(tag.ht);
          rowobj.hpx = pt2px(rowobj.hpt);
        }
        if (tag.hidden == "1") {
          rowrite = true;
          rowobj.hidden = true;
        }
        if (tag.outlineLevel != null) {
          rowrite = true;
          rowobj.level = +tag.outlineLevel;
        }
        if (rowrite) rows[tagr - 1] = rowobj;
      }
      cells = x3.slice(ri2).split(cellregex);
      for (var rslice = 0; rslice != cells.length; ++rslice) if (cells[rslice].trim().charAt(0) != "<") break;
      cells = cells.slice(rslice);
      for (ri2 = 0; ri2 != cells.length; ++ri2) {
        x3 = cells[ri2].trim();
        if (x3.length === 0) continue;
        cref = x3.match(rregex);
        idx = ri2;
        i3 = 0;
        cc2 = 0;
        x3 = "<c " + (x3.slice(0, 1) == "<" ? ">" : "") + x3;
        if (cref != null && cref.length === 2) {
          idx = 0;
          d4 = cref[1];
          for (i3 = 0; i3 != d4.length; ++i3) {
            if ((cc2 = d4.charCodeAt(i3) - 64) < 1 || cc2 > 26) break;
            idx = 26 * idx + cc2;
          }
          --idx;
          tagc = idx;
        } else ++tagc;
        for (i3 = 0; i3 != x3.length; ++i3) if (x3.charCodeAt(i3) === 62) break;
        ++i3;
        tag = parsexmltag(x3.slice(0, i3), true);
        if (!tag.r) tag.r = encode_cell({ r: tagr - 1, c: tagc });
        d4 = x3.slice(i3);
        p2 = { t: "" };
        if ((cref = d4.match(match_v)) != null && /*::cref != null && */
        cref[1] !== "") p2.v = unescapexml(cref[1]);
        if (opts.cellFormula) {
          if ((cref = d4.match(match_f)) != null && /*::cref != null && */
          cref[1] !== "") {
            p2.f = unescapexml(utf8read(cref[1])).replace(/\r\n/g, "\n");
            if (!opts.xlfn) p2.f = _xlfn(p2.f);
            if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="array"') > -1
            ) {
              p2.F = (d4.match(refregex) || [])[1];
              if (p2.F.indexOf(":") > -1) arrayf.push([safe_decode_range(p2.F), p2.F]);
            } else if (
              /*::cref != null && cref[0] != null && */
              cref[0].indexOf('t="shared"') > -1
            ) {
              ftag = parsexmltag(cref[0]);
              var ___f = unescapexml(utf8read(cref[1]));
              if (!opts.xlfn) ___f = _xlfn(___f);
              sharedf[parseInt(ftag.si, 10)] = [ftag, ___f, tag.r];
            }
          } else if (cref = d4.match(/<f[^>]*\/>/)) {
            ftag = parsexmltag(cref[0]);
            if (sharedf[ftag.si]) p2.f = shift_formula_xlsx(sharedf[ftag.si][1], sharedf[ftag.si][2], tag.r);
          }
          var _tag = decode_cell(tag.r);
          for (i3 = 0; i3 < arrayf.length; ++i3)
            if (_tag.r >= arrayf[i3][0].s.r && _tag.r <= arrayf[i3][0].e.r) {
              if (_tag.c >= arrayf[i3][0].s.c && _tag.c <= arrayf[i3][0].e.c)
                p2.F = arrayf[i3][1];
            }
        }
        if (tag.t == null && p2.v === void 0) {
          if (p2.f || p2.F) {
            p2.v = 0;
            p2.t = "n";
          } else if (!sheetStubs) continue;
          else p2.t = "z";
        } else p2.t = tag.t || "n";
        if (guess.s.c > tagc) guess.s.c = tagc;
        if (guess.e.c < tagc) guess.e.c = tagc;
        switch (p2.t) {
          case "n":
            if (p2.v == "" || p2.v == null) {
              if (!sheetStubs) continue;
              p2.t = "z";
            } else p2.v = parseFloat(p2.v);
            break;
          case "s":
            if (typeof p2.v == "undefined") {
              if (!sheetStubs) continue;
              p2.t = "z";
            } else {
              sstr = strs[parseInt(p2.v, 10)];
              p2.v = sstr.t;
              p2.r = sstr.r;
              if (opts.cellHTML) p2.h = sstr.h;
            }
            break;
          case "str":
            p2.t = "s";
            p2.v = p2.v != null ? utf8read(p2.v) : "";
            if (opts.cellHTML) p2.h = escapehtml(p2.v);
            break;
          case "inlineStr":
            cref = d4.match(isregex);
            p2.t = "s";
            if (cref != null && (sstr = parse_si(cref[1]))) {
              p2.v = sstr.t;
              if (opts.cellHTML) p2.h = sstr.h;
            } else p2.v = "";
            break;
          case "b":
            p2.v = parsexmlbool(p2.v);
            break;
          case "d":
            if (opts.cellDates) p2.v = parseDate(p2.v, 1);
            else {
              p2.v = datenum(parseDate(p2.v, 1));
              p2.t = "n";
            }
            break;
          case "e":
            if (!opts || opts.cellText !== false) p2.w = p2.v;
            p2.v = RBErr[p2.v];
            break;
        }
        fmtid = fillid = 0;
        cf2 = null;
        if (do_format && tag.s !== void 0) {
          cf2 = styles.CellXf[tag.s];
          if (cf2 != null) {
            if (cf2.numFmtId != null) fmtid = cf2.numFmtId;
            if (opts.cellStyles) {
              if (cf2.fillId != null) fillid = cf2.fillId;
            }
          }
        }
        safe_format(p2, fmtid, fillid, opts, themes, styles);
        if (opts.cellDates && do_format && p2.t == "n" && fmt_is_date(table_fmt[fmtid])) {
          p2.t = "d";
          p2.v = numdate(p2.v);
        }
        if (tag.cm && opts.xlmeta) {
          var cm = (opts.xlmeta.Cell || [])[+tag.cm - 1];
          if (cm && cm.type == "XLDAPR") p2.D = true;
        }
        if (dense) {
          var _r = decode_cell(tag.r);
          if (!s4[_r.r]) s4[_r.r] = [];
          s4[_r.r][_r.c] = p2;
        } else s4[tag.r] = p2;
      }
    }
    if (rows.length > 0) s4["!rows"] = rows;
  };
}();
function write_ws_xml_data(ws, opts, idx, wb2) {
  var o2 = [], r2 = [], range = safe_decode_range(ws["!ref"]), cell = "", ref, rr = "", cols = [], R3 = 0, C2 = 0, rows = ws["!rows"];
  var dense = Array.isArray(ws);
  var params = { r: rr }, row, height = -1;
  for (C2 = range.s.c; C2 <= range.e.c; ++C2) cols[C2] = encode_col(C2);
  for (R3 = range.s.r; R3 <= range.e.r; ++R3) {
    r2 = [];
    rr = encode_row(R3);
    for (C2 = range.s.c; C2 <= range.e.c; ++C2) {
      ref = cols[C2] + rr;
      var _cell = dense ? (ws[R3] || [])[C2] : ws[ref];
      if (_cell === void 0) continue;
      if ((cell = write_ws_xml_cell(_cell, ref, ws, opts)) != null) r2.push(cell);
    }
    if (r2.length > 0 || rows && rows[R3]) {
      params = { r: rr };
      if (rows && rows[R3]) {
        row = rows[R3];
        if (row.hidden) params.hidden = 1;
        height = -1;
        if (row.hpx) height = px2pt(row.hpx);
        else if (row.hpt) height = row.hpt;
        if (height > -1) {
          params.ht = height;
          params.customHeight = 1;
        }
        if (row.level) {
          params.outlineLevel = row.level;
        }
      }
      o2[o2.length] = writextag("row", r2.join(""), params);
    }
  }
  if (rows) for (; R3 < rows.length; ++R3) {
    if (rows && rows[R3]) {
      params = { r: R3 + 1 };
      row = rows[R3];
      if (row.hidden) params.hidden = 1;
      height = -1;
      if (row.hpx) height = px2pt(row.hpx);
      else if (row.hpt) height = row.hpt;
      if (height > -1) {
        params.ht = height;
        params.customHeight = 1;
      }
      if (row.level) {
        params.outlineLevel = row.level;
      }
      o2[o2.length] = writextag("row", "", params);
    }
  }
  return o2.join("");
}
function write_ws_xml(idx, opts, wb2, rels) {
  var o2 = [XML_HEADER, writextag("worksheet", null, {
    "xmlns": XMLNS_main[0],
    "xmlns:r": XMLNS.r
  })];
  var s4 = wb2.SheetNames[idx], sidx = 0, rdata = "";
  var ws = wb2.Sheets[s4];
  if (ws == null) ws = {};
  var ref = ws["!ref"] || "A1";
  var range = safe_decode_range(ref);
  if (range.e.c > 16383 || range.e.r > 1048575) {
    if (opts.WTF) throw new Error("Range " + ref + " exceeds format limit A1:XFD1048576");
    range.e.c = Math.min(range.e.c, 16383);
    range.e.r = Math.min(range.e.c, 1048575);
    ref = encode_range(range);
  }
  if (!rels) rels = {};
  ws["!comments"] = [];
  var _drawing = [];
  write_ws_xml_sheetpr(ws, wb2, idx, opts, o2);
  o2[o2.length] = writextag("dimension", null, { "ref": ref });
  o2[o2.length] = write_ws_xml_sheetviews(ws, opts, idx, wb2);
  if (opts.sheetFormat) o2[o2.length] = writextag("sheetFormatPr", null, {
    defaultRowHeight: opts.sheetFormat.defaultRowHeight || "16",
    baseColWidth: opts.sheetFormat.baseColWidth || "10",
    outlineLevelRow: opts.sheetFormat.outlineLevelRow || "7"
  });
  if (ws["!cols"] != null && ws["!cols"].length > 0) o2[o2.length] = write_ws_xml_cols(ws, ws["!cols"]);
  o2[sidx = o2.length] = "<sheetData/>";
  ws["!links"] = [];
  if (ws["!ref"] != null) {
    rdata = write_ws_xml_data(ws, opts);
    if (rdata.length > 0) o2[o2.length] = rdata;
  }
  if (o2.length > sidx + 1) {
    o2[o2.length] = "</sheetData>";
    o2[sidx] = o2[sidx].replace("/>", ">");
  }
  if (ws["!protect"]) o2[o2.length] = write_ws_xml_protection(ws["!protect"]);
  if (ws["!autofilter"] != null) o2[o2.length] = write_ws_xml_autofilter(ws["!autofilter"], ws, wb2, idx);
  if (ws["!merges"] != null && ws["!merges"].length > 0) o2[o2.length] = write_ws_xml_merges(ws["!merges"]);
  var relc = -1, rel, rId = -1;
  if (
    /*::(*/
    ws["!links"].length > 0
  ) {
    o2[o2.length] = "<hyperlinks>";
    ws["!links"].forEach(function(l2) {
      if (!l2[1].Target) return;
      rel = { "ref": l2[0] };
      if (l2[1].Target.charAt(0) != "#") {
        rId = add_rels(rels, -1, escapexml(l2[1].Target).replace(/#.*$/, ""), RELS.HLINK);
        rel["r:id"] = "rId" + rId;
      }
      if ((relc = l2[1].Target.indexOf("#")) > -1) rel.location = escapexml(l2[1].Target.slice(relc + 1));
      if (l2[1].Tooltip) rel.tooltip = escapexml(l2[1].Tooltip);
      o2[o2.length] = writextag("hyperlink", null, rel);
    });
    o2[o2.length] = "</hyperlinks>";
  }
  delete ws["!links"];
  if (ws["!margins"] != null) o2[o2.length] = write_ws_xml_margins(ws["!margins"]);
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) o2[o2.length] = writetag("ignoredErrors", writextag("ignoredError", null, { numberStoredAsText: 1, sqref: ref }));
  if (_drawing.length > 0) {
    rId = add_rels(rels, -1, "../drawings/drawing" + (idx + 1) + ".xml", RELS.DRAW);
    o2[o2.length] = writextag("drawing", null, { "r:id": "rId" + rId });
    ws["!drawing"] = _drawing;
  }
  if (ws["!comments"].length > 0) {
    rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    o2[o2.length] = writextag("legacyDrawing", null, { "r:id": "rId" + rId });
    ws["!legacy"] = rId;
  }
  if (o2.length > 1) {
    o2[o2.length] = "</worksheet>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function parse_BrtRowHdr(data, length) {
  var z3 = {};
  var tgt = data.l + length;
  z3.r = data.read_shift(4);
  data.l += 4;
  var miyRw = data.read_shift(2);
  data.l += 1;
  var flags = data.read_shift(1);
  data.l = tgt;
  if (flags & 7) z3.level = flags & 7;
  if (flags & 16) z3.hidden = true;
  if (flags & 32) z3.hpt = miyRw / 20;
  return z3;
}
function write_BrtRowHdr(R3, range, ws) {
  var o2 = new_buf(17 + 8 * 16);
  var row = (ws["!rows"] || [])[R3] || {};
  o2.write_shift(4, R3);
  o2.write_shift(4, 0);
  var miyRw = 320;
  if (row.hpx) miyRw = px2pt(row.hpx) * 20;
  else if (row.hpt) miyRw = row.hpt * 20;
  o2.write_shift(2, miyRw);
  o2.write_shift(1, 0);
  var flags = 0;
  if (row.level) flags |= row.level;
  if (row.hidden) flags |= 16;
  if (row.hpx || row.hpt) flags |= 32;
  o2.write_shift(1, flags);
  o2.write_shift(1, 0);
  var ncolspan = 0, lcs = o2.l;
  o2.l += 4;
  var caddr = { r: R3, c: 0 };
  for (var i3 = 0; i3 < 16; ++i3) {
    if (range.s.c > i3 + 1 << 10 || range.e.c < i3 << 10) continue;
    var first = -1, last = -1;
    for (var j2 = i3 << 10; j2 < i3 + 1 << 10; ++j2) {
      caddr.c = j2;
      var cell = Array.isArray(ws) ? (ws[caddr.r] || [])[caddr.c] : ws[encode_cell(caddr)];
      if (cell) {
        if (first < 0) first = j2;
        last = j2;
      }
    }
    if (first < 0) continue;
    ++ncolspan;
    o2.write_shift(4, first);
    o2.write_shift(4, last);
  }
  var l2 = o2.l;
  o2.l = lcs;
  o2.write_shift(4, ncolspan);
  o2.l = l2;
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function write_row_header(ba, ws, range, R3) {
  var o2 = write_BrtRowHdr(R3, range, ws);
  if (o2.length > 17 || (ws["!rows"] || [])[R3]) write_record(ba, 0, o2);
}
var parse_BrtWsDim = parse_UncheckedRfX;
var write_BrtWsDim = write_UncheckedRfX;
function parse_BrtWsFmtInfo() {
}
function parse_BrtWsProp(data, length) {
  var z3 = {};
  var f2 = data[data.l];
  ++data.l;
  z3.above = !(f2 & 64);
  z3.left = !(f2 & 128);
  data.l += 18;
  z3.name = parse_XLSBCodeName(data);
  return z3;
}
function write_BrtWsProp(str, outl, o2) {
  if (o2 == null) o2 = new_buf(84 + 4 * str.length);
  var f2 = 192;
  if (outl) {
    if (outl.above) f2 &= -65;
    if (outl.left) f2 &= -129;
  }
  o2.write_shift(1, f2);
  for (var i3 = 1; i3 < 3; ++i3) o2.write_shift(1, 0);
  write_BrtColor({ auto: 1 }, o2);
  o2.write_shift(-4, -1);
  o2.write_shift(-4, -1);
  write_XLSBCodeName(str, o2);
  return o2.slice(0, o2.l);
}
function parse_BrtCellBlank(data) {
  var cell = parse_XLSBCell(data);
  return [cell];
}
function write_BrtCellBlank(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(8);
  return write_XLSBCell(ncell, o2);
}
function parse_BrtShortBlank(data) {
  var cell = parse_XLSBShortCell(data);
  return [cell];
}
function write_BrtShortBlank(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(4);
  return write_XLSBShortCell(ncell, o2);
}
function parse_BrtCellBool(data) {
  var cell = parse_XLSBCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtCellBool(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(9);
  write_XLSBCell(ncell, o2);
  o2.write_shift(1, cell.v ? 1 : 0);
  return o2;
}
function parse_BrtShortBool(data) {
  var cell = parse_XLSBShortCell(data);
  var fBool = data.read_shift(1);
  return [cell, fBool, "b"];
}
function write_BrtShortBool(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(5);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(1, cell.v ? 1 : 0);
  return o2;
}
function parse_BrtCellError(data) {
  var cell = parse_XLSBCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtCellError(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(9);
  write_XLSBCell(ncell, o2);
  o2.write_shift(1, cell.v);
  return o2;
}
function parse_BrtShortError(data) {
  var cell = parse_XLSBShortCell(data);
  var bError = data.read_shift(1);
  return [cell, bError, "e"];
}
function write_BrtShortError(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(1, cell.v);
  o2.write_shift(2, 0);
  o2.write_shift(1, 0);
  return o2;
}
function parse_BrtCellIsst(data) {
  var cell = parse_XLSBCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtCellIsst(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(12);
  write_XLSBCell(ncell, o2);
  o2.write_shift(4, ncell.v);
  return o2;
}
function parse_BrtShortIsst(data) {
  var cell = parse_XLSBShortCell(data);
  var isst = data.read_shift(4);
  return [cell, isst, "s"];
}
function write_BrtShortIsst(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  o2.write_shift(4, ncell.v);
  return o2;
}
function parse_BrtCellReal(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtCellReal(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(16);
  write_XLSBCell(ncell, o2);
  write_Xnum(cell.v, o2);
  return o2;
}
function parse_BrtShortReal(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_Xnum(data);
  return [cell, value, "n"];
}
function write_BrtShortReal(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(12);
  write_XLSBShortCell(ncell, o2);
  write_Xnum(cell.v, o2);
  return o2;
}
function parse_BrtCellRk(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtCellRk(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(12);
  write_XLSBCell(ncell, o2);
  write_RkNumber(cell.v, o2);
  return o2;
}
function parse_BrtShortRk(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_RkNumber(data);
  return [cell, value, "n"];
}
function write_BrtShortRk(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(8);
  write_XLSBShortCell(ncell, o2);
  write_RkNumber(cell.v, o2);
  return o2;
}
function parse_BrtCellRString(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_RichStr(data);
  return [cell, value, "is"];
}
function parse_BrtCellSt(data) {
  var cell = parse_XLSBCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtCellSt(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(12 + 4 * cell.v.length);
  write_XLSBCell(ncell, o2);
  write_XLWideString(cell.v, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function parse_BrtShortSt(data) {
  var cell = parse_XLSBShortCell(data);
  var value = parse_XLWideString(data);
  return [cell, value, "str"];
}
function write_BrtShortSt(cell, ncell, o2) {
  if (o2 == null) o2 = new_buf(8 + 4 * cell.v.length);
  write_XLSBShortCell(ncell, o2);
  write_XLWideString(cell.v, o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function parse_BrtFmlaBool(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "b"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaError(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = data.read_shift(1);
  var o2 = [cell, value, "e"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaNum(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_Xnum(data);
  var o2 = [cell, value, "n"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
function parse_BrtFmlaString(data, length, opts) {
  var end = data.l + length;
  var cell = parse_XLSBCell(data);
  cell.r = opts["!row"];
  var value = parse_XLWideString(data);
  var o2 = [cell, value, "str"];
  if (opts.cellFormula) {
    data.l += 2;
    var formula = parse_XLSBCellParsedFormula(data, end - data.l, opts);
    o2[3] = stringify_formula(formula, null, cell, opts.supbooks, opts);
  } else data.l = end;
  return o2;
}
var parse_BrtMergeCell = parse_UncheckedRfX;
var write_BrtMergeCell = write_UncheckedRfX;
function write_BrtBeginMergeCells(cnt, o2) {
  if (o2 == null) o2 = new_buf(4);
  o2.write_shift(4, cnt);
  return o2;
}
function parse_BrtHLink(data, length) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var relId = parse_XLNullableWideString(data);
  var loc = parse_XLWideString(data);
  var tooltip = parse_XLWideString(data);
  var display = parse_XLWideString(data);
  data.l = end;
  var o2 = { rfx, relId, loc, display };
  if (tooltip) o2.Tooltip = tooltip;
  return o2;
}
function write_BrtHLink(l2, rId) {
  var o2 = new_buf(50 + 4 * (l2[1].Target.length + (l2[1].Tooltip || "").length));
  write_UncheckedRfX({ s: decode_cell(l2[0]), e: decode_cell(l2[0]) }, o2);
  write_RelID("rId" + rId, o2);
  var locidx = l2[1].Target.indexOf("#");
  var loc = locidx == -1 ? "" : l2[1].Target.slice(locidx + 1);
  write_XLWideString(loc || "", o2);
  write_XLWideString(l2[1].Tooltip || "", o2);
  write_XLWideString("", o2);
  return o2.slice(0, o2.l);
}
function parse_BrtPane() {
}
function parse_BrtArrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_RfX(data);
  var fAlwaysCalc = data.read_shift(1);
  var o2 = [rfx];
  o2[2] = fAlwaysCalc;
  if (opts.cellFormula) {
    var formula = parse_XLSBArrayParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
  } else data.l = end;
  return o2;
}
function parse_BrtShrFmla(data, length, opts) {
  var end = data.l + length;
  var rfx = parse_UncheckedRfX(data);
  var o2 = [rfx];
  if (opts.cellFormula) {
    var formula = parse_XLSBSharedParsedFormula(data, end - data.l, opts);
    o2[1] = formula;
    data.l = end;
  } else data.l = end;
  return o2;
}
function write_BrtColInfo(C2, col, o2) {
  if (o2 == null) o2 = new_buf(18);
  var p2 = col_obj_w(C2, col);
  o2.write_shift(-4, C2);
  o2.write_shift(-4, C2);
  o2.write_shift(4, (p2.width || 10) * 256);
  o2.write_shift(
    4,
    0
    /*ixfe*/
  );
  var flags = 0;
  if (col.hidden) flags |= 1;
  if (typeof p2.width == "number") flags |= 2;
  if (col.level) flags |= col.level << 8;
  o2.write_shift(2, flags);
  return o2;
}
var BrtMarginKeys = ["left", "right", "top", "bottom", "header", "footer"];
function parse_BrtMargins(data) {
  var margins = {};
  BrtMarginKeys.forEach(function(k3) {
    margins[k3] = parse_Xnum(data);
  });
  return margins;
}
function write_BrtMargins(margins, o2) {
  if (o2 == null) o2 = new_buf(6 * 8);
  default_margins(margins);
  BrtMarginKeys.forEach(function(k3) {
    write_Xnum(margins[k3], o2);
  });
  return o2;
}
function parse_BrtBeginWsView(data) {
  var f2 = data.read_shift(2);
  data.l += 28;
  return { RTL: f2 & 32 };
}
function write_BrtBeginWsView(ws, Workbook, o2) {
  if (o2 == null) o2 = new_buf(30);
  var f2 = 924;
  if ((((Workbook || {}).Views || [])[0] || {}).RTL) f2 |= 32;
  o2.write_shift(2, f2);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(1, 0);
  o2.write_shift(1, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 100);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(2, 0);
  o2.write_shift(4, 0);
  return o2;
}
function write_BrtCellIgnoreEC(ref) {
  var o2 = new_buf(24);
  o2.write_shift(4, 4);
  o2.write_shift(4, 1);
  write_UncheckedRfX(ref, o2);
  return o2;
}
function write_BrtSheetProtection(sp, o2) {
  if (o2 == null) o2 = new_buf(16 * 4 + 2);
  o2.write_shift(2, sp.password ? crypto_CreatePasswordVerifier_Method1(sp.password) : 0);
  o2.write_shift(4, 1);
  [
    ["objects", false],
    // fObjects
    ["scenarios", false],
    // fScenarios
    ["formatCells", true],
    // fFormatCells
    ["formatColumns", true],
    // fFormatColumns
    ["formatRows", true],
    // fFormatRows
    ["insertColumns", true],
    // fInsertColumns
    ["insertRows", true],
    // fInsertRows
    ["insertHyperlinks", true],
    // fInsertHyperlinks
    ["deleteColumns", true],
    // fDeleteColumns
    ["deleteRows", true],
    // fDeleteRows
    ["selectLockedCells", false],
    // fSelLockedCells
    ["sort", true],
    // fSort
    ["autoFilter", true],
    // fAutoFilter
    ["pivotTables", true],
    // fPivotTables
    ["selectUnlockedCells", false]
    // fSelUnlockedCells
  ].forEach(function(n2) {
    if (n2[1]) o2.write_shift(4, sp[n2[0]] != null && !sp[n2[0]] ? 1 : 0);
    else o2.write_shift(4, sp[n2[0]] != null && sp[n2[0]] ? 0 : 1);
  });
  return o2;
}
function parse_BrtDVal() {
}
function parse_BrtDVal14() {
}
function parse_ws_bin(data, _opts, idx, rels, wb2, themes, styles) {
  if (!data) return data;
  var opts = _opts || {};
  if (!rels) rels = { "!id": {} };
  var s4 = opts.dense ? [] : {};
  var ref;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var pass = false, end = false;
  var row, p2, cf2, R3, C2, addr, sstr, rr, cell;
  var merges = [];
  opts.biff = 12;
  opts["!row"] = 0;
  var ai2 = 0, af2 = false;
  var arrayf = [];
  var sharedf = {};
  var supbooks = opts.supbooks || /*::(*/
  wb2.supbooks || [[]];
  supbooks.sharedf = sharedf;
  supbooks.arrayf = arrayf;
  supbooks.SheetNames = wb2.SheetNames || wb2.Sheets.map(function(x3) {
    return x3.name;
  });
  if (!opts.supbooks) {
    opts.supbooks = supbooks;
    if (wb2.Names) for (var i3 = 0; i3 < wb2.Names.length; ++i3) supbooks[0][i3 + 1] = wb2.Names[i3];
  }
  var colinfo = [], rowinfo = [];
  var seencol = false;
  XLSBRecordEnum[16] = { n: "BrtShortReal", f: parse_BrtShortReal };
  var cm;
  recordhopper(data, function ws_parse(val, RR, RT) {
    if (end) return;
    switch (RT) {
      case 148:
        ref = val;
        break;
      case 0:
        row = val;
        if (opts.sheetRows && opts.sheetRows <= row.r) end = true;
        rr = encode_row(R3 = row.r);
        opts["!row"] = row.r;
        if (val.hidden || val.hpt || val.level != null) {
          if (val.hpt) val.hpx = pt2px(val.hpt);
          rowinfo[val.r] = val;
        }
        break;
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
      case 13:
      case 14:
      case 15:
      case 16:
      case 17:
      case 18:
      case 62:
        p2 = { t: val[2] };
        switch (val[2]) {
          case "n":
            p2.v = val[1];
            break;
          case "s":
            sstr = strs[val[1]];
            p2.v = sstr.t;
            p2.r = sstr.r;
            break;
          case "b":
            p2.v = val[1] ? true : false;
            break;
          case "e":
            p2.v = val[1];
            if (opts.cellText !== false) p2.w = BErr[p2.v];
            break;
          case "str":
            p2.t = "s";
            p2.v = val[1];
            break;
          case "is":
            p2.t = "s";
            p2.v = val[1].t;
            break;
        }
        if (cf2 = styles.CellXf[val[0].iStyleRef]) safe_format(p2, cf2.numFmtId, null, opts, themes, styles);
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s4[R3]) s4[R3] = [];
          s4[R3][C2] = p2;
        } else s4[encode_col(C2) + rr] = p2;
        if (opts.cellFormula) {
          af2 = false;
          for (ai2 = 0; ai2 < arrayf.length; ++ai2) {
            var aii = arrayf[ai2];
            if (row.r >= aii[0].s.r && row.r <= aii[0].e.r) {
              if (C2 >= aii[0].s.c && C2 <= aii[0].e.c) {
                p2.F = encode_range(aii[0]);
                af2 = true;
              }
            }
          }
          if (!af2 && val.length > 3) p2.f = val[3];
        }
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (opts.cellDates && cf2 && p2.t == "n" && fmt_is_date(table_fmt[cf2.numFmtId])) {
          var _d = SSF_parse_date_code(p2.v);
          if (_d) {
            p2.t = "d";
            p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
          }
        }
        if (cm) {
          if (cm.type == "XLDAPR") p2.D = true;
          cm = void 0;
        }
        break;
      case 1:
      case 12:
        if (!opts.sheetStubs || pass) break;
        p2 = { t: "z", v: void 0 };
        C2 = val[0].c == -1 ? C2 + 1 : val[0].c;
        if (opts.dense) {
          if (!s4[R3]) s4[R3] = [];
          s4[R3][C2] = p2;
        } else s4[encode_col(C2) + rr] = p2;
        if (refguess.s.r > row.r) refguess.s.r = row.r;
        if (refguess.s.c > C2) refguess.s.c = C2;
        if (refguess.e.r < row.r) refguess.e.r = row.r;
        if (refguess.e.c < C2) refguess.e.c = C2;
        if (cm) {
          if (cm.type == "XLDAPR") p2.D = true;
          cm = void 0;
        }
        break;
      case 176:
        merges.push(val);
        break;
      case 49:
        {
          cm = ((opts.xlmeta || {}).Cell || [])[val - 1];
        }
        break;
      case 494:
        var rel = rels["!id"][val.relId];
        if (rel) {
          val.Target = rel.Target;
          if (val.loc) val.Target += "#" + val.loc;
          val.Rel = rel;
        } else if (val.relId == "") {
          val.Target = "#" + val.loc;
        }
        for (R3 = val.rfx.s.r; R3 <= val.rfx.e.r; ++R3) for (C2 = val.rfx.s.c; C2 <= val.rfx.e.c; ++C2) {
          if (opts.dense) {
            if (!s4[R3]) s4[R3] = [];
            if (!s4[R3][C2]) s4[R3][C2] = { t: "z", v: void 0 };
            s4[R3][C2].l = val;
          } else {
            addr = encode_cell({ c: C2, r: R3 });
            if (!s4[addr]) s4[addr] = { t: "z", v: void 0 };
            s4[addr].l = val;
          }
        }
        break;
      case 426:
        if (!opts.cellFormula) break;
        arrayf.push(val);
        cell = opts.dense ? s4[R3][C2] : s4[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        cell.F = encode_range(val[0]);
        break;
      case 427:
        if (!opts.cellFormula) break;
        sharedf[encode_cell(val[0].s)] = val[1];
        cell = opts.dense ? s4[R3][C2] : s4[encode_col(C2) + rr];
        cell.f = stringify_formula(val[1], refguess, { r: row.r, c: C2 }, supbooks, opts);
        break;
      case 60:
        if (!opts.cellStyles) break;
        while (val.e >= val.s) {
          colinfo[val.e--] = { width: val.w / 256, hidden: !!(val.flags & 1), level: val.level };
          if (!seencol) {
            seencol = true;
            find_mdw_colw(val.w / 256);
          }
          process_col(colinfo[val.e + 1]);
        }
        break;
      case 161:
        s4["!autofilter"] = { ref: encode_range(val) };
        break;
      case 476:
        s4["!margins"] = val;
        break;
      case 147:
        if (!wb2.Sheets[idx]) wb2.Sheets[idx] = {};
        if (val.name) wb2.Sheets[idx].CodeName = val.name;
        if (val.above || val.left) s4["!outline"] = { above: val.above, left: val.left };
        break;
      case 137:
        if (!wb2.Views) wb2.Views = [{}];
        if (!wb2.Views[0]) wb2.Views[0] = {};
        if (val.RTL) wb2.Views[0].RTL = true;
        break;
      case 485:
        break;
      case 64:
      case 1053:
        break;
      case 151:
        break;
      case 152:
      case 175:
      case 644:
      case 625:
      case 562:
      case 396:
      case 1112:
      case 1146:
      case 471:
      case 1050:
      case 649:
      case 1105:
      case 589:
      case 607:
      case 564:
      case 1055:
      case 168:
      case 174:
      case 1180:
      case 499:
      case 507:
      case 550:
      case 171:
      case 167:
      case 1177:
      case 169:
      case 1181:
      case 551:
      case 552:
      case 661:
      case 639:
      case 478:
      case 537:
      case 477:
      case 536:
      case 1103:
      case 680:
      case 1104:
      case 1024:
      case 663:
      case 535:
      case 678:
      case 504:
      case 1043:
      case 428:
      case 170:
      case 3072:
      case 50:
      case 2070:
      case 1045:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        pass = true;
        break;
      case 38:
        pass = false;
        break;
      default:
        if (RR.T) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  delete opts.supbooks;
  delete opts["!row"];
  if (!s4["!ref"] && (refguess.s.r < 2e6 || ref && (ref.e.r > 0 || ref.e.c > 0 || ref.s.r > 0 || ref.s.c > 0))) s4["!ref"] = encode_range(ref || refguess);
  if (opts.sheetRows && s4["!ref"]) {
    var tmpref = safe_decode_range(s4["!ref"]);
    if (opts.sheetRows <= +tmpref.e.r) {
      tmpref.e.r = opts.sheetRows - 1;
      if (tmpref.e.r > refguess.e.r) tmpref.e.r = refguess.e.r;
      if (tmpref.e.r < tmpref.s.r) tmpref.s.r = tmpref.e.r;
      if (tmpref.e.c > refguess.e.c) tmpref.e.c = refguess.e.c;
      if (tmpref.e.c < tmpref.s.c) tmpref.s.c = tmpref.e.c;
      s4["!fullref"] = s4["!ref"];
      s4["!ref"] = encode_range(tmpref);
    }
  }
  if (merges.length > 0) s4["!merges"] = merges;
  if (colinfo.length > 0) s4["!cols"] = colinfo;
  if (rowinfo.length > 0) s4["!rows"] = rowinfo;
  return s4;
}
function write_ws_bin_cell(ba, cell, R3, C2, opts, ws, last_seen) {
  if (cell.v === void 0) return false;
  var vv = "";
  switch (cell.t) {
    case "b":
      vv = cell.v ? "1" : "0";
      break;
    case "d":
      cell = dup(cell);
      cell.z = cell.z || table_fmt[14];
      cell.v = datenum(parseDate(cell.v));
      cell.t = "n";
      break;
    case "n":
    case "e":
      vv = "" + cell.v;
      break;
    default:
      vv = cell.v;
      break;
  }
  var o2 = { r: R3, c: C2 };
  o2.s = get_cell_style(opts.cellXfs, cell, opts);
  if (cell.l) ws["!links"].push([encode_cell(o2), cell.l]);
  if (cell.c) ws["!comments"].push([encode_cell(o2), cell.c]);
  switch (cell.t) {
    case "s":
    case "str":
      if (opts.bookSST) {
        vv = get_sst_id(opts.Strings, cell.v, opts.revStrings);
        o2.t = "s";
        o2.v = vv;
        if (last_seen) write_record(ba, 18, write_BrtShortIsst(cell, o2));
        else write_record(ba, 7, write_BrtCellIsst(cell, o2));
      } else {
        o2.t = "str";
        if (last_seen) write_record(ba, 17, write_BrtShortSt(cell, o2));
        else write_record(ba, 6, write_BrtCellSt(cell, o2));
      }
      return true;
    case "n":
      if (cell.v == (cell.v | 0) && cell.v > -1e3 && cell.v < 1e3) {
        if (last_seen) write_record(ba, 13, write_BrtShortRk(cell, o2));
        else write_record(ba, 2, write_BrtCellRk(cell, o2));
      } else {
        if (last_seen) write_record(ba, 16, write_BrtShortReal(cell, o2));
        else write_record(ba, 5, write_BrtCellReal(cell, o2));
      }
      return true;
    case "b":
      o2.t = "b";
      if (last_seen) write_record(ba, 15, write_BrtShortBool(cell, o2));
      else write_record(ba, 4, write_BrtCellBool(cell, o2));
      return true;
    case "e":
      o2.t = "e";
      if (last_seen) write_record(ba, 14, write_BrtShortError(cell, o2));
      else write_record(ba, 3, write_BrtCellError(cell, o2));
      return true;
  }
  if (last_seen) write_record(ba, 12, write_BrtShortBlank(cell, o2));
  else write_record(ba, 1, write_BrtCellBlank(cell, o2));
  return true;
}
function write_CELLTABLE(ba, ws, idx, opts) {
  var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
  write_record(
    ba,
    145
    /* BrtBeginSheetData */
  );
  var dense = Array.isArray(ws);
  var cap = range.e.r;
  if (ws["!rows"]) cap = Math.max(range.e.r, ws["!rows"].length - 1);
  for (var R3 = range.s.r; R3 <= cap; ++R3) {
    rr = encode_row(R3);
    write_row_header(ba, ws, range, R3);
    var last_seen = false;
    if (R3 <= range.e.r) for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      if (R3 === range.s.r) cols[C2] = encode_col(C2);
      ref = cols[C2] + rr;
      var cell = dense ? (ws[R3] || [])[C2] : ws[ref];
      if (!cell) {
        last_seen = false;
        continue;
      }
      last_seen = write_ws_bin_cell(ba, cell, R3, C2, opts, ws, last_seen);
    }
  }
  write_record(
    ba,
    146
    /* BrtEndSheetData */
  );
}
function write_MERGECELLS(ba, ws) {
  if (!ws || !ws["!merges"]) return;
  write_record(ba, 177, write_BrtBeginMergeCells(ws["!merges"].length));
  ws["!merges"].forEach(function(m4) {
    write_record(ba, 176, write_BrtMergeCell(m4));
  });
  write_record(
    ba,
    178
    /* BrtEndMergeCells */
  );
}
function write_COLINFOS(ba, ws) {
  if (!ws || !ws["!cols"]) return;
  write_record(
    ba,
    390
    /* BrtBeginColInfos */
  );
  ws["!cols"].forEach(function(m4, i3) {
    if (m4) write_record(ba, 60, write_BrtColInfo(i3, m4));
  });
  write_record(
    ba,
    391
    /* BrtEndColInfos */
  );
}
function write_IGNOREECS(ba, ws) {
  if (!ws || !ws["!ref"]) return;
  write_record(
    ba,
    648
    /* BrtBeginCellIgnoreECs */
  );
  write_record(ba, 649, write_BrtCellIgnoreEC(safe_decode_range(ws["!ref"])));
  write_record(
    ba,
    650
    /* BrtEndCellIgnoreECs */
  );
}
function write_HLINKS(ba, ws, rels) {
  ws["!links"].forEach(function(l2) {
    if (!l2[1].Target) return;
    var rId = add_rels(rels, -1, l2[1].Target.replace(/#.*$/, ""), RELS.HLINK);
    write_record(ba, 494, write_BrtHLink(l2, rId));
  });
  delete ws["!links"];
}
function write_LEGACYDRAWING(ba, ws, idx, rels) {
  if (ws["!comments"].length > 0) {
    var rId = add_rels(rels, -1, "../drawings/vmlDrawing" + (idx + 1) + ".vml", RELS.VML);
    write_record(ba, 551, write_RelID("rId" + rId));
    ws["!legacy"] = rId;
  }
}
function write_AUTOFILTER(ba, ws, wb2, idx) {
  if (!ws["!autofilter"]) return;
  var data = ws["!autofilter"];
  var ref = typeof data.ref === "string" ? data.ref : encode_range(data.ref);
  if (!wb2.Workbook) wb2.Workbook = { Sheets: [] };
  if (!wb2.Workbook.Names) wb2.Workbook.Names = [];
  var names = wb2.Workbook.Names;
  var range = decode_range(ref);
  if (range.s.r == range.e.r) {
    range.e.r = decode_range(ws["!ref"]).e.r;
    ref = encode_range(range);
  }
  for (var i3 = 0; i3 < names.length; ++i3) {
    var name = names[i3];
    if (name.Name != "_xlnm._FilterDatabase") continue;
    if (name.Sheet != idx) continue;
    name.Ref = "'" + wb2.SheetNames[idx] + "'!" + ref;
    break;
  }
  if (i3 == names.length) names.push({ Name: "_xlnm._FilterDatabase", Sheet: idx, Ref: "'" + wb2.SheetNames[idx] + "'!" + ref });
  write_record(ba, 161, write_UncheckedRfX(safe_decode_range(ref)));
  write_record(
    ba,
    162
    /* BrtEndAFilter */
  );
}
function write_WSVIEWS2(ba, ws, Workbook) {
  write_record(
    ba,
    133
    /* BrtBeginWsViews */
  );
  {
    write_record(ba, 137, write_BrtBeginWsView(ws, Workbook));
    write_record(
      ba,
      138
      /* BrtEndWsView */
    );
  }
  write_record(
    ba,
    134
    /* BrtEndWsViews */
  );
}
function write_SHEETPROTECT(ba, ws) {
  if (!ws["!protect"]) return;
  write_record(ba, 535, write_BrtSheetProtection(ws["!protect"]));
}
function write_ws_bin(idx, opts, wb2, rels) {
  var ba = buf_array();
  var s4 = wb2.SheetNames[idx], ws = wb2.Sheets[s4] || {};
  var c3 = s4;
  try {
    if (wb2 && wb2.Workbook) c3 = wb2.Workbook.Sheets[idx].CodeName || c3;
  } catch (e3) {
  }
  var r2 = safe_decode_range(ws["!ref"] || "A1");
  if (r2.e.c > 16383 || r2.e.r > 1048575) {
    if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:XFD1048576");
    r2.e.c = Math.min(r2.e.c, 16383);
    r2.e.r = Math.min(r2.e.c, 1048575);
  }
  ws["!links"] = [];
  ws["!comments"] = [];
  write_record(
    ba,
    129
    /* BrtBeginSheet */
  );
  if (wb2.vbaraw || ws["!outline"]) write_record(ba, 147, write_BrtWsProp(c3, ws["!outline"]));
  write_record(ba, 148, write_BrtWsDim(r2));
  write_WSVIEWS2(ba, ws, wb2.Workbook);
  write_COLINFOS(ba, ws);
  write_CELLTABLE(ba, ws, idx, opts);
  write_SHEETPROTECT(ba, ws);
  write_AUTOFILTER(ba, ws, wb2, idx);
  write_MERGECELLS(ba, ws);
  write_HLINKS(ba, ws, rels);
  if (ws["!margins"]) write_record(ba, 476, write_BrtMargins(ws["!margins"]));
  if (!opts || opts.ignoreEC || opts.ignoreEC == void 0) write_IGNOREECS(ba, ws);
  write_LEGACYDRAWING(ba, ws, idx, rels);
  write_record(
    ba,
    130
    /* BrtEndSheet */
  );
  return ba.end();
}
function parse_Cache(data) {
  var col = [];
  var num = data.match(/^<c:numCache>/);
  var f2;
  (data.match(/<c:pt idx="(\d*)">(.*?)<\/c:pt>/mg) || []).forEach(function(pt) {
    var q3 = pt.match(/<c:pt idx="(\d*?)"><c:v>(.*)<\/c:v><\/c:pt>/);
    if (!q3) return;
    col[+q3[1]] = num ? +q3[2] : q3[2];
  });
  var nf2 = unescapexml((data.match(/<c:formatCode>([\s\S]*?)<\/c:formatCode>/) || ["", "General"])[1]);
  (data.match(/<c:f>(.*?)<\/c:f>/mg) || []).forEach(function(F2) {
    f2 = F2.replace(/<.*?>/g, "");
  });
  return [col, nf2, f2];
}
function parse_chart(data, name, opts, rels, wb2, csheet) {
  var cs = csheet || { "!type": "chart" };
  if (!data) return csheet;
  var C2 = 0, R3 = 0, col = "A";
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  (data.match(/<c:numCache>[\s\S]*?<\/c:numCache>/gm) || []).forEach(function(nc2) {
    var cache = parse_Cache(nc2);
    refguess.s.r = refguess.s.c = 0;
    refguess.e.c = C2;
    col = encode_col(C2);
    cache[0].forEach(function(n2, i3) {
      cs[col + encode_row(i3)] = { t: "n", v: n2, z: cache[1] };
      R3 = i3;
    });
    if (refguess.e.r < R3) refguess.e.r = R3;
    ++C2;
  });
  if (C2 > 0) cs["!ref"] = encode_range(refguess);
  return cs;
}
function parse_cs_xml(data, opts, idx, rels, wb2) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s4 = { "!type": "chart", "!drawel": null, "!rel": "" };
  var m4;
  var sheetPr = data.match(sheetprregex);
  if (sheetPr) parse_ws_xml_sheetpr(sheetPr[0], s4, wb2, idx);
  if (m4 = data.match(/drawing r:id="(.*?)"/)) s4["!rel"] = m4[1];
  if (rels["!id"][s4["!rel"]]) s4["!drawel"] = rels["!id"][s4["!rel"]];
  return s4;
}
function parse_BrtCsProp(data, length) {
  data.l += 10;
  var name = parse_XLWideString(data);
  return { name };
}
function parse_cs_bin(data, opts, idx, rels, wb2) {
  if (!data) return data;
  if (!rels) rels = { "!id": {} };
  var s4 = { "!type": "chart", "!drawel": null, "!rel": "" };
  var pass = false;
  recordhopper(data, function cs_parse(val, R3, RT) {
    switch (RT) {
      case 550:
        s4["!rel"] = val;
        break;
      case 651:
        if (!wb2.Sheets[idx]) wb2.Sheets[idx] = {};
        if (val.name) wb2.Sheets[idx].CodeName = val.name;
        break;
      case 562:
      case 652:
      case 669:
      case 679:
      case 551:
      case 552:
      case 476:
      case 3072:
        break;
      case 35:
        pass = true;
        break;
      case 36:
        pass = false;
        break;
      case 37:
        break;
      case 38:
        break;
      default:
        if (R3.T > 0) ;
        else if (R3.T < 0) ;
        else if (!pass || opts.WTF) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  if (rels["!id"][s4["!rel"]]) s4["!drawel"] = rels["!id"][s4["!rel"]];
  return s4;
}
var WBPropsDef = [
  ["allowRefreshQuery", false, "bool"],
  ["autoCompressPictures", true, "bool"],
  ["backupFile", false, "bool"],
  ["checkCompatibility", false, "bool"],
  ["CodeName", ""],
  ["date1904", false, "bool"],
  ["defaultThemeVersion", 0, "int"],
  ["filterPrivacy", false, "bool"],
  ["hidePivotFieldList", false, "bool"],
  ["promptedSolutions", false, "bool"],
  ["publishItems", false, "bool"],
  ["refreshAllConnections", false, "bool"],
  ["saveExternalLinkValues", true, "bool"],
  ["showBorderUnselectedTables", true, "bool"],
  ["showInkAnnotation", true, "bool"],
  ["showObjects", "all"],
  ["showPivotChartFilter", false, "bool"],
  ["updateLinks", "userSet"]
];
var WBViewDef = [
  ["activeTab", 0, "int"],
  ["autoFilterDateGrouping", true, "bool"],
  ["firstSheet", 0, "int"],
  ["minimized", false, "bool"],
  ["showHorizontalScroll", true, "bool"],
  ["showSheetTabs", true, "bool"],
  ["showVerticalScroll", true, "bool"],
  ["tabRatio", 600, "int"],
  ["visibility", "visible"]
  //window{Height,Width}, {x,y}Window
];
var SheetDef = [
  //['state', 'visible']
];
var CalcPrDef = [
  ["calcCompleted", "true"],
  ["calcMode", "auto"],
  ["calcOnSave", "true"],
  ["concurrentCalc", "true"],
  ["fullCalcOnLoad", "false"],
  ["fullPrecision", "true"],
  ["iterate", "false"],
  ["iterateCount", "100"],
  ["iterateDelta", "0.001"],
  ["refMode", "A1"]
];
function push_defaults_array(target, defaults) {
  for (var j2 = 0; j2 != target.length; ++j2) {
    var w3 = target[j2];
    for (var i3 = 0; i3 != defaults.length; ++i3) {
      var z3 = defaults[i3];
      if (w3[z3[0]] == null) w3[z3[0]] = z3[1];
      else switch (z3[2]) {
        case "bool":
          if (typeof w3[z3[0]] == "string") w3[z3[0]] = parsexmlbool(w3[z3[0]]);
          break;
        case "int":
          if (typeof w3[z3[0]] == "string") w3[z3[0]] = parseInt(w3[z3[0]], 10);
          break;
      }
    }
  }
}
function push_defaults(target, defaults) {
  for (var i3 = 0; i3 != defaults.length; ++i3) {
    var z3 = defaults[i3];
    if (target[z3[0]] == null) target[z3[0]] = z3[1];
    else switch (z3[2]) {
      case "bool":
        if (typeof target[z3[0]] == "string") target[z3[0]] = parsexmlbool(target[z3[0]]);
        break;
      case "int":
        if (typeof target[z3[0]] == "string") target[z3[0]] = parseInt(target[z3[0]], 10);
        break;
    }
  }
}
function parse_wb_defaults(wb2) {
  push_defaults(wb2.WBProps, WBPropsDef);
  push_defaults(wb2.CalcPr, CalcPrDef);
  push_defaults_array(wb2.WBView, WBViewDef);
  push_defaults_array(wb2.Sheets, SheetDef);
  _ssfopts.date1904 = parsexmlbool(wb2.WBProps.date1904);
}
function safe1904(wb2) {
  if (!wb2.Workbook) return "false";
  if (!wb2.Workbook.WBProps) return "false";
  return parsexmlbool(wb2.Workbook.WBProps.date1904) ? "true" : "false";
}
var badchars = /* @__PURE__ */ "][*?/\\".split("");
function check_ws_name(n2, safe) {
  if (n2.length > 31) {
    throw new Error("Sheet names cannot exceed 31 chars");
  }
  var _good = true;
  badchars.forEach(function(c3) {
    if (n2.indexOf(c3) == -1) return;
    throw new Error("Sheet name cannot contain : \\ / ? * [ ]");
  });
  return _good;
}
function check_wb_names(N2, S4, codes) {
  N2.forEach(function(n2, i3) {
    check_ws_name(n2);
    for (var j2 = 0; j2 < i3; ++j2) if (n2 == N2[j2]) throw new Error("Duplicate Sheet Name: " + n2);
    if (codes) {
      var cn2 = S4 && S4[i3] && S4[i3].CodeName || n2;
      if (cn2.charCodeAt(0) == 95 && cn2.length > 22) throw new Error("Bad Code Name: Worksheet" + cn2);
    }
  });
}
function check_wb(wb2) {
  if (!wb2 || !wb2.SheetNames || !wb2.Sheets) throw new Error("Invalid Workbook");
  if (!wb2.SheetNames.length) throw new Error("Workbook is empty");
  var Sheets = wb2.Workbook && wb2.Workbook.Sheets || [];
  check_wb_names(wb2.SheetNames, Sheets, !!wb2.vbaraw);
  for (var i3 = 0; i3 < wb2.SheetNames.length; ++i3) check_ws(wb2.Sheets[wb2.SheetNames[i3]], wb2.SheetNames[i3], i3);
}
var wbnsregex = /<\w+:workbook/;
function parse_wb_xml(data, opts) {
  if (!data) throw new Error("Could not find file");
  var wb2 = (
    /*::(*/
    { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, Names: [], xmlns: "" }
  );
  var pass = false, xmlns = "xmlns";
  var dname = {}, dnstart = 0;
  data.replace(tagregex, function xml_wb(x3, idx) {
    var y4 = parsexmltag(x3);
    switch (strip_ns(y4[0])) {
      case "<?xml":
        break;
      case "<workbook":
        if (x3.match(wbnsregex)) xmlns = "xmlns" + x3.match(/<(\w+):/)[1];
        wb2.xmlns = y4[xmlns];
        break;
      case "</workbook>":
        break;
      case "<fileVersion":
        delete y4[0];
        wb2.AppVersion = y4;
        break;
      case "<fileVersion/>":
      case "</fileVersion>":
        break;
      case "<fileSharing":
        break;
      case "<fileSharing/>":
        break;
      case "<workbookPr":
      case "<workbookPr/>":
        WBPropsDef.forEach(function(w3) {
          if (y4[w3[0]] == null) return;
          switch (w3[2]) {
            case "bool":
              wb2.WBProps[w3[0]] = parsexmlbool(y4[w3[0]]);
              break;
            case "int":
              wb2.WBProps[w3[0]] = parseInt(y4[w3[0]], 10);
              break;
            default:
              wb2.WBProps[w3[0]] = y4[w3[0]];
          }
        });
        if (y4.codeName) wb2.WBProps.CodeName = utf8read(y4.codeName);
        break;
      case "</workbookPr>":
        break;
      case "<workbookProtection":
        break;
      case "<workbookProtection/>":
        break;
      case "<bookViews":
      case "<bookViews>":
      case "</bookViews>":
        break;
      case "<workbookView":
      case "<workbookView/>":
        delete y4[0];
        wb2.WBView.push(y4);
        break;
      case "</workbookView>":
        break;
      case "<sheets":
      case "<sheets>":
      case "</sheets>":
        break;
      case "<sheet":
        switch (y4.state) {
          case "hidden":
            y4.Hidden = 1;
            break;
          case "veryHidden":
            y4.Hidden = 2;
            break;
          default:
            y4.Hidden = 0;
        }
        delete y4.state;
        y4.name = unescapexml(utf8read(y4.name));
        delete y4[0];
        wb2.Sheets.push(y4);
        break;
      case "</sheet>":
        break;
      case "<functionGroups":
      case "<functionGroups/>":
        break;
      case "<functionGroup":
        break;
      case "<externalReferences":
      case "</externalReferences>":
      case "<externalReferences>":
        break;
      case "<externalReference":
        break;
      case "<definedNames/>":
        break;
      case "<definedNames>":
      case "<definedNames":
        pass = true;
        break;
      case "</definedNames>":
        pass = false;
        break;
      case "<definedName":
        {
          dname = {};
          dname.Name = utf8read(y4.name);
          if (y4.comment) dname.Comment = y4.comment;
          if (y4.localSheetId) dname.Sheet = +y4.localSheetId;
          if (parsexmlbool(y4.hidden || "0")) dname.Hidden = true;
          dnstart = idx + x3.length;
        }
        break;
      case "</definedName>":
        {
          dname.Ref = unescapexml(utf8read(data.slice(dnstart, idx)));
          wb2.Names.push(dname);
        }
        break;
      case "<definedName/>":
        break;
      case "<calcPr":
        delete y4[0];
        wb2.CalcPr = y4;
        break;
      case "<calcPr/>":
        delete y4[0];
        wb2.CalcPr = y4;
        break;
      case "</calcPr>":
        break;
      case "<oleSize":
        break;
      case "<customWorkbookViews>":
      case "</customWorkbookViews>":
      case "<customWorkbookViews":
        break;
      case "<customWorkbookView":
      case "</customWorkbookView>":
        break;
      case "<pivotCaches>":
      case "</pivotCaches>":
      case "<pivotCaches":
        break;
      case "<pivotCache":
        break;
      case "<smartTagPr":
      case "<smartTagPr/>":
        break;
      case "<smartTagTypes":
      case "<smartTagTypes>":
      case "</smartTagTypes>":
        break;
      case "<smartTagType":
        break;
      case "<webPublishing":
      case "<webPublishing/>":
        break;
      case "<fileRecoveryPr":
      case "<fileRecoveryPr/>":
        break;
      case "<webPublishObjects>":
      case "<webPublishObjects":
      case "</webPublishObjects>":
        break;
      case "<webPublishObject":
        break;
      case "<extLst":
      case "<extLst>":
      case "</extLst>":
      case "<extLst/>":
        break;
      case "<ext":
        pass = true;
        break;
      case "</ext>":
        pass = false;
        break;
      case "<ArchID":
        break;
      case "<AlternateContent":
      case "<AlternateContent>":
        pass = true;
        break;
      case "</AlternateContent>":
        pass = false;
        break;
      case "<revisionPtr":
        break;
      default:
        if (!pass && opts.WTF) throw new Error("unrecognized " + y4[0] + " in workbook");
    }
    return x3;
  });
  if (XMLNS_main.indexOf(wb2.xmlns) === -1) throw new Error("Unknown Namespace: " + wb2.xmlns);
  parse_wb_defaults(wb2);
  return wb2;
}
function write_wb_xml(wb2) {
  var o2 = [XML_HEADER];
  o2[o2.length] = writextag("workbook", null, {
    "xmlns": XMLNS_main[0],
    //'xmlns:mx': XMLNS.mx,
    //'xmlns:s': XMLNS_main[0],
    "xmlns:r": XMLNS.r
  });
  var write_names = wb2.Workbook && (wb2.Workbook.Names || []).length > 0;
  var workbookPr = { codeName: "ThisWorkbook" };
  if (wb2.Workbook && wb2.Workbook.WBProps) {
    WBPropsDef.forEach(function(x3) {
      if (wb2.Workbook.WBProps[x3[0]] == null) return;
      if (wb2.Workbook.WBProps[x3[0]] == x3[1]) return;
      workbookPr[x3[0]] = wb2.Workbook.WBProps[x3[0]];
    });
    if (wb2.Workbook.WBProps.CodeName) {
      workbookPr.codeName = wb2.Workbook.WBProps.CodeName;
      delete workbookPr.CodeName;
    }
  }
  o2[o2.length] = writextag("workbookPr", null, workbookPr);
  var sheets = wb2.Workbook && wb2.Workbook.Sheets || [];
  var i3 = 0;
  if (sheets && sheets[0] && !!sheets[0].Hidden) {
    o2[o2.length] = "<bookViews>";
    for (i3 = 0; i3 != wb2.SheetNames.length; ++i3) {
      if (!sheets[i3]) break;
      if (!sheets[i3].Hidden) break;
    }
    if (i3 == wb2.SheetNames.length) i3 = 0;
    o2[o2.length] = '<workbookView firstSheet="' + i3 + '" activeTab="' + i3 + '"/>';
    o2[o2.length] = "</bookViews>";
  }
  o2[o2.length] = "<sheets>";
  for (i3 = 0; i3 != wb2.SheetNames.length; ++i3) {
    var sht = { name: escapexml(wb2.SheetNames[i3].slice(0, 31)) };
    sht.sheetId = "" + (i3 + 1);
    sht["r:id"] = "rId" + (i3 + 1);
    if (sheets[i3]) switch (sheets[i3].Hidden) {
      case 1:
        sht.state = "hidden";
        break;
      case 2:
        sht.state = "veryHidden";
        break;
    }
    o2[o2.length] = writextag("sheet", null, sht);
  }
  o2[o2.length] = "</sheets>";
  if (write_names) {
    o2[o2.length] = "<definedNames>";
    if (wb2.Workbook && wb2.Workbook.Names) wb2.Workbook.Names.forEach(function(n2) {
      var d4 = { name: n2.Name };
      if (n2.Comment) d4.comment = n2.Comment;
      if (n2.Sheet != null) d4.localSheetId = "" + n2.Sheet;
      if (n2.Hidden) d4.hidden = "1";
      if (!n2.Ref) return;
      o2[o2.length] = writextag("definedName", escapexml(n2.Ref), d4);
    });
    o2[o2.length] = "</definedNames>";
  }
  if (o2.length > 2) {
    o2[o2.length] = "</workbook>";
    o2[1] = o2[1].replace("/>", ">");
  }
  return o2.join("");
}
function parse_BrtBundleSh(data, length) {
  var z3 = {};
  z3.Hidden = data.read_shift(4);
  z3.iTabID = data.read_shift(4);
  z3.strRelID = parse_RelID(data);
  z3.name = parse_XLWideString(data);
  return z3;
}
function write_BrtBundleSh(data, o2) {
  if (!o2) o2 = new_buf(127);
  o2.write_shift(4, data.Hidden);
  o2.write_shift(4, data.iTabID);
  write_RelID(data.strRelID, o2);
  write_XLWideString(data.name.slice(0, 31), o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function parse_BrtWbProp(data, length) {
  var o2 = {};
  var flags = data.read_shift(4);
  o2.defaultThemeVersion = data.read_shift(4);
  var strName = length > 8 ? parse_XLWideString(data) : "";
  if (strName.length > 0) o2.CodeName = strName;
  o2.autoCompressPictures = !!(flags & 65536);
  o2.backupFile = !!(flags & 64);
  o2.checkCompatibility = !!(flags & 4096);
  o2.date1904 = !!(flags & 1);
  o2.filterPrivacy = !!(flags & 8);
  o2.hidePivotFieldList = !!(flags & 1024);
  o2.promptedSolutions = !!(flags & 16);
  o2.publishItems = !!(flags & 2048);
  o2.refreshAllConnections = !!(flags & 262144);
  o2.saveExternalLinkValues = !!(flags & 128);
  o2.showBorderUnselectedTables = !!(flags & 4);
  o2.showInkAnnotation = !!(flags & 32);
  o2.showObjects = ["all", "placeholders", "none"][flags >> 13 & 3];
  o2.showPivotChartFilter = !!(flags & 32768);
  o2.updateLinks = ["userSet", "never", "always"][flags >> 8 & 3];
  return o2;
}
function write_BrtWbProp(data, o2) {
  if (!o2) o2 = new_buf(72);
  var flags = 0;
  if (data) {
    if (data.filterPrivacy) flags |= 8;
  }
  o2.write_shift(4, flags);
  o2.write_shift(4, 0);
  write_XLSBCodeName(data && data.CodeName || "ThisWorkbook", o2);
  return o2.slice(0, o2.l);
}
function parse_BrtFRTArchID$(data, length) {
  var o2 = {};
  data.read_shift(4);
  o2.ArchID = data.read_shift(4);
  data.l += length - 8;
  return o2;
}
function parse_BrtName(data, length, opts) {
  var end = data.l + length;
  data.l += 4;
  data.l += 1;
  var itab = data.read_shift(4);
  var name = parse_XLNameWideString(data);
  var formula = parse_XLSBNameParsedFormula(data, 0, opts);
  var comment = parse_XLNullableWideString(data);
  data.l = end;
  var out = { Name: name, Ptg: formula };
  if (itab < 268435455) out.Sheet = itab;
  if (comment) out.Comment = comment;
  return out;
}
function parse_wb_bin(data, opts) {
  var wb2 = { AppVersion: {}, WBProps: {}, WBView: [], Sheets: [], CalcPr: {}, xmlns: "" };
  var state = [];
  var pass = false;
  if (!opts) opts = {};
  opts.biff = 12;
  var Names = [];
  var supbooks = [[]];
  supbooks.SheetNames = [];
  supbooks.XTI = [];
  XLSBRecordEnum[16] = { n: "BrtFRTArchID$", f: parse_BrtFRTArchID$ };
  recordhopper(data, function hopper_wb(val, R3, RT) {
    switch (RT) {
      case 156:
        supbooks.SheetNames.push(val.name);
        wb2.Sheets.push(val);
        break;
      case 153:
        wb2.WBProps = val;
        break;
      case 39:
        if (val.Sheet != null) opts.SID = val.Sheet;
        val.Ref = stringify_formula(val.Ptg, null, null, supbooks, opts);
        delete opts.SID;
        delete val.Ptg;
        Names.push(val);
        break;
      case 1036:
        break;
      case 357:
      case 358:
      case 355:
      case 667:
        if (!supbooks[0].length) supbooks[0] = [RT, val];
        else supbooks.push([RT, val]);
        supbooks[supbooks.length - 1].XTI = [];
        break;
      case 362:
        if (supbooks.length === 0) {
          supbooks[0] = [];
          supbooks[0].XTI = [];
        }
        supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
        supbooks.XTI = supbooks.XTI.concat(val);
        break;
      case 361:
        break;
      case 2071:
      case 158:
      case 143:
      case 664:
      case 353:
        break;
      case 3072:
      case 3073:
      case 534:
      case 677:
      case 157:
      case 610:
      case 2050:
      case 155:
      case 548:
      case 676:
      case 128:
      case 665:
      case 2128:
      case 2125:
      case 549:
      case 2053:
      case 596:
      case 2076:
      case 2075:
      case 2082:
      case 397:
      case 154:
      case 1117:
      case 553:
      case 2091:
        break;
      case 35:
        state.push(RT);
        pass = true;
        break;
      case 36:
        state.pop();
        pass = false;
        break;
      case 37:
        state.push(RT);
        pass = true;
        break;
      case 38:
        state.pop();
        pass = false;
        break;
      case 16:
        break;
      default:
        if (R3.T) ;
        else if (!pass || opts.WTF && state[state.length - 1] != 37 && state[state.length - 1] != 35) throw new Error("Unexpected record 0x" + RT.toString(16));
    }
  }, opts);
  parse_wb_defaults(wb2);
  wb2.Names = Names;
  wb2.supbooks = supbooks;
  return wb2;
}
function write_BUNDLESHS(ba, wb2) {
  write_record(
    ba,
    143
    /* BrtBeginBundleShs */
  );
  for (var idx = 0; idx != wb2.SheetNames.length; ++idx) {
    var viz = wb2.Workbook && wb2.Workbook.Sheets && wb2.Workbook.Sheets[idx] && wb2.Workbook.Sheets[idx].Hidden || 0;
    var d4 = { Hidden: viz, iTabID: idx + 1, strRelID: "rId" + (idx + 1), name: wb2.SheetNames[idx] };
    write_record(ba, 156, write_BrtBundleSh(d4));
  }
  write_record(
    ba,
    144
    /* BrtEndBundleShs */
  );
}
function write_BrtFileVersion(data, o2) {
  if (!o2) o2 = new_buf(127);
  for (var i3 = 0; i3 != 4; ++i3) o2.write_shift(4, 0);
  write_XLWideString("SheetJS", o2);
  write_XLWideString(XLSX.version, o2);
  write_XLWideString(XLSX.version, o2);
  write_XLWideString("7262", o2);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function write_BrtBookView(idx, o2) {
  if (!o2) o2 = new_buf(29);
  o2.write_shift(-4, 0);
  o2.write_shift(-4, 460);
  o2.write_shift(4, 28800);
  o2.write_shift(4, 17600);
  o2.write_shift(4, 500);
  o2.write_shift(4, idx);
  o2.write_shift(4, idx);
  var flags = 120;
  o2.write_shift(1, flags);
  return o2.length > o2.l ? o2.slice(0, o2.l) : o2;
}
function write_BOOKVIEWS(ba, wb2) {
  if (!wb2.Workbook || !wb2.Workbook.Sheets) return;
  var sheets = wb2.Workbook.Sheets;
  var i3 = 0, vistab = -1, hidden = -1;
  for (; i3 < sheets.length; ++i3) {
    if (!sheets[i3] || !sheets[i3].Hidden && vistab == -1) vistab = i3;
    else if (sheets[i3].Hidden == 1 && hidden == -1) hidden = i3;
  }
  if (hidden > vistab) return;
  write_record(
    ba,
    135
    /* BrtBeginBookViews */
  );
  write_record(ba, 158, write_BrtBookView(vistab));
  write_record(
    ba,
    136
    /* BrtEndBookViews */
  );
}
function write_wb_bin(wb2, opts) {
  var ba = buf_array();
  write_record(
    ba,
    131
    /* BrtBeginBook */
  );
  write_record(ba, 128, write_BrtFileVersion());
  write_record(ba, 153, write_BrtWbProp(wb2.Workbook && wb2.Workbook.WBProps || null));
  write_BOOKVIEWS(ba, wb2);
  write_BUNDLESHS(ba, wb2);
  write_record(
    ba,
    132
    /* BrtEndBook */
  );
  return ba.end();
}
function parse_wb(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_wb_bin(data, opts);
  return parse_wb_xml(data, opts);
}
function parse_ws(data, name, idx, opts, rels, wb2, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ws_bin(data, opts, idx, rels, wb2, themes, styles);
  return parse_ws_xml(data, opts, idx, rels, wb2, themes, styles);
}
function parse_cs(data, name, idx, opts, rels, wb2, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_cs_bin(data, opts, idx, rels, wb2);
  return parse_cs_xml(data, opts, idx, rels, wb2);
}
function parse_ms(data, name, idx, opts, rels, wb2, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ms_bin();
  return parse_ms_xml();
}
function parse_ds(data, name, idx, opts, rels, wb2, themes, styles) {
  if (name.slice(-4) === ".bin") return parse_ds_bin();
  return parse_ds_xml();
}
function parse_sty(data, name, themes, opts) {
  if (name.slice(-4) === ".bin") return parse_sty_bin(data, themes, opts);
  return parse_sty_xml(data, themes, opts);
}
function parse_theme(data, name, opts) {
  return parse_theme_xml(data, opts);
}
function parse_sst(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_sst_bin(data, opts);
  return parse_sst_xml(data, opts);
}
function parse_cmnt(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_comments_bin(data, opts);
  return parse_comments_xml(data, opts);
}
function parse_cc(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_cc_bin(data);
  return parse_cc_xml(data);
}
function parse_xlink(data, rel, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlink_bin(data, rel, name, opts);
  return parse_xlink_xml();
}
function parse_xlmeta(data, name, opts) {
  if (name.slice(-4) === ".bin") return parse_xlmeta_bin(data, name, opts);
  return parse_xlmeta_xml(data, name, opts);
}
function write_wb(wb2, name, opts) {
  return (name.slice(-4) === ".bin" ? write_wb_bin : write_wb_xml)(wb2);
}
function write_ws(data, name, opts, wb2, rels) {
  return (name.slice(-4) === ".bin" ? write_ws_bin : write_ws_xml)(data, opts, wb2, rels);
}
function write_sty(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sty_bin : write_sty_xml)(data, opts);
}
function write_sst(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_sst_bin : write_sst_xml)(data, opts);
}
function write_cmnt(data, name, opts) {
  return (name.slice(-4) === ".bin" ? write_comments_bin : write_comments_xml)(data);
}
function write_xlmeta(name) {
  return (name.slice(-4) === ".bin" ? write_xlmeta_bin : write_xlmeta_xml)();
}
var attregexg2 = /([\w:]+)=((?:")([^"]*)(?:")|(?:')([^']*)(?:'))/g;
var attregex2 = /([\w:]+)=((?:")(?:[^"]*)(?:")|(?:')(?:[^']*)(?:'))/;
function xlml_parsexmltag(tag, skip_root) {
  var words = tag.split(/\s+/);
  var z3 = [];
  z3[0] = words[0];
  if (words.length === 1) return z3;
  var m4 = tag.match(attregexg2), y4, j2, w3, i3;
  if (m4) for (i3 = 0; i3 != m4.length; ++i3) {
    y4 = m4[i3].match(attregex2);
    if ((j2 = y4[1].indexOf(":")) === -1) z3[y4[1]] = y4[2].slice(1, y4[2].length - 1);
    else {
      if (y4[1].slice(0, 6) === "xmlns:") w3 = "xmlns" + y4[1].slice(6);
      else w3 = y4[1].slice(j2 + 1);
      z3[w3] = y4[2].slice(1, y4[2].length - 1);
    }
  }
  return z3;
}
function xlml_parsexmltagobj(tag) {
  var words = tag.split(/\s+/);
  var z3 = {};
  if (words.length === 1) return z3;
  var m4 = tag.match(attregexg2), y4, j2, w3, i3;
  if (m4) for (i3 = 0; i3 != m4.length; ++i3) {
    y4 = m4[i3].match(attregex2);
    if ((j2 = y4[1].indexOf(":")) === -1) z3[y4[1]] = y4[2].slice(1, y4[2].length - 1);
    else {
      if (y4[1].slice(0, 6) === "xmlns:") w3 = "xmlns" + y4[1].slice(6);
      else w3 = y4[1].slice(j2 + 1);
      z3[w3] = y4[2].slice(1, y4[2].length - 1);
    }
  }
  return z3;
}
var XLMLFormatMap;
function xlml_format(format2, value) {
  var fmt = XLMLFormatMap[format2] || unescapexml(format2);
  if (fmt === "General") return SSF_general(value);
  return SSF_format(fmt, value);
}
function xlml_set_custprop(Custprops, key, cp, val) {
  var oval = val;
  switch ((cp[0].match(/dt:dt="([\w.]+)"/) || ["", ""])[1]) {
    case "boolean":
      oval = parsexmlbool(val);
      break;
    case "i2":
    case "int":
      oval = parseInt(val, 10);
      break;
    case "r4":
    case "float":
      oval = parseFloat(val);
      break;
    case "date":
    case "dateTime.tz":
      oval = parseDate(val);
      break;
    case "i8":
    case "string":
    case "fixed":
    case "uuid":
    case "bin.base64":
      break;
    default:
      throw new Error("bad custprop:" + cp[0]);
  }
  Custprops[unescapexml(key)] = oval;
}
function safe_format_xlml(cell, nf2, o2) {
  if (cell.t === "z") return;
  if (!o2 || o2.cellText !== false) try {
    if (cell.t === "e") {
      cell.w = cell.w || BErr[cell.v];
    } else if (nf2 === "General") {
      if (cell.t === "n") {
        if ((cell.v | 0) === cell.v) cell.w = cell.v.toString(10);
        else cell.w = SSF_general_num(cell.v);
      } else cell.w = SSF_general(cell.v);
    } else cell.w = xlml_format(nf2 || "General", cell.v);
  } catch (e3) {
    if (o2.WTF) throw e3;
  }
  try {
    var z3 = XLMLFormatMap[nf2] || nf2 || "General";
    if (o2.cellNF) cell.z = z3;
    if (o2.cellDates && cell.t == "n" && fmt_is_date(z3)) {
      var _d = SSF_parse_date_code(cell.v);
      if (_d) {
        cell.t = "d";
        cell.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
      }
    }
  } catch (e3) {
    if (o2.WTF) throw e3;
  }
}
function process_style_xlml(styles, stag, opts) {
  if (opts.cellStyles) {
    if (stag.Interior) {
      var I3 = stag.Interior;
      if (I3.Pattern) I3.patternType = XLMLPatternTypeMap[I3.Pattern] || I3.Pattern;
    }
  }
  styles[stag.ID] = stag;
}
function parse_xlml_data(xml, ss, data, cell, base, styles, csty, row, arrayf, o2) {
  var nf2 = "General", sid = cell.StyleID, S4 = {};
  o2 = o2 || {};
  var interiors = [];
  var i3 = 0;
  if (sid === void 0 && row) sid = row.StyleID;
  if (sid === void 0 && csty) sid = csty.StyleID;
  while (styles[sid] !== void 0) {
    if (styles[sid].nf) nf2 = styles[sid].nf;
    if (styles[sid].Interior) interiors.push(styles[sid].Interior);
    if (!styles[sid].Parent) break;
    sid = styles[sid].Parent;
  }
  switch (data.Type) {
    case "Boolean":
      cell.t = "b";
      cell.v = parsexmlbool(xml);
      break;
    case "String":
      cell.t = "s";
      cell.r = xlml_fixstr(unescapexml(xml));
      cell.v = xml.indexOf("<") > -1 ? unescapexml(ss || xml).replace(/<.*?>/g, "") : cell.r;
      break;
    case "DateTime":
      if (xml.slice(-1) != "Z") xml += "Z";
      cell.v = (parseDate(xml) - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1e3);
      if (cell.v !== cell.v) cell.v = unescapexml(xml);
      else if (cell.v < 60) cell.v = cell.v - 1;
      if (!nf2 || nf2 == "General") nf2 = "yyyy-mm-dd";
    case "Number":
      if (cell.v === void 0) cell.v = +xml;
      if (!cell.t) cell.t = "n";
      break;
    case "Error":
      cell.t = "e";
      cell.v = RBErr[xml];
      if (o2.cellText !== false) cell.w = xml;
      break;
    default:
      if (xml == "" && ss == "") {
        cell.t = "z";
      } else {
        cell.t = "s";
        cell.v = xlml_fixstr(ss || xml);
      }
      break;
  }
  safe_format_xlml(cell, nf2, o2);
  if (o2.cellFormula !== false) {
    if (cell.Formula) {
      var fstr = unescapexml(cell.Formula);
      if (fstr.charCodeAt(0) == 61) fstr = fstr.slice(1);
      cell.f = rc_to_a1(fstr, base);
      delete cell.Formula;
      if (cell.ArrayRange == "RC") cell.F = rc_to_a1("RC:RC", base);
      else if (cell.ArrayRange) {
        cell.F = rc_to_a1(cell.ArrayRange, base);
        arrayf.push([safe_decode_range(cell.F), cell.F]);
      }
    } else {
      for (i3 = 0; i3 < arrayf.length; ++i3)
        if (base.r >= arrayf[i3][0].s.r && base.r <= arrayf[i3][0].e.r) {
          if (base.c >= arrayf[i3][0].s.c && base.c <= arrayf[i3][0].e.c)
            cell.F = arrayf[i3][1];
        }
    }
  }
  if (o2.cellStyles) {
    interiors.forEach(function(x3) {
      if (!S4.patternType && x3.patternType) S4.patternType = x3.patternType;
    });
    cell.s = S4;
  }
  if (cell.StyleID !== void 0) cell.ixfe = cell.StyleID;
}
function xlml_clean_comment(comment) {
  comment.t = comment.v || "";
  comment.t = comment.t.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  comment.v = comment.w = comment.ixfe = void 0;
}
function parse_xlml_xml(d4, _opts) {
  var opts = _opts || {};
  make_ssf();
  var str = debom(xlml_normalize(d4));
  if (opts.type == "binary" || opts.type == "array" || opts.type == "base64") {
    str = utf8read(str);
  }
  var opening = str.slice(0, 1024).toLowerCase(), ishtml = false;
  opening = opening.replace(/".*?"/g, "");
  if ((opening.indexOf(">") & 1023) > Math.min(opening.indexOf(",") & 1023, opening.indexOf(";") & 1023)) {
    var _o = dup(opts);
    _o.type = "string";
    return PRN.to_workbook(str, _o);
  }
  if (opening.indexOf("<?xml") == -1) ["html", "table", "head", "meta", "script", "style", "div"].forEach(function(tag) {
    if (opening.indexOf("<" + tag) >= 0) ishtml = true;
  });
  if (ishtml) return html_to_workbook(str, opts);
  XLMLFormatMap = {
    "General Number": "General",
    "General Date": table_fmt[22],
    "Long Date": "dddd, mmmm dd, yyyy",
    "Medium Date": table_fmt[15],
    "Short Date": table_fmt[14],
    "Long Time": table_fmt[19],
    "Medium Time": table_fmt[18],
    "Short Time": table_fmt[20],
    "Currency": '"$"#,##0.00_);[Red]\\("$"#,##0.00\\)',
    "Fixed": table_fmt[2],
    "Standard": table_fmt[4],
    "Percent": table_fmt[10],
    "Scientific": table_fmt[11],
    "Yes/No": '"Yes";"Yes";"No";@',
    "True/False": '"True";"True";"False";@',
    "On/Off": '"Yes";"Yes";"No";@'
  };
  var Rn;
  var state = [], tmp;
  var sheets = {}, sheetnames = [], cursheet = opts.dense ? [] : {}, sheetname = "";
  var cell = {}, row = {};
  var dtag = xlml_parsexmltag('<Data ss:Type="String">'), didx = 0;
  var c3 = 0, r2 = 0;
  var refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
  var styles = {}, stag = {};
  var ss = "", fidx = 0;
  var merges = [];
  var Props = {}, Custprops = {}, pidx = 0, cp = [];
  var comments = [], comment = {};
  var cstys = [], csty, seencol = false;
  var arrayf = [];
  var rowinfo = [], rowobj = {}, cc2 = 0, rr = 0;
  var Workbook = { Sheets: [], WBProps: { date1904: false } }, wsprops = {};
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "");
  var raw_Rn3 = "";
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = (raw_Rn3 = Rn[3]).toLowerCase()) {
    case "data":
      if (raw_Rn3 == "data") {
        if (Rn[1] === "/") {
          if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
        break;
      }
      if (state[state.length - 1][1]) break;
      if (Rn[1] === "/") parse_xlml_data(str.slice(didx, Rn.index), ss, dtag, state[state.length - 1][0] == /*"Comment"*/
      "comment" ? comment : cell, { c: c3, r: r2 }, styles, cstys[c3], row, arrayf, opts);
      else {
        ss = "";
        dtag = xlml_parsexmltag(Rn[0]);
        didx = Rn.index + Rn[0].length;
      }
      break;
    case "cell":
      if (Rn[1] === "/") {
        if (comments.length > 0) cell.c = comments;
        if ((!opts.sheetRows || opts.sheetRows > r2) && cell.v !== void 0) {
          if (opts.dense) {
            if (!cursheet[r2]) cursheet[r2] = [];
            cursheet[r2][c3] = cell;
          } else cursheet[encode_col(c3) + encode_row(r2)] = cell;
        }
        if (cell.HRef) {
          cell.l = { Target: unescapexml(cell.HRef) };
          if (cell.HRefScreenTip) cell.l.Tooltip = cell.HRefScreenTip;
          delete cell.HRef;
          delete cell.HRefScreenTip;
        }
        if (cell.MergeAcross || cell.MergeDown) {
          cc2 = c3 + (parseInt(cell.MergeAcross, 10) | 0);
          rr = r2 + (parseInt(cell.MergeDown, 10) | 0);
          merges.push({ s: { c: c3, r: r2 }, e: { c: cc2, r: rr } });
        }
        if (!opts.sheetStubs) {
          if (cell.MergeAcross) c3 = cc2 + 1;
          else ++c3;
        } else if (cell.MergeAcross || cell.MergeDown) {
          for (var cma = c3; cma <= cc2; ++cma) {
            for (var cmd = r2; cmd <= rr; ++cmd) {
              if (cma > c3 || cmd > r2) {
                if (opts.dense) {
                  if (!cursheet[cmd]) cursheet[cmd] = [];
                  cursheet[cmd][cma] = { t: "z" };
                } else cursheet[encode_col(cma) + encode_row(cmd)] = { t: "z" };
              }
            }
          }
          c3 = cc2 + 1;
        } else ++c3;
      } else {
        cell = xlml_parsexmltagobj(Rn[0]);
        if (cell.Index) c3 = +cell.Index - 1;
        if (c3 < refguess.s.c) refguess.s.c = c3;
        if (c3 > refguess.e.c) refguess.e.c = c3;
        if (Rn[0].slice(-2) === "/>") ++c3;
        comments = [];
      }
      break;
    case "row":
      if (Rn[1] === "/" || Rn[0].slice(-2) === "/>") {
        if (r2 < refguess.s.r) refguess.s.r = r2;
        if (r2 > refguess.e.r) refguess.e.r = r2;
        if (Rn[0].slice(-2) === "/>") {
          row = xlml_parsexmltag(Rn[0]);
          if (row.Index) r2 = +row.Index - 1;
        }
        c3 = 0;
        ++r2;
      } else {
        row = xlml_parsexmltag(Rn[0]);
        if (row.Index) r2 = +row.Index - 1;
        rowobj = {};
        if (row.AutoFitHeight == "0" || row.Height) {
          rowobj.hpx = parseInt(row.Height, 10);
          rowobj.hpt = px2pt(rowobj.hpx);
          rowinfo[r2] = rowobj;
        }
        if (row.Hidden == "1") {
          rowobj.hidden = true;
          rowinfo[r2] = rowobj;
        }
      }
      break;
    case "worksheet":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        sheetnames.push(sheetname);
        if (refguess.s.r <= refguess.e.r && refguess.s.c <= refguess.e.c) {
          cursheet["!ref"] = encode_range(refguess);
          if (opts.sheetRows && opts.sheetRows <= refguess.e.r) {
            cursheet["!fullref"] = cursheet["!ref"];
            refguess.e.r = opts.sheetRows - 1;
            cursheet["!ref"] = encode_range(refguess);
          }
        }
        if (merges.length) cursheet["!merges"] = merges;
        if (cstys.length > 0) cursheet["!cols"] = cstys;
        if (rowinfo.length > 0) cursheet["!rows"] = rowinfo;
        sheets[sheetname] = cursheet;
      } else {
        refguess = { s: { r: 2e6, c: 2e6 }, e: { r: 0, c: 0 } };
        r2 = c3 = 0;
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        sheetname = unescapexml(tmp.Name);
        cursheet = opts.dense ? [] : {};
        merges = [];
        arrayf = [];
        rowinfo = [];
        wsprops = { name: sheetname, Hidden: 0 };
        Workbook.Sheets.push(wsprops);
      }
      break;
    case "table":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].slice(-2) == "/>") break;
      else {
        state.push([Rn[3], false]);
        cstys = [];
        seencol = false;
      }
      break;
    case "style":
      if (Rn[1] === "/") process_style_xlml(styles, stag, opts);
      else stag = xlml_parsexmltag(Rn[0]);
      break;
    case "numberformat":
      stag.nf = unescapexml(xlml_parsexmltag(Rn[0]).Format || "General");
      if (XLMLFormatMap[stag.nf]) stag.nf = XLMLFormatMap[stag.nf];
      for (var ssfidx = 0; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == stag.nf) break;
      if (ssfidx == 392) {
        for (ssfidx = 57; ssfidx != 392; ++ssfidx) if (table_fmt[ssfidx] == null) {
          SSF_load(stag.nf, ssfidx);
          break;
        }
      }
      break;
    case "column":
      if (state[state.length - 1][0] !== /*'Table'*/
      "table") break;
      csty = xlml_parsexmltag(Rn[0]);
      if (csty.Hidden) {
        csty.hidden = true;
        delete csty.Hidden;
      }
      if (csty.Width) csty.wpx = parseInt(csty.Width, 10);
      if (!seencol && csty.wpx > 10) {
        seencol = true;
        MDW = DEF_MDW;
        for (var _col = 0; _col < cstys.length; ++_col) if (cstys[_col]) process_col(cstys[_col]);
      }
      if (seencol) process_col(csty);
      cstys[csty.Index - 1 || cstys.length] = csty;
      for (var i3 = 0; i3 < +csty.Span; ++i3) cstys[cstys.length] = dup(csty);
      break;
    case "namedrange":
      if (Rn[1] === "/") break;
      if (!Workbook.Names) Workbook.Names = [];
      var _NamedRange = parsexmltag(Rn[0]);
      var _DefinedName = {
        Name: _NamedRange.Name,
        Ref: rc_to_a1(_NamedRange.RefersTo.slice(1), { r: 0, c: 0 })
      };
      if (Workbook.Sheets.length > 0) _DefinedName.Sheet = Workbook.Sheets.length - 1;
      Workbook.Names.push(_DefinedName);
      break;
    case "namedcell":
      break;
    case "b":
      break;
    case "i":
      break;
    case "u":
      break;
    case "s":
      break;
    case "em":
      break;
    case "h2":
      break;
    case "h3":
      break;
    case "sub":
      break;
    case "sup":
      break;
    case "span":
      break;
    case "alignment":
      break;
    case "borders":
      break;
    case "border":
      break;
    case "font":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") ss += str.slice(fidx, Rn.index);
      else fidx = Rn.index + Rn[0].length;
      break;
    case "interior":
      if (!opts.cellStyles) break;
      stag.Interior = xlml_parsexmltag(Rn[0]);
      break;
    case "protection":
      break;
    case "author":
    case "title":
    case "description":
    case "created":
    case "keywords":
    case "subject":
    case "category":
    case "company":
    case "lastauthor":
    case "lastsaved":
    case "lastprinted":
    case "version":
    case "revision":
    case "totaltime":
    case "hyperlinkbase":
    case "manager":
    case "contentstatus":
    case "identifier":
    case "language":
    case "appname":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") xlml_set_prop(Props, raw_Rn3, str.slice(pidx, Rn.index));
      else pidx = Rn.index + Rn[0].length;
      break;
    case "paragraphs":
      break;
    case "styles":
    case "workbook":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else state.push([Rn[3], false]);
      break;
    case "comment":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
        xlml_clean_comment(comment);
        comments.push(comment);
      } else {
        state.push([Rn[3], false]);
        tmp = xlml_parsexmltag(Rn[0]);
        comment = { a: tmp.Author };
      }
      break;
    case "autofilter":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        var AutoFilter = xlml_parsexmltag(Rn[0]);
        cursheet["!autofilter"] = { ref: rc_to_a1(AutoFilter.Range).replace(/\$/g, "") };
        state.push([Rn[3], true]);
      }
      break;
    case "name":
      break;
    case "datavalidation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else {
        if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      }
      break;
    case "pixelsperinch":
      break;
    case "componentoptions":
    case "documentproperties":
    case "customdocumentproperties":
    case "officedocumentsettings":
    case "pivottable":
    case "pivotcache":
    case "names":
    case "mapinfo":
    case "pagebreaks":
    case "querytable":
    case "sorting":
    case "schema":
    case "conditionalformatting":
    case "smarttagtype":
    case "smarttags":
    case "excelworkbook":
    case "workbookoptions":
    case "worksheetoptions":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw new Error("Bad state: " + tmp.join("|"));
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "null":
      break;
    default:
      if (state.length == 0 && Rn[3] == "document") return parse_fods(str, opts);
      if (state.length == 0 && Rn[3] == "uof") return parse_fods(str, opts);
      var seen = true;
      switch (state[state.length - 1][0]) {
        case "officedocumentsettings":
          switch (Rn[3]) {
            case "allowpng":
              break;
            case "removepersonalinformation":
              break;
            case "downloadcomponents":
              break;
            case "locationofcomponents":
              break;
            case "colors":
              break;
            case "color":
              break;
            case "index":
              break;
            case "rgb":
              break;
            case "targetscreensize":
              break;
            case "readonlyrecommended":
              break;
            default:
              seen = false;
          }
          break;
        case "componentoptions":
          switch (Rn[3]) {
            case "toolbar":
              break;
            case "hideofficelogo":
              break;
            case "spreadsheetautofit":
              break;
            case "label":
              break;
            case "caption":
              break;
            case "maxheight":
              break;
            case "maxwidth":
              break;
            case "nextsheetnumber":
              break;
            default:
              seen = false;
          }
          break;
        case "excelworkbook":
          switch (Rn[3]) {
            case "date1904":
              Workbook.WBProps.date1904 = true;
              break;
            case "windowheight":
              break;
            case "windowwidth":
              break;
            case "windowtopx":
              break;
            case "windowtopy":
              break;
            case "tabratio":
              break;
            case "protectstructure":
              break;
            case "protectwindow":
              break;
            case "protectwindows":
              break;
            case "activesheet":
              break;
            case "displayinknotes":
              break;
            case "firstvisiblesheet":
              break;
            case "supbook":
              break;
            case "sheetname":
              break;
            case "sheetindex":
              break;
            case "sheetindexfirst":
              break;
            case "sheetindexlast":
              break;
            case "dll":
              break;
            case "acceptlabelsinformulas":
              break;
            case "donotsavelinkvalues":
              break;
            case "iteration":
              break;
            case "maxiterations":
              break;
            case "maxchange":
              break;
            case "path":
              break;
            case "xct":
              break;
            case "count":
              break;
            case "selectedsheets":
              break;
            case "calculation":
              break;
            case "uncalced":
              break;
            case "startupprompt":
              break;
            case "crn":
              break;
            case "externname":
              break;
            case "formula":
              break;
            case "colfirst":
              break;
            case "collast":
              break;
            case "wantadvise":
              break;
            case "boolean":
              break;
            case "error":
              break;
            case "text":
              break;
            case "ole":
              break;
            case "noautorecover":
              break;
            case "publishobjects":
              break;
            case "donotcalculatebeforesave":
              break;
            case "number":
              break;
            case "refmoder1c1":
              break;
            case "embedsavesmarttags":
              break;
            default:
              seen = false;
          }
          break;
        case "workbookoptions":
          switch (Rn[3]) {
            case "owcversion":
              break;
            case "height":
              break;
            case "width":
              break;
            default:
              seen = false;
          }
          break;
        case "worksheetoptions":
          switch (Rn[3]) {
            case "visible":
              if (Rn[0].slice(-2) === "/>") ;
              else if (Rn[1] === "/") switch (str.slice(pidx, Rn.index)) {
                case "SheetHidden":
                  wsprops.Hidden = 1;
                  break;
                case "SheetVeryHidden":
                  wsprops.Hidden = 2;
                  break;
              }
              else pidx = Rn.index + Rn[0].length;
              break;
            case "header":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].header = +parsexmltag(Rn[0]).Margin;
              break;
            case "footer":
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+parsexmltag(Rn[0]).Margin)) cursheet["!margins"].footer = +parsexmltag(Rn[0]).Margin;
              break;
            case "pagemargins":
              var pagemargins = parsexmltag(Rn[0]);
              if (!cursheet["!margins"]) default_margins(cursheet["!margins"] = {}, "xlml");
              if (!isNaN(+pagemargins.Top)) cursheet["!margins"].top = +pagemargins.Top;
              if (!isNaN(+pagemargins.Left)) cursheet["!margins"].left = +pagemargins.Left;
              if (!isNaN(+pagemargins.Right)) cursheet["!margins"].right = +pagemargins.Right;
              if (!isNaN(+pagemargins.Bottom)) cursheet["!margins"].bottom = +pagemargins.Bottom;
              break;
            case "displayrighttoleft":
              if (!Workbook.Views) Workbook.Views = [];
              if (!Workbook.Views[0]) Workbook.Views[0] = {};
              Workbook.Views[0].RTL = true;
              break;
            case "freezepanes":
              break;
            case "frozennosplit":
              break;
            case "splithorizontal":
            case "splitvertical":
              break;
            case "donotdisplaygridlines":
              break;
            case "activerow":
              break;
            case "activecol":
              break;
            case "toprowbottompane":
              break;
            case "leftcolumnrightpane":
              break;
            case "unsynced":
              break;
            case "print":
              break;
            case "printerrors":
              break;
            case "panes":
              break;
            case "scale":
              break;
            case "pane":
              break;
            case "number":
              break;
            case "layout":
              break;
            case "pagesetup":
              break;
            case "selected":
              break;
            case "protectobjects":
              break;
            case "enableselection":
              break;
            case "protectscenarios":
              break;
            case "validprinterinfo":
              break;
            case "horizontalresolution":
              break;
            case "verticalresolution":
              break;
            case "numberofcopies":
              break;
            case "activepane":
              break;
            case "toprowvisible":
              break;
            case "leftcolumnvisible":
              break;
            case "fittopage":
              break;
            case "rangeselection":
              break;
            case "papersizeindex":
              break;
            case "pagelayoutzoom":
              break;
            case "pagebreakzoom":
              break;
            case "filteron":
              break;
            case "fitwidth":
              break;
            case "fitheight":
              break;
            case "commentslayout":
              break;
            case "zoom":
              break;
            case "lefttoright":
              break;
            case "gridlines":
              break;
            case "allowsort":
              break;
            case "allowfilter":
              break;
            case "allowinsertrows":
              break;
            case "allowdeleterows":
              break;
            case "allowinsertcols":
              break;
            case "allowdeletecols":
              break;
            case "allowinserthyperlinks":
              break;
            case "allowformatcells":
              break;
            case "allowsizecols":
              break;
            case "allowsizerows":
              break;
            case "nosummaryrowsbelowdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].above = true;
              break;
            case "tabcolorindex":
              break;
            case "donotdisplayheadings":
              break;
            case "showpagelayoutzoom":
              break;
            case "nosummarycolumnsrightdetail":
              if (!cursheet["!outline"]) cursheet["!outline"] = {};
              cursheet["!outline"].left = true;
              break;
            case "blackandwhite":
              break;
            case "donotdisplayzeros":
              break;
            case "displaypagebreak":
              break;
            case "rowcolheadings":
              break;
            case "donotdisplayoutline":
              break;
            case "noorientation":
              break;
            case "allowusepivottables":
              break;
            case "zeroheight":
              break;
            case "viewablerange":
              break;
            case "selection":
              break;
            case "protectcontents":
              break;
            default:
              seen = false;
          }
          break;
        case "pivottable":
        case "pivotcache":
          switch (Rn[3]) {
            case "immediateitemsondrop":
              break;
            case "showpagemultipleitemlabel":
              break;
            case "compactrowindent":
              break;
            case "location":
              break;
            case "pivotfield":
              break;
            case "orientation":
              break;
            case "layoutform":
              break;
            case "layoutsubtotallocation":
              break;
            case "layoutcompactrow":
              break;
            case "position":
              break;
            case "pivotitem":
              break;
            case "datatype":
              break;
            case "datafield":
              break;
            case "sourcename":
              break;
            case "parentfield":
              break;
            case "ptlineitems":
              break;
            case "ptlineitem":
              break;
            case "countofsameitems":
              break;
            case "item":
              break;
            case "itemtype":
              break;
            case "ptsource":
              break;
            case "cacheindex":
              break;
            case "consolidationreference":
              break;
            case "filename":
              break;
            case "reference":
              break;
            case "nocolumngrand":
              break;
            case "norowgrand":
              break;
            case "blanklineafteritems":
              break;
            case "hidden":
              break;
            case "subtotal":
              break;
            case "basefield":
              break;
            case "mapchilditems":
              break;
            case "function":
              break;
            case "refreshonfileopen":
              break;
            case "printsettitles":
              break;
            case "mergelabels":
              break;
            case "defaultversion":
              break;
            case "refreshname":
              break;
            case "refreshdate":
              break;
            case "refreshdatecopy":
              break;
            case "versionlastrefresh":
              break;
            case "versionlastupdate":
              break;
            case "versionupdateablemin":
              break;
            case "versionrefreshablemin":
              break;
            case "calculation":
              break;
            default:
              seen = false;
          }
          break;
        case "pagebreaks":
          switch (Rn[3]) {
            case "colbreaks":
              break;
            case "colbreak":
              break;
            case "rowbreaks":
              break;
            case "rowbreak":
              break;
            case "colstart":
              break;
            case "colend":
              break;
            case "rowend":
              break;
            default:
              seen = false;
          }
          break;
        case "autofilter":
          switch (Rn[3]) {
            case "autofiltercolumn":
              break;
            case "autofiltercondition":
              break;
            case "autofilterand":
              break;
            case "autofilteror":
              break;
            default:
              seen = false;
          }
          break;
        case "querytable":
          switch (Rn[3]) {
            case "id":
              break;
            case "autoformatfont":
              break;
            case "autoformatpattern":
              break;
            case "querysource":
              break;
            case "querytype":
              break;
            case "enableredirections":
              break;
            case "refreshedinxl9":
              break;
            case "urlstring":
              break;
            case "htmltables":
              break;
            case "connection":
              break;
            case "commandtext":
              break;
            case "refreshinfo":
              break;
            case "notitles":
              break;
            case "nextid":
              break;
            case "columninfo":
              break;
            case "overwritecells":
              break;
            case "donotpromptforfile":
              break;
            case "textwizardsettings":
              break;
            case "source":
              break;
            case "number":
              break;
            case "decimal":
              break;
            case "thousandseparator":
              break;
            case "trailingminusnumbers":
              break;
            case "formatsettings":
              break;
            case "fieldtype":
              break;
            case "delimiters":
              break;
            case "tab":
              break;
            case "comma":
              break;
            case "autoformatname":
              break;
            case "versionlastedit":
              break;
            case "versionlastrefresh":
              break;
            default:
              seen = false;
          }
          break;
        case "datavalidation":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            case "cellrangelist":
              break;
            default:
              seen = false;
          }
          break;
        case "sorting":
        case "conditionalformatting":
          switch (Rn[3]) {
            case "range":
              break;
            case "type":
              break;
            case "min":
              break;
            case "max":
              break;
            case "sort":
              break;
            case "descending":
              break;
            case "order":
              break;
            case "casesensitive":
              break;
            case "value":
              break;
            case "errorstyle":
              break;
            case "errormessage":
              break;
            case "errortitle":
              break;
            case "cellrangelist":
              break;
            case "inputmessage":
              break;
            case "inputtitle":
              break;
            case "combohide":
              break;
            case "inputhide":
              break;
            case "condition":
              break;
            case "qualifier":
              break;
            case "useblank":
              break;
            case "value1":
              break;
            case "value2":
              break;
            case "format":
              break;
            default:
              seen = false;
          }
          break;
        case "mapinfo":
        case "schema":
        case "data":
          switch (Rn[3]) {
            case "map":
              break;
            case "entry":
              break;
            case "range":
              break;
            case "xpath":
              break;
            case "field":
              break;
            case "xsdtype":
              break;
            case "filteron":
              break;
            case "aggregate":
              break;
            case "elementtype":
              break;
            case "attributetype":
              break;
            case "schema":
            case "element":
            case "complextype":
            case "datatype":
            case "all":
            case "attribute":
            case "extends":
              break;
            case "row":
              break;
            default:
              seen = false;
          }
          break;
        case "smarttags":
          break;
        default:
          seen = false;
          break;
      }
      if (seen) break;
      if (Rn[3].match(/!\[CDATA/)) break;
      if (!state[state.length - 1][1]) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
      if (state[state.length - 1][0] === /*'CustomDocumentProperties'*/
      "customdocumentproperties") {
        if (Rn[0].slice(-2) === "/>") break;
        else if (Rn[1] === "/") xlml_set_custprop(Custprops, raw_Rn3, cp, str.slice(pidx, Rn.index));
        else {
          cp = Rn;
          pidx = Rn.index + Rn[0].length;
        }
        break;
      }
      if (opts.WTF) throw "Unrecognized tag: " + Rn[3] + "|" + state.join("|");
  }
  var out = {};
  if (!opts.bookSheets && !opts.bookProps) out.Sheets = sheets;
  out.SheetNames = sheetnames;
  out.Workbook = Workbook;
  out.SSF = dup(table_fmt);
  out.Props = Props;
  out.Custprops = Custprops;
  return out;
}
function parse_xlml(data, opts) {
  fix_read_opts(opts = opts || {});
  switch (opts.type || "base64") {
    case "base64":
      return parse_xlml_xml(Base64_decode(data), opts);
    case "binary":
    case "buffer":
    case "file":
      return parse_xlml_xml(data, opts);
    case "array":
      return parse_xlml_xml(a2s(data), opts);
  }
}
function write_props_xlml(wb2, opts) {
  var o2 = [];
  if (wb2.Props) o2.push(xlml_write_docprops(wb2.Props, opts));
  if (wb2.Custprops) o2.push(xlml_write_custprops(wb2.Props, wb2.Custprops));
  return o2.join("");
}
function write_wb_xlml() {
  return "";
}
function write_sty_xlml(wb2, opts) {
  var styles = ['<Style ss:ID="Default" ss:Name="Normal"><NumberFormat/></Style>'];
  opts.cellXfs.forEach(function(xf2, id2) {
    var payload = [];
    payload.push(writextag("NumberFormat", null, { "ss:Format": escapexml(table_fmt[xf2.numFmtId]) }));
    var o2 = (
      /*::(*/
      { "ss:ID": "s" + (21 + id2) }
    );
    styles.push(writextag("Style", payload.join(""), o2));
  });
  return writextag("Styles", styles.join(""));
}
function write_name_xlml(n2) {
  return writextag("NamedRange", null, { "ss:Name": n2.Name, "ss:RefersTo": "=" + a1_to_rc(n2.Ref, { r: 0, c: 0 }) });
}
function write_names_xlml(wb2) {
  if (!((wb2 || {}).Workbook || {}).Names) return "";
  var names = wb2.Workbook.Names;
  var out = [];
  for (var i3 = 0; i3 < names.length; ++i3) {
    var n2 = names[i3];
    if (n2.Sheet != null) continue;
    if (n2.Name.match(/^_xlfn\./)) continue;
    out.push(write_name_xlml(n2));
  }
  return writextag("Names", out.join(""));
}
function write_ws_xlml_names(ws, opts, idx, wb2) {
  if (!ws) return "";
  if (!((wb2 || {}).Workbook || {}).Names) return "";
  var names = wb2.Workbook.Names;
  var out = [];
  for (var i3 = 0; i3 < names.length; ++i3) {
    var n2 = names[i3];
    if (n2.Sheet != idx) continue;
    if (n2.Name.match(/^_xlfn\./)) continue;
    out.push(write_name_xlml(n2));
  }
  return out.join("");
}
function write_ws_xlml_wsopts(ws, opts, idx, wb2) {
  if (!ws) return "";
  var o2 = [];
  if (ws["!margins"]) {
    o2.push("<PageSetup>");
    if (ws["!margins"].header) o2.push(writextag("Header", null, { "x:Margin": ws["!margins"].header }));
    if (ws["!margins"].footer) o2.push(writextag("Footer", null, { "x:Margin": ws["!margins"].footer }));
    o2.push(writextag("PageMargins", null, {
      "x:Bottom": ws["!margins"].bottom || "0.75",
      "x:Left": ws["!margins"].left || "0.7",
      "x:Right": ws["!margins"].right || "0.7",
      "x:Top": ws["!margins"].top || "0.75"
    }));
    o2.push("</PageSetup>");
  }
  if (wb2 && wb2.Workbook && wb2.Workbook.Sheets && wb2.Workbook.Sheets[idx]) {
    if (wb2.Workbook.Sheets[idx].Hidden) o2.push(writextag("Visible", wb2.Workbook.Sheets[idx].Hidden == 1 ? "SheetHidden" : "SheetVeryHidden", {}));
    else {
      for (var i3 = 0; i3 < idx; ++i3) if (wb2.Workbook.Sheets[i3] && !wb2.Workbook.Sheets[i3].Hidden) break;
      if (i3 == idx) o2.push("<Selected/>");
    }
  }
  if (((((wb2 || {}).Workbook || {}).Views || [])[0] || {}).RTL) o2.push("<DisplayRightToLeft/>");
  if (ws["!protect"]) {
    o2.push(writetag("ProtectContents", "True"));
    if (ws["!protect"].objects) o2.push(writetag("ProtectObjects", "True"));
    if (ws["!protect"].scenarios) o2.push(writetag("ProtectScenarios", "True"));
    if (ws["!protect"].selectLockedCells != null && !ws["!protect"].selectLockedCells) o2.push(writetag("EnableSelection", "NoSelection"));
    else if (ws["!protect"].selectUnlockedCells != null && !ws["!protect"].selectUnlockedCells) o2.push(writetag("EnableSelection", "UnlockedCells"));
    [
      ["formatCells", "AllowFormatCells"],
      ["formatColumns", "AllowSizeCols"],
      ["formatRows", "AllowSizeRows"],
      ["insertColumns", "AllowInsertCols"],
      ["insertRows", "AllowInsertRows"],
      ["insertHyperlinks", "AllowInsertHyperlinks"],
      ["deleteColumns", "AllowDeleteCols"],
      ["deleteRows", "AllowDeleteRows"],
      ["sort", "AllowSort"],
      ["autoFilter", "AllowFilter"],
      ["pivotTables", "AllowUsePivotTables"]
    ].forEach(function(x3) {
      if (ws["!protect"][x3[0]]) o2.push("<" + x3[1] + "/>");
    });
  }
  if (o2.length == 0) return "";
  return writextag("WorksheetOptions", o2.join(""), { xmlns: XLMLNS.x });
}
function write_ws_xlml_comment(comments) {
  return comments.map(function(c3) {
    var t3 = xlml_unfixstr(c3.t || "");
    var d4 = writextag("ss:Data", t3, { "xmlns": "http://www.w3.org/TR/REC-html40" });
    return writextag("Comment", d4, { "ss:Author": c3.a });
  }).join("");
}
function write_ws_xlml_cell(cell, ref, ws, opts, idx, wb2, addr) {
  if (!cell || cell.v == void 0 && cell.f == void 0) return "";
  var attr = {};
  if (cell.f) attr["ss:Formula"] = "=" + escapexml(a1_to_rc(cell.f, addr));
  if (cell.F && cell.F.slice(0, ref.length) == ref) {
    var end = decode_cell(cell.F.slice(ref.length + 1));
    attr["ss:ArrayRange"] = "RC:R" + (end.r == addr.r ? "" : "[" + (end.r - addr.r) + "]") + "C" + (end.c == addr.c ? "" : "[" + (end.c - addr.c) + "]");
  }
  if (cell.l && cell.l.Target) {
    attr["ss:HRef"] = escapexml(cell.l.Target);
    if (cell.l.Tooltip) attr["x:HRefScreenTip"] = escapexml(cell.l.Tooltip);
  }
  if (ws["!merges"]) {
    var marr = ws["!merges"];
    for (var mi2 = 0; mi2 != marr.length; ++mi2) {
      if (marr[mi2].s.c != addr.c || marr[mi2].s.r != addr.r) continue;
      if (marr[mi2].e.c > marr[mi2].s.c) attr["ss:MergeAcross"] = marr[mi2].e.c - marr[mi2].s.c;
      if (marr[mi2].e.r > marr[mi2].s.r) attr["ss:MergeDown"] = marr[mi2].e.r - marr[mi2].s.r;
    }
  }
  var t3 = "", p2 = "";
  switch (cell.t) {
    case "z":
      if (!opts.sheetStubs) return "";
      break;
    case "n":
      t3 = "Number";
      p2 = String(cell.v);
      break;
    case "b":
      t3 = "Boolean";
      p2 = cell.v ? "1" : "0";
      break;
    case "e":
      t3 = "Error";
      p2 = BErr[cell.v];
      break;
    case "d":
      t3 = "DateTime";
      p2 = new Date(cell.v).toISOString();
      if (cell.z == null) cell.z = cell.z || table_fmt[14];
      break;
    case "s":
      t3 = "String";
      p2 = escapexlml(cell.v || "");
      break;
  }
  var os = get_cell_style(opts.cellXfs, cell, opts);
  attr["ss:StyleID"] = "s" + (21 + os);
  attr["ss:Index"] = addr.c + 1;
  var _v = cell.v != null ? p2 : "";
  var m4 = cell.t == "z" ? "" : '<Data ss:Type="' + t3 + '">' + _v + "</Data>";
  if ((cell.c || []).length > 0) m4 += write_ws_xlml_comment(cell.c);
  return writextag("Cell", m4, attr);
}
function write_ws_xlml_row(R3, row) {
  var o2 = '<Row ss:Index="' + (R3 + 1) + '"';
  if (row) {
    if (row.hpt && !row.hpx) row.hpx = pt2px(row.hpt);
    if (row.hpx) o2 += ' ss:AutoFitHeight="0" ss:Height="' + row.hpx + '"';
    if (row.hidden) o2 += ' ss:Hidden="1"';
  }
  return o2 + ">";
}
function write_ws_xlml_table(ws, opts, idx, wb2) {
  if (!ws["!ref"]) return "";
  var range = safe_decode_range(ws["!ref"]);
  var marr = ws["!merges"] || [], mi2 = 0;
  var o2 = [];
  if (ws["!cols"]) ws["!cols"].forEach(function(n2, i3) {
    process_col(n2);
    var w3 = !!n2.width;
    var p2 = col_obj_w(i3, n2);
    var k3 = { "ss:Index": i3 + 1 };
    if (w3) k3["ss:Width"] = width2px(p2.width);
    if (n2.hidden) k3["ss:Hidden"] = "1";
    o2.push(writextag("Column", null, k3));
  });
  var dense = Array.isArray(ws);
  for (var R3 = range.s.r; R3 <= range.e.r; ++R3) {
    var row = [write_ws_xlml_row(R3, (ws["!rows"] || [])[R3])];
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      var skip = false;
      for (mi2 = 0; mi2 != marr.length; ++mi2) {
        if (marr[mi2].s.c > C2) continue;
        if (marr[mi2].s.r > R3) continue;
        if (marr[mi2].e.c < C2) continue;
        if (marr[mi2].e.r < R3) continue;
        if (marr[mi2].s.c != C2 || marr[mi2].s.r != R3) skip = true;
        break;
      }
      if (skip) continue;
      var addr = { r: R3, c: C2 };
      var ref = encode_cell(addr), cell = dense ? (ws[R3] || [])[C2] : ws[ref];
      row.push(write_ws_xlml_cell(cell, ref, ws, opts, idx, wb2, addr));
    }
    row.push("</Row>");
    if (row.length > 2) o2.push(row.join(""));
  }
  return o2.join("");
}
function write_ws_xlml(idx, opts, wb2) {
  var o2 = [];
  var s4 = wb2.SheetNames[idx];
  var ws = wb2.Sheets[s4];
  var t3 = ws ? write_ws_xlml_names(ws, opts, idx, wb2) : "";
  if (t3.length > 0) o2.push("<Names>" + t3 + "</Names>");
  t3 = ws ? write_ws_xlml_table(ws, opts, idx, wb2) : "";
  if (t3.length > 0) o2.push("<Table>" + t3 + "</Table>");
  o2.push(write_ws_xlml_wsopts(ws, opts, idx, wb2));
  return o2.join("");
}
function write_xlml(wb2, opts) {
  if (!opts) opts = {};
  if (!wb2.SSF) wb2.SSF = dup(table_fmt);
  if (wb2.SSF) {
    make_ssf();
    SSF_load_table(wb2.SSF);
    opts.revssf = evert_num(wb2.SSF);
    opts.revssf[wb2.SSF[65535]] = 0;
    opts.ssf = wb2.SSF;
    opts.cellXfs = [];
    get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  }
  var d4 = [];
  d4.push(write_props_xlml(wb2, opts));
  d4.push(write_wb_xlml());
  d4.push("");
  d4.push("");
  for (var i3 = 0; i3 < wb2.SheetNames.length; ++i3)
    d4.push(writextag("Worksheet", write_ws_xlml(i3, opts, wb2), { "ss:Name": escapexml(wb2.SheetNames[i3]) }));
  d4[2] = write_sty_xlml(wb2, opts);
  d4[3] = write_names_xlml(wb2);
  return XML_HEADER + writextag("Workbook", d4.join(""), {
    "xmlns": XLMLNS.ss,
    "xmlns:o": XLMLNS.o,
    "xmlns:x": XLMLNS.x,
    "xmlns:ss": XLMLNS.ss,
    "xmlns:dt": XLMLNS.dt,
    "xmlns:html": XLMLNS.html
  });
}
function parse_compobj(obj) {
  var v2 = {};
  var o2 = obj.content;
  o2.l = 28;
  v2.AnsiUserType = o2.read_shift(0, "lpstr-ansi");
  v2.AnsiClipboardFormat = parse_ClipboardFormatOrAnsiString(o2);
  if (o2.length - o2.l <= 4) return v2;
  var m4 = o2.read_shift(4);
  if (m4 == 0 || m4 > 40) return v2;
  o2.l -= 4;
  v2.Reserved1 = o2.read_shift(0, "lpstr-ansi");
  if (o2.length - o2.l <= 4) return v2;
  m4 = o2.read_shift(4);
  if (m4 !== 1907505652) return v2;
  v2.UnicodeClipboardFormat = parse_ClipboardFormatOrUnicodeString(o2);
  m4 = o2.read_shift(4);
  if (m4 == 0 || m4 > 40) return v2;
  o2.l -= 4;
  v2.Reserved2 = o2.read_shift(0, "lpwstr");
}
var CONTINUE_RT = [60, 1084, 2066, 2165, 2175];
function slurp(RecordType, R3, blob, length, opts) {
  var l2 = length;
  var bufs = [];
  var d4 = blob.slice(blob.l, blob.l + l2);
  if (opts && opts.enc && opts.enc.insitu && d4.length > 0) switch (RecordType) {
    case 9:
    case 521:
    case 1033:
    case 2057:
    case 47:
    case 405:
    case 225:
    case 406:
    case 312:
    case 404:
    case 10:
      break;
    case 133:
      break;
    default:
      opts.enc.insitu(d4);
  }
  bufs.push(d4);
  blob.l += l2;
  var nextrt = __readUInt16LE(blob, blob.l), next = XLSRecordEnum[nextrt];
  var start = 0;
  while (next != null && CONTINUE_RT.indexOf(nextrt) > -1) {
    l2 = __readUInt16LE(blob, blob.l + 2);
    start = blob.l + 4;
    if (nextrt == 2066) start += 4;
    else if (nextrt == 2165 || nextrt == 2175) {
      start += 12;
    }
    d4 = blob.slice(start, blob.l + 4 + l2);
    bufs.push(d4);
    blob.l += 4 + l2;
    next = XLSRecordEnum[nextrt = __readUInt16LE(blob, blob.l)];
  }
  var b2 = bconcat(bufs);
  prep_blob(b2, 0);
  var ll2 = 0;
  b2.lens = [];
  for (var j2 = 0; j2 < bufs.length; ++j2) {
    b2.lens.push(ll2);
    ll2 += bufs[j2].length;
  }
  if (b2.length < length) throw "XLS Record 0x" + RecordType.toString(16) + " Truncated: " + b2.length + " < " + length;
  return R3.f(b2, b2.length, opts);
}
function safe_format_xf(p2, opts, date1904) {
  if (p2.t === "z") return;
  if (!p2.XF) return;
  var fmtid = 0;
  try {
    fmtid = p2.z || p2.XF.numFmtId || 0;
    if (opts.cellNF) p2.z = table_fmt[fmtid];
  } catch (e3) {
    if (opts.WTF) throw e3;
  }
  if (!opts || opts.cellText !== false) try {
    if (p2.t === "e") {
      p2.w = p2.w || BErr[p2.v];
    } else if (fmtid === 0 || fmtid == "General") {
      if (p2.t === "n") {
        if ((p2.v | 0) === p2.v) p2.w = p2.v.toString(10);
        else p2.w = SSF_general_num(p2.v);
      } else p2.w = SSF_general(p2.v);
    } else p2.w = SSF_format(fmtid, p2.v, { date1904: !!date1904, dateNF: opts && opts.dateNF });
  } catch (e3) {
    if (opts.WTF) throw e3;
  }
  if (opts.cellDates && fmtid && p2.t == "n" && fmt_is_date(table_fmt[fmtid] || String(fmtid))) {
    var _d = SSF_parse_date_code(p2.v);
    if (_d) {
      p2.t = "d";
      p2.v = new Date(_d.y, _d.m - 1, _d.d, _d.H, _d.M, _d.S, _d.u);
    }
  }
}
function make_cell(val, ixfe, t3) {
  return { v: val, ixfe, t: t3 };
}
function parse_workbook(blob, options) {
  var wb2 = { opts: {} };
  var Sheets = {};
  var out = options.dense ? [] : {};
  var Directory = {};
  var range = {};
  var last_formula = null;
  var sst = [];
  var cur_sheet = "";
  var Preamble = {};
  var lastcell, last_cell = "", cc2, cmnt, rngC, rngR;
  var sharedf = {};
  var arrayf = [];
  var temp_val;
  var country;
  var XFs = [];
  var palette = [];
  var Workbook = { Sheets: [], WBProps: { date1904: false }, Views: [{}] }, wsprops = {};
  var get_rgb = function getrgb(icv) {
    if (icv < 8) return XLSIcv[icv];
    if (icv < 64) return palette[icv - 8] || XLSIcv[icv];
    return XLSIcv[icv];
  };
  var process_cell_style = function pcs(cell, line, options2) {
    var xfd = line.XF.data;
    if (!xfd || !xfd.patternType || !options2 || !options2.cellStyles) return;
    line.s = {};
    line.s.patternType = xfd.patternType;
    var t3;
    if (t3 = rgb2Hex(get_rgb(xfd.icvFore))) {
      line.s.fgColor = { rgb: t3 };
    }
    if (t3 = rgb2Hex(get_rgb(xfd.icvBack))) {
      line.s.bgColor = { rgb: t3 };
    }
  };
  var addcell = function addcell2(cell, line, options2) {
    if (file_depth > 1) return;
    if (options2.sheetRows && cell.r >= options2.sheetRows) return;
    if (options2.cellStyles && line.XF && line.XF.data) process_cell_style(cell, line, options2);
    delete line.ixfe;
    delete line.XF;
    lastcell = cell;
    last_cell = encode_cell(cell);
    if (!range || !range.s || !range.e) range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
    if (cell.r < range.s.r) range.s.r = cell.r;
    if (cell.c < range.s.c) range.s.c = cell.c;
    if (cell.r + 1 > range.e.r) range.e.r = cell.r + 1;
    if (cell.c + 1 > range.e.c) range.e.c = cell.c + 1;
    if (options2.cellFormula && line.f) {
      for (var afi = 0; afi < arrayf.length; ++afi) {
        if (arrayf[afi][0].s.c > cell.c || arrayf[afi][0].s.r > cell.r) continue;
        if (arrayf[afi][0].e.c < cell.c || arrayf[afi][0].e.r < cell.r) continue;
        line.F = encode_range(arrayf[afi][0]);
        if (arrayf[afi][0].s.c != cell.c || arrayf[afi][0].s.r != cell.r) delete line.f;
        if (line.f) line.f = "" + stringify_formula(arrayf[afi][1], range, cell, supbooks, opts);
        break;
      }
    }
    {
      if (options2.dense) {
        if (!out[cell.r]) out[cell.r] = [];
        out[cell.r][cell.c] = line;
      } else out[last_cell] = line;
    }
  };
  var opts = {
    enc: false,
    // encrypted
    sbcch: 0,
    // cch in the preceding SupBook
    snames: [],
    // sheetnames
    sharedf,
    // shared formulae by address
    arrayf,
    // array formulae array
    rrtabid: [],
    // RRTabId
    lastuser: "",
    // Last User from WriteAccess
    biff: 8,
    // BIFF version
    codepage: 0,
    // CP from CodePage record
    winlocked: 0,
    // fLockWn from WinProtect
    cellStyles: !!options && !!options.cellStyles,
    WTF: !!options && !!options.wtf
  };
  if (options.password) opts.password = options.password;
  var themes;
  var merges = [];
  var objects = [];
  var colinfo = [], rowinfo = [];
  var seencol = false;
  var supbooks = [];
  supbooks.SheetNames = opts.snames;
  supbooks.sharedf = opts.sharedf;
  supbooks.arrayf = opts.arrayf;
  supbooks.names = [];
  supbooks.XTI = [];
  var last_RT = 0;
  var file_depth = 0;
  var BIFF2Fmt = 0, BIFF2FmtTable = [];
  var FilterDatabases = [];
  var last_lbl;
  opts.codepage = 1200;
  set_cp(1200);
  var seen_codepage = false;
  while (blob.l < blob.length - 1) {
    var s4 = blob.l;
    var RecordType = blob.read_shift(2);
    if (RecordType === 0 && last_RT === 10) break;
    var length = blob.l === blob.length ? 0 : blob.read_shift(2);
    var R3 = XLSRecordEnum[RecordType];
    if (R3 && R3.f) {
      if (options.bookSheets) {
        if (last_RT === 133 && RecordType !== 133) break;
      }
      last_RT = RecordType;
      if (R3.r === 2 || R3.r == 12) {
        var rt = blob.read_shift(2);
        length -= 2;
        if (!opts.enc && rt !== RecordType && ((rt & 255) << 8 | rt >> 8) !== RecordType) throw new Error("rt mismatch: " + rt + "!=" + RecordType);
        if (R3.r == 12) {
          blob.l += 10;
          length -= 10;
        }
      }
      var val = {};
      if (RecordType === 10) val = /*::(*/
      R3.f(blob, length, opts);
      else val = /*::(*/
      slurp(RecordType, R3, blob, length, opts);
      if (file_depth == 0 && [9, 521, 1033, 2057].indexOf(last_RT) === -1) continue;
      switch (RecordType) {
        case 34:
          wb2.opts.Date1904 = Workbook.WBProps.date1904 = val;
          break;
        case 134:
          wb2.opts.WriteProtect = true;
          break;
        case 47:
          if (!opts.enc) blob.l = 0;
          opts.enc = val;
          if (!options.password) throw new Error("File is password-protected");
          if (val.valid == null) throw new Error("Encryption scheme unsupported");
          if (!val.valid) throw new Error("Password is incorrect");
          break;
        case 92:
          opts.lastuser = val;
          break;
        case 66:
          var cpval = Number(val);
          switch (cpval) {
            case 21010:
              cpval = 1200;
              break;
            case 32768:
              cpval = 1e4;
              break;
            case 32769:
              cpval = 1252;
              break;
          }
          set_cp(opts.codepage = cpval);
          seen_codepage = true;
          break;
        case 317:
          opts.rrtabid = val;
          break;
        case 25:
          opts.winlocked = val;
          break;
        case 439:
          wb2.opts["RefreshAll"] = val;
          break;
        case 12:
          wb2.opts["CalcCount"] = val;
          break;
        case 16:
          wb2.opts["CalcDelta"] = val;
          break;
        case 17:
          wb2.opts["CalcIter"] = val;
          break;
        case 13:
          wb2.opts["CalcMode"] = val;
          break;
        case 14:
          wb2.opts["CalcPrecision"] = val;
          break;
        case 95:
          wb2.opts["CalcSaveRecalc"] = val;
          break;
        case 15:
          opts.CalcRefMode = val;
          break;
        case 2211:
          wb2.opts.FullCalc = val;
          break;
        case 129:
          if (val.fDialog) out["!type"] = "dialog";
          if (!val.fBelow) (out["!outline"] || (out["!outline"] = {})).above = true;
          if (!val.fRight) (out["!outline"] || (out["!outline"] = {})).left = true;
          break;
        case 224:
          XFs.push(val);
          break;
        case 430:
          supbooks.push([val]);
          supbooks[supbooks.length - 1].XTI = [];
          break;
        case 35:
        case 547:
          supbooks[supbooks.length - 1].push(val);
          break;
        case 24:
        case 536:
          last_lbl = {
            Name: val.Name,
            Ref: stringify_formula(val.rgce, range, null, supbooks, opts)
          };
          if (val.itab > 0) last_lbl.Sheet = val.itab - 1;
          supbooks.names.push(last_lbl);
          if (!supbooks[0]) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].push(val);
          if (val.Name == "_xlnm._FilterDatabase" && val.itab > 0) {
            if (val.rgce && val.rgce[0] && val.rgce[0][0] && val.rgce[0][0][0] == "PtgArea3d")
              FilterDatabases[val.itab - 1] = { ref: encode_range(val.rgce[0][0][1][2]) };
          }
          break;
        case 22:
          opts.ExternCount = val;
          break;
        case 23:
          if (supbooks.length == 0) {
            supbooks[0] = [];
            supbooks[0].XTI = [];
          }
          supbooks[supbooks.length - 1].XTI = supbooks[supbooks.length - 1].XTI.concat(val);
          supbooks.XTI = supbooks.XTI.concat(val);
          break;
        case 2196:
          if (opts.biff < 8) break;
          if (last_lbl != null) last_lbl.Comment = val[1];
          break;
        case 18:
          out["!protect"] = val;
          break;
        case 19:
          if (val !== 0 && opts.WTF) console.error("Password verifier: " + val);
          break;
        case 133:
          {
            Directory[val.pos] = val;
            opts.snames.push(val.name);
          }
          break;
        case 10:
          {
            if (--file_depth) break;
            if (range.e) {
              if (range.e.r > 0 && range.e.c > 0) {
                range.e.r--;
                range.e.c--;
                out["!ref"] = encode_range(range);
                if (options.sheetRows && options.sheetRows <= range.e.r) {
                  var tmpri = range.e.r;
                  range.e.r = options.sheetRows - 1;
                  out["!fullref"] = out["!ref"];
                  out["!ref"] = encode_range(range);
                  range.e.r = tmpri;
                }
                range.e.r++;
                range.e.c++;
              }
              if (merges.length > 0) out["!merges"] = merges;
              if (objects.length > 0) out["!objects"] = objects;
              if (colinfo.length > 0) out["!cols"] = colinfo;
              if (rowinfo.length > 0) out["!rows"] = rowinfo;
              Workbook.Sheets.push(wsprops);
            }
            if (cur_sheet === "") Preamble = out;
            else Sheets[cur_sheet] = out;
            out = options.dense ? [] : {};
          }
          break;
        case 9:
        case 521:
        case 1033:
        case 2057:
          {
            if (opts.biff === 8) opts.biff = {
              /*::[*/
              9: 2,
              /*::[*/
              521: 3,
              /*::[*/
              1033: 4
            }[RecordType] || {
              /*::[*/
              512: 2,
              /*::[*/
              768: 3,
              /*::[*/
              1024: 4,
              /*::[*/
              1280: 5,
              /*::[*/
              1536: 8,
              /*::[*/
              2: 2,
              /*::[*/
              7: 2
            }[val.BIFFVer] || 8;
            opts.biffguess = val.BIFFVer == 0;
            if (val.BIFFVer == 0 && val.dt == 4096) {
              opts.biff = 5;
              seen_codepage = true;
              set_cp(opts.codepage = 28591);
            }
            if (opts.biff == 8 && val.BIFFVer == 0 && val.dt == 16) opts.biff = 2;
            if (file_depth++) break;
            out = options.dense ? [] : {};
            if (opts.biff < 8 && !seen_codepage) {
              seen_codepage = true;
              set_cp(opts.codepage = options.codepage || 1252);
            }
            if (opts.biff < 5 || val.BIFFVer == 0 && val.dt == 4096) {
              if (cur_sheet === "") cur_sheet = "Sheet1";
              range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
              var fakebs8 = { pos: blob.l - length, name: cur_sheet };
              Directory[fakebs8.pos] = fakebs8;
              opts.snames.push(cur_sheet);
            } else cur_sheet = (Directory[s4] || { name: "" }).name;
            if (val.dt == 32) out["!type"] = "chart";
            if (val.dt == 64) out["!type"] = "macro";
            merges = [];
            objects = [];
            opts.arrayf = arrayf = [];
            colinfo = [];
            rowinfo = [];
            seencol = false;
            wsprops = { Hidden: (Directory[s4] || { hs: 0 }).hs, name: cur_sheet };
          }
          break;
        case 515:
        case 3:
        case 2:
          {
            if (out["!type"] == "chart") {
              if (options.dense ? (out[val.r] || [])[val.c] : out[encode_cell({ c: val.c, r: val.r })]) ++val.c;
            }
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe] || {}, v: val.val, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb2.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 5:
        case 517:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.val, t: val.t };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb2.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 638:
          {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], v: val.rknum, t: "n" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb2.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 189:
          {
            for (var j2 = val.c; j2 <= val.C; ++j2) {
              var ixfe = val.rkrec[j2 - val.c][0];
              temp_val = { ixfe, XF: XFs[ixfe], v: val.rkrec[j2 - val.c][1], t: "n" };
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb2.opts.Date1904);
              addcell({ c: j2, r: val.r }, temp_val, options);
            }
          }
          break;
        case 6:
        case 518:
        case 1030:
          {
            if (val.val == "String") {
              last_formula = val;
              break;
            }
            temp_val = make_cell(val.val, val.cell.ixfe, val.tt);
            temp_val.XF = XFs[temp_val.ixfe];
            if (options.cellFormula) {
              var _f = val.formula;
              if (_f && _f[0] && _f[0][0] && _f[0][0][0] == "PtgExp") {
                var _fr = _f[0][0][1][0], _fc = _f[0][0][1][1];
                var _fe = encode_cell({ r: _fr, c: _fc });
                if (sharedf[_fe]) temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
                else temp_val.F = ((options.dense ? (out[_fr] || [])[_fc] : out[_fe]) || {}).F;
              } else temp_val.f = "" + stringify_formula(val.formula, range, val.cell, supbooks, opts);
            }
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb2.opts.Date1904);
            addcell(val.cell, temp_val, options);
            last_formula = val;
          }
          break;
        case 7:
        case 519:
          {
            if (last_formula) {
              last_formula.val = val;
              temp_val = make_cell(val, last_formula.cell.ixfe, "s");
              temp_val.XF = XFs[temp_val.ixfe];
              if (options.cellFormula) {
                temp_val.f = "" + stringify_formula(last_formula.formula, range, last_formula.cell, supbooks, opts);
              }
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb2.opts.Date1904);
              addcell(last_formula.cell, temp_val, options);
              last_formula = null;
            } else throw new Error("String record expects Formula");
          }
          break;
        case 33:
        case 545:
          {
            arrayf.push(val);
            var _arraystart = encode_cell(val[0].s);
            cc2 = options.dense ? (out[val[0].s.r] || [])[val[0].s.c] : out[_arraystart];
            if (options.cellFormula && cc2) {
              if (!last_formula) break;
              if (!_arraystart || !cc2) break;
              cc2.f = "" + stringify_formula(val[1], range, val[0], supbooks, opts);
              cc2.F = encode_range(val[0]);
            }
          }
          break;
        case 1212:
          {
            if (!options.cellFormula) break;
            if (last_cell) {
              if (!last_formula) break;
              sharedf[encode_cell(last_formula.cell)] = val[0];
              cc2 = options.dense ? (out[last_formula.cell.r] || [])[last_formula.cell.c] : out[encode_cell(last_formula.cell)];
              (cc2 || {}).f = "" + stringify_formula(val[0], range, lastcell, supbooks, opts);
            }
          }
          break;
        case 253:
          temp_val = make_cell(sst[val.isst].t, val.ixfe, "s");
          if (sst[val.isst].h) temp_val.h = sst[val.isst].h;
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb2.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 513:
          if (options.sheetStubs) {
            temp_val = { ixfe: val.ixfe, XF: XFs[val.ixfe], t: "z" };
            if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
            safe_format_xf(temp_val, options, wb2.opts.Date1904);
            addcell({ c: val.c, r: val.r }, temp_val, options);
          }
          break;
        case 190:
          if (options.sheetStubs) {
            for (var _j = val.c; _j <= val.C; ++_j) {
              var _ixfe = val.ixfe[_j - val.c];
              temp_val = { ixfe: _ixfe, XF: XFs[_ixfe], t: "z" };
              if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
              safe_format_xf(temp_val, options, wb2.opts.Date1904);
              addcell({ c: _j, r: val.r }, temp_val, options);
            }
          }
          break;
        case 214:
        case 516:
        case 4:
          temp_val = make_cell(val.val, val.ixfe, "s");
          temp_val.XF = XFs[temp_val.ixfe];
          if (BIFF2Fmt > 0) temp_val.z = BIFF2FmtTable[temp_val.ixfe >> 8 & 63];
          safe_format_xf(temp_val, options, wb2.opts.Date1904);
          addcell({ c: val.c, r: val.r }, temp_val, options);
          break;
        case 0:
        case 512:
          {
            if (file_depth === 1) range = val;
          }
          break;
        case 252:
          {
            sst = val;
          }
          break;
        case 1054:
          {
            if (opts.biff == 4) {
              BIFF2FmtTable[BIFF2Fmt++] = val[1];
              for (var b4idx = 0; b4idx < BIFF2Fmt + 163; ++b4idx) if (table_fmt[b4idx] == val[1]) break;
              if (b4idx >= 163) SSF_load(val[1], BIFF2Fmt + 163);
            } else SSF_load(val[1], val[0]);
          }
          break;
        case 30:
          {
            BIFF2FmtTable[BIFF2Fmt++] = val;
            for (var b2idx = 0; b2idx < BIFF2Fmt + 163; ++b2idx) if (table_fmt[b2idx] == val) break;
            if (b2idx >= 163) SSF_load(val, BIFF2Fmt + 163);
          }
          break;
        case 229:
          merges = merges.concat(val);
          break;
        case 93:
          objects[val.cmo[0]] = opts.lastobj = val;
          break;
        case 438:
          opts.lastobj.TxO = val;
          break;
        case 127:
          opts.lastobj.ImData = val;
          break;
        case 440:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc2 = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc2) cc2.l = val[1];
              }
          }
          break;
        case 2048:
          {
            for (rngR = val[0].s.r; rngR <= val[0].e.r; ++rngR)
              for (rngC = val[0].s.c; rngC <= val[0].e.c; ++rngC) {
                cc2 = options.dense ? (out[rngR] || [])[rngC] : out[encode_cell({ c: rngC, r: rngR })];
                if (cc2 && cc2.l) cc2.l.Tooltip = val[1];
              }
          }
          break;
        case 28:
          {
            if (opts.biff <= 5 && opts.biff >= 2) break;
            cc2 = options.dense ? (out[val[0].r] || [])[val[0].c] : out[encode_cell(val[0])];
            var noteobj = objects[val[2]];
            if (!cc2) {
              if (options.dense) {
                if (!out[val[0].r]) out[val[0].r] = [];
                cc2 = out[val[0].r][val[0].c] = { t: "z" };
              } else {
                cc2 = out[encode_cell(val[0])] = { t: "z" };
              }
              range.e.r = Math.max(range.e.r, val[0].r);
              range.s.r = Math.min(range.s.r, val[0].r);
              range.e.c = Math.max(range.e.c, val[0].c);
              range.s.c = Math.min(range.s.c, val[0].c);
            }
            if (!cc2.c) cc2.c = [];
            cmnt = { a: val[1], t: noteobj.TxO.t };
            cc2.c.push(cmnt);
          }
          break;
        case 2173:
          update_xfext(XFs[val.ixfe], val.ext);
          break;
        case 125:
          {
            if (!opts.cellStyles) break;
            while (val.e >= val.s) {
              colinfo[val.e--] = { width: val.w / 256, level: val.level || 0, hidden: !!(val.flags & 1) };
              if (!seencol) {
                seencol = true;
                find_mdw_colw(val.w / 256);
              }
              process_col(colinfo[val.e + 1]);
            }
          }
          break;
        case 520:
          {
            var rowobj = {};
            if (val.level != null) {
              rowinfo[val.r] = rowobj;
              rowobj.level = val.level;
            }
            if (val.hidden) {
              rowinfo[val.r] = rowobj;
              rowobj.hidden = true;
            }
            if (val.hpt) {
              rowinfo[val.r] = rowobj;
              rowobj.hpt = val.hpt;
              rowobj.hpx = pt2px(val.hpt);
            }
          }
          break;
        case 38:
        case 39:
        case 40:
        case 41:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"][{ 38: "left", 39: "right", 40: "top", 41: "bottom" }[RecordType]] = val;
          break;
        case 161:
          if (!out["!margins"]) default_margins(out["!margins"] = {});
          out["!margins"].header = val.header;
          out["!margins"].footer = val.footer;
          break;
        case 574:
          if (val.RTL) Workbook.Views[0].RTL = true;
          break;
        case 146:
          palette = val;
          break;
        case 2198:
          themes = val;
          break;
        case 140:
          country = val;
          break;
        case 442:
          {
            if (!cur_sheet) Workbook.WBProps.CodeName = val || "ThisWorkbook";
            else wsprops.CodeName = val || wsprops.name;
          }
          break;
      }
    } else {
      if (!R3) console.error("Missing Info for XLS Record 0x" + RecordType.toString(16));
      blob.l += length;
    }
  }
  wb2.SheetNames = keys(Directory).sort(function(a4, b2) {
    return Number(a4) - Number(b2);
  }).map(function(x3) {
    return Directory[x3].name;
  });
  if (!options.bookSheets) wb2.Sheets = Sheets;
  if (!wb2.SheetNames.length && Preamble["!ref"]) {
    wb2.SheetNames.push("Sheet1");
    if (wb2.Sheets) wb2.Sheets["Sheet1"] = Preamble;
  } else wb2.Preamble = Preamble;
  if (wb2.Sheets) FilterDatabases.forEach(function(r2, i3) {
    wb2.Sheets[wb2.SheetNames[i3]]["!autofilter"] = r2;
  });
  wb2.Strings = sst;
  wb2.SSF = dup(table_fmt);
  if (opts.enc) wb2.Encryption = opts.enc;
  if (themes) wb2.Themes = themes;
  wb2.Metadata = {};
  if (country !== void 0) wb2.Metadata.Country = country;
  if (supbooks.names.length > 0) Workbook.Names = supbooks.names;
  wb2.Workbook = Workbook;
  return wb2;
}
var PSCLSID = {
  SI: "e0859ff2f94f6810ab9108002b27b3d9",
  DSI: "02d5cdd59c2e1b10939708002b2cf9ae",
  UDI: "05d5cdd59c2e1b10939708002b2cf9ae"
};
function parse_xls_props(cfb, props, o2) {
  var DSI = CFB.find(cfb, "/!DocumentSummaryInformation");
  if (DSI && DSI.size > 0) try {
    var DocSummary = parse_PropertySetStream(DSI, DocSummaryPIDDSI, PSCLSID.DSI);
    for (var d4 in DocSummary) props[d4] = DocSummary[d4];
  } catch (e3) {
    if (o2.WTF) throw e3;
  }
  var SI = CFB.find(cfb, "/!SummaryInformation");
  if (SI && SI.size > 0) try {
    var Summary = parse_PropertySetStream(SI, SummaryPIDSI, PSCLSID.SI);
    for (var s4 in Summary) if (props[s4] == null) props[s4] = Summary[s4];
  } catch (e3) {
    if (o2.WTF) throw e3;
  }
  if (props.HeadingPairs && props.TitlesOfParts) {
    load_props_pairs(props.HeadingPairs, props.TitlesOfParts, props, o2);
    delete props.HeadingPairs;
    delete props.TitlesOfParts;
  }
}
function write_xls_props(wb2, cfb) {
  var DSEntries = [], SEntries = [], CEntries = [];
  var i3 = 0, Keys;
  var DocSummaryRE = evert_key(DocSummaryPIDDSI, "n");
  var SummaryRE = evert_key(SummaryPIDSI, "n");
  if (wb2.Props) {
    Keys = keys(wb2.Props);
    for (i3 = 0; i3 < Keys.length; ++i3) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i3]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i3]) ? SEntries : CEntries).push([Keys[i3], wb2.Props[Keys[i3]]]);
  }
  if (wb2.Custprops) {
    Keys = keys(wb2.Custprops);
    for (i3 = 0; i3 < Keys.length; ++i3) if (!Object.prototype.hasOwnProperty.call(wb2.Props || {}, Keys[i3])) (Object.prototype.hasOwnProperty.call(DocSummaryRE, Keys[i3]) ? DSEntries : Object.prototype.hasOwnProperty.call(SummaryRE, Keys[i3]) ? SEntries : CEntries).push([Keys[i3], wb2.Custprops[Keys[i3]]]);
  }
  var CEntries2 = [];
  for (i3 = 0; i3 < CEntries.length; ++i3) {
    if (XLSPSSkip.indexOf(CEntries[i3][0]) > -1 || PseudoPropsPairs.indexOf(CEntries[i3][0]) > -1) continue;
    if (CEntries[i3][1] == null) continue;
    CEntries2.push(CEntries[i3]);
  }
  if (SEntries.length) CFB.utils.cfb_add(cfb, "/SummaryInformation", write_PropertySetStream(SEntries, PSCLSID.SI, SummaryRE, SummaryPIDSI));
  if (DSEntries.length || CEntries2.length) CFB.utils.cfb_add(cfb, "/DocumentSummaryInformation", write_PropertySetStream(DSEntries, PSCLSID.DSI, DocSummaryRE, DocSummaryPIDDSI, CEntries2.length ? CEntries2 : null, PSCLSID.UDI));
}
function parse_xlscfb(cfb, options) {
  if (!options) options = {};
  fix_read_opts(options);
  reset_cp();
  if (options.codepage) set_ansi(options.codepage);
  var CompObj, WB;
  if (cfb.FullPaths) {
    if (CFB.find(cfb, "/encryption")) throw new Error("File is password-protected");
    CompObj = CFB.find(cfb, "!CompObj");
    WB = CFB.find(cfb, "/Workbook") || CFB.find(cfb, "/Book");
  } else {
    switch (options.type) {
      case "base64":
        cfb = s2a(Base64_decode(cfb));
        break;
      case "binary":
        cfb = s2a(cfb);
        break;
      case "buffer":
        break;
      case "array":
        if (!Array.isArray(cfb)) cfb = Array.prototype.slice.call(cfb);
        break;
    }
    prep_blob(cfb, 0);
    WB = { content: cfb };
  }
  var WorkbookP;
  var _data;
  if (CompObj) parse_compobj(CompObj);
  if (options.bookProps && !options.bookSheets) WorkbookP = {};
  else {
    var T3 = has_buf ? "buffer" : "array";
    if (WB && WB.content) WorkbookP = parse_workbook(WB.content, options);
    else if ((_data = CFB.find(cfb, "PerfectOffice_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T3, options));
    else if ((_data = CFB.find(cfb, "NativeContent_MAIN")) && _data.content) WorkbookP = WK_.to_workbook(_data.content, (options.type = T3, options));
    else if ((_data = CFB.find(cfb, "MN0")) && _data.content) throw new Error("Unsupported Works 4 for Mac file");
    else throw new Error("Cannot find Workbook stream");
    if (options.bookVBA && cfb.FullPaths && CFB.find(cfb, "/_VBA_PROJECT_CUR/VBA/dir")) WorkbookP.vbaraw = make_vba_xls(cfb);
  }
  var props = {};
  if (cfb.FullPaths) parse_xls_props(
    /*::((*/
    cfb,
    props,
    options
  );
  WorkbookP.Props = WorkbookP.Custprops = props;
  if (options.bookFiles) WorkbookP.cfb = cfb;
  return WorkbookP;
}
function write_xlscfb(wb2, opts) {
  var o2 = opts || {};
  var cfb = CFB.utils.cfb_new({ root: "R" });
  var wbpath = "/Workbook";
  switch (o2.bookType || "xls") {
    case "xls":
      o2.bookType = "biff8";
    case "xla":
      if (!o2.bookType) o2.bookType = "xla";
    case "biff8":
      wbpath = "/Workbook";
      o2.biff = 8;
      break;
    case "biff5":
      wbpath = "/Book";
      o2.biff = 5;
      break;
    default:
      throw new Error("invalid type " + o2.bookType + " for XLS CFB");
  }
  CFB.utils.cfb_add(cfb, wbpath, write_biff_buf(wb2, o2));
  if (o2.biff == 8 && (wb2.Props || wb2.Custprops)) write_xls_props(wb2, cfb);
  if (o2.biff == 8 && wb2.vbaraw) fill_vba_xls(cfb, CFB.read(wb2.vbaraw, { type: typeof wb2.vbaraw == "string" ? "binary" : "buffer" }));
  return cfb;
}
var XLSBRecordEnum = {
  /*::[*/
  0: {
    /* n:"BrtRowHdr", */
    f: parse_BrtRowHdr
  },
  /*::[*/
  1: {
    /* n:"BrtCellBlank", */
    f: parse_BrtCellBlank
  },
  /*::[*/
  2: {
    /* n:"BrtCellRk", */
    f: parse_BrtCellRk
  },
  /*::[*/
  3: {
    /* n:"BrtCellError", */
    f: parse_BrtCellError
  },
  /*::[*/
  4: {
    /* n:"BrtCellBool", */
    f: parse_BrtCellBool
  },
  /*::[*/
  5: {
    /* n:"BrtCellReal", */
    f: parse_BrtCellReal
  },
  /*::[*/
  6: {
    /* n:"BrtCellSt", */
    f: parse_BrtCellSt
  },
  /*::[*/
  7: {
    /* n:"BrtCellIsst", */
    f: parse_BrtCellIsst
  },
  /*::[*/
  8: {
    /* n:"BrtFmlaString", */
    f: parse_BrtFmlaString
  },
  /*::[*/
  9: {
    /* n:"BrtFmlaNum", */
    f: parse_BrtFmlaNum
  },
  /*::[*/
  10: {
    /* n:"BrtFmlaBool", */
    f: parse_BrtFmlaBool
  },
  /*::[*/
  11: {
    /* n:"BrtFmlaError", */
    f: parse_BrtFmlaError
  },
  /*::[*/
  12: {
    /* n:"BrtShortBlank", */
    f: parse_BrtShortBlank
  },
  /*::[*/
  13: {
    /* n:"BrtShortRk", */
    f: parse_BrtShortRk
  },
  /*::[*/
  14: {
    /* n:"BrtShortError", */
    f: parse_BrtShortError
  },
  /*::[*/
  15: {
    /* n:"BrtShortBool", */
    f: parse_BrtShortBool
  },
  /*::[*/
  16: {
    /* n:"BrtShortReal", */
    f: parse_BrtShortReal
  },
  /*::[*/
  17: {
    /* n:"BrtShortSt", */
    f: parse_BrtShortSt
  },
  /*::[*/
  18: {
    /* n:"BrtShortIsst", */
    f: parse_BrtShortIsst
  },
  /*::[*/
  19: {
    /* n:"BrtSSTItem", */
    f: parse_RichStr
  },
  /*::[*/
  20: {
    /* n:"BrtPCDIMissing" */
  },
  /*::[*/
  21: {
    /* n:"BrtPCDINumber" */
  },
  /*::[*/
  22: {
    /* n:"BrtPCDIBoolean" */
  },
  /*::[*/
  23: {
    /* n:"BrtPCDIError" */
  },
  /*::[*/
  24: {
    /* n:"BrtPCDIString" */
  },
  /*::[*/
  25: {
    /* n:"BrtPCDIDatetime" */
  },
  /*::[*/
  26: {
    /* n:"BrtPCDIIndex" */
  },
  /*::[*/
  27: {
    /* n:"BrtPCDIAMissing" */
  },
  /*::[*/
  28: {
    /* n:"BrtPCDIANumber" */
  },
  /*::[*/
  29: {
    /* n:"BrtPCDIABoolean" */
  },
  /*::[*/
  30: {
    /* n:"BrtPCDIAError" */
  },
  /*::[*/
  31: {
    /* n:"BrtPCDIAString" */
  },
  /*::[*/
  32: {
    /* n:"BrtPCDIADatetime" */
  },
  /*::[*/
  33: {
    /* n:"BrtPCRRecord" */
  },
  /*::[*/
  34: {
    /* n:"BrtPCRRecordDt" */
  },
  /*::[*/
  35: {
    /* n:"BrtFRTBegin", */
    T: 1
  },
  /*::[*/
  36: {
    /* n:"BrtFRTEnd", */
    T: -1
  },
  /*::[*/
  37: {
    /* n:"BrtACBegin", */
    T: 1
  },
  /*::[*/
  38: {
    /* n:"BrtACEnd", */
    T: -1
  },
  /*::[*/
  39: {
    /* n:"BrtName", */
    f: parse_BrtName
  },
  /*::[*/
  40: {
    /* n:"BrtIndexRowBlock" */
  },
  /*::[*/
  42: {
    /* n:"BrtIndexBlock" */
  },
  /*::[*/
  43: {
    /* n:"BrtFont", */
    f: parse_BrtFont
  },
  /*::[*/
  44: {
    /* n:"BrtFmt", */
    f: parse_BrtFmt
  },
  /*::[*/
  45: {
    /* n:"BrtFill", */
    f: parse_BrtFill
  },
  /*::[*/
  46: {
    /* n:"BrtBorder", */
    f: parse_BrtBorder
  },
  /*::[*/
  47: {
    /* n:"BrtXF", */
    f: parse_BrtXF
  },
  /*::[*/
  48: {
    /* n:"BrtStyle" */
  },
  /*::[*/
  49: {
    /* n:"BrtCellMeta", */
    f: parse_Int32LE
  },
  /*::[*/
  50: {
    /* n:"BrtValueMeta" */
  },
  /*::[*/
  51: {
    /* n:"BrtMdb" */
    f: parse_BrtMdb
  },
  /*::[*/
  52: {
    /* n:"BrtBeginFmd", */
    T: 1
  },
  /*::[*/
  53: {
    /* n:"BrtEndFmd", */
    T: -1
  },
  /*::[*/
  54: {
    /* n:"BrtBeginMdx", */
    T: 1
  },
  /*::[*/
  55: {
    /* n:"BrtEndMdx", */
    T: -1
  },
  /*::[*/
  56: {
    /* n:"BrtBeginMdxTuple", */
    T: 1
  },
  /*::[*/
  57: {
    /* n:"BrtEndMdxTuple", */
    T: -1
  },
  /*::[*/
  58: {
    /* n:"BrtMdxMbrIstr" */
  },
  /*::[*/
  59: {
    /* n:"BrtStr" */
  },
  /*::[*/
  60: {
    /* n:"BrtColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  62: {
    /* n:"BrtCellRString", */
    f: parse_BrtCellRString
  },
  /*::[*/
  63: {
    /* n:"BrtCalcChainItem$", */
    f: parse_BrtCalcChainItem$
  },
  /*::[*/
  64: {
    /* n:"BrtDVal", */
    f: parse_BrtDVal
  },
  /*::[*/
  65: {
    /* n:"BrtSxvcellNum" */
  },
  /*::[*/
  66: {
    /* n:"BrtSxvcellStr" */
  },
  /*::[*/
  67: {
    /* n:"BrtSxvcellBool" */
  },
  /*::[*/
  68: {
    /* n:"BrtSxvcellErr" */
  },
  /*::[*/
  69: {
    /* n:"BrtSxvcellDate" */
  },
  /*::[*/
  70: {
    /* n:"BrtSxvcellNil" */
  },
  /*::[*/
  128: {
    /* n:"BrtFileVersion" */
  },
  /*::[*/
  129: {
    /* n:"BrtBeginSheet", */
    T: 1
  },
  /*::[*/
  130: {
    /* n:"BrtEndSheet", */
    T: -1
  },
  /*::[*/
  131: {
    /* n:"BrtBeginBook", */
    T: 1,
    f: parsenoop,
    p: 0
  },
  /*::[*/
  132: {
    /* n:"BrtEndBook", */
    T: -1
  },
  /*::[*/
  133: {
    /* n:"BrtBeginWsViews", */
    T: 1
  },
  /*::[*/
  134: {
    /* n:"BrtEndWsViews", */
    T: -1
  },
  /*::[*/
  135: {
    /* n:"BrtBeginBookViews", */
    T: 1
  },
  /*::[*/
  136: {
    /* n:"BrtEndBookViews", */
    T: -1
  },
  /*::[*/
  137: {
    /* n:"BrtBeginWsView", */
    T: 1,
    f: parse_BrtBeginWsView
  },
  /*::[*/
  138: {
    /* n:"BrtEndWsView", */
    T: -1
  },
  /*::[*/
  139: {
    /* n:"BrtBeginCsViews", */
    T: 1
  },
  /*::[*/
  140: {
    /* n:"BrtEndCsViews", */
    T: -1
  },
  /*::[*/
  141: {
    /* n:"BrtBeginCsView", */
    T: 1
  },
  /*::[*/
  142: {
    /* n:"BrtEndCsView", */
    T: -1
  },
  /*::[*/
  143: {
    /* n:"BrtBeginBundleShs", */
    T: 1
  },
  /*::[*/
  144: {
    /* n:"BrtEndBundleShs", */
    T: -1
  },
  /*::[*/
  145: {
    /* n:"BrtBeginSheetData", */
    T: 1
  },
  /*::[*/
  146: {
    /* n:"BrtEndSheetData", */
    T: -1
  },
  /*::[*/
  147: {
    /* n:"BrtWsProp", */
    f: parse_BrtWsProp
  },
  /*::[*/
  148: {
    /* n:"BrtWsDim", */
    f: parse_BrtWsDim,
    p: 16
  },
  /*::[*/
  151: {
    /* n:"BrtPane", */
    f: parse_BrtPane
  },
  /*::[*/
  152: {
    /* n:"BrtSel" */
  },
  /*::[*/
  153: {
    /* n:"BrtWbProp", */
    f: parse_BrtWbProp
  },
  /*::[*/
  154: {
    /* n:"BrtWbFactoid" */
  },
  /*::[*/
  155: {
    /* n:"BrtFileRecover" */
  },
  /*::[*/
  156: {
    /* n:"BrtBundleSh", */
    f: parse_BrtBundleSh
  },
  /*::[*/
  157: {
    /* n:"BrtCalcProp" */
  },
  /*::[*/
  158: {
    /* n:"BrtBookView" */
  },
  /*::[*/
  159: {
    /* n:"BrtBeginSst", */
    T: 1,
    f: parse_BrtBeginSst
  },
  /*::[*/
  160: {
    /* n:"BrtEndSst", */
    T: -1
  },
  /*::[*/
  161: {
    /* n:"BrtBeginAFilter", */
    T: 1,
    f: parse_UncheckedRfX
  },
  /*::[*/
  162: {
    /* n:"BrtEndAFilter", */
    T: -1
  },
  /*::[*/
  163: {
    /* n:"BrtBeginFilterColumn", */
    T: 1
  },
  /*::[*/
  164: {
    /* n:"BrtEndFilterColumn", */
    T: -1
  },
  /*::[*/
  165: {
    /* n:"BrtBeginFilters", */
    T: 1
  },
  /*::[*/
  166: {
    /* n:"BrtEndFilters", */
    T: -1
  },
  /*::[*/
  167: {
    /* n:"BrtFilter" */
  },
  /*::[*/
  168: {
    /* n:"BrtColorFilter" */
  },
  /*::[*/
  169: {
    /* n:"BrtIconFilter" */
  },
  /*::[*/
  170: {
    /* n:"BrtTop10Filter" */
  },
  /*::[*/
  171: {
    /* n:"BrtDynamicFilter" */
  },
  /*::[*/
  172: {
    /* n:"BrtBeginCustomFilters", */
    T: 1
  },
  /*::[*/
  173: {
    /* n:"BrtEndCustomFilters", */
    T: -1
  },
  /*::[*/
  174: {
    /* n:"BrtCustomFilter" */
  },
  /*::[*/
  175: {
    /* n:"BrtAFilterDateGroupItem" */
  },
  /*::[*/
  176: {
    /* n:"BrtMergeCell", */
    f: parse_BrtMergeCell
  },
  /*::[*/
  177: {
    /* n:"BrtBeginMergeCells", */
    T: 1
  },
  /*::[*/
  178: {
    /* n:"BrtEndMergeCells", */
    T: -1
  },
  /*::[*/
  179: {
    /* n:"BrtBeginPivotCacheDef", */
    T: 1
  },
  /*::[*/
  180: {
    /* n:"BrtEndPivotCacheDef", */
    T: -1
  },
  /*::[*/
  181: {
    /* n:"BrtBeginPCDFields", */
    T: 1
  },
  /*::[*/
  182: {
    /* n:"BrtEndPCDFields", */
    T: -1
  },
  /*::[*/
  183: {
    /* n:"BrtBeginPCDField", */
    T: 1
  },
  /*::[*/
  184: {
    /* n:"BrtEndPCDField", */
    T: -1
  },
  /*::[*/
  185: {
    /* n:"BrtBeginPCDSource", */
    T: 1
  },
  /*::[*/
  186: {
    /* n:"BrtEndPCDSource", */
    T: -1
  },
  /*::[*/
  187: {
    /* n:"BrtBeginPCDSRange", */
    T: 1
  },
  /*::[*/
  188: {
    /* n:"BrtEndPCDSRange", */
    T: -1
  },
  /*::[*/
  189: {
    /* n:"BrtBeginPCDFAtbl", */
    T: 1
  },
  /*::[*/
  190: {
    /* n:"BrtEndPCDFAtbl", */
    T: -1
  },
  /*::[*/
  191: {
    /* n:"BrtBeginPCDIRun", */
    T: 1
  },
  /*::[*/
  192: {
    /* n:"BrtEndPCDIRun", */
    T: -1
  },
  /*::[*/
  193: {
    /* n:"BrtBeginPivotCacheRecords", */
    T: 1
  },
  /*::[*/
  194: {
    /* n:"BrtEndPivotCacheRecords", */
    T: -1
  },
  /*::[*/
  195: {
    /* n:"BrtBeginPCDHierarchies", */
    T: 1
  },
  /*::[*/
  196: {
    /* n:"BrtEndPCDHierarchies", */
    T: -1
  },
  /*::[*/
  197: {
    /* n:"BrtBeginPCDHierarchy", */
    T: 1
  },
  /*::[*/
  198: {
    /* n:"BrtEndPCDHierarchy", */
    T: -1
  },
  /*::[*/
  199: {
    /* n:"BrtBeginPCDHFieldsUsage", */
    T: 1
  },
  /*::[*/
  200: {
    /* n:"BrtEndPCDHFieldsUsage", */
    T: -1
  },
  /*::[*/
  201: {
    /* n:"BrtBeginExtConnection", */
    T: 1
  },
  /*::[*/
  202: {
    /* n:"BrtEndExtConnection", */
    T: -1
  },
  /*::[*/
  203: {
    /* n:"BrtBeginECDbProps", */
    T: 1
  },
  /*::[*/
  204: {
    /* n:"BrtEndECDbProps", */
    T: -1
  },
  /*::[*/
  205: {
    /* n:"BrtBeginECOlapProps", */
    T: 1
  },
  /*::[*/
  206: {
    /* n:"BrtEndECOlapProps", */
    T: -1
  },
  /*::[*/
  207: {
    /* n:"BrtBeginPCDSConsol", */
    T: 1
  },
  /*::[*/
  208: {
    /* n:"BrtEndPCDSConsol", */
    T: -1
  },
  /*::[*/
  209: {
    /* n:"BrtBeginPCDSCPages", */
    T: 1
  },
  /*::[*/
  210: {
    /* n:"BrtEndPCDSCPages", */
    T: -1
  },
  /*::[*/
  211: {
    /* n:"BrtBeginPCDSCPage", */
    T: 1
  },
  /*::[*/
  212: {
    /* n:"BrtEndPCDSCPage", */
    T: -1
  },
  /*::[*/
  213: {
    /* n:"BrtBeginPCDSCPItem", */
    T: 1
  },
  /*::[*/
  214: {
    /* n:"BrtEndPCDSCPItem", */
    T: -1
  },
  /*::[*/
  215: {
    /* n:"BrtBeginPCDSCSets", */
    T: 1
  },
  /*::[*/
  216: {
    /* n:"BrtEndPCDSCSets", */
    T: -1
  },
  /*::[*/
  217: {
    /* n:"BrtBeginPCDSCSet", */
    T: 1
  },
  /*::[*/
  218: {
    /* n:"BrtEndPCDSCSet", */
    T: -1
  },
  /*::[*/
  219: {
    /* n:"BrtBeginPCDFGroup", */
    T: 1
  },
  /*::[*/
  220: {
    /* n:"BrtEndPCDFGroup", */
    T: -1
  },
  /*::[*/
  221: {
    /* n:"BrtBeginPCDFGItems", */
    T: 1
  },
  /*::[*/
  222: {
    /* n:"BrtEndPCDFGItems", */
    T: -1
  },
  /*::[*/
  223: {
    /* n:"BrtBeginPCDFGRange", */
    T: 1
  },
  /*::[*/
  224: {
    /* n:"BrtEndPCDFGRange", */
    T: -1
  },
  /*::[*/
  225: {
    /* n:"BrtBeginPCDFGDiscrete", */
    T: 1
  },
  /*::[*/
  226: {
    /* n:"BrtEndPCDFGDiscrete", */
    T: -1
  },
  /*::[*/
  227: {
    /* n:"BrtBeginPCDSDTupleCache", */
    T: 1
  },
  /*::[*/
  228: {
    /* n:"BrtEndPCDSDTupleCache", */
    T: -1
  },
  /*::[*/
  229: {
    /* n:"BrtBeginPCDSDTCEntries", */
    T: 1
  },
  /*::[*/
  230: {
    /* n:"BrtEndPCDSDTCEntries", */
    T: -1
  },
  /*::[*/
  231: {
    /* n:"BrtBeginPCDSDTCEMembers", */
    T: 1
  },
  /*::[*/
  232: {
    /* n:"BrtEndPCDSDTCEMembers", */
    T: -1
  },
  /*::[*/
  233: {
    /* n:"BrtBeginPCDSDTCEMember", */
    T: 1
  },
  /*::[*/
  234: {
    /* n:"BrtEndPCDSDTCEMember", */
    T: -1
  },
  /*::[*/
  235: {
    /* n:"BrtBeginPCDSDTCQueries", */
    T: 1
  },
  /*::[*/
  236: {
    /* n:"BrtEndPCDSDTCQueries", */
    T: -1
  },
  /*::[*/
  237: {
    /* n:"BrtBeginPCDSDTCQuery", */
    T: 1
  },
  /*::[*/
  238: {
    /* n:"BrtEndPCDSDTCQuery", */
    T: -1
  },
  /*::[*/
  239: {
    /* n:"BrtBeginPCDSDTCSets", */
    T: 1
  },
  /*::[*/
  240: {
    /* n:"BrtEndPCDSDTCSets", */
    T: -1
  },
  /*::[*/
  241: {
    /* n:"BrtBeginPCDSDTCSet", */
    T: 1
  },
  /*::[*/
  242: {
    /* n:"BrtEndPCDSDTCSet", */
    T: -1
  },
  /*::[*/
  243: {
    /* n:"BrtBeginPCDCalcItems", */
    T: 1
  },
  /*::[*/
  244: {
    /* n:"BrtEndPCDCalcItems", */
    T: -1
  },
  /*::[*/
  245: {
    /* n:"BrtBeginPCDCalcItem", */
    T: 1
  },
  /*::[*/
  246: {
    /* n:"BrtEndPCDCalcItem", */
    T: -1
  },
  /*::[*/
  247: {
    /* n:"BrtBeginPRule", */
    T: 1
  },
  /*::[*/
  248: {
    /* n:"BrtEndPRule", */
    T: -1
  },
  /*::[*/
  249: {
    /* n:"BrtBeginPRFilters", */
    T: 1
  },
  /*::[*/
  250: {
    /* n:"BrtEndPRFilters", */
    T: -1
  },
  /*::[*/
  251: {
    /* n:"BrtBeginPRFilter", */
    T: 1
  },
  /*::[*/
  252: {
    /* n:"BrtEndPRFilter", */
    T: -1
  },
  /*::[*/
  253: {
    /* n:"BrtBeginPNames", */
    T: 1
  },
  /*::[*/
  254: {
    /* n:"BrtEndPNames", */
    T: -1
  },
  /*::[*/
  255: {
    /* n:"BrtBeginPName", */
    T: 1
  },
  /*::[*/
  256: {
    /* n:"BrtEndPName", */
    T: -1
  },
  /*::[*/
  257: {
    /* n:"BrtBeginPNPairs", */
    T: 1
  },
  /*::[*/
  258: {
    /* n:"BrtEndPNPairs", */
    T: -1
  },
  /*::[*/
  259: {
    /* n:"BrtBeginPNPair", */
    T: 1
  },
  /*::[*/
  260: {
    /* n:"BrtEndPNPair", */
    T: -1
  },
  /*::[*/
  261: {
    /* n:"BrtBeginECWebProps", */
    T: 1
  },
  /*::[*/
  262: {
    /* n:"BrtEndECWebProps", */
    T: -1
  },
  /*::[*/
  263: {
    /* n:"BrtBeginEcWpTables", */
    T: 1
  },
  /*::[*/
  264: {
    /* n:"BrtEndECWPTables", */
    T: -1
  },
  /*::[*/
  265: {
    /* n:"BrtBeginECParams", */
    T: 1
  },
  /*::[*/
  266: {
    /* n:"BrtEndECParams", */
    T: -1
  },
  /*::[*/
  267: {
    /* n:"BrtBeginECParam", */
    T: 1
  },
  /*::[*/
  268: {
    /* n:"BrtEndECParam", */
    T: -1
  },
  /*::[*/
  269: {
    /* n:"BrtBeginPCDKPIs", */
    T: 1
  },
  /*::[*/
  270: {
    /* n:"BrtEndPCDKPIs", */
    T: -1
  },
  /*::[*/
  271: {
    /* n:"BrtBeginPCDKPI", */
    T: 1
  },
  /*::[*/
  272: {
    /* n:"BrtEndPCDKPI", */
    T: -1
  },
  /*::[*/
  273: {
    /* n:"BrtBeginDims", */
    T: 1
  },
  /*::[*/
  274: {
    /* n:"BrtEndDims", */
    T: -1
  },
  /*::[*/
  275: {
    /* n:"BrtBeginDim", */
    T: 1
  },
  /*::[*/
  276: {
    /* n:"BrtEndDim", */
    T: -1
  },
  /*::[*/
  277: {
    /* n:"BrtIndexPartEnd" */
  },
  /*::[*/
  278: {
    /* n:"BrtBeginStyleSheet", */
    T: 1
  },
  /*::[*/
  279: {
    /* n:"BrtEndStyleSheet", */
    T: -1
  },
  /*::[*/
  280: {
    /* n:"BrtBeginSXView", */
    T: 1
  },
  /*::[*/
  281: {
    /* n:"BrtEndSXVI", */
    T: -1
  },
  /*::[*/
  282: {
    /* n:"BrtBeginSXVI", */
    T: 1
  },
  /*::[*/
  283: {
    /* n:"BrtBeginSXVIs", */
    T: 1
  },
  /*::[*/
  284: {
    /* n:"BrtEndSXVIs", */
    T: -1
  },
  /*::[*/
  285: {
    /* n:"BrtBeginSXVD", */
    T: 1
  },
  /*::[*/
  286: {
    /* n:"BrtEndSXVD", */
    T: -1
  },
  /*::[*/
  287: {
    /* n:"BrtBeginSXVDs", */
    T: 1
  },
  /*::[*/
  288: {
    /* n:"BrtEndSXVDs", */
    T: -1
  },
  /*::[*/
  289: {
    /* n:"BrtBeginSXPI", */
    T: 1
  },
  /*::[*/
  290: {
    /* n:"BrtEndSXPI", */
    T: -1
  },
  /*::[*/
  291: {
    /* n:"BrtBeginSXPIs", */
    T: 1
  },
  /*::[*/
  292: {
    /* n:"BrtEndSXPIs", */
    T: -1
  },
  /*::[*/
  293: {
    /* n:"BrtBeginSXDI", */
    T: 1
  },
  /*::[*/
  294: {
    /* n:"BrtEndSXDI", */
    T: -1
  },
  /*::[*/
  295: {
    /* n:"BrtBeginSXDIs", */
    T: 1
  },
  /*::[*/
  296: {
    /* n:"BrtEndSXDIs", */
    T: -1
  },
  /*::[*/
  297: {
    /* n:"BrtBeginSXLI", */
    T: 1
  },
  /*::[*/
  298: {
    /* n:"BrtEndSXLI", */
    T: -1
  },
  /*::[*/
  299: {
    /* n:"BrtBeginSXLIRws", */
    T: 1
  },
  /*::[*/
  300: {
    /* n:"BrtEndSXLIRws", */
    T: -1
  },
  /*::[*/
  301: {
    /* n:"BrtBeginSXLICols", */
    T: 1
  },
  /*::[*/
  302: {
    /* n:"BrtEndSXLICols", */
    T: -1
  },
  /*::[*/
  303: {
    /* n:"BrtBeginSXFormat", */
    T: 1
  },
  /*::[*/
  304: {
    /* n:"BrtEndSXFormat", */
    T: -1
  },
  /*::[*/
  305: {
    /* n:"BrtBeginSXFormats", */
    T: 1
  },
  /*::[*/
  306: {
    /* n:"BrtEndSxFormats", */
    T: -1
  },
  /*::[*/
  307: {
    /* n:"BrtBeginSxSelect", */
    T: 1
  },
  /*::[*/
  308: {
    /* n:"BrtEndSxSelect", */
    T: -1
  },
  /*::[*/
  309: {
    /* n:"BrtBeginISXVDRws", */
    T: 1
  },
  /*::[*/
  310: {
    /* n:"BrtEndISXVDRws", */
    T: -1
  },
  /*::[*/
  311: {
    /* n:"BrtBeginISXVDCols", */
    T: 1
  },
  /*::[*/
  312: {
    /* n:"BrtEndISXVDCols", */
    T: -1
  },
  /*::[*/
  313: {
    /* n:"BrtEndSXLocation", */
    T: -1
  },
  /*::[*/
  314: {
    /* n:"BrtBeginSXLocation", */
    T: 1
  },
  /*::[*/
  315: {
    /* n:"BrtEndSXView", */
    T: -1
  },
  /*::[*/
  316: {
    /* n:"BrtBeginSXTHs", */
    T: 1
  },
  /*::[*/
  317: {
    /* n:"BrtEndSXTHs", */
    T: -1
  },
  /*::[*/
  318: {
    /* n:"BrtBeginSXTH", */
    T: 1
  },
  /*::[*/
  319: {
    /* n:"BrtEndSXTH", */
    T: -1
  },
  /*::[*/
  320: {
    /* n:"BrtBeginISXTHRws", */
    T: 1
  },
  /*::[*/
  321: {
    /* n:"BrtEndISXTHRws", */
    T: -1
  },
  /*::[*/
  322: {
    /* n:"BrtBeginISXTHCols", */
    T: 1
  },
  /*::[*/
  323: {
    /* n:"BrtEndISXTHCols", */
    T: -1
  },
  /*::[*/
  324: {
    /* n:"BrtBeginSXTDMPS", */
    T: 1
  },
  /*::[*/
  325: {
    /* n:"BrtEndSXTDMPs", */
    T: -1
  },
  /*::[*/
  326: {
    /* n:"BrtBeginSXTDMP", */
    T: 1
  },
  /*::[*/
  327: {
    /* n:"BrtEndSXTDMP", */
    T: -1
  },
  /*::[*/
  328: {
    /* n:"BrtBeginSXTHItems", */
    T: 1
  },
  /*::[*/
  329: {
    /* n:"BrtEndSXTHItems", */
    T: -1
  },
  /*::[*/
  330: {
    /* n:"BrtBeginSXTHItem", */
    T: 1
  },
  /*::[*/
  331: {
    /* n:"BrtEndSXTHItem", */
    T: -1
  },
  /*::[*/
  332: {
    /* n:"BrtBeginMetadata", */
    T: 1
  },
  /*::[*/
  333: {
    /* n:"BrtEndMetadata", */
    T: -1
  },
  /*::[*/
  334: {
    /* n:"BrtBeginEsmdtinfo", */
    T: 1
  },
  /*::[*/
  335: {
    /* n:"BrtMdtinfo", */
    f: parse_BrtMdtinfo
  },
  /*::[*/
  336: {
    /* n:"BrtEndEsmdtinfo", */
    T: -1
  },
  /*::[*/
  337: {
    /* n:"BrtBeginEsmdb", */
    f: parse_BrtBeginEsmdb,
    T: 1
  },
  /*::[*/
  338: {
    /* n:"BrtEndEsmdb", */
    T: -1
  },
  /*::[*/
  339: {
    /* n:"BrtBeginEsfmd", */
    T: 1
  },
  /*::[*/
  340: {
    /* n:"BrtEndEsfmd", */
    T: -1
  },
  /*::[*/
  341: {
    /* n:"BrtBeginSingleCells", */
    T: 1
  },
  /*::[*/
  342: {
    /* n:"BrtEndSingleCells", */
    T: -1
  },
  /*::[*/
  343: {
    /* n:"BrtBeginList", */
    T: 1
  },
  /*::[*/
  344: {
    /* n:"BrtEndList", */
    T: -1
  },
  /*::[*/
  345: {
    /* n:"BrtBeginListCols", */
    T: 1
  },
  /*::[*/
  346: {
    /* n:"BrtEndListCols", */
    T: -1
  },
  /*::[*/
  347: {
    /* n:"BrtBeginListCol", */
    T: 1
  },
  /*::[*/
  348: {
    /* n:"BrtEndListCol", */
    T: -1
  },
  /*::[*/
  349: {
    /* n:"BrtBeginListXmlCPr", */
    T: 1
  },
  /*::[*/
  350: {
    /* n:"BrtEndListXmlCPr", */
    T: -1
  },
  /*::[*/
  351: {
    /* n:"BrtListCCFmla" */
  },
  /*::[*/
  352: {
    /* n:"BrtListTrFmla" */
  },
  /*::[*/
  353: {
    /* n:"BrtBeginExternals", */
    T: 1
  },
  /*::[*/
  354: {
    /* n:"BrtEndExternals", */
    T: -1
  },
  /*::[*/
  355: {
    /* n:"BrtSupBookSrc", */
    f: parse_RelID
  },
  /*::[*/
  357: {
    /* n:"BrtSupSelf" */
  },
  /*::[*/
  358: {
    /* n:"BrtSupSame" */
  },
  /*::[*/
  359: {
    /* n:"BrtSupTabs" */
  },
  /*::[*/
  360: {
    /* n:"BrtBeginSupBook", */
    T: 1
  },
  /*::[*/
  361: {
    /* n:"BrtPlaceholderName" */
  },
  /*::[*/
  362: {
    /* n:"BrtExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  363: {
    /* n:"BrtExternTableStart" */
  },
  /*::[*/
  364: {
    /* n:"BrtExternTableEnd" */
  },
  /*::[*/
  366: {
    /* n:"BrtExternRowHdr" */
  },
  /*::[*/
  367: {
    /* n:"BrtExternCellBlank" */
  },
  /*::[*/
  368: {
    /* n:"BrtExternCellReal" */
  },
  /*::[*/
  369: {
    /* n:"BrtExternCellBool" */
  },
  /*::[*/
  370: {
    /* n:"BrtExternCellError" */
  },
  /*::[*/
  371: {
    /* n:"BrtExternCellString" */
  },
  /*::[*/
  372: {
    /* n:"BrtBeginEsmdx", */
    T: 1
  },
  /*::[*/
  373: {
    /* n:"BrtEndEsmdx", */
    T: -1
  },
  /*::[*/
  374: {
    /* n:"BrtBeginMdxSet", */
    T: 1
  },
  /*::[*/
  375: {
    /* n:"BrtEndMdxSet", */
    T: -1
  },
  /*::[*/
  376: {
    /* n:"BrtBeginMdxMbrProp", */
    T: 1
  },
  /*::[*/
  377: {
    /* n:"BrtEndMdxMbrProp", */
    T: -1
  },
  /*::[*/
  378: {
    /* n:"BrtBeginMdxKPI", */
    T: 1
  },
  /*::[*/
  379: {
    /* n:"BrtEndMdxKPI", */
    T: -1
  },
  /*::[*/
  380: {
    /* n:"BrtBeginEsstr", */
    T: 1
  },
  /*::[*/
  381: {
    /* n:"BrtEndEsstr", */
    T: -1
  },
  /*::[*/
  382: {
    /* n:"BrtBeginPRFItem", */
    T: 1
  },
  /*::[*/
  383: {
    /* n:"BrtEndPRFItem", */
    T: -1
  },
  /*::[*/
  384: {
    /* n:"BrtBeginPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  385: {
    /* n:"BrtEndPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  386: {
    /* n:"BrtBeginPivotCacheID", */
    T: 1
  },
  /*::[*/
  387: {
    /* n:"BrtEndPivotCacheID", */
    T: -1
  },
  /*::[*/
  388: {
    /* n:"BrtBeginISXVIs", */
    T: 1
  },
  /*::[*/
  389: {
    /* n:"BrtEndISXVIs", */
    T: -1
  },
  /*::[*/
  390: {
    /* n:"BrtBeginColInfos", */
    T: 1
  },
  /*::[*/
  391: {
    /* n:"BrtEndColInfos", */
    T: -1
  },
  /*::[*/
  392: {
    /* n:"BrtBeginRwBrk", */
    T: 1
  },
  /*::[*/
  393: {
    /* n:"BrtEndRwBrk", */
    T: -1
  },
  /*::[*/
  394: {
    /* n:"BrtBeginColBrk", */
    T: 1
  },
  /*::[*/
  395: {
    /* n:"BrtEndColBrk", */
    T: -1
  },
  /*::[*/
  396: {
    /* n:"BrtBrk" */
  },
  /*::[*/
  397: {
    /* n:"BrtUserBookView" */
  },
  /*::[*/
  398: {
    /* n:"BrtInfo" */
  },
  /*::[*/
  399: {
    /* n:"BrtCUsr" */
  },
  /*::[*/
  400: {
    /* n:"BrtUsr" */
  },
  /*::[*/
  401: {
    /* n:"BrtBeginUsers", */
    T: 1
  },
  /*::[*/
  403: {
    /* n:"BrtEOF" */
  },
  /*::[*/
  404: {
    /* n:"BrtUCR" */
  },
  /*::[*/
  405: {
    /* n:"BrtRRInsDel" */
  },
  /*::[*/
  406: {
    /* n:"BrtRREndInsDel" */
  },
  /*::[*/
  407: {
    /* n:"BrtRRMove" */
  },
  /*::[*/
  408: {
    /* n:"BrtRREndMove" */
  },
  /*::[*/
  409: {
    /* n:"BrtRRChgCell" */
  },
  /*::[*/
  410: {
    /* n:"BrtRREndChgCell" */
  },
  /*::[*/
  411: {
    /* n:"BrtRRHeader" */
  },
  /*::[*/
  412: {
    /* n:"BrtRRUserView" */
  },
  /*::[*/
  413: {
    /* n:"BrtRRRenSheet" */
  },
  /*::[*/
  414: {
    /* n:"BrtRRInsertSh" */
  },
  /*::[*/
  415: {
    /* n:"BrtRRDefName" */
  },
  /*::[*/
  416: {
    /* n:"BrtRRNote" */
  },
  /*::[*/
  417: {
    /* n:"BrtRRConflict" */
  },
  /*::[*/
  418: {
    /* n:"BrtRRTQSIF" */
  },
  /*::[*/
  419: {
    /* n:"BrtRRFormat" */
  },
  /*::[*/
  420: {
    /* n:"BrtRREndFormat" */
  },
  /*::[*/
  421: {
    /* n:"BrtRRAutoFmt" */
  },
  /*::[*/
  422: {
    /* n:"BrtBeginUserShViews", */
    T: 1
  },
  /*::[*/
  423: {
    /* n:"BrtBeginUserShView", */
    T: 1
  },
  /*::[*/
  424: {
    /* n:"BrtEndUserShView", */
    T: -1
  },
  /*::[*/
  425: {
    /* n:"BrtEndUserShViews", */
    T: -1
  },
  /*::[*/
  426: {
    /* n:"BrtArrFmla", */
    f: parse_BrtArrFmla
  },
  /*::[*/
  427: {
    /* n:"BrtShrFmla", */
    f: parse_BrtShrFmla
  },
  /*::[*/
  428: {
    /* n:"BrtTable" */
  },
  /*::[*/
  429: {
    /* n:"BrtBeginExtConnections", */
    T: 1
  },
  /*::[*/
  430: {
    /* n:"BrtEndExtConnections", */
    T: -1
  },
  /*::[*/
  431: {
    /* n:"BrtBeginPCDCalcMems", */
    T: 1
  },
  /*::[*/
  432: {
    /* n:"BrtEndPCDCalcMems", */
    T: -1
  },
  /*::[*/
  433: {
    /* n:"BrtBeginPCDCalcMem", */
    T: 1
  },
  /*::[*/
  434: {
    /* n:"BrtEndPCDCalcMem", */
    T: -1
  },
  /*::[*/
  435: {
    /* n:"BrtBeginPCDHGLevels", */
    T: 1
  },
  /*::[*/
  436: {
    /* n:"BrtEndPCDHGLevels", */
    T: -1
  },
  /*::[*/
  437: {
    /* n:"BrtBeginPCDHGLevel", */
    T: 1
  },
  /*::[*/
  438: {
    /* n:"BrtEndPCDHGLevel", */
    T: -1
  },
  /*::[*/
  439: {
    /* n:"BrtBeginPCDHGLGroups", */
    T: 1
  },
  /*::[*/
  440: {
    /* n:"BrtEndPCDHGLGroups", */
    T: -1
  },
  /*::[*/
  441: {
    /* n:"BrtBeginPCDHGLGroup", */
    T: 1
  },
  /*::[*/
  442: {
    /* n:"BrtEndPCDHGLGroup", */
    T: -1
  },
  /*::[*/
  443: {
    /* n:"BrtBeginPCDHGLGMembers", */
    T: 1
  },
  /*::[*/
  444: {
    /* n:"BrtEndPCDHGLGMembers", */
    T: -1
  },
  /*::[*/
  445: {
    /* n:"BrtBeginPCDHGLGMember", */
    T: 1
  },
  /*::[*/
  446: {
    /* n:"BrtEndPCDHGLGMember", */
    T: -1
  },
  /*::[*/
  447: {
    /* n:"BrtBeginQSI", */
    T: 1
  },
  /*::[*/
  448: {
    /* n:"BrtEndQSI", */
    T: -1
  },
  /*::[*/
  449: {
    /* n:"BrtBeginQSIR", */
    T: 1
  },
  /*::[*/
  450: {
    /* n:"BrtEndQSIR", */
    T: -1
  },
  /*::[*/
  451: {
    /* n:"BrtBeginDeletedNames", */
    T: 1
  },
  /*::[*/
  452: {
    /* n:"BrtEndDeletedNames", */
    T: -1
  },
  /*::[*/
  453: {
    /* n:"BrtBeginDeletedName", */
    T: 1
  },
  /*::[*/
  454: {
    /* n:"BrtEndDeletedName", */
    T: -1
  },
  /*::[*/
  455: {
    /* n:"BrtBeginQSIFs", */
    T: 1
  },
  /*::[*/
  456: {
    /* n:"BrtEndQSIFs", */
    T: -1
  },
  /*::[*/
  457: {
    /* n:"BrtBeginQSIF", */
    T: 1
  },
  /*::[*/
  458: {
    /* n:"BrtEndQSIF", */
    T: -1
  },
  /*::[*/
  459: {
    /* n:"BrtBeginAutoSortScope", */
    T: 1
  },
  /*::[*/
  460: {
    /* n:"BrtEndAutoSortScope", */
    T: -1
  },
  /*::[*/
  461: {
    /* n:"BrtBeginConditionalFormatting", */
    T: 1
  },
  /*::[*/
  462: {
    /* n:"BrtEndConditionalFormatting", */
    T: -1
  },
  /*::[*/
  463: {
    /* n:"BrtBeginCFRule", */
    T: 1
  },
  /*::[*/
  464: {
    /* n:"BrtEndCFRule", */
    T: -1
  },
  /*::[*/
  465: {
    /* n:"BrtBeginIconSet", */
    T: 1
  },
  /*::[*/
  466: {
    /* n:"BrtEndIconSet", */
    T: -1
  },
  /*::[*/
  467: {
    /* n:"BrtBeginDatabar", */
    T: 1
  },
  /*::[*/
  468: {
    /* n:"BrtEndDatabar", */
    T: -1
  },
  /*::[*/
  469: {
    /* n:"BrtBeginColorScale", */
    T: 1
  },
  /*::[*/
  470: {
    /* n:"BrtEndColorScale", */
    T: -1
  },
  /*::[*/
  471: {
    /* n:"BrtCFVO" */
  },
  /*::[*/
  472: {
    /* n:"BrtExternValueMeta" */
  },
  /*::[*/
  473: {
    /* n:"BrtBeginColorPalette", */
    T: 1
  },
  /*::[*/
  474: {
    /* n:"BrtEndColorPalette", */
    T: -1
  },
  /*::[*/
  475: {
    /* n:"BrtIndexedColor" */
  },
  /*::[*/
  476: {
    /* n:"BrtMargins", */
    f: parse_BrtMargins
  },
  /*::[*/
  477: {
    /* n:"BrtPrintOptions" */
  },
  /*::[*/
  478: {
    /* n:"BrtPageSetup" */
  },
  /*::[*/
  479: {
    /* n:"BrtBeginHeaderFooter", */
    T: 1
  },
  /*::[*/
  480: {
    /* n:"BrtEndHeaderFooter", */
    T: -1
  },
  /*::[*/
  481: {
    /* n:"BrtBeginSXCrtFormat", */
    T: 1
  },
  /*::[*/
  482: {
    /* n:"BrtEndSXCrtFormat", */
    T: -1
  },
  /*::[*/
  483: {
    /* n:"BrtBeginSXCrtFormats", */
    T: 1
  },
  /*::[*/
  484: {
    /* n:"BrtEndSXCrtFormats", */
    T: -1
  },
  /*::[*/
  485: {
    /* n:"BrtWsFmtInfo", */
    f: parse_BrtWsFmtInfo
  },
  /*::[*/
  486: {
    /* n:"BrtBeginMgs", */
    T: 1
  },
  /*::[*/
  487: {
    /* n:"BrtEndMGs", */
    T: -1
  },
  /*::[*/
  488: {
    /* n:"BrtBeginMGMaps", */
    T: 1
  },
  /*::[*/
  489: {
    /* n:"BrtEndMGMaps", */
    T: -1
  },
  /*::[*/
  490: {
    /* n:"BrtBeginMG", */
    T: 1
  },
  /*::[*/
  491: {
    /* n:"BrtEndMG", */
    T: -1
  },
  /*::[*/
  492: {
    /* n:"BrtBeginMap", */
    T: 1
  },
  /*::[*/
  493: {
    /* n:"BrtEndMap", */
    T: -1
  },
  /*::[*/
  494: {
    /* n:"BrtHLink", */
    f: parse_BrtHLink
  },
  /*::[*/
  495: {
    /* n:"BrtBeginDCon", */
    T: 1
  },
  /*::[*/
  496: {
    /* n:"BrtEndDCon", */
    T: -1
  },
  /*::[*/
  497: {
    /* n:"BrtBeginDRefs", */
    T: 1
  },
  /*::[*/
  498: {
    /* n:"BrtEndDRefs", */
    T: -1
  },
  /*::[*/
  499: {
    /* n:"BrtDRef" */
  },
  /*::[*/
  500: {
    /* n:"BrtBeginScenMan", */
    T: 1
  },
  /*::[*/
  501: {
    /* n:"BrtEndScenMan", */
    T: -1
  },
  /*::[*/
  502: {
    /* n:"BrtBeginSct", */
    T: 1
  },
  /*::[*/
  503: {
    /* n:"BrtEndSct", */
    T: -1
  },
  /*::[*/
  504: {
    /* n:"BrtSlc" */
  },
  /*::[*/
  505: {
    /* n:"BrtBeginDXFs", */
    T: 1
  },
  /*::[*/
  506: {
    /* n:"BrtEndDXFs", */
    T: -1
  },
  /*::[*/
  507: {
    /* n:"BrtDXF" */
  },
  /*::[*/
  508: {
    /* n:"BrtBeginTableStyles", */
    T: 1
  },
  /*::[*/
  509: {
    /* n:"BrtEndTableStyles", */
    T: -1
  },
  /*::[*/
  510: {
    /* n:"BrtBeginTableStyle", */
    T: 1
  },
  /*::[*/
  511: {
    /* n:"BrtEndTableStyle", */
    T: -1
  },
  /*::[*/
  512: {
    /* n:"BrtTableStyleElement" */
  },
  /*::[*/
  513: {
    /* n:"BrtTableStyleClient" */
  },
  /*::[*/
  514: {
    /* n:"BrtBeginVolDeps", */
    T: 1
  },
  /*::[*/
  515: {
    /* n:"BrtEndVolDeps", */
    T: -1
  },
  /*::[*/
  516: {
    /* n:"BrtBeginVolType", */
    T: 1
  },
  /*::[*/
  517: {
    /* n:"BrtEndVolType", */
    T: -1
  },
  /*::[*/
  518: {
    /* n:"BrtBeginVolMain", */
    T: 1
  },
  /*::[*/
  519: {
    /* n:"BrtEndVolMain", */
    T: -1
  },
  /*::[*/
  520: {
    /* n:"BrtBeginVolTopic", */
    T: 1
  },
  /*::[*/
  521: {
    /* n:"BrtEndVolTopic", */
    T: -1
  },
  /*::[*/
  522: {
    /* n:"BrtVolSubtopic" */
  },
  /*::[*/
  523: {
    /* n:"BrtVolRef" */
  },
  /*::[*/
  524: {
    /* n:"BrtVolNum" */
  },
  /*::[*/
  525: {
    /* n:"BrtVolErr" */
  },
  /*::[*/
  526: {
    /* n:"BrtVolStr" */
  },
  /*::[*/
  527: {
    /* n:"BrtVolBool" */
  },
  /*::[*/
  528: {
    /* n:"BrtBeginCalcChain$", */
    T: 1
  },
  /*::[*/
  529: {
    /* n:"BrtEndCalcChain$", */
    T: -1
  },
  /*::[*/
  530: {
    /* n:"BrtBeginSortState", */
    T: 1
  },
  /*::[*/
  531: {
    /* n:"BrtEndSortState", */
    T: -1
  },
  /*::[*/
  532: {
    /* n:"BrtBeginSortCond", */
    T: 1
  },
  /*::[*/
  533: {
    /* n:"BrtEndSortCond", */
    T: -1
  },
  /*::[*/
  534: {
    /* n:"BrtBookProtection" */
  },
  /*::[*/
  535: {
    /* n:"BrtSheetProtection" */
  },
  /*::[*/
  536: {
    /* n:"BrtRangeProtection" */
  },
  /*::[*/
  537: {
    /* n:"BrtPhoneticInfo" */
  },
  /*::[*/
  538: {
    /* n:"BrtBeginECTxtWiz", */
    T: 1
  },
  /*::[*/
  539: {
    /* n:"BrtEndECTxtWiz", */
    T: -1
  },
  /*::[*/
  540: {
    /* n:"BrtBeginECTWFldInfoLst", */
    T: 1
  },
  /*::[*/
  541: {
    /* n:"BrtEndECTWFldInfoLst", */
    T: -1
  },
  /*::[*/
  542: {
    /* n:"BrtBeginECTwFldInfo", */
    T: 1
  },
  /*::[*/
  548: {
    /* n:"BrtFileSharing" */
  },
  /*::[*/
  549: {
    /* n:"BrtOleSize" */
  },
  /*::[*/
  550: {
    /* n:"BrtDrawing", */
    f: parse_RelID
  },
  /*::[*/
  551: {
    /* n:"BrtLegacyDrawing" */
  },
  /*::[*/
  552: {
    /* n:"BrtLegacyDrawingHF" */
  },
  /*::[*/
  553: {
    /* n:"BrtWebOpt" */
  },
  /*::[*/
  554: {
    /* n:"BrtBeginWebPubItems", */
    T: 1
  },
  /*::[*/
  555: {
    /* n:"BrtEndWebPubItems", */
    T: -1
  },
  /*::[*/
  556: {
    /* n:"BrtBeginWebPubItem", */
    T: 1
  },
  /*::[*/
  557: {
    /* n:"BrtEndWebPubItem", */
    T: -1
  },
  /*::[*/
  558: {
    /* n:"BrtBeginSXCondFmt", */
    T: 1
  },
  /*::[*/
  559: {
    /* n:"BrtEndSXCondFmt", */
    T: -1
  },
  /*::[*/
  560: {
    /* n:"BrtBeginSXCondFmts", */
    T: 1
  },
  /*::[*/
  561: {
    /* n:"BrtEndSXCondFmts", */
    T: -1
  },
  /*::[*/
  562: {
    /* n:"BrtBkHim" */
  },
  /*::[*/
  564: {
    /* n:"BrtColor" */
  },
  /*::[*/
  565: {
    /* n:"BrtBeginIndexedColors", */
    T: 1
  },
  /*::[*/
  566: {
    /* n:"BrtEndIndexedColors", */
    T: -1
  },
  /*::[*/
  569: {
    /* n:"BrtBeginMRUColors", */
    T: 1
  },
  /*::[*/
  570: {
    /* n:"BrtEndMRUColors", */
    T: -1
  },
  /*::[*/
  572: {
    /* n:"BrtMRUColor" */
  },
  /*::[*/
  573: {
    /* n:"BrtBeginDVals", */
    T: 1
  },
  /*::[*/
  574: {
    /* n:"BrtEndDVals", */
    T: -1
  },
  /*::[*/
  577: {
    /* n:"BrtSupNameStart" */
  },
  /*::[*/
  578: {
    /* n:"BrtSupNameValueStart" */
  },
  /*::[*/
  579: {
    /* n:"BrtSupNameValueEnd" */
  },
  /*::[*/
  580: {
    /* n:"BrtSupNameNum" */
  },
  /*::[*/
  581: {
    /* n:"BrtSupNameErr" */
  },
  /*::[*/
  582: {
    /* n:"BrtSupNameSt" */
  },
  /*::[*/
  583: {
    /* n:"BrtSupNameNil" */
  },
  /*::[*/
  584: {
    /* n:"BrtSupNameBool" */
  },
  /*::[*/
  585: {
    /* n:"BrtSupNameFmla" */
  },
  /*::[*/
  586: {
    /* n:"BrtSupNameBits" */
  },
  /*::[*/
  587: {
    /* n:"BrtSupNameEnd" */
  },
  /*::[*/
  588: {
    /* n:"BrtEndSupBook", */
    T: -1
  },
  /*::[*/
  589: {
    /* n:"BrtCellSmartTagProperty" */
  },
  /*::[*/
  590: {
    /* n:"BrtBeginCellSmartTag", */
    T: 1
  },
  /*::[*/
  591: {
    /* n:"BrtEndCellSmartTag", */
    T: -1
  },
  /*::[*/
  592: {
    /* n:"BrtBeginCellSmartTags", */
    T: 1
  },
  /*::[*/
  593: {
    /* n:"BrtEndCellSmartTags", */
    T: -1
  },
  /*::[*/
  594: {
    /* n:"BrtBeginSmartTags", */
    T: 1
  },
  /*::[*/
  595: {
    /* n:"BrtEndSmartTags", */
    T: -1
  },
  /*::[*/
  596: {
    /* n:"BrtSmartTagType" */
  },
  /*::[*/
  597: {
    /* n:"BrtBeginSmartTagTypes", */
    T: 1
  },
  /*::[*/
  598: {
    /* n:"BrtEndSmartTagTypes", */
    T: -1
  },
  /*::[*/
  599: {
    /* n:"BrtBeginSXFilters", */
    T: 1
  },
  /*::[*/
  600: {
    /* n:"BrtEndSXFilters", */
    T: -1
  },
  /*::[*/
  601: {
    /* n:"BrtBeginSXFILTER", */
    T: 1
  },
  /*::[*/
  602: {
    /* n:"BrtEndSXFilter", */
    T: -1
  },
  /*::[*/
  603: {
    /* n:"BrtBeginFills", */
    T: 1
  },
  /*::[*/
  604: {
    /* n:"BrtEndFills", */
    T: -1
  },
  /*::[*/
  605: {
    /* n:"BrtBeginCellWatches", */
    T: 1
  },
  /*::[*/
  606: {
    /* n:"BrtEndCellWatches", */
    T: -1
  },
  /*::[*/
  607: {
    /* n:"BrtCellWatch" */
  },
  /*::[*/
  608: {
    /* n:"BrtBeginCRErrs", */
    T: 1
  },
  /*::[*/
  609: {
    /* n:"BrtEndCRErrs", */
    T: -1
  },
  /*::[*/
  610: {
    /* n:"BrtCrashRecErr" */
  },
  /*::[*/
  611: {
    /* n:"BrtBeginFonts", */
    T: 1
  },
  /*::[*/
  612: {
    /* n:"BrtEndFonts", */
    T: -1
  },
  /*::[*/
  613: {
    /* n:"BrtBeginBorders", */
    T: 1
  },
  /*::[*/
  614: {
    /* n:"BrtEndBorders", */
    T: -1
  },
  /*::[*/
  615: {
    /* n:"BrtBeginFmts", */
    T: 1
  },
  /*::[*/
  616: {
    /* n:"BrtEndFmts", */
    T: -1
  },
  /*::[*/
  617: {
    /* n:"BrtBeginCellXFs", */
    T: 1
  },
  /*::[*/
  618: {
    /* n:"BrtEndCellXFs", */
    T: -1
  },
  /*::[*/
  619: {
    /* n:"BrtBeginStyles", */
    T: 1
  },
  /*::[*/
  620: {
    /* n:"BrtEndStyles", */
    T: -1
  },
  /*::[*/
  625: {
    /* n:"BrtBigName" */
  },
  /*::[*/
  626: {
    /* n:"BrtBeginCellStyleXFs", */
    T: 1
  },
  /*::[*/
  627: {
    /* n:"BrtEndCellStyleXFs", */
    T: -1
  },
  /*::[*/
  628: {
    /* n:"BrtBeginComments", */
    T: 1
  },
  /*::[*/
  629: {
    /* n:"BrtEndComments", */
    T: -1
  },
  /*::[*/
  630: {
    /* n:"BrtBeginCommentAuthors", */
    T: 1
  },
  /*::[*/
  631: {
    /* n:"BrtEndCommentAuthors", */
    T: -1
  },
  /*::[*/
  632: {
    /* n:"BrtCommentAuthor", */
    f: parse_BrtCommentAuthor
  },
  /*::[*/
  633: {
    /* n:"BrtBeginCommentList", */
    T: 1
  },
  /*::[*/
  634: {
    /* n:"BrtEndCommentList", */
    T: -1
  },
  /*::[*/
  635: {
    /* n:"BrtBeginComment", */
    T: 1,
    f: parse_BrtBeginComment
  },
  /*::[*/
  636: {
    /* n:"BrtEndComment", */
    T: -1
  },
  /*::[*/
  637: {
    /* n:"BrtCommentText", */
    f: parse_BrtCommentText
  },
  /*::[*/
  638: {
    /* n:"BrtBeginOleObjects", */
    T: 1
  },
  /*::[*/
  639: {
    /* n:"BrtOleObject" */
  },
  /*::[*/
  640: {
    /* n:"BrtEndOleObjects", */
    T: -1
  },
  /*::[*/
  641: {
    /* n:"BrtBeginSxrules", */
    T: 1
  },
  /*::[*/
  642: {
    /* n:"BrtEndSxRules", */
    T: -1
  },
  /*::[*/
  643: {
    /* n:"BrtBeginActiveXControls", */
    T: 1
  },
  /*::[*/
  644: {
    /* n:"BrtActiveX" */
  },
  /*::[*/
  645: {
    /* n:"BrtEndActiveXControls", */
    T: -1
  },
  /*::[*/
  646: {
    /* n:"BrtBeginPCDSDTCEMembersSortBy", */
    T: 1
  },
  /*::[*/
  648: {
    /* n:"BrtBeginCellIgnoreECs", */
    T: 1
  },
  /*::[*/
  649: {
    /* n:"BrtCellIgnoreEC" */
  },
  /*::[*/
  650: {
    /* n:"BrtEndCellIgnoreECs", */
    T: -1
  },
  /*::[*/
  651: {
    /* n:"BrtCsProp", */
    f: parse_BrtCsProp
  },
  /*::[*/
  652: {
    /* n:"BrtCsPageSetup" */
  },
  /*::[*/
  653: {
    /* n:"BrtBeginUserCsViews", */
    T: 1
  },
  /*::[*/
  654: {
    /* n:"BrtEndUserCsViews", */
    T: -1
  },
  /*::[*/
  655: {
    /* n:"BrtBeginUserCsView", */
    T: 1
  },
  /*::[*/
  656: {
    /* n:"BrtEndUserCsView", */
    T: -1
  },
  /*::[*/
  657: {
    /* n:"BrtBeginPcdSFCIEntries", */
    T: 1
  },
  /*::[*/
  658: {
    /* n:"BrtEndPCDSFCIEntries", */
    T: -1
  },
  /*::[*/
  659: {
    /* n:"BrtPCDSFCIEntry" */
  },
  /*::[*/
  660: {
    /* n:"BrtBeginListParts", */
    T: 1
  },
  /*::[*/
  661: {
    /* n:"BrtListPart" */
  },
  /*::[*/
  662: {
    /* n:"BrtEndListParts", */
    T: -1
  },
  /*::[*/
  663: {
    /* n:"BrtSheetCalcProp" */
  },
  /*::[*/
  664: {
    /* n:"BrtBeginFnGroup", */
    T: 1
  },
  /*::[*/
  665: {
    /* n:"BrtFnGroup" */
  },
  /*::[*/
  666: {
    /* n:"BrtEndFnGroup", */
    T: -1
  },
  /*::[*/
  667: {
    /* n:"BrtSupAddin" */
  },
  /*::[*/
  668: {
    /* n:"BrtSXTDMPOrder" */
  },
  /*::[*/
  669: {
    /* n:"BrtCsProtection" */
  },
  /*::[*/
  671: {
    /* n:"BrtBeginWsSortMap", */
    T: 1
  },
  /*::[*/
  672: {
    /* n:"BrtEndWsSortMap", */
    T: -1
  },
  /*::[*/
  673: {
    /* n:"BrtBeginRRSort", */
    T: 1
  },
  /*::[*/
  674: {
    /* n:"BrtEndRRSort", */
    T: -1
  },
  /*::[*/
  675: {
    /* n:"BrtRRSortItem" */
  },
  /*::[*/
  676: {
    /* n:"BrtFileSharingIso" */
  },
  /*::[*/
  677: {
    /* n:"BrtBookProtectionIso" */
  },
  /*::[*/
  678: {
    /* n:"BrtSheetProtectionIso" */
  },
  /*::[*/
  679: {
    /* n:"BrtCsProtectionIso" */
  },
  /*::[*/
  680: {
    /* n:"BrtRangeProtectionIso" */
  },
  /*::[*/
  681: {
    /* n:"BrtDValList" */
  },
  /*::[*/
  1024: {
    /* n:"BrtRwDescent" */
  },
  /*::[*/
  1025: {
    /* n:"BrtKnownFonts" */
  },
  /*::[*/
  1026: {
    /* n:"BrtBeginSXTupleSet", */
    T: 1
  },
  /*::[*/
  1027: {
    /* n:"BrtEndSXTupleSet", */
    T: -1
  },
  /*::[*/
  1028: {
    /* n:"BrtBeginSXTupleSetHeader", */
    T: 1
  },
  /*::[*/
  1029: {
    /* n:"BrtEndSXTupleSetHeader", */
    T: -1
  },
  /*::[*/
  1030: {
    /* n:"BrtSXTupleSetHeaderItem" */
  },
  /*::[*/
  1031: {
    /* n:"BrtBeginSXTupleSetData", */
    T: 1
  },
  /*::[*/
  1032: {
    /* n:"BrtEndSXTupleSetData", */
    T: -1
  },
  /*::[*/
  1033: {
    /* n:"BrtBeginSXTupleSetRow", */
    T: 1
  },
  /*::[*/
  1034: {
    /* n:"BrtEndSXTupleSetRow", */
    T: -1
  },
  /*::[*/
  1035: {
    /* n:"BrtSXTupleSetRowItem" */
  },
  /*::[*/
  1036: {
    /* n:"BrtNameExt" */
  },
  /*::[*/
  1037: {
    /* n:"BrtPCDH14" */
  },
  /*::[*/
  1038: {
    /* n:"BrtBeginPCDCalcMem14", */
    T: 1
  },
  /*::[*/
  1039: {
    /* n:"BrtEndPCDCalcMem14", */
    T: -1
  },
  /*::[*/
  1040: {
    /* n:"BrtSXTH14" */
  },
  /*::[*/
  1041: {
    /* n:"BrtBeginSparklineGroup", */
    T: 1
  },
  /*::[*/
  1042: {
    /* n:"BrtEndSparklineGroup", */
    T: -1
  },
  /*::[*/
  1043: {
    /* n:"BrtSparkline" */
  },
  /*::[*/
  1044: {
    /* n:"BrtSXDI14" */
  },
  /*::[*/
  1045: {
    /* n:"BrtWsFmtInfoEx14" */
  },
  /*::[*/
  1046: {
    /* n:"BrtBeginConditionalFormatting14", */
    T: 1
  },
  /*::[*/
  1047: {
    /* n:"BrtEndConditionalFormatting14", */
    T: -1
  },
  /*::[*/
  1048: {
    /* n:"BrtBeginCFRule14", */
    T: 1
  },
  /*::[*/
  1049: {
    /* n:"BrtEndCFRule14", */
    T: -1
  },
  /*::[*/
  1050: {
    /* n:"BrtCFVO14" */
  },
  /*::[*/
  1051: {
    /* n:"BrtBeginDatabar14", */
    T: 1
  },
  /*::[*/
  1052: {
    /* n:"BrtBeginIconSet14", */
    T: 1
  },
  /*::[*/
  1053: {
    /* n:"BrtDVal14", */
    f: parse_BrtDVal14
  },
  /*::[*/
  1054: {
    /* n:"BrtBeginDVals14", */
    T: 1
  },
  /*::[*/
  1055: {
    /* n:"BrtColor14" */
  },
  /*::[*/
  1056: {
    /* n:"BrtBeginSparklines", */
    T: 1
  },
  /*::[*/
  1057: {
    /* n:"BrtEndSparklines", */
    T: -1
  },
  /*::[*/
  1058: {
    /* n:"BrtBeginSparklineGroups", */
    T: 1
  },
  /*::[*/
  1059: {
    /* n:"BrtEndSparklineGroups", */
    T: -1
  },
  /*::[*/
  1061: {
    /* n:"BrtSXVD14" */
  },
  /*::[*/
  1062: {
    /* n:"BrtBeginSXView14", */
    T: 1
  },
  /*::[*/
  1063: {
    /* n:"BrtEndSXView14", */
    T: -1
  },
  /*::[*/
  1064: {
    /* n:"BrtBeginSXView16", */
    T: 1
  },
  /*::[*/
  1065: {
    /* n:"BrtEndSXView16", */
    T: -1
  },
  /*::[*/
  1066: {
    /* n:"BrtBeginPCD14", */
    T: 1
  },
  /*::[*/
  1067: {
    /* n:"BrtEndPCD14", */
    T: -1
  },
  /*::[*/
  1068: {
    /* n:"BrtBeginExtConn14", */
    T: 1
  },
  /*::[*/
  1069: {
    /* n:"BrtEndExtConn14", */
    T: -1
  },
  /*::[*/
  1070: {
    /* n:"BrtBeginSlicerCacheIDs", */
    T: 1
  },
  /*::[*/
  1071: {
    /* n:"BrtEndSlicerCacheIDs", */
    T: -1
  },
  /*::[*/
  1072: {
    /* n:"BrtBeginSlicerCacheID", */
    T: 1
  },
  /*::[*/
  1073: {
    /* n:"BrtEndSlicerCacheID", */
    T: -1
  },
  /*::[*/
  1075: {
    /* n:"BrtBeginSlicerCache", */
    T: 1
  },
  /*::[*/
  1076: {
    /* n:"BrtEndSlicerCache", */
    T: -1
  },
  /*::[*/
  1077: {
    /* n:"BrtBeginSlicerCacheDef", */
    T: 1
  },
  /*::[*/
  1078: {
    /* n:"BrtEndSlicerCacheDef", */
    T: -1
  },
  /*::[*/
  1079: {
    /* n:"BrtBeginSlicersEx", */
    T: 1
  },
  /*::[*/
  1080: {
    /* n:"BrtEndSlicersEx", */
    T: -1
  },
  /*::[*/
  1081: {
    /* n:"BrtBeginSlicerEx", */
    T: 1
  },
  /*::[*/
  1082: {
    /* n:"BrtEndSlicerEx", */
    T: -1
  },
  /*::[*/
  1083: {
    /* n:"BrtBeginSlicer", */
    T: 1
  },
  /*::[*/
  1084: {
    /* n:"BrtEndSlicer", */
    T: -1
  },
  /*::[*/
  1085: {
    /* n:"BrtSlicerCachePivotTables" */
  },
  /*::[*/
  1086: {
    /* n:"BrtBeginSlicerCacheOlapImpl", */
    T: 1
  },
  /*::[*/
  1087: {
    /* n:"BrtEndSlicerCacheOlapImpl", */
    T: -1
  },
  /*::[*/
  1088: {
    /* n:"BrtBeginSlicerCacheLevelsData", */
    T: 1
  },
  /*::[*/
  1089: {
    /* n:"BrtEndSlicerCacheLevelsData", */
    T: -1
  },
  /*::[*/
  1090: {
    /* n:"BrtBeginSlicerCacheLevelData", */
    T: 1
  },
  /*::[*/
  1091: {
    /* n:"BrtEndSlicerCacheLevelData", */
    T: -1
  },
  /*::[*/
  1092: {
    /* n:"BrtBeginSlicerCacheSiRanges", */
    T: 1
  },
  /*::[*/
  1093: {
    /* n:"BrtEndSlicerCacheSiRanges", */
    T: -1
  },
  /*::[*/
  1094: {
    /* n:"BrtBeginSlicerCacheSiRange", */
    T: 1
  },
  /*::[*/
  1095: {
    /* n:"BrtEndSlicerCacheSiRange", */
    T: -1
  },
  /*::[*/
  1096: {
    /* n:"BrtSlicerCacheOlapItem" */
  },
  /*::[*/
  1097: {
    /* n:"BrtBeginSlicerCacheSelections", */
    T: 1
  },
  /*::[*/
  1098: {
    /* n:"BrtSlicerCacheSelection" */
  },
  /*::[*/
  1099: {
    /* n:"BrtEndSlicerCacheSelections", */
    T: -1
  },
  /*::[*/
  1100: {
    /* n:"BrtBeginSlicerCacheNative", */
    T: 1
  },
  /*::[*/
  1101: {
    /* n:"BrtEndSlicerCacheNative", */
    T: -1
  },
  /*::[*/
  1102: {
    /* n:"BrtSlicerCacheNativeItem" */
  },
  /*::[*/
  1103: {
    /* n:"BrtRangeProtection14" */
  },
  /*::[*/
  1104: {
    /* n:"BrtRangeProtectionIso14" */
  },
  /*::[*/
  1105: {
    /* n:"BrtCellIgnoreEC14" */
  },
  /*::[*/
  1111: {
    /* n:"BrtList14" */
  },
  /*::[*/
  1112: {
    /* n:"BrtCFIcon" */
  },
  /*::[*/
  1113: {
    /* n:"BrtBeginSlicerCachesPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  1114: {
    /* n:"BrtEndSlicerCachesPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  1115: {
    /* n:"BrtBeginSlicers", */
    T: 1
  },
  /*::[*/
  1116: {
    /* n:"BrtEndSlicers", */
    T: -1
  },
  /*::[*/
  1117: {
    /* n:"BrtWbProp14" */
  },
  /*::[*/
  1118: {
    /* n:"BrtBeginSXEdit", */
    T: 1
  },
  /*::[*/
  1119: {
    /* n:"BrtEndSXEdit", */
    T: -1
  },
  /*::[*/
  1120: {
    /* n:"BrtBeginSXEdits", */
    T: 1
  },
  /*::[*/
  1121: {
    /* n:"BrtEndSXEdits", */
    T: -1
  },
  /*::[*/
  1122: {
    /* n:"BrtBeginSXChange", */
    T: 1
  },
  /*::[*/
  1123: {
    /* n:"BrtEndSXChange", */
    T: -1
  },
  /*::[*/
  1124: {
    /* n:"BrtBeginSXChanges", */
    T: 1
  },
  /*::[*/
  1125: {
    /* n:"BrtEndSXChanges", */
    T: -1
  },
  /*::[*/
  1126: {
    /* n:"BrtSXTupleItems" */
  },
  /*::[*/
  1128: {
    /* n:"BrtBeginSlicerStyle", */
    T: 1
  },
  /*::[*/
  1129: {
    /* n:"BrtEndSlicerStyle", */
    T: -1
  },
  /*::[*/
  1130: {
    /* n:"BrtSlicerStyleElement" */
  },
  /*::[*/
  1131: {
    /* n:"BrtBeginStyleSheetExt14", */
    T: 1
  },
  /*::[*/
  1132: {
    /* n:"BrtEndStyleSheetExt14", */
    T: -1
  },
  /*::[*/
  1133: {
    /* n:"BrtBeginSlicerCachesPivotCacheID", */
    T: 1
  },
  /*::[*/
  1134: {
    /* n:"BrtEndSlicerCachesPivotCacheID", */
    T: -1
  },
  /*::[*/
  1135: {
    /* n:"BrtBeginConditionalFormattings", */
    T: 1
  },
  /*::[*/
  1136: {
    /* n:"BrtEndConditionalFormattings", */
    T: -1
  },
  /*::[*/
  1137: {
    /* n:"BrtBeginPCDCalcMemExt", */
    T: 1
  },
  /*::[*/
  1138: {
    /* n:"BrtEndPCDCalcMemExt", */
    T: -1
  },
  /*::[*/
  1139: {
    /* n:"BrtBeginPCDCalcMemsExt", */
    T: 1
  },
  /*::[*/
  1140: {
    /* n:"BrtEndPCDCalcMemsExt", */
    T: -1
  },
  /*::[*/
  1141: {
    /* n:"BrtPCDField14" */
  },
  /*::[*/
  1142: {
    /* n:"BrtBeginSlicerStyles", */
    T: 1
  },
  /*::[*/
  1143: {
    /* n:"BrtEndSlicerStyles", */
    T: -1
  },
  /*::[*/
  1144: {
    /* n:"BrtBeginSlicerStyleElements", */
    T: 1
  },
  /*::[*/
  1145: {
    /* n:"BrtEndSlicerStyleElements", */
    T: -1
  },
  /*::[*/
  1146: {
    /* n:"BrtCFRuleExt" */
  },
  /*::[*/
  1147: {
    /* n:"BrtBeginSXCondFmt14", */
    T: 1
  },
  /*::[*/
  1148: {
    /* n:"BrtEndSXCondFmt14", */
    T: -1
  },
  /*::[*/
  1149: {
    /* n:"BrtBeginSXCondFmts14", */
    T: 1
  },
  /*::[*/
  1150: {
    /* n:"BrtEndSXCondFmts14", */
    T: -1
  },
  /*::[*/
  1152: {
    /* n:"BrtBeginSortCond14", */
    T: 1
  },
  /*::[*/
  1153: {
    /* n:"BrtEndSortCond14", */
    T: -1
  },
  /*::[*/
  1154: {
    /* n:"BrtEndDVals14", */
    T: -1
  },
  /*::[*/
  1155: {
    /* n:"BrtEndIconSet14", */
    T: -1
  },
  /*::[*/
  1156: {
    /* n:"BrtEndDatabar14", */
    T: -1
  },
  /*::[*/
  1157: {
    /* n:"BrtBeginColorScale14", */
    T: 1
  },
  /*::[*/
  1158: {
    /* n:"BrtEndColorScale14", */
    T: -1
  },
  /*::[*/
  1159: {
    /* n:"BrtBeginSxrules14", */
    T: 1
  },
  /*::[*/
  1160: {
    /* n:"BrtEndSxrules14", */
    T: -1
  },
  /*::[*/
  1161: {
    /* n:"BrtBeginPRule14", */
    T: 1
  },
  /*::[*/
  1162: {
    /* n:"BrtEndPRule14", */
    T: -1
  },
  /*::[*/
  1163: {
    /* n:"BrtBeginPRFilters14", */
    T: 1
  },
  /*::[*/
  1164: {
    /* n:"BrtEndPRFilters14", */
    T: -1
  },
  /*::[*/
  1165: {
    /* n:"BrtBeginPRFilter14", */
    T: 1
  },
  /*::[*/
  1166: {
    /* n:"BrtEndPRFilter14", */
    T: -1
  },
  /*::[*/
  1167: {
    /* n:"BrtBeginPRFItem14", */
    T: 1
  },
  /*::[*/
  1168: {
    /* n:"BrtEndPRFItem14", */
    T: -1
  },
  /*::[*/
  1169: {
    /* n:"BrtBeginCellIgnoreECs14", */
    T: 1
  },
  /*::[*/
  1170: {
    /* n:"BrtEndCellIgnoreECs14", */
    T: -1
  },
  /*::[*/
  1171: {
    /* n:"BrtDxf14" */
  },
  /*::[*/
  1172: {
    /* n:"BrtBeginDxF14s", */
    T: 1
  },
  /*::[*/
  1173: {
    /* n:"BrtEndDxf14s", */
    T: -1
  },
  /*::[*/
  1177: {
    /* n:"BrtFilter14" */
  },
  /*::[*/
  1178: {
    /* n:"BrtBeginCustomFilters14", */
    T: 1
  },
  /*::[*/
  1180: {
    /* n:"BrtCustomFilter14" */
  },
  /*::[*/
  1181: {
    /* n:"BrtIconFilter14" */
  },
  /*::[*/
  1182: {
    /* n:"BrtPivotCacheConnectionName" */
  },
  /*::[*/
  2048: {
    /* n:"BrtBeginDecoupledPivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2049: {
    /* n:"BrtEndDecoupledPivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2050: {
    /* n:"BrtDecoupledPivotCacheID" */
  },
  /*::[*/
  2051: {
    /* n:"BrtBeginPivotTableRefs", */
    T: 1
  },
  /*::[*/
  2052: {
    /* n:"BrtEndPivotTableRefs", */
    T: -1
  },
  /*::[*/
  2053: {
    /* n:"BrtPivotTableRef" */
  },
  /*::[*/
  2054: {
    /* n:"BrtSlicerCacheBookPivotTables" */
  },
  /*::[*/
  2055: {
    /* n:"BrtBeginSxvcells", */
    T: 1
  },
  /*::[*/
  2056: {
    /* n:"BrtEndSxvcells", */
    T: -1
  },
  /*::[*/
  2057: {
    /* n:"BrtBeginSxRow", */
    T: 1
  },
  /*::[*/
  2058: {
    /* n:"BrtEndSxRow", */
    T: -1
  },
  /*::[*/
  2060: {
    /* n:"BrtPcdCalcMem15" */
  },
  /*::[*/
  2067: {
    /* n:"BrtQsi15" */
  },
  /*::[*/
  2068: {
    /* n:"BrtBeginWebExtensions", */
    T: 1
  },
  /*::[*/
  2069: {
    /* n:"BrtEndWebExtensions", */
    T: -1
  },
  /*::[*/
  2070: {
    /* n:"BrtWebExtension" */
  },
  /*::[*/
  2071: {
    /* n:"BrtAbsPath15" */
  },
  /*::[*/
  2072: {
    /* n:"BrtBeginPivotTableUISettings", */
    T: 1
  },
  /*::[*/
  2073: {
    /* n:"BrtEndPivotTableUISettings", */
    T: -1
  },
  /*::[*/
  2075: {
    /* n:"BrtTableSlicerCacheIDs" */
  },
  /*::[*/
  2076: {
    /* n:"BrtTableSlicerCacheID" */
  },
  /*::[*/
  2077: {
    /* n:"BrtBeginTableSlicerCache", */
    T: 1
  },
  /*::[*/
  2078: {
    /* n:"BrtEndTableSlicerCache", */
    T: -1
  },
  /*::[*/
  2079: {
    /* n:"BrtSxFilter15" */
  },
  /*::[*/
  2080: {
    /* n:"BrtBeginTimelineCachePivotCacheIDs", */
    T: 1
  },
  /*::[*/
  2081: {
    /* n:"BrtEndTimelineCachePivotCacheIDs", */
    T: -1
  },
  /*::[*/
  2082: {
    /* n:"BrtTimelineCachePivotCacheID" */
  },
  /*::[*/
  2083: {
    /* n:"BrtBeginTimelineCacheIDs", */
    T: 1
  },
  /*::[*/
  2084: {
    /* n:"BrtEndTimelineCacheIDs", */
    T: -1
  },
  /*::[*/
  2085: {
    /* n:"BrtBeginTimelineCacheID", */
    T: 1
  },
  /*::[*/
  2086: {
    /* n:"BrtEndTimelineCacheID", */
    T: -1
  },
  /*::[*/
  2087: {
    /* n:"BrtBeginTimelinesEx", */
    T: 1
  },
  /*::[*/
  2088: {
    /* n:"BrtEndTimelinesEx", */
    T: -1
  },
  /*::[*/
  2089: {
    /* n:"BrtBeginTimelineEx", */
    T: 1
  },
  /*::[*/
  2090: {
    /* n:"BrtEndTimelineEx", */
    T: -1
  },
  /*::[*/
  2091: {
    /* n:"BrtWorkBookPr15" */
  },
  /*::[*/
  2092: {
    /* n:"BrtPCDH15" */
  },
  /*::[*/
  2093: {
    /* n:"BrtBeginTimelineStyle", */
    T: 1
  },
  /*::[*/
  2094: {
    /* n:"BrtEndTimelineStyle", */
    T: -1
  },
  /*::[*/
  2095: {
    /* n:"BrtTimelineStyleElement" */
  },
  /*::[*/
  2096: {
    /* n:"BrtBeginTimelineStylesheetExt15", */
    T: 1
  },
  /*::[*/
  2097: {
    /* n:"BrtEndTimelineStylesheetExt15", */
    T: -1
  },
  /*::[*/
  2098: {
    /* n:"BrtBeginTimelineStyles", */
    T: 1
  },
  /*::[*/
  2099: {
    /* n:"BrtEndTimelineStyles", */
    T: -1
  },
  /*::[*/
  2100: {
    /* n:"BrtBeginTimelineStyleElements", */
    T: 1
  },
  /*::[*/
  2101: {
    /* n:"BrtEndTimelineStyleElements", */
    T: -1
  },
  /*::[*/
  2102: {
    /* n:"BrtDxf15" */
  },
  /*::[*/
  2103: {
    /* n:"BrtBeginDxfs15", */
    T: 1
  },
  /*::[*/
  2104: {
    /* n:"BrtEndDxfs15", */
    T: -1
  },
  /*::[*/
  2105: {
    /* n:"BrtSlicerCacheHideItemsWithNoData" */
  },
  /*::[*/
  2106: {
    /* n:"BrtBeginItemUniqueNames", */
    T: 1
  },
  /*::[*/
  2107: {
    /* n:"BrtEndItemUniqueNames", */
    T: -1
  },
  /*::[*/
  2108: {
    /* n:"BrtItemUniqueName" */
  },
  /*::[*/
  2109: {
    /* n:"BrtBeginExtConn15", */
    T: 1
  },
  /*::[*/
  2110: {
    /* n:"BrtEndExtConn15", */
    T: -1
  },
  /*::[*/
  2111: {
    /* n:"BrtBeginOledbPr15", */
    T: 1
  },
  /*::[*/
  2112: {
    /* n:"BrtEndOledbPr15", */
    T: -1
  },
  /*::[*/
  2113: {
    /* n:"BrtBeginDataFeedPr15", */
    T: 1
  },
  /*::[*/
  2114: {
    /* n:"BrtEndDataFeedPr15", */
    T: -1
  },
  /*::[*/
  2115: {
    /* n:"BrtTextPr15" */
  },
  /*::[*/
  2116: {
    /* n:"BrtRangePr15" */
  },
  /*::[*/
  2117: {
    /* n:"BrtDbCommand15" */
  },
  /*::[*/
  2118: {
    /* n:"BrtBeginDbTables15", */
    T: 1
  },
  /*::[*/
  2119: {
    /* n:"BrtEndDbTables15", */
    T: -1
  },
  /*::[*/
  2120: {
    /* n:"BrtDbTable15" */
  },
  /*::[*/
  2121: {
    /* n:"BrtBeginDataModel", */
    T: 1
  },
  /*::[*/
  2122: {
    /* n:"BrtEndDataModel", */
    T: -1
  },
  /*::[*/
  2123: {
    /* n:"BrtBeginModelTables", */
    T: 1
  },
  /*::[*/
  2124: {
    /* n:"BrtEndModelTables", */
    T: -1
  },
  /*::[*/
  2125: {
    /* n:"BrtModelTable" */
  },
  /*::[*/
  2126: {
    /* n:"BrtBeginModelRelationships", */
    T: 1
  },
  /*::[*/
  2127: {
    /* n:"BrtEndModelRelationships", */
    T: -1
  },
  /*::[*/
  2128: {
    /* n:"BrtModelRelationship" */
  },
  /*::[*/
  2129: {
    /* n:"BrtBeginECTxtWiz15", */
    T: 1
  },
  /*::[*/
  2130: {
    /* n:"BrtEndECTxtWiz15", */
    T: -1
  },
  /*::[*/
  2131: {
    /* n:"BrtBeginECTWFldInfoLst15", */
    T: 1
  },
  /*::[*/
  2132: {
    /* n:"BrtEndECTWFldInfoLst15", */
    T: -1
  },
  /*::[*/
  2133: {
    /* n:"BrtBeginECTWFldInfo15", */
    T: 1
  },
  /*::[*/
  2134: {
    /* n:"BrtFieldListActiveItem" */
  },
  /*::[*/
  2135: {
    /* n:"BrtPivotCacheIdVersion" */
  },
  /*::[*/
  2136: {
    /* n:"BrtSXDI15" */
  },
  /*::[*/
  2137: {
    /* n:"BrtBeginModelTimeGroupings", */
    T: 1
  },
  /*::[*/
  2138: {
    /* n:"BrtEndModelTimeGroupings", */
    T: -1
  },
  /*::[*/
  2139: {
    /* n:"BrtBeginModelTimeGrouping", */
    T: 1
  },
  /*::[*/
  2140: {
    /* n:"BrtEndModelTimeGrouping", */
    T: -1
  },
  /*::[*/
  2141: {
    /* n:"BrtModelTimeGroupingCalcCol" */
  },
  /*::[*/
  3072: {
    /* n:"BrtUid" */
  },
  /*::[*/
  3073: {
    /* n:"BrtRevisionPtr" */
  },
  /*::[*/
  4096: {
    /* n:"BrtBeginDynamicArrayPr", */
    T: 1
  },
  /*::[*/
  4097: {
    /* n:"BrtEndDynamicArrayPr", */
    T: -1
  },
  /*::[*/
  5002: {
    /* n:"BrtBeginRichValueBlock", */
    T: 1
  },
  /*::[*/
  5003: {
    /* n:"BrtEndRichValueBlock", */
    T: -1
  },
  /*::[*/
  5081: {
    /* n:"BrtBeginRichFilters", */
    T: 1
  },
  /*::[*/
  5082: {
    /* n:"BrtEndRichFilters", */
    T: -1
  },
  /*::[*/
  5083: {
    /* n:"BrtRichFilter" */
  },
  /*::[*/
  5084: {
    /* n:"BrtBeginRichFilterColumn", */
    T: 1
  },
  /*::[*/
  5085: {
    /* n:"BrtEndRichFilterColumn", */
    T: -1
  },
  /*::[*/
  5086: {
    /* n:"BrtBeginCustomRichFilters", */
    T: 1
  },
  /*::[*/
  5087: {
    /* n:"BrtEndCustomRichFilters", */
    T: -1
  },
  /*::[*/
  5088: {
    /* n:"BrtCustomRichFilter" */
  },
  /*::[*/
  5089: {
    /* n:"BrtTop10RichFilter" */
  },
  /*::[*/
  5090: {
    /* n:"BrtDynamicRichFilter" */
  },
  /*::[*/
  5092: {
    /* n:"BrtBeginRichSortCondition", */
    T: 1
  },
  /*::[*/
  5093: {
    /* n:"BrtEndRichSortCondition", */
    T: -1
  },
  /*::[*/
  5094: {
    /* n:"BrtRichFilterDateGroupItem" */
  },
  /*::[*/
  5095: {
    /* n:"BrtBeginCalcFeatures", */
    T: 1
  },
  /*::[*/
  5096: {
    /* n:"BrtEndCalcFeatures", */
    T: -1
  },
  /*::[*/
  5097: {
    /* n:"BrtCalcFeature" */
  },
  /*::[*/
  5099: {
    /* n:"BrtExternalLinksPr" */
  },
  /*::[*/
  65535: { n: "" }
};
var XLSRecordEnum = {
  /* [MS-XLS] 2.3 Record Enumeration 2021-08-17 */
  /*::[*/
  6: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  10: {
    /* n:"EOF", */
    f: parsenoop2
  },
  /*::[*/
  12: {
    /* n:"CalcCount", */
    f: parseuint16
  },
  //
  /*::[*/
  13: {
    /* n:"CalcMode", */
    f: parseuint16
  },
  //
  /*::[*/
  14: {
    /* n:"CalcPrecision", */
    f: parsebool
  },
  //
  /*::[*/
  15: {
    /* n:"CalcRefMode", */
    f: parsebool
  },
  //
  /*::[*/
  16: {
    /* n:"CalcDelta", */
    f: parse_Xnum
  },
  //
  /*::[*/
  17: {
    /* n:"CalcIter", */
    f: parsebool
  },
  //
  /*::[*/
  18: {
    /* n:"Protect", */
    f: parsebool
  },
  /*::[*/
  19: {
    /* n:"Password", */
    f: parseuint16
  },
  /*::[*/
  20: {
    /* n:"Header", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  21: {
    /* n:"Footer", */
    f: parse_XLHeaderFooter
  },
  /*::[*/
  23: {
    /* n:"ExternSheet", */
    f: parse_ExternSheet
  },
  /*::[*/
  24: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  25: {
    /* n:"WinProtect", */
    f: parsebool
  },
  /*::[*/
  26: {
    /* n:"VerticalPageBreaks", */
  },
  /*::[*/
  27: {
    /* n:"HorizontalPageBreaks", */
  },
  /*::[*/
  28: {
    /* n:"Note", */
    f: parse_Note
  },
  /*::[*/
  29: {
    /* n:"Selection", */
  },
  /*::[*/
  34: {
    /* n:"Date1904", */
    f: parsebool
  },
  /*::[*/
  35: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  38: {
    /* n:"LeftMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  39: {
    /* n:"RightMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  40: {
    /* n:"TopMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  41: {
    /* n:"BottomMargin", */
    f: parse_Xnum
  },
  // *
  /*::[*/
  42: {
    /* n:"PrintRowCol", */
    f: parsebool
  },
  /*::[*/
  43: {
    /* n:"PrintGrid", */
    f: parsebool
  },
  /*::[*/
  47: {
    /* n:"FilePass", */
    f: parse_FilePass
  },
  /*::[*/
  49: {
    /* n:"Font", */
    f: parse_Font
  },
  /*::[*/
  51: {
    /* n:"PrintSize", */
    f: parseuint16
  },
  /*::[*/
  60: {
    /* n:"Continue", */
  },
  /*::[*/
  61: {
    /* n:"Window1", */
    f: parse_Window1
  },
  /*::[*/
  64: {
    /* n:"Backup", */
    f: parsebool
  },
  /*::[*/
  65: {
    /* n:"Pane", */
    f: parse_Pane
  },
  /*::[*/
  66: {
    /* n:"CodePage", */
    f: parseuint16
  },
  /*::[*/
  77: {
    /* n:"Pls", */
  },
  /*::[*/
  80: {
    /* n:"DCon", */
  },
  /*::[*/
  81: {
    /* n:"DConRef", */
  },
  /*::[*/
  82: {
    /* n:"DConName", */
  },
  /*::[*/
  85: {
    /* n:"DefColWidth", */
    f: parseuint16
  },
  /*::[*/
  89: {
    /* n:"XCT", */
  },
  /*::[*/
  90: {
    /* n:"CRN", */
  },
  /*::[*/
  91: {
    /* n:"FileSharing", */
  },
  /*::[*/
  92: {
    /* n:"WriteAccess", */
    f: parse_WriteAccess
  },
  /*::[*/
  93: {
    /* n:"Obj", */
    f: parse_Obj
  },
  /*::[*/
  94: {
    /* n:"Uncalced", */
  },
  /*::[*/
  95: {
    /* n:"CalcSaveRecalc", */
    f: parsebool
  },
  //
  /*::[*/
  96: {
    /* n:"Template", */
  },
  /*::[*/
  97: {
    /* n:"Intl", */
  },
  /*::[*/
  99: {
    /* n:"ObjProtect", */
    f: parsebool
  },
  /*::[*/
  125: {
    /* n:"ColInfo", */
    f: parse_ColInfo
  },
  /*::[*/
  128: {
    /* n:"Guts", */
    f: parse_Guts
  },
  /*::[*/
  129: {
    /* n:"WsBool", */
    f: parse_WsBool
  },
  /*::[*/
  130: {
    /* n:"GridSet", */
    f: parseuint16
  },
  /*::[*/
  131: {
    /* n:"HCenter", */
    f: parsebool
  },
  /*::[*/
  132: {
    /* n:"VCenter", */
    f: parsebool
  },
  /*::[*/
  133: {
    /* n:"BoundSheet8", */
    f: parse_BoundSheet8
  },
  /*::[*/
  134: {
    /* n:"WriteProtect", */
  },
  /*::[*/
  140: {
    /* n:"Country", */
    f: parse_Country
  },
  /*::[*/
  141: {
    /* n:"HideObj", */
    f: parseuint16
  },
  /*::[*/
  144: {
    /* n:"Sort", */
  },
  /*::[*/
  146: {
    /* n:"Palette", */
    f: parse_Palette
  },
  /*::[*/
  151: {
    /* n:"Sync", */
  },
  /*::[*/
  152: {
    /* n:"LPr", */
  },
  /*::[*/
  153: {
    /* n:"DxGCol", */
  },
  /*::[*/
  154: {
    /* n:"FnGroupName", */
  },
  /*::[*/
  155: {
    /* n:"FilterMode", */
  },
  /*::[*/
  156: {
    /* n:"BuiltInFnGroupCount", */
    f: parseuint16
  },
  /*::[*/
  157: {
    /* n:"AutoFilterInfo", */
  },
  /*::[*/
  158: {
    /* n:"AutoFilter", */
  },
  /*::[*/
  160: {
    /* n:"Scl", */
    f: parse_Scl
  },
  /*::[*/
  161: {
    /* n:"Setup", */
    f: parse_Setup
  },
  /*::[*/
  174: {
    /* n:"ScenMan", */
  },
  /*::[*/
  175: {
    /* n:"SCENARIO", */
  },
  /*::[*/
  176: {
    /* n:"SxView", */
  },
  /*::[*/
  177: {
    /* n:"Sxvd", */
  },
  /*::[*/
  178: {
    /* n:"SXVI", */
  },
  /*::[*/
  180: {
    /* n:"SxIvd", */
  },
  /*::[*/
  181: {
    /* n:"SXLI", */
  },
  /*::[*/
  182: {
    /* n:"SXPI", */
  },
  /*::[*/
  184: {
    /* n:"DocRoute", */
  },
  /*::[*/
  185: {
    /* n:"RecipName", */
  },
  /*::[*/
  189: {
    /* n:"MulRk", */
    f: parse_MulRk
  },
  /*::[*/
  190: {
    /* n:"MulBlank", */
    f: parse_MulBlank
  },
  /*::[*/
  193: {
    /* n:"Mms", */
    f: parsenoop2
  },
  /*::[*/
  197: {
    /* n:"SXDI", */
  },
  /*::[*/
  198: {
    /* n:"SXDB", */
  },
  /*::[*/
  199: {
    /* n:"SXFDB", */
  },
  /*::[*/
  200: {
    /* n:"SXDBB", */
  },
  /*::[*/
  201: {
    /* n:"SXNum", */
  },
  /*::[*/
  202: {
    /* n:"SxBool", */
    f: parsebool
  },
  /*::[*/
  203: {
    /* n:"SxErr", */
  },
  /*::[*/
  204: {
    /* n:"SXInt", */
  },
  /*::[*/
  205: {
    /* n:"SXString", */
  },
  /*::[*/
  206: {
    /* n:"SXDtr", */
  },
  /*::[*/
  207: {
    /* n:"SxNil", */
  },
  /*::[*/
  208: {
    /* n:"SXTbl", */
  },
  /*::[*/
  209: {
    /* n:"SXTBRGIITM", */
  },
  /*::[*/
  210: {
    /* n:"SxTbpg", */
  },
  /*::[*/
  211: {
    /* n:"ObProj", */
  },
  /*::[*/
  213: {
    /* n:"SXStreamID", */
  },
  /*::[*/
  215: {
    /* n:"DBCell", */
  },
  /*::[*/
  216: {
    /* n:"SXRng", */
  },
  /*::[*/
  217: {
    /* n:"SxIsxoper", */
  },
  /*::[*/
  218: {
    /* n:"BookBool", */
    f: parseuint16
  },
  /*::[*/
  220: {
    /* n:"DbOrParamQry", */
  },
  /*::[*/
  221: {
    /* n:"ScenarioProtect", */
    f: parsebool
  },
  /*::[*/
  222: {
    /* n:"OleObjectSize", */
  },
  /*::[*/
  224: {
    /* n:"XF", */
    f: parse_XF
  },
  /*::[*/
  225: {
    /* n:"InterfaceHdr", */
    f: parse_InterfaceHdr
  },
  /*::[*/
  226: {
    /* n:"InterfaceEnd", */
    f: parsenoop2
  },
  /*::[*/
  227: {
    /* n:"SXVS", */
  },
  /*::[*/
  229: {
    /* n:"MergeCells", */
    f: parse_MergeCells
  },
  /*::[*/
  233: {
    /* n:"BkHim", */
  },
  /*::[*/
  235: {
    /* n:"MsoDrawingGroup", */
  },
  /*::[*/
  236: {
    /* n:"MsoDrawing", */
  },
  /*::[*/
  237: {
    /* n:"MsoDrawingSelection", */
  },
  /*::[*/
  239: {
    /* n:"PhoneticInfo", */
  },
  /*::[*/
  240: {
    /* n:"SxRule", */
  },
  /*::[*/
  241: {
    /* n:"SXEx", */
  },
  /*::[*/
  242: {
    /* n:"SxFilt", */
  },
  /*::[*/
  244: {
    /* n:"SxDXF", */
  },
  /*::[*/
  245: {
    /* n:"SxItm", */
  },
  /*::[*/
  246: {
    /* n:"SxName", */
  },
  /*::[*/
  247: {
    /* n:"SxSelect", */
  },
  /*::[*/
  248: {
    /* n:"SXPair", */
  },
  /*::[*/
  249: {
    /* n:"SxFmla", */
  },
  /*::[*/
  251: {
    /* n:"SxFormat", */
  },
  /*::[*/
  252: {
    /* n:"SST", */
    f: parse_SST
  },
  /*::[*/
  253: {
    /* n:"LabelSst", */
    f: parse_LabelSst
  },
  /*::[*/
  255: {
    /* n:"ExtSST", */
    f: parse_ExtSST
  },
  /*::[*/
  256: {
    /* n:"SXVDEx", */
  },
  /*::[*/
  259: {
    /* n:"SXFormula", */
  },
  /*::[*/
  290: {
    /* n:"SXDBEx", */
  },
  /*::[*/
  311: {
    /* n:"RRDInsDel", */
  },
  /*::[*/
  312: {
    /* n:"RRDHead", */
  },
  /*::[*/
  315: {
    /* n:"RRDChgCell", */
  },
  /*::[*/
  317: {
    /* n:"RRTabId", */
    f: parseuint16a
  },
  /*::[*/
  318: {
    /* n:"RRDRenSheet", */
  },
  /*::[*/
  319: {
    /* n:"RRSort", */
  },
  /*::[*/
  320: {
    /* n:"RRDMove", */
  },
  /*::[*/
  330: {
    /* n:"RRFormat", */
  },
  /*::[*/
  331: {
    /* n:"RRAutoFmt", */
  },
  /*::[*/
  333: {
    /* n:"RRInsertSh", */
  },
  /*::[*/
  334: {
    /* n:"RRDMoveBegin", */
  },
  /*::[*/
  335: {
    /* n:"RRDMoveEnd", */
  },
  /*::[*/
  336: {
    /* n:"RRDInsDelBegin", */
  },
  /*::[*/
  337: {
    /* n:"RRDInsDelEnd", */
  },
  /*::[*/
  338: {
    /* n:"RRDConflict", */
  },
  /*::[*/
  339: {
    /* n:"RRDDefName", */
  },
  /*::[*/
  340: {
    /* n:"RRDRstEtxp", */
  },
  /*::[*/
  351: {
    /* n:"LRng", */
  },
  /*::[*/
  352: {
    /* n:"UsesELFs", */
    f: parsebool
  },
  /*::[*/
  353: {
    /* n:"DSF", */
    f: parsenoop2
  },
  /*::[*/
  401: {
    /* n:"CUsr", */
  },
  /*::[*/
  402: {
    /* n:"CbUsr", */
  },
  /*::[*/
  403: {
    /* n:"UsrInfo", */
  },
  /*::[*/
  404: {
    /* n:"UsrExcl", */
  },
  /*::[*/
  405: {
    /* n:"FileLock", */
  },
  /*::[*/
  406: {
    /* n:"RRDInfo", */
  },
  /*::[*/
  407: {
    /* n:"BCUsrs", */
  },
  /*::[*/
  408: {
    /* n:"UsrChk", */
  },
  /*::[*/
  425: {
    /* n:"UserBView", */
  },
  /*::[*/
  426: {
    /* n:"UserSViewBegin", */
  },
  /*::[*/
  427: {
    /* n:"UserSViewEnd", */
  },
  /*::[*/
  428: {
    /* n:"RRDUserView", */
  },
  /*::[*/
  429: {
    /* n:"Qsi", */
  },
  /*::[*/
  430: {
    /* n:"SupBook", */
    f: parse_SupBook
  },
  /*::[*/
  431: {
    /* n:"Prot4Rev", */
    f: parsebool
  },
  /*::[*/
  432: {
    /* n:"CondFmt", */
  },
  /*::[*/
  433: {
    /* n:"CF", */
  },
  /*::[*/
  434: {
    /* n:"DVal", */
  },
  /*::[*/
  437: {
    /* n:"DConBin", */
  },
  /*::[*/
  438: {
    /* n:"TxO", */
    f: parse_TxO
  },
  /*::[*/
  439: {
    /* n:"RefreshAll", */
    f: parsebool
  },
  //
  /*::[*/
  440: {
    /* n:"HLink", */
    f: parse_HLink
  },
  /*::[*/
  441: {
    /* n:"Lel", */
  },
  /*::[*/
  442: {
    /* n:"CodeName", */
    f: parse_XLUnicodeString
  },
  /*::[*/
  443: {
    /* n:"SXFDBType", */
  },
  /*::[*/
  444: {
    /* n:"Prot4RevPass", */
    f: parseuint16
  },
  /*::[*/
  445: {
    /* n:"ObNoMacros", */
  },
  /*::[*/
  446: {
    /* n:"Dv", */
  },
  /*::[*/
  448: {
    /* n:"Excel9File", */
    f: parsenoop2
  },
  /*::[*/
  449: {
    /* n:"RecalcId", */
    f: parse_RecalcId,
    r: 2
  },
  /*::[*/
  450: {
    /* n:"EntExU2", */
    f: parsenoop2
  },
  /*::[*/
  512: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  513: {
    /* n:"Blank", */
    f: parse_Blank
  },
  /*::[*/
  515: {
    /* n:"Number", */
    f: parse_Number
  },
  /*::[*/
  516: {
    /* n:"Label", */
    f: parse_Label
  },
  /*::[*/
  517: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  519: {
    /* n:"String", */
    f: parse_String
  },
  /*::[*/
  520: {
    /* n:"Row", */
    f: parse_Row
  },
  /*::[*/
  523: {
    /* n:"Index", */
  },
  /*::[*/
  545: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  549: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  /*::[*/
  566: {
    /* n:"Table", */
  },
  /*::[*/
  574: {
    /* n:"Window2", */
    f: parse_Window2
  },
  /*::[*/
  638: {
    /* n:"RK", */
    f: parse_RK
  },
  /*::[*/
  659: {
    /* n:"Style", */
  },
  /*::[*/
  1048: {
    /* n:"BigName", */
  },
  /*::[*/
  1054: {
    /* n:"Format", */
    f: parse_Format
  },
  /*::[*/
  1084: {
    /* n:"ContinueBigName", */
  },
  /*::[*/
  1212: {
    /* n:"ShrFmla", */
    f: parse_ShrFmla
  },
  /*::[*/
  2048: {
    /* n:"HLinkTooltip", */
    f: parse_HLinkTooltip
  },
  /*::[*/
  2049: {
    /* n:"WebPub", */
  },
  /*::[*/
  2050: {
    /* n:"QsiSXTag", */
  },
  /*::[*/
  2051: {
    /* n:"DBQueryExt", */
  },
  /*::[*/
  2052: {
    /* n:"ExtString", */
  },
  /*::[*/
  2053: {
    /* n:"TxtQry", */
  },
  /*::[*/
  2054: {
    /* n:"Qsir", */
  },
  /*::[*/
  2055: {
    /* n:"Qsif", */
  },
  /*::[*/
  2056: {
    /* n:"RRDTQSIF", */
  },
  /*::[*/
  2057: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  2058: {
    /* n:"OleDbConn", */
  },
  /*::[*/
  2059: {
    /* n:"WOpt", */
  },
  /*::[*/
  2060: {
    /* n:"SXViewEx", */
  },
  /*::[*/
  2061: {
    /* n:"SXTH", */
  },
  /*::[*/
  2062: {
    /* n:"SXPIEx", */
  },
  /*::[*/
  2063: {
    /* n:"SXVDTEx", */
  },
  /*::[*/
  2064: {
    /* n:"SXViewEx9", */
  },
  /*::[*/
  2066: {
    /* n:"ContinueFrt", */
  },
  /*::[*/
  2067: {
    /* n:"RealTimeData", */
  },
  /*::[*/
  2128: {
    /* n:"ChartFrtInfo", */
  },
  /*::[*/
  2129: {
    /* n:"FrtWrapper", */
  },
  /*::[*/
  2130: {
    /* n:"StartBlock", */
  },
  /*::[*/
  2131: {
    /* n:"EndBlock", */
  },
  /*::[*/
  2132: {
    /* n:"StartObject", */
  },
  /*::[*/
  2133: {
    /* n:"EndObject", */
  },
  /*::[*/
  2134: {
    /* n:"CatLab", */
  },
  /*::[*/
  2135: {
    /* n:"YMult", */
  },
  /*::[*/
  2136: {
    /* n:"SXViewLink", */
  },
  /*::[*/
  2137: {
    /* n:"PivotChartBits", */
  },
  /*::[*/
  2138: {
    /* n:"FrtFontList", */
  },
  /*::[*/
  2146: {
    /* n:"SheetExt", */
  },
  /*::[*/
  2147: {
    /* n:"BookExt", */
    r: 12
  },
  /*::[*/
  2148: {
    /* n:"SXAddl", */
  },
  /*::[*/
  2149: {
    /* n:"CrErr", */
  },
  /*::[*/
  2150: {
    /* n:"HFPicture", */
  },
  /*::[*/
  2151: {
    /* n:"FeatHdr", */
    f: parsenoop2
  },
  /*::[*/
  2152: {
    /* n:"Feat", */
  },
  /*::[*/
  2154: {
    /* n:"DataLabExt", */
  },
  /*::[*/
  2155: {
    /* n:"DataLabExtContents", */
  },
  /*::[*/
  2156: {
    /* n:"CellWatch", */
  },
  /*::[*/
  2161: {
    /* n:"FeatHdr11", */
  },
  /*::[*/
  2162: {
    /* n:"Feature11", */
  },
  /*::[*/
  2164: {
    /* n:"DropDownObjIds", */
  },
  /*::[*/
  2165: {
    /* n:"ContinueFrt11", */
  },
  /*::[*/
  2166: {
    /* n:"DConn", */
  },
  /*::[*/
  2167: {
    /* n:"List12", */
  },
  /*::[*/
  2168: {
    /* n:"Feature12", */
  },
  /*::[*/
  2169: {
    /* n:"CondFmt12", */
  },
  /*::[*/
  2170: {
    /* n:"CF12", */
  },
  /*::[*/
  2171: {
    /* n:"CFEx", */
  },
  /*::[*/
  2172: {
    /* n:"XFCRC", */
    f: parse_XFCRC,
    r: 12
  },
  /*::[*/
  2173: {
    /* n:"XFExt", */
    f: parse_XFExt,
    r: 12
  },
  /*::[*/
  2174: {
    /* n:"AutoFilter12", */
  },
  /*::[*/
  2175: {
    /* n:"ContinueFrt12", */
  },
  /*::[*/
  2180: {
    /* n:"MDTInfo", */
  },
  /*::[*/
  2181: {
    /* n:"MDXStr", */
  },
  /*::[*/
  2182: {
    /* n:"MDXTuple", */
  },
  /*::[*/
  2183: {
    /* n:"MDXSet", */
  },
  /*::[*/
  2184: {
    /* n:"MDXProp", */
  },
  /*::[*/
  2185: {
    /* n:"MDXKPI", */
  },
  /*::[*/
  2186: {
    /* n:"MDB", */
  },
  /*::[*/
  2187: {
    /* n:"PLV", */
  },
  /*::[*/
  2188: {
    /* n:"Compat12", */
    f: parsebool,
    r: 12
  },
  /*::[*/
  2189: {
    /* n:"DXF", */
  },
  /*::[*/
  2190: {
    /* n:"TableStyles", */
    r: 12
  },
  /*::[*/
  2191: {
    /* n:"TableStyle", */
  },
  /*::[*/
  2192: {
    /* n:"TableStyleElement", */
  },
  /*::[*/
  2194: {
    /* n:"StyleExt", */
  },
  /*::[*/
  2195: {
    /* n:"NamePublish", */
  },
  /*::[*/
  2196: {
    /* n:"NameCmt", */
    f: parse_NameCmt,
    r: 12
  },
  /*::[*/
  2197: {
    /* n:"SortData", */
  },
  /*::[*/
  2198: {
    /* n:"Theme", */
    f: parse_Theme,
    r: 12
  },
  /*::[*/
  2199: {
    /* n:"GUIDTypeLib", */
  },
  /*::[*/
  2200: {
    /* n:"FnGrp12", */
  },
  /*::[*/
  2201: {
    /* n:"NameFnGrp12", */
  },
  /*::[*/
  2202: {
    /* n:"MTRSettings", */
    f: parse_MTRSettings,
    r: 12
  },
  /*::[*/
  2203: {
    /* n:"CompressPictures", */
    f: parsenoop2
  },
  /*::[*/
  2204: {
    /* n:"HeaderFooter", */
  },
  /*::[*/
  2205: {
    /* n:"CrtLayout12", */
  },
  /*::[*/
  2206: {
    /* n:"CrtMlFrt", */
  },
  /*::[*/
  2207: {
    /* n:"CrtMlFrtContinue", */
  },
  /*::[*/
  2211: {
    /* n:"ForceFullCalculation", */
    f: parse_ForceFullCalculation
  },
  /*::[*/
  2212: {
    /* n:"ShapePropsStream", */
  },
  /*::[*/
  2213: {
    /* n:"TextPropsStream", */
  },
  /*::[*/
  2214: {
    /* n:"RichTextStream", */
  },
  /*::[*/
  2215: {
    /* n:"CrtLayout12A", */
  },
  /*::[*/
  4097: {
    /* n:"Units", */
  },
  /*::[*/
  4098: {
    /* n:"Chart", */
  },
  /*::[*/
  4099: {
    /* n:"Series", */
  },
  /*::[*/
  4102: {
    /* n:"DataFormat", */
  },
  /*::[*/
  4103: {
    /* n:"LineFormat", */
  },
  /*::[*/
  4105: {
    /* n:"MarkerFormat", */
  },
  /*::[*/
  4106: {
    /* n:"AreaFormat", */
  },
  /*::[*/
  4107: {
    /* n:"PieFormat", */
  },
  /*::[*/
  4108: {
    /* n:"AttachedLabel", */
  },
  /*::[*/
  4109: {
    /* n:"SeriesText", */
  },
  /*::[*/
  4116: {
    /* n:"ChartFormat", */
  },
  /*::[*/
  4117: {
    /* n:"Legend", */
  },
  /*::[*/
  4118: {
    /* n:"SeriesList", */
  },
  /*::[*/
  4119: {
    /* n:"Bar", */
  },
  /*::[*/
  4120: {
    /* n:"Line", */
  },
  /*::[*/
  4121: {
    /* n:"Pie", */
  },
  /*::[*/
  4122: {
    /* n:"Area", */
  },
  /*::[*/
  4123: {
    /* n:"Scatter", */
  },
  /*::[*/
  4124: {
    /* n:"CrtLine", */
  },
  /*::[*/
  4125: {
    /* n:"Axis", */
  },
  /*::[*/
  4126: {
    /* n:"Tick", */
  },
  /*::[*/
  4127: {
    /* n:"ValueRange", */
  },
  /*::[*/
  4128: {
    /* n:"CatSerRange", */
  },
  /*::[*/
  4129: {
    /* n:"AxisLine", */
  },
  /*::[*/
  4130: {
    /* n:"CrtLink", */
  },
  /*::[*/
  4132: {
    /* n:"DefaultText", */
  },
  /*::[*/
  4133: {
    /* n:"Text", */
  },
  /*::[*/
  4134: {
    /* n:"FontX", */
    f: parseuint16
  },
  /*::[*/
  4135: {
    /* n:"ObjectLink", */
  },
  /*::[*/
  4146: {
    /* n:"Frame", */
  },
  /*::[*/
  4147: {
    /* n:"Begin", */
  },
  /*::[*/
  4148: {
    /* n:"End", */
  },
  /*::[*/
  4149: {
    /* n:"PlotArea", */
  },
  /*::[*/
  4154: {
    /* n:"Chart3d", */
  },
  /*::[*/
  4156: {
    /* n:"PicF", */
  },
  /*::[*/
  4157: {
    /* n:"DropBar", */
  },
  /*::[*/
  4158: {
    /* n:"Radar", */
  },
  /*::[*/
  4159: {
    /* n:"Surf", */
  },
  /*::[*/
  4160: {
    /* n:"RadarArea", */
  },
  /*::[*/
  4161: {
    /* n:"AxisParent", */
  },
  /*::[*/
  4163: {
    /* n:"LegendException", */
  },
  /*::[*/
  4164: {
    /* n:"ShtProps", */
    f: parse_ShtProps
  },
  /*::[*/
  4165: {
    /* n:"SerToCrt", */
  },
  /*::[*/
  4166: {
    /* n:"AxesUsed", */
  },
  /*::[*/
  4168: {
    /* n:"SBaseRef", */
  },
  /*::[*/
  4170: {
    /* n:"SerParent", */
  },
  /*::[*/
  4171: {
    /* n:"SerAuxTrend", */
  },
  /*::[*/
  4174: {
    /* n:"IFmtRecord", */
  },
  /*::[*/
  4175: {
    /* n:"Pos", */
  },
  /*::[*/
  4176: {
    /* n:"AlRuns", */
  },
  /*::[*/
  4177: {
    /* n:"BRAI", */
  },
  /*::[*/
  4187: {
    /* n:"SerAuxErrBar", */
  },
  /*::[*/
  4188: {
    /* n:"ClrtClient", */
    f: parse_ClrtClient
  },
  /*::[*/
  4189: {
    /* n:"SerFmt", */
  },
  /*::[*/
  4191: {
    /* n:"Chart3DBarShape", */
  },
  /*::[*/
  4192: {
    /* n:"Fbi", */
  },
  /*::[*/
  4193: {
    /* n:"BopPop", */
  },
  /*::[*/
  4194: {
    /* n:"AxcExt", */
  },
  /*::[*/
  4195: {
    /* n:"Dat", */
  },
  /*::[*/
  4196: {
    /* n:"PlotGrowth", */
  },
  /*::[*/
  4197: {
    /* n:"SIIndex", */
  },
  /*::[*/
  4198: {
    /* n:"GelFrame", */
  },
  /*::[*/
  4199: {
    /* n:"BopPopCustom", */
  },
  /*::[*/
  4200: {
    /* n:"Fbi2", */
  },
  /*::[*/
  0: {
    /* n:"Dimensions", */
    f: parse_Dimensions
  },
  /*::[*/
  1: {
    /* n:"BIFF2BLANK", */
  },
  /*::[*/
  2: {
    /* n:"BIFF2INT", */
    f: parse_BIFF2INT
  },
  /*::[*/
  3: {
    /* n:"BIFF2NUM", */
    f: parse_BIFF2NUM
  },
  /*::[*/
  4: {
    /* n:"BIFF2STR", */
    f: parse_BIFF2STR
  },
  /*::[*/
  5: {
    /* n:"BoolErr", */
    f: parse_BoolErr
  },
  /*::[*/
  7: {
    /* n:"String", */
    f: parse_BIFF2STRING
  },
  /*::[*/
  8: {
    /* n:"BIFF2ROW", */
  },
  /*::[*/
  9: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  11: {
    /* n:"Index", */
  },
  /*::[*/
  22: {
    /* n:"ExternCount", */
    f: parseuint16
  },
  /*::[*/
  30: {
    /* n:"BIFF2FORMAT", */
    f: parse_BIFF2Format
  },
  /*::[*/
  31: {
    /* n:"BIFF2FMTCNT", */
  },
  /* 16-bit cnt of BIFF2FORMAT records */
  /*::[*/
  32: {
    /* n:"BIFF2COLINFO", */
  },
  /*::[*/
  33: {
    /* n:"Array", */
    f: parse_Array
  },
  /*::[*/
  36: {
    /* n:"COLWIDTH", */
  },
  /*::[*/
  37: {
    /* n:"DefaultRowHeight", */
    f: parse_DefaultRowHeight
  },
  // 0x2c ??
  // 0x2d ??
  // 0x2e ??
  // 0x30 FONTCOUNT: number of fonts
  /*::[*/
  50: {
    /* n:"BIFF2FONTXTRA", */
    f: parse_BIFF2FONTXTRA
  },
  // 0x35: INFOOPTS
  // 0x36: TABLE (BIFF2 only)
  // 0x37: TABLE2 (BIFF2 only)
  // 0x38: WNDESK
  // 0x39 ??
  // 0x3a: BEGINPREF
  // 0x3b: ENDPREF
  /*::[*/
  62: {
    /* n:"BIFF2WINDOW2", */
  },
  // 0x3f ??
  // 0x46: SHOWSCROLL
  // 0x47: SHOWFORMULA
  // 0x48: STATUSBAR
  // 0x49: SHORTMENUS
  // 0x4A:
  // 0x4B:
  // 0x4C:
  // 0x4E:
  // 0x4F:
  // 0x58: TOOLBAR (BIFF3)
  /* - - - */
  /*::[*/
  52: {
    /* n:"DDEObjName", */
  },
  /*::[*/
  67: {
    /* n:"BIFF2XF", */
  },
  /*::[*/
  68: {
    /* n:"BIFF2XFINDEX", */
    f: parseuint16
  },
  /*::[*/
  69: {
    /* n:"BIFF2FONTCLR", */
  },
  /*::[*/
  86: {
    /* n:"BIFF4FMTCNT", */
  },
  /* 16-bit cnt, similar to BIFF2 */
  /*::[*/
  126: {
    /* n:"RK", */
  },
  /* Not necessarily same as 0x027e */
  /*::[*/
  127: {
    /* n:"ImData", */
    f: parse_ImData
  },
  /*::[*/
  135: {
    /* n:"Addin", */
  },
  /*::[*/
  136: {
    /* n:"Edg", */
  },
  /*::[*/
  137: {
    /* n:"Pub", */
  },
  // 0x8A
  // 0x8B LH: alternate menu key flag (BIFF3/4)
  // 0x8E
  // 0x8F
  /*::[*/
  145: {
    /* n:"Sub", */
  },
  // 0x93 STYLE
  /*::[*/
  148: {
    /* n:"LHRecord", */
  },
  /*::[*/
  149: {
    /* n:"LHNGraph", */
  },
  /*::[*/
  150: {
    /* n:"Sound", */
  },
  // 0xA2 FNPROTO: function prototypes (BIFF4)
  // 0xA3
  // 0xA8
  /*::[*/
  169: {
    /* n:"CoordList", */
  },
  /*::[*/
  171: {
    /* n:"GCW", */
  },
  /*::[*/
  188: {
    /* n:"ShrFmla", */
  },
  /* Not necessarily same as 0x04bc */
  /*::[*/
  191: {
    /* n:"ToolbarHdr", */
  },
  /*::[*/
  192: {
    /* n:"ToolbarEnd", */
  },
  /*::[*/
  194: {
    /* n:"AddMenu", */
  },
  /*::[*/
  195: {
    /* n:"DelMenu", */
  },
  /*::[*/
  214: {
    /* n:"RString", */
    f: parse_RString
  },
  /*::[*/
  223: {
    /* n:"UDDesc", */
  },
  /*::[*/
  234: {
    /* n:"TabIdConf", */
  },
  /*::[*/
  354: {
    /* n:"XL5Modify", */
  },
  /*::[*/
  421: {
    /* n:"FileSharing2", */
  },
  /*::[*/
  518: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  521: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  536: {
    /* n:"Lbl", */
    f: parse_Lbl
  },
  /*::[*/
  547: {
    /* n:"ExternName", */
    f: parse_ExternName
  },
  /*::[*/
  561: {
    /* n:"Font", */
  },
  /*::[*/
  579: {
    /* n:"BIFF3XF", */
  },
  /*::[*/
  1030: {
    /* n:"Formula", */
    f: parse_Formula
  },
  /*::[*/
  1033: {
    /* n:"BOF", */
    f: parse_BOF
  },
  /*::[*/
  1091: {
    /* n:"BIFF4XF", */
  },
  /*::[*/
  2157: {
    /* n:"FeatInfo", */
  },
  /*::[*/
  2163: {
    /* n:"FeatInfo11", */
  },
  /*::[*/
  2177: {
    /* n:"SXAddl12", */
  },
  /*::[*/
  2240: {
    /* n:"AutoWebPub", */
  },
  /*::[*/
  2241: {
    /* n:"ListObj", */
  },
  /*::[*/
  2242: {
    /* n:"ListField", */
  },
  /*::[*/
  2243: {
    /* n:"ListDV", */
  },
  /*::[*/
  2244: {
    /* n:"ListCondFmt", */
  },
  /*::[*/
  2245: {
    /* n:"ListCF", */
  },
  /*::[*/
  2246: {
    /* n:"FMQry", */
  },
  /*::[*/
  2247: {
    /* n:"FMSQry", */
  },
  /*::[*/
  2248: {
    /* n:"PLV", */
  },
  /*::[*/
  2249: {
    /* n:"LnExt", */
  },
  /*::[*/
  2250: {
    /* n:"MkrExt", */
  },
  /*::[*/
  2251: {
    /* n:"CrtCoopt", */
  },
  /*::[*/
  2262: {
    /* n:"FRTArchId$", */
    r: 12
  },
  /*::[*/
  29282: {}
};
function write_biff_rec(ba, type, payload, length) {
  var t3 = type;
  if (isNaN(t3)) return;
  var len = length || (payload || []).length || 0;
  var o2 = ba.next(4);
  o2.write_shift(2, t3);
  o2.write_shift(2, len);
  if (
    /*:: len != null &&*/
    len > 0 && is_buf(payload)
  ) ba.push(payload);
}
function write_biff_continue(ba, type, payload, length) {
  var len = (payload || []).length || 0;
  if (len <= 8224) return write_biff_rec(ba, type, payload, len);
  var t3 = type;
  if (isNaN(t3)) return;
  var parts = payload.parts || [], sidx = 0;
  var i3 = 0, w3 = 0;
  while (w3 + (parts[sidx] || 8224) <= 8224) {
    w3 += parts[sidx] || 8224;
    sidx++;
  }
  var o2 = ba.next(4);
  o2.write_shift(2, t3);
  o2.write_shift(2, w3);
  ba.push(payload.slice(i3, i3 + w3));
  i3 += w3;
  while (i3 < len) {
    o2 = ba.next(4);
    o2.write_shift(2, 60);
    w3 = 0;
    while (w3 + (parts[sidx] || 8224) <= 8224) {
      w3 += parts[sidx] || 8224;
      sidx++;
    }
    o2.write_shift(2, w3);
    ba.push(payload.slice(i3, i3 + w3));
    i3 += w3;
  }
}
function write_BIFF2Cell(out, r2, c3) {
  if (!out) out = new_buf(7);
  out.write_shift(2, r2);
  out.write_shift(2, c3);
  out.write_shift(2, 0);
  out.write_shift(1, 0);
  return out;
}
function write_BIFF2BERR(r2, c3, val, t3) {
  var out = new_buf(9);
  write_BIFF2Cell(out, r2, c3);
  write_Bes(val, t3 || "b", out);
  return out;
}
function write_BIFF2LABEL(r2, c3, val) {
  var out = new_buf(8 + 2 * val.length);
  write_BIFF2Cell(out, r2, c3);
  out.write_shift(1, val.length);
  out.write_shift(val.length, val, "sbcs");
  return out.l < out.length ? out.slice(0, out.l) : out;
}
function write_ws_biff2_cell(ba, cell, R3, C2) {
  if (cell.v != null) switch (cell.t) {
    case "d":
    case "n":
      var v2 = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
      if (v2 == (v2 | 0) && v2 >= 0 && v2 < 65536)
        write_biff_rec(ba, 2, write_BIFF2INT(R3, C2, v2));
      else
        write_biff_rec(ba, 3, write_BIFF2NUM(R3, C2, v2));
      return;
    case "b":
    case "e":
      write_biff_rec(ba, 5, write_BIFF2BERR(R3, C2, cell.v, cell.t));
      return;
    case "s":
    case "str":
      write_biff_rec(ba, 4, write_BIFF2LABEL(R3, C2, (cell.v || "").slice(0, 255)));
      return;
  }
  write_biff_rec(ba, 1, write_BIFF2Cell(null, R3, C2));
}
function write_ws_biff2(ba, ws, idx, opts) {
  var dense = Array.isArray(ws);
  var range = safe_decode_range(ws["!ref"] || "A1"), ref, rr = "", cols = [];
  if (range.e.c > 255 || range.e.r > 16383) {
    if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, 16383);
    ref = encode_range(range);
  }
  for (var R3 = range.s.r; R3 <= range.e.r; ++R3) {
    rr = encode_row(R3);
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      if (R3 === range.s.r) cols[C2] = encode_col(C2);
      ref = cols[C2] + rr;
      var cell = dense ? (ws[R3] || [])[C2] : ws[ref];
      if (!cell) continue;
      write_ws_biff2_cell(ba, cell, R3, C2);
    }
  }
}
function write_biff2_buf(wb2, opts) {
  var o2 = opts || {};
  var ba = buf_array();
  var idx = 0;
  for (var i3 = 0; i3 < wb2.SheetNames.length; ++i3) if (wb2.SheetNames[i3] == o2.sheet) idx = i3;
  if (idx == 0 && !!o2.sheet && wb2.SheetNames[0] != o2.sheet) throw new Error("Sheet not found: " + o2.sheet);
  write_biff_rec(ba, o2.biff == 4 ? 1033 : o2.biff == 3 ? 521 : 9, write_BOF(wb2, 16, o2));
  write_ws_biff2(ba, wb2.Sheets[wb2.SheetNames[idx]], idx, o2);
  write_biff_rec(ba, 10);
  return ba.end();
}
function write_FONTS_biff8(ba, data, opts) {
  write_biff_rec(ba, 49, write_Font({
    sz: 12,
    name: "Arial"
  }, opts));
}
function write_FMTS_biff8(ba, NF, opts) {
  if (!NF) return;
  [[5, 8], [23, 26], [41, 44], [
    /*63*/
    50,
    /*66],[164,*/
    392
  ]].forEach(function(r2) {
    for (var i3 = r2[0]; i3 <= r2[1]; ++i3) if (NF[i3] != null) write_biff_rec(ba, 1054, write_Format(i3, NF[i3], opts));
  });
}
function write_FEAT(ba, ws) {
  var o2 = new_buf(19);
  o2.write_shift(4, 2151);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 3);
  o2.write_shift(1, 1);
  o2.write_shift(4, 0);
  write_biff_rec(ba, 2151, o2);
  o2 = new_buf(39);
  o2.write_shift(4, 2152);
  o2.write_shift(4, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 3);
  o2.write_shift(1, 0);
  o2.write_shift(4, 0);
  o2.write_shift(2, 1);
  o2.write_shift(4, 4);
  o2.write_shift(2, 0);
  write_Ref8U(safe_decode_range(ws["!ref"] || "A1"), o2);
  o2.write_shift(4, 4);
  write_biff_rec(ba, 2152, o2);
}
function write_CELLXFS_biff8(ba, opts) {
  for (var i3 = 0; i3 < 16; ++i3) write_biff_rec(ba, 224, write_XF({ numFmtId: 0, style: true }, 0, opts));
  opts.cellXfs.forEach(function(c3) {
    write_biff_rec(ba, 224, write_XF(c3, 0, opts));
  });
}
function write_ws_biff8_hlinks(ba, ws) {
  for (var R3 = 0; R3 < ws["!links"].length; ++R3) {
    var HL = ws["!links"][R3];
    write_biff_rec(ba, 440, write_HLink(HL));
    if (HL[1].Tooltip) write_biff_rec(ba, 2048, write_HLinkTooltip(HL));
  }
  delete ws["!links"];
}
function write_ws_cols_biff8(ba, cols) {
  if (!cols) return;
  var cnt = 0;
  cols.forEach(function(col, idx) {
    if (++cnt <= 256 && col) {
      write_biff_rec(ba, 125, write_ColInfo(col_obj_w(idx, col), idx));
    }
  });
}
function write_ws_biff8_cell(ba, cell, R3, C2, opts) {
  var os = 16 + get_cell_style(opts.cellXfs, cell, opts);
  if (cell.v == null && !cell.bf) {
    write_biff_rec(ba, 513, write_XLSCell(R3, C2, os));
    return;
  }
  if (cell.bf) write_biff_rec(ba, 6, write_Formula(cell, R3, C2, opts, os));
  else switch (cell.t) {
    case "d":
    case "n":
      var v2 = cell.t == "d" ? datenum(parseDate(cell.v)) : cell.v;
      write_biff_rec(ba, 515, write_Number(R3, C2, v2, os));
      break;
    case "b":
    case "e":
      write_biff_rec(ba, 517, write_BoolErr(R3, C2, cell.v, os, opts, cell.t));
      break;
    case "s":
    case "str":
      if (opts.bookSST) {
        var isst = get_sst_id(opts.Strings, cell.v, opts.revStrings);
        write_biff_rec(ba, 253, write_LabelSst(R3, C2, isst, os));
      } else write_biff_rec(ba, 516, write_Label(R3, C2, (cell.v || "").slice(0, 255), os, opts));
      break;
    default:
      write_biff_rec(ba, 513, write_XLSCell(R3, C2, os));
  }
}
function write_ws_biff8(idx, opts, wb2) {
  var ba = buf_array();
  var s4 = wb2.SheetNames[idx], ws = wb2.Sheets[s4] || {};
  var _WB = (wb2 || {}).Workbook || {};
  var _sheet = (_WB.Sheets || [])[idx] || {};
  var dense = Array.isArray(ws);
  var b8 = opts.biff == 8;
  var ref, rr = "", cols = [];
  var range = safe_decode_range(ws["!ref"] || "A1");
  var MAX_ROWS = b8 ? 65536 : 16384;
  if (range.e.c > 255 || range.e.r >= MAX_ROWS) {
    if (opts.WTF) throw new Error("Range " + (ws["!ref"] || "A1") + " exceeds format limit A1:IV16384");
    range.e.c = Math.min(range.e.c, 255);
    range.e.r = Math.min(range.e.c, MAX_ROWS - 1);
  }
  write_biff_rec(ba, 2057, write_BOF(wb2, 16, opts));
  write_biff_rec(ba, 13, writeuint16(1));
  write_biff_rec(ba, 12, writeuint16(100));
  write_biff_rec(ba, 15, writebool(true));
  write_biff_rec(ba, 17, writebool(false));
  write_biff_rec(ba, 16, write_Xnum(1e-3));
  write_biff_rec(ba, 95, writebool(true));
  write_biff_rec(ba, 42, writebool(false));
  write_biff_rec(ba, 43, writebool(false));
  write_biff_rec(ba, 130, writeuint16(1));
  write_biff_rec(ba, 128, write_Guts());
  write_biff_rec(ba, 131, writebool(false));
  write_biff_rec(ba, 132, writebool(false));
  if (b8) write_ws_cols_biff8(ba, ws["!cols"]);
  write_biff_rec(ba, 512, write_Dimensions(range, opts));
  if (b8) ws["!links"] = [];
  for (var R3 = range.s.r; R3 <= range.e.r; ++R3) {
    rr = encode_row(R3);
    for (var C2 = range.s.c; C2 <= range.e.c; ++C2) {
      if (R3 === range.s.r) cols[C2] = encode_col(C2);
      ref = cols[C2] + rr;
      var cell = dense ? (ws[R3] || [])[C2] : ws[ref];
      if (!cell) continue;
      write_ws_biff8_cell(ba, cell, R3, C2, opts);
      if (b8 && cell.l) ws["!links"].push([ref, cell.l]);
    }
  }
  var cname = _sheet.CodeName || _sheet.name || s4;
  if (b8) write_biff_rec(ba, 574, write_Window2((_WB.Views || [])[0]));
  if (b8 && (ws["!merges"] || []).length) write_biff_rec(ba, 229, write_MergeCells(ws["!merges"]));
  if (b8) write_ws_biff8_hlinks(ba, ws);
  write_biff_rec(ba, 442, write_XLUnicodeString(cname));
  if (b8) write_FEAT(ba, ws);
  write_biff_rec(
    ba,
    10
    /* EOF */
  );
  return ba.end();
}
function write_biff8_global(wb2, bufs, opts) {
  var A2 = buf_array();
  var _WB = (wb2 || {}).Workbook || {};
  var _sheets = _WB.Sheets || [];
  var _wb = (
    /*::((*/
    _WB.WBProps || {
      /*::CodeName:"ThisWorkbook"*/
    }
  );
  var b8 = opts.biff == 8, b5 = opts.biff == 5;
  write_biff_rec(A2, 2057, write_BOF(wb2, 5, opts));
  if (opts.bookType == "xla") write_biff_rec(
    A2,
    135
    /* Addin */
  );
  write_biff_rec(A2, 225, b8 ? writeuint16(1200) : null);
  write_biff_rec(A2, 193, writezeroes(2));
  if (b5) write_biff_rec(
    A2,
    191
    /* ToolbarHdr */
  );
  if (b5) write_biff_rec(
    A2,
    192
    /* ToolbarEnd */
  );
  write_biff_rec(
    A2,
    226
    /* InterfaceEnd */
  );
  write_biff_rec(A2, 92, write_WriteAccess("SheetJS", opts));
  write_biff_rec(A2, 66, writeuint16(b8 ? 1200 : 1252));
  if (b8) write_biff_rec(A2, 353, writeuint16(0));
  if (b8) write_biff_rec(
    A2,
    448
    /* Excel9File */
  );
  write_biff_rec(A2, 317, write_RRTabId(wb2.SheetNames.length));
  if (b8 && wb2.vbaraw) write_biff_rec(
    A2,
    211
    /* ObProj */
  );
  if (b8 && wb2.vbaraw) {
    var cname = _wb.CodeName || "ThisWorkbook";
    write_biff_rec(A2, 442, write_XLUnicodeString(cname));
  }
  write_biff_rec(A2, 156, writeuint16(17));
  write_biff_rec(A2, 25, writebool(false));
  write_biff_rec(A2, 18, writebool(false));
  write_biff_rec(A2, 19, writeuint16(0));
  if (b8) write_biff_rec(A2, 431, writebool(false));
  if (b8) write_biff_rec(A2, 444, writeuint16(0));
  write_biff_rec(A2, 61, write_Window1());
  write_biff_rec(A2, 64, writebool(false));
  write_biff_rec(A2, 141, writeuint16(0));
  write_biff_rec(A2, 34, writebool(safe1904(wb2) == "true"));
  write_biff_rec(A2, 14, writebool(true));
  if (b8) write_biff_rec(A2, 439, writebool(false));
  write_biff_rec(A2, 218, writeuint16(0));
  write_FONTS_biff8(A2, wb2, opts);
  write_FMTS_biff8(A2, wb2.SSF, opts);
  write_CELLXFS_biff8(A2, opts);
  if (b8) write_biff_rec(A2, 352, writebool(false));
  var a4 = A2.end();
  var C2 = buf_array();
  if (b8) write_biff_rec(C2, 140, write_Country());
  if (b8 && opts.Strings) write_biff_continue(C2, 252, write_SST(opts.Strings));
  write_biff_rec(
    C2,
    10
    /* EOF */
  );
  var c3 = C2.end();
  var B3 = buf_array();
  var blen = 0, j2 = 0;
  for (j2 = 0; j2 < wb2.SheetNames.length; ++j2) blen += (b8 ? 12 : 11) + (b8 ? 2 : 1) * wb2.SheetNames[j2].length;
  var start = a4.length + blen + c3.length;
  for (j2 = 0; j2 < wb2.SheetNames.length; ++j2) {
    var _sheet = _sheets[j2] || {};
    write_biff_rec(B3, 133, write_BoundSheet8({ pos: start, hs: _sheet.Hidden || 0, dt: 0, name: wb2.SheetNames[j2] }, opts));
    start += bufs[j2].length;
  }
  var b2 = B3.end();
  if (blen != b2.length) throw new Error("BS8 " + blen + " != " + b2.length);
  var out = [];
  if (a4.length) out.push(a4);
  if (b2.length) out.push(b2);
  if (c3.length) out.push(c3);
  return bconcat(out);
}
function write_biff8_buf(wb2, opts) {
  var o2 = opts || {};
  var bufs = [];
  if (wb2 && !wb2.SSF) {
    wb2.SSF = dup(table_fmt);
  }
  if (wb2 && wb2.SSF) {
    make_ssf();
    SSF_load_table(wb2.SSF);
    o2.revssf = evert_num(wb2.SSF);
    o2.revssf[wb2.SSF[65535]] = 0;
    o2.ssf = wb2.SSF;
  }
  o2.Strings = /*::((*/
  [];
  o2.Strings.Count = 0;
  o2.Strings.Unique = 0;
  fix_write_opts(o2);
  o2.cellXfs = [];
  get_cell_style(o2.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb2.Props) wb2.Props = {};
  for (var i3 = 0; i3 < wb2.SheetNames.length; ++i3) bufs[bufs.length] = write_ws_biff8(i3, o2, wb2);
  bufs.unshift(write_biff8_global(wb2, bufs, o2));
  return bconcat(bufs);
}
function write_biff_buf(wb2, opts) {
  for (var i3 = 0; i3 <= wb2.SheetNames.length; ++i3) {
    var ws = wb2.Sheets[wb2.SheetNames[i3]];
    if (!ws || !ws["!ref"]) continue;
    var range = decode_range(ws["!ref"]);
    if (range.e.c > 255) {
      if (typeof console != "undefined" && console.error) console.error("Worksheet '" + wb2.SheetNames[i3] + "' extends beyond column IV (255).  Data may be lost.");
    }
  }
  var o2 = opts || {};
  switch (o2.biff || 2) {
    case 8:
    case 5:
      return write_biff8_buf(wb2, opts);
    case 4:
    case 3:
    case 2:
      return write_biff2_buf(wb2, opts);
  }
  throw new Error("invalid type " + o2.bookType + " for BIFF");
}
function html_to_sheet(str, _opts) {
  var opts = _opts || {};
  var ws = opts.dense ? [] : {};
  str = str.replace(/<!--.*?-->/g, "");
  var mtch = str.match(/<table/i);
  if (!mtch) throw new Error("Invalid HTML: could not find <table>");
  var mtch2 = str.match(/<\/table/i);
  var i3 = mtch.index, j2 = mtch2 && mtch2.index || str.length;
  var rows = split_regex(str.slice(i3, j2), /(:?<tr[^>]*>)/i, "<tr>");
  var R3 = -1, C2 = 0, RS = 0, CS = 0;
  var range = { s: { r: 1e7, c: 1e7 }, e: { r: 0, c: 0 } };
  var merges = [];
  for (i3 = 0; i3 < rows.length; ++i3) {
    var row = rows[i3].trim();
    var hd2 = row.slice(0, 3).toLowerCase();
    if (hd2 == "<tr") {
      ++R3;
      if (opts.sheetRows && opts.sheetRows <= R3) {
        --R3;
        break;
      }
      C2 = 0;
      continue;
    }
    if (hd2 != "<td" && hd2 != "<th") continue;
    var cells = row.split(/<\/t[dh]>/i);
    for (j2 = 0; j2 < cells.length; ++j2) {
      var cell = cells[j2].trim();
      if (!cell.match(/<t[dh]/i)) continue;
      var m4 = cell, cc2 = 0;
      while (m4.charAt(0) == "<" && (cc2 = m4.indexOf(">")) > -1) m4 = m4.slice(cc2 + 1);
      for (var midx = 0; midx < merges.length; ++midx) {
        var _merge = merges[midx];
        if (_merge.s.c == C2 && _merge.s.r < R3 && R3 <= _merge.e.r) {
          C2 = _merge.e.c + 1;
          midx = -1;
        }
      }
      var tag = parsexmltag(cell.slice(0, cell.indexOf(">")));
      CS = tag.colspan ? +tag.colspan : 1;
      if ((RS = +tag.rowspan) > 1 || CS > 1) merges.push({ s: { r: R3, c: C2 }, e: { r: R3 + (RS || 1) - 1, c: C2 + CS - 1 } });
      var _t2 = tag.t || tag["data-t"] || "";
      if (!m4.length) {
        C2 += CS;
        continue;
      }
      m4 = htmldecode(m4);
      if (range.s.r > R3) range.s.r = R3;
      if (range.e.r < R3) range.e.r = R3;
      if (range.s.c > C2) range.s.c = C2;
      if (range.e.c < C2) range.e.c = C2;
      if (!m4.length) {
        C2 += CS;
        continue;
      }
      var o2 = { t: "s", v: m4 };
      if (opts.raw || !m4.trim().length || _t2 == "s") ;
      else if (m4 === "TRUE") o2 = { t: "b", v: true };
      else if (m4 === "FALSE") o2 = { t: "b", v: false };
      else if (!isNaN(fuzzynum(m4))) o2 = { t: "n", v: fuzzynum(m4) };
      else if (!isNaN(fuzzydate(m4).getDate())) {
        o2 = { t: "d", v: parseDate(m4) };
        if (!opts.cellDates) o2 = { t: "n", v: datenum(o2.v) };
        o2.z = opts.dateNF || table_fmt[14];
      }
      if (opts.dense) {
        if (!ws[R3]) ws[R3] = [];
        ws[R3][C2] = o2;
      } else ws[encode_cell({ r: R3, c: C2 })] = o2;
      C2 += CS;
    }
  }
  ws["!ref"] = encode_range(range);
  if (merges.length) ws["!merges"] = merges;
  return ws;
}
function make_html_row(ws, r2, R3, o2) {
  var M4 = ws["!merges"] || [];
  var oo = [];
  for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    var RS = 0, CS = 0;
    for (var j2 = 0; j2 < M4.length; ++j2) {
      if (M4[j2].s.r > R3 || M4[j2].s.c > C2) continue;
      if (M4[j2].e.r < R3 || M4[j2].e.c < C2) continue;
      if (M4[j2].s.r < R3 || M4[j2].s.c < C2) {
        RS = -1;
        break;
      }
      RS = M4[j2].e.r - M4[j2].s.r + 1;
      CS = M4[j2].e.c - M4[j2].s.c + 1;
      break;
    }
    if (RS < 0) continue;
    var coord = encode_cell({ r: R3, c: C2 });
    var cell = o2.dense ? (ws[R3] || [])[C2] : ws[coord];
    var w3 = cell && cell.v != null && (cell.h || escapehtml(cell.w || (format_cell(cell), cell.w) || "")) || "";
    var sp = {};
    if (RS > 1) sp.rowspan = RS;
    if (CS > 1) sp.colspan = CS;
    if (o2.editable) w3 = '<span contenteditable="true">' + w3 + "</span>";
    else if (cell) {
      sp["data-t"] = cell && cell.t || "z";
      if (cell.v != null) sp["data-v"] = cell.v;
      if (cell.z != null) sp["data-z"] = cell.z;
      if (cell.l && (cell.l.Target || "#").charAt(0) != "#") w3 = '<a href="' + cell.l.Target + '">' + w3 + "</a>";
    }
    sp.id = (o2.id || "sjs") + "-" + coord;
    oo.push(writextag("td", w3, sp));
  }
  var preamble = "<tr>";
  return preamble + oo.join("") + "</tr>";
}
var HTML_BEGIN = '<html><head><meta charset="utf-8"/><title>SheetJS Table Export</title></head><body>';
var HTML_END = "</body></html>";
function html_to_workbook(str, opts) {
  var mtch = str.match(/<table[\s\S]*?>[\s\S]*?<\/table>/gi);
  if (!mtch || mtch.length == 0) throw new Error("Invalid HTML: could not find <table>");
  if (mtch.length == 1) return sheet_to_workbook(html_to_sheet(mtch[0], opts), opts);
  var wb2 = book_new();
  mtch.forEach(function(s4, idx) {
    book_append_sheet(wb2, html_to_sheet(s4, opts), "Sheet" + (idx + 1));
  });
  return wb2;
}
function make_html_preamble(ws, R3, o2) {
  var out = [];
  return out.join("") + "<table" + (o2 && o2.id ? ' id="' + o2.id + '"' : "") + ">";
}
function sheet_to_html(ws, opts) {
  var o2 = opts || {};
  var header = o2.header != null ? o2.header : HTML_BEGIN;
  var footer = o2.footer != null ? o2.footer : HTML_END;
  var out = [header];
  var r2 = decode_range(ws["!ref"]);
  o2.dense = Array.isArray(ws);
  out.push(make_html_preamble(ws, r2, o2));
  for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) out.push(make_html_row(ws, r2, R3, o2));
  out.push("</table>" + footer);
  return out.join("");
}
function sheet_add_dom(ws, table, _opts) {
  var opts = _opts || {};
  var or_R = 0, or_C = 0;
  if (opts.origin != null) {
    if (typeof opts.origin == "number") or_R = opts.origin;
    else {
      var _origin = typeof opts.origin == "string" ? decode_cell(opts.origin) : opts.origin;
      or_R = _origin.r;
      or_C = _origin.c;
    }
  }
  var rows = table.getElementsByTagName("tr");
  var sheetRows = Math.min(opts.sheetRows || 1e7, rows.length);
  var range = { s: { r: 0, c: 0 }, e: { r: or_R, c: or_C } };
  if (ws["!ref"]) {
    var _range = decode_range(ws["!ref"]);
    range.s.r = Math.min(range.s.r, _range.s.r);
    range.s.c = Math.min(range.s.c, _range.s.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    range.e.c = Math.max(range.e.c, _range.e.c);
    if (or_R == -1) range.e.r = or_R = _range.e.r + 1;
  }
  var merges = [], midx = 0;
  var rowinfo = ws["!rows"] || (ws["!rows"] = []);
  var _R = 0, R3 = 0, _C = 0, C2 = 0, RS = 0, CS = 0;
  if (!ws["!cols"]) ws["!cols"] = [];
  for (; _R < rows.length && R3 < sheetRows; ++_R) {
    var row = rows[_R];
    if (is_dom_element_hidden(row)) {
      if (opts.display) continue;
      rowinfo[R3] = { hidden: true };
    }
    var elts = row.children;
    for (_C = C2 = 0; _C < elts.length; ++_C) {
      var elt = elts[_C];
      if (opts.display && is_dom_element_hidden(elt)) continue;
      var v2 = elt.hasAttribute("data-v") ? elt.getAttribute("data-v") : elt.hasAttribute("v") ? elt.getAttribute("v") : htmldecode(elt.innerHTML);
      var z3 = elt.getAttribute("data-z") || elt.getAttribute("z");
      for (midx = 0; midx < merges.length; ++midx) {
        var m4 = merges[midx];
        if (m4.s.c == C2 + or_C && m4.s.r < R3 + or_R && R3 + or_R <= m4.e.r) {
          C2 = m4.e.c + 1 - or_C;
          midx = -1;
        }
      }
      CS = +elt.getAttribute("colspan") || 1;
      if ((RS = +elt.getAttribute("rowspan") || 1) > 1 || CS > 1) merges.push({ s: { r: R3 + or_R, c: C2 + or_C }, e: { r: R3 + or_R + (RS || 1) - 1, c: C2 + or_C + (CS || 1) - 1 } });
      var o2 = { t: "s", v: v2 };
      var _t2 = elt.getAttribute("data-t") || elt.getAttribute("t") || "";
      if (v2 != null) {
        if (v2.length == 0) o2.t = _t2 || "z";
        else if (opts.raw || v2.trim().length == 0 || _t2 == "s") ;
        else if (v2 === "TRUE") o2 = { t: "b", v: true };
        else if (v2 === "FALSE") o2 = { t: "b", v: false };
        else if (!isNaN(fuzzynum(v2))) o2 = { t: "n", v: fuzzynum(v2) };
        else if (!isNaN(fuzzydate(v2).getDate())) {
          o2 = { t: "d", v: parseDate(v2) };
          if (!opts.cellDates) o2 = { t: "n", v: datenum(o2.v) };
          o2.z = opts.dateNF || table_fmt[14];
        }
      }
      if (o2.z === void 0 && z3 != null) o2.z = z3;
      var l2 = "", Aelts = elt.getElementsByTagName("A");
      if (Aelts && Aelts.length) {
        for (var Aelti = 0; Aelti < Aelts.length; ++Aelti) if (Aelts[Aelti].hasAttribute("href")) {
          l2 = Aelts[Aelti].getAttribute("href");
          if (l2.charAt(0) != "#") break;
        }
      }
      if (l2 && l2.charAt(0) != "#") o2.l = { Target: l2 };
      if (opts.dense) {
        if (!ws[R3 + or_R]) ws[R3 + or_R] = [];
        ws[R3 + or_R][C2 + or_C] = o2;
      } else ws[encode_cell({ c: C2 + or_C, r: R3 + or_R })] = o2;
      if (range.e.c < C2 + or_C) range.e.c = C2 + or_C;
      C2 += CS;
    }
    ++R3;
  }
  if (merges.length) ws["!merges"] = (ws["!merges"] || []).concat(merges);
  range.e.r = Math.max(range.e.r, R3 - 1 + or_R);
  ws["!ref"] = encode_range(range);
  if (R3 >= sheetRows) ws["!fullref"] = encode_range((range.e.r = rows.length - _R + R3 - 1 + or_R, range));
  return ws;
}
function parse_dom_table(table, _opts) {
  var opts = _opts || {};
  var ws = opts.dense ? [] : {};
  return sheet_add_dom(ws, table, _opts);
}
function table_to_book(table, opts) {
  return sheet_to_workbook(parse_dom_table(table, opts), opts);
}
function is_dom_element_hidden(element) {
  var display = "";
  var get_computed_style = get_get_computed_style_function(element);
  if (get_computed_style) display = get_computed_style(element).getPropertyValue("display");
  if (!display) display = element.style && element.style.display;
  return display === "none";
}
function get_get_computed_style_function(element) {
  if (element.ownerDocument.defaultView && typeof element.ownerDocument.defaultView.getComputedStyle === "function") return element.ownerDocument.defaultView.getComputedStyle;
  if (typeof getComputedStyle === "function") return getComputedStyle;
  return null;
}
function parse_text_p(text) {
  var fixed = text.replace(/[\t\r\n]/g, " ").trim().replace(/ +/g, " ").replace(/<text:s\/>/g, " ").replace(/<text:s text:c="(\d+)"\/>/g, function($$, $1) {
    return Array(parseInt($1, 10) + 1).join(" ");
  }).replace(/<text:tab[^>]*\/>/g, "	").replace(/<text:line-break\/>/g, "\n");
  var v2 = unescapexml(fixed.replace(/<[^>]*>/g, ""));
  return [v2];
}
var number_formats_ods = {
  /* ods name: [short ssf fmt, long ssf fmt] */
  day: ["d", "dd"],
  month: ["m", "mm"],
  year: ["y", "yy"],
  hours: ["h", "hh"],
  minutes: ["m", "mm"],
  seconds: ["s", "ss"],
  "am-pm": ["A/P", "AM/PM"],
  "day-of-week": ["ddd", "dddd"],
  era: ["e", "ee"],
  /* there is no native representation of LO "Q" format */
  quarter: ["\\Qm", 'm\\"th quarter"']
};
function parse_content_xml(d4, _opts) {
  var opts = _opts || {};
  var str = xlml_normalize(d4);
  var state = [], tmp;
  var tag;
  var NFtag = { name: "" }, NF = "", pidx = 0;
  var sheetag;
  var rowtag;
  var Sheets = {}, SheetNames = [];
  var ws = opts.dense ? [] : {};
  var Rn, q3;
  var ctag = { value: "" };
  var textp = "", textpidx = 0;
  var textR = [];
  var R3 = -1, C2 = -1, range = { s: { r: 1e6, c: 1e7 }, e: { r: 0, c: 0 } };
  var row_ol = 0;
  var number_format_map = {};
  var merges = [], mrange = {}, mR = 0, mC = 0;
  var rowinfo = [], rowpeat = 1, colpeat = 1;
  var arrayf = [];
  var WB = { Names: [] };
  var atag = {};
  var _Ref = ["", ""];
  var comments = [], comment = {};
  var creator = "", creatoridx = 0;
  var isstub = false, intable = false;
  var i3 = 0;
  xlmlregex.lastIndex = 0;
  str = str.replace(/<!--([\s\S]*?)-->/mg, "").replace(/<!DOCTYPE[^\[]*\[[^\]]*\]>/gm, "");
  while (Rn = xlmlregex.exec(str)) switch (Rn[3] = Rn[3].replace(/_.*$/, "")) {
    case "table":
    case "工作表":
      if (Rn[1] === "/") {
        if (range.e.c >= range.s.c && range.e.r >= range.s.r) ws["!ref"] = encode_range(range);
        else ws["!ref"] = "A1:A1";
        if (opts.sheetRows > 0 && opts.sheetRows <= range.e.r) {
          ws["!fullref"] = ws["!ref"];
          range.e.r = opts.sheetRows - 1;
          ws["!ref"] = encode_range(range);
        }
        if (merges.length) ws["!merges"] = merges;
        if (rowinfo.length) ws["!rows"] = rowinfo;
        sheetag.name = sheetag["名称"] || sheetag.name;
        if (typeof JSON !== "undefined") JSON.stringify(sheetag);
        SheetNames.push(sheetag.name);
        Sheets[sheetag.name] = ws;
        intable = false;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        sheetag = parsexmltag(Rn[0], false);
        R3 = C2 = -1;
        range.s.r = range.s.c = 1e7;
        range.e.r = range.e.c = 0;
        ws = opts.dense ? [] : {};
        merges = [];
        rowinfo = [];
        intable = true;
      }
      break;
    case "table-row-group":
      if (Rn[1] === "/") --row_ol;
      else ++row_ol;
      break;
    case "table-row":
    case "行":
      if (Rn[1] === "/") {
        R3 += rowpeat;
        rowpeat = 1;
        break;
      }
      rowtag = parsexmltag(Rn[0], false);
      if (rowtag["行号"]) R3 = rowtag["行号"] - 1;
      else if (R3 == -1) R3 = 0;
      rowpeat = +rowtag["number-rows-repeated"] || 1;
      if (rowpeat < 10) {
        for (i3 = 0; i3 < rowpeat; ++i3) if (row_ol > 0) rowinfo[R3 + i3] = { level: row_ol };
      }
      C2 = -1;
      break;
    case "covered-table-cell":
      if (Rn[1] !== "/") ++C2;
      if (opts.sheetStubs) {
        if (opts.dense) {
          if (!ws[R3]) ws[R3] = [];
          ws[R3][C2] = { t: "z" };
        } else ws[encode_cell({ r: R3, c: C2 })] = { t: "z" };
      }
      textp = "";
      textR = [];
      break;
    case "table-cell":
    case "数据":
      if (Rn[0].charAt(Rn[0].length - 2) === "/") {
        ++C2;
        ctag = parsexmltag(Rn[0], false);
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        q3 = {
          t: "z",
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (ctag.formula && opts.cellFormula != false) q3.f = ods_to_csf_formula(unescapexml(ctag.formula));
        if ((ctag["数据类型"] || ctag["value-type"]) == "string") {
          q3.t = "s";
          q3.v = unescapexml(ctag["string-value"] || "");
          if (opts.dense) {
            if (!ws[R3]) ws[R3] = [];
            ws[R3][C2] = q3;
          } else {
            ws[encode_cell({ r: R3, c: C2 })] = q3;
          }
        }
        C2 += colpeat - 1;
      } else if (Rn[1] !== "/") {
        ++C2;
        textp = "";
        textpidx = 0;
        textR = [];
        colpeat = 1;
        var rptR = rowpeat ? R3 + rowpeat - 1 : R3;
        if (C2 > range.e.c) range.e.c = C2;
        if (C2 < range.s.c) range.s.c = C2;
        if (R3 < range.s.r) range.s.r = R3;
        if (rptR > range.e.r) range.e.r = rptR;
        ctag = parsexmltag(Rn[0], false);
        comments = [];
        comment = {};
        q3 = {
          t: ctag["数据类型"] || ctag["value-type"],
          v: null
          /*:: , z:null, w:"",c:[]*/
        };
        if (opts.cellFormula) {
          if (ctag.formula) ctag.formula = unescapexml(ctag.formula);
          if (ctag["number-matrix-columns-spanned"] && ctag["number-matrix-rows-spanned"]) {
            mR = parseInt(ctag["number-matrix-rows-spanned"], 10) || 0;
            mC = parseInt(ctag["number-matrix-columns-spanned"], 10) || 0;
            mrange = { s: { r: R3, c: C2 }, e: { r: R3 + mR - 1, c: C2 + mC - 1 } };
            q3.F = encode_range(mrange);
            arrayf.push([mrange, q3.F]);
          }
          if (ctag.formula) q3.f = ods_to_csf_formula(ctag.formula);
          else for (i3 = 0; i3 < arrayf.length; ++i3)
            if (R3 >= arrayf[i3][0].s.r && R3 <= arrayf[i3][0].e.r) {
              if (C2 >= arrayf[i3][0].s.c && C2 <= arrayf[i3][0].e.c)
                q3.F = arrayf[i3][1];
            }
        }
        if (ctag["number-columns-spanned"] || ctag["number-rows-spanned"]) {
          mR = parseInt(ctag["number-rows-spanned"], 10) || 0;
          mC = parseInt(ctag["number-columns-spanned"], 10) || 0;
          mrange = { s: { r: R3, c: C2 }, e: { r: R3 + mR - 1, c: C2 + mC - 1 } };
          merges.push(mrange);
        }
        if (ctag["number-columns-repeated"]) colpeat = parseInt(ctag["number-columns-repeated"], 10);
        switch (q3.t) {
          case "boolean":
            q3.t = "b";
            q3.v = parsexmlbool(ctag["boolean-value"]);
            break;
          case "float":
            q3.t = "n";
            q3.v = parseFloat(ctag.value);
            break;
          case "percentage":
            q3.t = "n";
            q3.v = parseFloat(ctag.value);
            break;
          case "currency":
            q3.t = "n";
            q3.v = parseFloat(ctag.value);
            break;
          case "date":
            q3.t = "d";
            q3.v = parseDate(ctag["date-value"]);
            if (!opts.cellDates) {
              q3.t = "n";
              q3.v = datenum(q3.v);
            }
            q3.z = "m/d/yy";
            break;
          case "time":
            q3.t = "n";
            q3.v = parse_isodur(ctag["time-value"]) / 86400;
            if (opts.cellDates) {
              q3.t = "d";
              q3.v = numdate(q3.v);
            }
            q3.z = "HH:MM:SS";
            break;
          case "number":
            q3.t = "n";
            q3.v = parseFloat(ctag["数据数值"]);
            break;
          default:
            if (q3.t === "string" || q3.t === "text" || !q3.t) {
              q3.t = "s";
              if (ctag["string-value"] != null) {
                textp = unescapexml(ctag["string-value"]);
                textR = [];
              }
            } else throw new Error("Unsupported value type " + q3.t);
        }
      } else {
        isstub = false;
        if (q3.t === "s") {
          q3.v = textp || "";
          if (textR.length) q3.R = textR;
          isstub = textpidx == 0;
        }
        if (atag.Target) q3.l = atag;
        if (comments.length > 0) {
          q3.c = comments;
          comments = [];
        }
        if (textp && opts.cellText !== false) q3.w = textp;
        if (isstub) {
          q3.t = "z";
          delete q3.v;
        }
        if (!isstub || opts.sheetStubs) {
          if (!(opts.sheetRows && opts.sheetRows <= R3)) {
            for (var rpt = 0; rpt < rowpeat; ++rpt) {
              colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
              if (opts.dense) {
                if (!ws[R3 + rpt]) ws[R3 + rpt] = [];
                ws[R3 + rpt][C2] = rpt == 0 ? q3 : dup(q3);
                while (--colpeat > 0) ws[R3 + rpt][C2 + colpeat] = dup(q3);
              } else {
                ws[encode_cell({ r: R3 + rpt, c: C2 })] = q3;
                while (--colpeat > 0) ws[encode_cell({ r: R3 + rpt, c: C2 + colpeat })] = dup(q3);
              }
              if (range.e.c <= C2) range.e.c = C2;
            }
          }
        }
        colpeat = parseInt(ctag["number-columns-repeated"] || "1", 10);
        C2 += colpeat - 1;
        colpeat = 0;
        q3 = {
          /*:: t:"", v:null, z:null, w:"",c:[]*/
        };
        textp = "";
        textR = [];
      }
      atag = {};
      break;
    case "document":
    case "document-content":
    case "电子表格文档":
    case "spreadsheet":
    case "主体":
    case "scripts":
    case "styles":
    case "font-face-decls":
    case "master-styles":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], true]);
      break;
    case "annotation":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
        comment.t = textp;
        if (textR.length) comment.R = textR;
        comment.a = creator;
        comments.push(comment);
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        state.push([Rn[3], false]);
      }
      creator = "";
      creatoridx = 0;
      textp = "";
      textpidx = 0;
      textR = [];
      break;
    case "creator":
      if (Rn[1] === "/") {
        creator = str.slice(creatoridx, Rn.index);
      } else creatoridx = Rn.index + Rn[0].length;
      break;
    case "meta":
    case "元数据":
    case "settings":
    case "config-item-set":
    case "config-item-map-indexed":
    case "config-item-map-entry":
    case "config-item-map-named":
    case "shapes":
    case "frame":
    case "text-box":
    case "image":
    case "data-pilot-tables":
    case "list-style":
    case "form":
    case "dde-links":
    case "event-listeners":
    case "chart":
      if (Rn[1] === "/") {
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") state.push([Rn[3], false]);
      textp = "";
      textpidx = 0;
      textR = [];
      break;
    case "scientific-number":
      break;
    case "currency-symbol":
      break;
    case "currency-style":
      break;
    case "number-style":
    case "percentage-style":
    case "date-style":
    case "time-style":
      if (Rn[1] === "/") {
        number_format_map[NFtag.name] = NF;
        if ((tmp = state.pop())[0] !== Rn[3]) throw "Bad state: " + tmp;
      } else if (Rn[0].charAt(Rn[0].length - 2) !== "/") {
        NF = "";
        NFtag = parsexmltag(Rn[0], false);
        state.push([Rn[3], true]);
      }
      break;
    case "script":
      break;
    case "libraries":
      break;
    case "automatic-styles":
      break;
    case "default-style":
    case "page-layout":
      break;
    case "style":
      break;
    case "map":
      break;
    case "font-face":
      break;
    case "paragraph-properties":
      break;
    case "table-properties":
      break;
    case "table-column-properties":
      break;
    case "table-row-properties":
      break;
    case "table-cell-properties":
      break;
    case "number":
      switch (state[state.length - 1][0]) {
        case "time-style":
        case "date-style":
          tag = parsexmltag(Rn[0], false);
          NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "fraction":
      break;
    case "day":
    case "month":
    case "year":
    case "era":
    case "day-of-week":
    case "week-of-year":
    case "quarter":
    case "hours":
    case "minutes":
    case "seconds":
    case "am-pm":
      switch (state[state.length - 1][0]) {
        case "time-style":
        case "date-style":
          tag = parsexmltag(Rn[0], false);
          NF += number_formats_ods[Rn[3]][tag.style === "long" ? 1 : 0];
          break;
      }
      break;
    case "boolean-style":
      break;
    case "boolean":
      break;
    case "text-style":
      break;
    case "text":
      if (Rn[0].slice(-2) === "/>") break;
      else if (Rn[1] === "/") switch (state[state.length - 1][0]) {
        case "number-style":
        case "date-style":
        case "time-style":
          NF += str.slice(pidx, Rn.index);
          break;
      }
      else pidx = Rn.index + Rn[0].length;
      break;
    case "named-range":
      tag = parsexmltag(Rn[0], false);
      _Ref = ods_to_csf_3D(tag["cell-range-address"]);
      var nrange = { Name: tag.name, Ref: _Ref[0] + "!" + _Ref[1] };
      if (intable) nrange.Sheet = SheetNames.length;
      WB.Names.push(nrange);
      break;
    case "text-content":
      break;
    case "text-properties":
      break;
    case "embedded-text":
      break;
    case "body":
    case "电子表格":
      break;
    case "forms":
      break;
    case "table-column":
      break;
    case "table-header-rows":
      break;
    case "table-rows":
      break;
    case "table-column-group":
      break;
    case "table-header-columns":
      break;
    case "table-columns":
      break;
    case "null-date":
      break;
    case "graphic-properties":
      break;
    case "calculation-settings":
      break;
    case "named-expressions":
      break;
    case "label-range":
      break;
    case "label-ranges":
      break;
    case "named-expression":
      break;
    case "sort":
      break;
    case "sort-by":
      break;
    case "sort-groups":
      break;
    case "tab":
      break;
    case "line-break":
      break;
    case "span":
      break;
    case "p":
    case "文本串":
      if (["master-styles"].indexOf(state[state.length - 1][0]) > -1) break;
      if (Rn[1] === "/" && (!ctag || !ctag["string-value"])) {
        var ptp = parse_text_p(str.slice(textpidx, Rn.index));
        textp = (textp.length > 0 ? textp + "\n" : "") + ptp[0];
      } else {
        parsexmltag(Rn[0], false);
        textpidx = Rn.index + Rn[0].length;
      }
      break;
    case "s":
      break;
    case "database-range":
      if (Rn[1] === "/") break;
      try {
        _Ref = ods_to_csf_3D(parsexmltag(Rn[0])["target-range-address"]);
        Sheets[_Ref[0]]["!autofilter"] = { ref: _Ref[1] };
      } catch (e3) {
      }
      break;
    case "date":
      break;
    case "object":
      break;
    case "title":
    case "标题":
      break;
    case "desc":
      break;
    case "binary-data":
      break;
    case "table-source":
      break;
    case "scenario":
      break;
    case "iteration":
      break;
    case "content-validations":
      break;
    case "content-validation":
      break;
    case "help-message":
      break;
    case "error-message":
      break;
    case "database-ranges":
      break;
    case "filter":
      break;
    case "filter-and":
      break;
    case "filter-or":
      break;
    case "filter-condition":
      break;
    case "list-level-style-bullet":
      break;
    case "list-level-style-number":
      break;
    case "list-level-properties":
      break;
    case "sender-firstname":
    case "sender-lastname":
    case "sender-initials":
    case "sender-title":
    case "sender-position":
    case "sender-email":
    case "sender-phone-private":
    case "sender-fax":
    case "sender-company":
    case "sender-phone-work":
    case "sender-street":
    case "sender-city":
    case "sender-postal-code":
    case "sender-country":
    case "sender-state-or-province":
    case "author-name":
    case "author-initials":
    case "chapter":
    case "file-name":
    case "template-name":
    case "sheet-name":
      break;
    case "event-listener":
      break;
    case "initial-creator":
    case "creation-date":
    case "print-date":
    case "generator":
    case "document-statistic":
    case "user-defined":
    case "editing-duration":
    case "editing-cycles":
      break;
    case "config-item":
      break;
    case "page-number":
      break;
    case "page-count":
      break;
    case "time":
      break;
    case "cell-range-source":
      break;
    case "detective":
      break;
    case "operation":
      break;
    case "highlighted-range":
      break;
    case "data-pilot-table":
    case "source-cell-range":
    case "source-service":
    case "data-pilot-field":
    case "data-pilot-level":
    case "data-pilot-subtotals":
    case "data-pilot-subtotal":
    case "data-pilot-members":
    case "data-pilot-member":
    case "data-pilot-display-info":
    case "data-pilot-sort-info":
    case "data-pilot-layout-info":
    case "data-pilot-field-reference":
    case "data-pilot-groups":
    case "data-pilot-group":
    case "data-pilot-group-member":
      break;
    case "rect":
      break;
    case "dde-connection-decls":
    case "dde-connection-decl":
    case "dde-link":
    case "dde-source":
      break;
    case "properties":
      break;
    case "property":
      break;
    case "a":
      if (Rn[1] !== "/") {
        atag = parsexmltag(Rn[0], false);
        if (!atag.href) break;
        atag.Target = unescapexml(atag.href);
        delete atag.href;
        if (atag.Target.charAt(0) == "#" && atag.Target.indexOf(".") > -1) {
          _Ref = ods_to_csf_3D(atag.Target.slice(1));
          atag.Target = "#" + _Ref[0] + "!" + _Ref[1];
        } else if (atag.Target.match(/^\.\.[\\\/]/)) atag.Target = atag.Target.slice(3);
      }
      break;
    case "table-protection":
      break;
    case "data-pilot-grand-total":
      break;
    case "office-document-common-attrs":
      break;
    default:
      switch (Rn[2]) {
        case "dc:":
        case "calcext:":
        case "loext:":
        case "ooo:":
        case "chartooo:":
        case "draw:":
        case "style:":
        case "chart:":
        case "form:":
        case "uof:":
        case "表:":
        case "字:":
          break;
        default:
          if (opts.WTF) throw new Error(Rn);
      }
  }
  var out = {
    Sheets,
    SheetNames,
    Workbook: WB
  };
  if (opts.bookSheets) delete /*::(*/
  out.Sheets;
  return out;
}
function parse_ods(zip, opts) {
  opts = opts || {};
  if (safegetzipfile(zip, "META-INF/manifest.xml")) parse_manifest(getzipdata(zip, "META-INF/manifest.xml"), opts);
  var content = getzipstr(zip, "content.xml");
  if (!content) throw new Error("Missing content.xml in ODS / UOF file");
  var wb2 = parse_content_xml(utf8read(content), opts);
  if (safegetzipfile(zip, "meta.xml")) wb2.Props = parse_core_props(getzipdata(zip, "meta.xml"));
  return wb2;
}
function parse_fods(data, opts) {
  return parse_content_xml(data, opts);
}
var write_styles_ods = /* @__PURE__ */ function() {
  var master_styles = [
    "<office:master-styles>",
    '<style:master-page style:name="mp1" style:page-layout-name="mp1">',
    "<style:header/>",
    '<style:header-left style:display="false"/>',
    "<style:footer/>",
    '<style:footer-left style:display="false"/>',
    "</style:master-page>",
    "</office:master-styles>"
  ].join("");
  var payload = "<office:document-styles " + wxt_helper({
    "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
    "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
    "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
    "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
    "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
    "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
    "xmlns:xlink": "http://www.w3.org/1999/xlink",
    "xmlns:dc": "http://purl.org/dc/elements/1.1/",
    "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
    "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
    "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
    "office:version": "1.2"
  }) + ">" + master_styles + "</office:document-styles>";
  return function wso() {
    return XML_HEADER + payload;
  };
}();
var write_content_ods = /* @__PURE__ */ function() {
  var write_text_p = function(text) {
    return escapexml(text).replace(/  +/g, function($$) {
      return '<text:s text:c="' + $$.length + '"/>';
    }).replace(/\t/g, "<text:tab/>").replace(/\n/g, "</text:p><text:p>").replace(/^ /, "<text:s/>").replace(/ $/, "<text:s/>");
  };
  var null_cell_xml = "          <table:table-cell />\n";
  var covered_cell_xml = "          <table:covered-table-cell/>\n";
  var write_ws2 = function(ws, wb2, i3) {
    var o2 = [];
    o2.push('      <table:table table:name="' + escapexml(wb2.SheetNames[i3]) + '" table:style-name="ta1">\n');
    var R3 = 0, C2 = 0, range = decode_range(ws["!ref"] || "A1");
    var marr = ws["!merges"] || [], mi2 = 0;
    var dense = Array.isArray(ws);
    if (ws["!cols"]) {
      for (C2 = 0; C2 <= range.e.c; ++C2) o2.push("        <table:table-column" + (ws["!cols"][C2] ? ' table:style-name="co' + ws["!cols"][C2].ods + '"' : "") + "></table:table-column>\n");
    }
    var H4 = "", ROWS = ws["!rows"] || [];
    for (R3 = 0; R3 < range.s.r; ++R3) {
      H4 = ROWS[R3] ? ' table:style-name="ro' + ROWS[R3].ods + '"' : "";
      o2.push("        <table:table-row" + H4 + "></table:table-row>\n");
    }
    for (; R3 <= range.e.r; ++R3) {
      H4 = ROWS[R3] ? ' table:style-name="ro' + ROWS[R3].ods + '"' : "";
      o2.push("        <table:table-row" + H4 + ">\n");
      for (C2 = 0; C2 < range.s.c; ++C2) o2.push(null_cell_xml);
      for (; C2 <= range.e.c; ++C2) {
        var skip = false, ct = {}, textp = "";
        for (mi2 = 0; mi2 != marr.length; ++mi2) {
          if (marr[mi2].s.c > C2) continue;
          if (marr[mi2].s.r > R3) continue;
          if (marr[mi2].e.c < C2) continue;
          if (marr[mi2].e.r < R3) continue;
          if (marr[mi2].s.c != C2 || marr[mi2].s.r != R3) skip = true;
          ct["table:number-columns-spanned"] = marr[mi2].e.c - marr[mi2].s.c + 1;
          ct["table:number-rows-spanned"] = marr[mi2].e.r - marr[mi2].s.r + 1;
          break;
        }
        if (skip) {
          o2.push(covered_cell_xml);
          continue;
        }
        var ref = encode_cell({ r: R3, c: C2 }), cell = dense ? (ws[R3] || [])[C2] : ws[ref];
        if (cell && cell.f) {
          ct["table:formula"] = escapexml(csf_to_ods_formula(cell.f));
          if (cell.F) {
            if (cell.F.slice(0, ref.length) == ref) {
              var _Fref = decode_range(cell.F);
              ct["table:number-matrix-columns-spanned"] = _Fref.e.c - _Fref.s.c + 1;
              ct["table:number-matrix-rows-spanned"] = _Fref.e.r - _Fref.s.r + 1;
            }
          }
        }
        if (!cell) {
          o2.push(null_cell_xml);
          continue;
        }
        switch (cell.t) {
          case "b":
            textp = cell.v ? "TRUE" : "FALSE";
            ct["office:value-type"] = "boolean";
            ct["office:boolean-value"] = cell.v ? "true" : "false";
            break;
          case "n":
            textp = cell.w || String(cell.v || 0);
            ct["office:value-type"] = "float";
            ct["office:value"] = cell.v || 0;
            break;
          case "s":
          case "str":
            textp = cell.v == null ? "" : cell.v;
            ct["office:value-type"] = "string";
            break;
          case "d":
            textp = cell.w || parseDate(cell.v).toISOString();
            ct["office:value-type"] = "date";
            ct["office:date-value"] = parseDate(cell.v).toISOString();
            ct["table:style-name"] = "ce1";
            break;
          default:
            o2.push(null_cell_xml);
            continue;
        }
        var text_p = write_text_p(textp);
        if (cell.l && cell.l.Target) {
          var _tgt = cell.l.Target;
          _tgt = _tgt.charAt(0) == "#" ? "#" + csf_to_ods_3D(_tgt.slice(1)) : _tgt;
          if (_tgt.charAt(0) != "#" && !_tgt.match(/^\w+:/)) _tgt = "../" + _tgt;
          text_p = writextag("text:a", text_p, { "xlink:href": _tgt.replace(/&/g, "&amp;") });
        }
        o2.push("          " + writextag("table:table-cell", writextag("text:p", text_p, {}), ct) + "\n");
      }
      o2.push("        </table:table-row>\n");
    }
    o2.push("      </table:table>\n");
    return o2.join("");
  };
  var write_automatic_styles_ods = function(o2, wb2) {
    o2.push(" <office:automatic-styles>\n");
    o2.push('  <number:date-style style:name="N37" number:automatic-order="true">\n');
    o2.push('   <number:month number:style="long"/>\n');
    o2.push("   <number:text>/</number:text>\n");
    o2.push('   <number:day number:style="long"/>\n');
    o2.push("   <number:text>/</number:text>\n");
    o2.push("   <number:year/>\n");
    o2.push("  </number:date-style>\n");
    var cidx = 0;
    wb2.SheetNames.map(function(n2) {
      return wb2.Sheets[n2];
    }).forEach(function(ws) {
      if (!ws) return;
      if (ws["!cols"]) {
        for (var C2 = 0; C2 < ws["!cols"].length; ++C2) if (ws["!cols"][C2]) {
          var colobj = ws["!cols"][C2];
          if (colobj.width == null && colobj.wpx == null && colobj.wch == null) continue;
          process_col(colobj);
          colobj.ods = cidx;
          var w3 = ws["!cols"][C2].wpx + "px";
          o2.push('  <style:style style:name="co' + cidx + '" style:family="table-column">\n');
          o2.push('   <style:table-column-properties fo:break-before="auto" style:column-width="' + w3 + '"/>\n');
          o2.push("  </style:style>\n");
          ++cidx;
        }
      }
    });
    var ridx = 0;
    wb2.SheetNames.map(function(n2) {
      return wb2.Sheets[n2];
    }).forEach(function(ws) {
      if (!ws) return;
      if (ws["!rows"]) {
        for (var R3 = 0; R3 < ws["!rows"].length; ++R3) if (ws["!rows"][R3]) {
          ws["!rows"][R3].ods = ridx;
          var h4 = ws["!rows"][R3].hpx + "px";
          o2.push('  <style:style style:name="ro' + ridx + '" style:family="table-row">\n');
          o2.push('   <style:table-row-properties fo:break-before="auto" style:row-height="' + h4 + '"/>\n');
          o2.push("  </style:style>\n");
          ++ridx;
        }
      }
    });
    o2.push('  <style:style style:name="ta1" style:family="table" style:master-page-name="mp1">\n');
    o2.push('   <style:table-properties table:display="true" style:writing-mode="lr-tb"/>\n');
    o2.push("  </style:style>\n");
    o2.push('  <style:style style:name="ce1" style:family="table-cell" style:parent-style-name="Default" style:data-style-name="N37"/>\n');
    o2.push(" </office:automatic-styles>\n");
  };
  return function wcx(wb2, opts) {
    var o2 = [XML_HEADER];
    var attr = wxt_helper({
      "xmlns:office": "urn:oasis:names:tc:opendocument:xmlns:office:1.0",
      "xmlns:table": "urn:oasis:names:tc:opendocument:xmlns:table:1.0",
      "xmlns:style": "urn:oasis:names:tc:opendocument:xmlns:style:1.0",
      "xmlns:text": "urn:oasis:names:tc:opendocument:xmlns:text:1.0",
      "xmlns:draw": "urn:oasis:names:tc:opendocument:xmlns:drawing:1.0",
      "xmlns:fo": "urn:oasis:names:tc:opendocument:xmlns:xsl-fo-compatible:1.0",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      "xmlns:dc": "http://purl.org/dc/elements/1.1/",
      "xmlns:meta": "urn:oasis:names:tc:opendocument:xmlns:meta:1.0",
      "xmlns:number": "urn:oasis:names:tc:opendocument:xmlns:datastyle:1.0",
      "xmlns:presentation": "urn:oasis:names:tc:opendocument:xmlns:presentation:1.0",
      "xmlns:svg": "urn:oasis:names:tc:opendocument:xmlns:svg-compatible:1.0",
      "xmlns:chart": "urn:oasis:names:tc:opendocument:xmlns:chart:1.0",
      "xmlns:dr3d": "urn:oasis:names:tc:opendocument:xmlns:dr3d:1.0",
      "xmlns:math": "http://www.w3.org/1998/Math/MathML",
      "xmlns:form": "urn:oasis:names:tc:opendocument:xmlns:form:1.0",
      "xmlns:script": "urn:oasis:names:tc:opendocument:xmlns:script:1.0",
      "xmlns:ooo": "http://openoffice.org/2004/office",
      "xmlns:ooow": "http://openoffice.org/2004/writer",
      "xmlns:oooc": "http://openoffice.org/2004/calc",
      "xmlns:dom": "http://www.w3.org/2001/xml-events",
      "xmlns:xforms": "http://www.w3.org/2002/xforms",
      "xmlns:xsd": "http://www.w3.org/2001/XMLSchema",
      "xmlns:xsi": "http://www.w3.org/2001/XMLSchema-instance",
      "xmlns:sheet": "urn:oasis:names:tc:opendocument:sh33tjs:1.0",
      "xmlns:rpt": "http://openoffice.org/2005/report",
      "xmlns:of": "urn:oasis:names:tc:opendocument:xmlns:of:1.2",
      "xmlns:xhtml": "http://www.w3.org/1999/xhtml",
      "xmlns:grddl": "http://www.w3.org/2003/g/data-view#",
      "xmlns:tableooo": "http://openoffice.org/2009/table",
      "xmlns:drawooo": "http://openoffice.org/2010/draw",
      "xmlns:calcext": "urn:org:documentfoundation:names:experimental:calc:xmlns:calcext:1.0",
      "xmlns:loext": "urn:org:documentfoundation:names:experimental:office:xmlns:loext:1.0",
      "xmlns:field": "urn:openoffice:names:experimental:ooo-ms-interop:xmlns:field:1.0",
      "xmlns:formx": "urn:openoffice:names:experimental:ooxml-odf-interop:xmlns:form:1.0",
      "xmlns:css3t": "http://www.w3.org/TR/css3-text/",
      "office:version": "1.2"
    });
    var fods = wxt_helper({
      "xmlns:config": "urn:oasis:names:tc:opendocument:xmlns:config:1.0",
      "office:mimetype": "application/vnd.oasis.opendocument.spreadsheet"
    });
    if (opts.bookType == "fods") {
      o2.push("<office:document" + attr + fods + ">\n");
      o2.push(write_meta_ods().replace(/office:document-meta/g, "office:meta"));
    } else o2.push("<office:document-content" + attr + ">\n");
    write_automatic_styles_ods(o2, wb2);
    o2.push("  <office:body>\n");
    o2.push("    <office:spreadsheet>\n");
    for (var i3 = 0; i3 != wb2.SheetNames.length; ++i3) o2.push(write_ws2(wb2.Sheets[wb2.SheetNames[i3]], wb2, i3));
    o2.push("    </office:spreadsheet>\n");
    o2.push("  </office:body>\n");
    if (opts.bookType == "fods") o2.push("</office:document>");
    else o2.push("</office:document-content>");
    return o2.join("");
  };
}();
function write_ods(wb2, opts) {
  if (opts.bookType == "fods") return write_content_ods(wb2, opts);
  var zip = zip_new();
  var f2 = "";
  var manifest = [];
  var rdf = [];
  f2 = "mimetype";
  zip_add_file(zip, f2, "application/vnd.oasis.opendocument.spreadsheet");
  f2 = "content.xml";
  zip_add_file(zip, f2, write_content_ods(wb2, opts));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "ContentFile"]);
  f2 = "styles.xml";
  zip_add_file(zip, f2, write_styles_ods(wb2, opts));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "StylesFile"]);
  f2 = "meta.xml";
  zip_add_file(zip, f2, XML_HEADER + write_meta_ods(
    /*::wb, opts*/
  ));
  manifest.push([f2, "text/xml"]);
  rdf.push([f2, "MetadataFile"]);
  f2 = "manifest.rdf";
  zip_add_file(zip, f2, write_rdf(
    rdf
    /*, opts*/
  ));
  manifest.push([f2, "application/rdf+xml"]);
  f2 = "META-INF/manifest.xml";
  zip_add_file(zip, f2, write_manifest(
    manifest
    /*, opts*/
  ));
  return zip;
}
/*! sheetjs (C) 2013-present SheetJS -- http://sheetjs.com */
function u8_to_dataview(array) {
  return new DataView(array.buffer, array.byteOffset, array.byteLength);
}
function u8str(u8) {
  return typeof TextDecoder != "undefined" ? new TextDecoder().decode(u8) : utf8read(a2s(u8));
}
function stru8(str) {
  return typeof TextEncoder != "undefined" ? new TextEncoder().encode(str) : s2a(utf8write(str));
}
function u8contains(body, search) {
  outer:
    for (var L3 = 0; L3 <= body.length - search.length; ++L3) {
      for (var j2 = 0; j2 < search.length; ++j2)
        if (body[L3 + j2] != search[j2])
          continue outer;
      return true;
    }
  return false;
}
function u8concat(u8a) {
  var len = u8a.reduce(function(acc, x3) {
    return acc + x3.length;
  }, 0);
  var out = new Uint8Array(len);
  var off = 0;
  u8a.forEach(function(u8) {
    out.set(u8, off);
    off += u8.length;
  });
  return out;
}
function popcnt(x3) {
  x3 -= x3 >> 1 & 1431655765;
  x3 = (x3 & 858993459) + (x3 >> 2 & 858993459);
  return (x3 + (x3 >> 4) & 252645135) * 16843009 >>> 24;
}
function readDecimal128LE(buf, offset2) {
  var exp = (buf[offset2 + 15] & 127) << 7 | buf[offset2 + 14] >> 1;
  var mantissa = buf[offset2 + 14] & 1;
  for (var j2 = offset2 + 13; j2 >= offset2; --j2)
    mantissa = mantissa * 256 + buf[j2];
  return (buf[offset2 + 15] & 128 ? -mantissa : mantissa) * Math.pow(10, exp - 6176);
}
function writeDecimal128LE(buf, offset2, value) {
  var exp = Math.floor(value == 0 ? 0 : Math.LOG10E * Math.log(Math.abs(value))) + 6176 - 20;
  var mantissa = value / Math.pow(10, exp - 6176);
  buf[offset2 + 15] |= exp >> 7;
  buf[offset2 + 14] |= (exp & 127) << 1;
  for (var i3 = 0; mantissa >= 1; ++i3, mantissa /= 256)
    buf[offset2 + i3] = mantissa & 255;
  buf[offset2 + 15] |= value >= 0 ? 0 : 128;
}
function parse_varint49(buf, ptr) {
  var l2 = ptr ? ptr[0] : 0;
  var usz = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      usz |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      usz |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 28);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 35);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
      usz += (buf[l2] & 127) * Math.pow(2, 42);
      ++l2;
      if (buf[l2++] < 128)
        break varint;
    }
  if (ptr)
    ptr[0] = l2;
  return usz;
}
function write_varint49(v2) {
  var usz = new Uint8Array(7);
  usz[0] = v2 & 127;
  var L3 = 1;
  sz:
    if (v2 > 127) {
      usz[L3 - 1] |= 128;
      usz[L3] = v2 >> 7 & 127;
      ++L3;
      if (v2 <= 16383)
        break sz;
      usz[L3 - 1] |= 128;
      usz[L3] = v2 >> 14 & 127;
      ++L3;
      if (v2 <= 2097151)
        break sz;
      usz[L3 - 1] |= 128;
      usz[L3] = v2 >> 21 & 127;
      ++L3;
      if (v2 <= 268435455)
        break sz;
      usz[L3 - 1] |= 128;
      usz[L3] = v2 / 256 >>> 21 & 127;
      ++L3;
      if (v2 <= 34359738367)
        break sz;
      usz[L3 - 1] |= 128;
      usz[L3] = v2 / 65536 >>> 21 & 127;
      ++L3;
      if (v2 <= 4398046511103)
        break sz;
      usz[L3 - 1] |= 128;
      usz[L3] = v2 / 16777216 >>> 21 & 127;
      ++L3;
    }
  return usz.slice(0, L3);
}
function varint_to_i32(buf) {
  var l2 = 0, i32 = buf[l2] & 127;
  varint:
    if (buf[l2++] >= 128) {
      i32 |= (buf[l2] & 127) << 7;
      if (buf[l2++] < 128)
        break varint;
      i32 |= (buf[l2] & 127) << 14;
      if (buf[l2++] < 128)
        break varint;
      i32 |= (buf[l2] & 127) << 21;
      if (buf[l2++] < 128)
        break varint;
      i32 |= (buf[l2] & 127) << 28;
    }
  return i32;
}
function parse_shallow(buf) {
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var off = ptr[0];
    var num = parse_varint49(buf, ptr);
    var type = num & 7;
    num = Math.floor(num / 8);
    var len = 0;
    var res;
    if (num == 0)
      break;
    switch (type) {
      case 0:
        {
          var l2 = ptr[0];
          while (buf[ptr[0]++] >= 128)
            ;
          res = buf.slice(l2, ptr[0]);
        }
        break;
      case 5:
        len = 4;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 1:
        len = 8;
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 2:
        len = parse_varint49(buf, ptr);
        res = buf.slice(ptr[0], ptr[0] + len);
        ptr[0] += len;
        break;
      case 3:
      case 4:
      default:
        throw new Error("PB Type ".concat(type, " for Field ").concat(num, " at offset ").concat(off));
    }
    var v2 = { data: res, type };
    if (out[num] == null)
      out[num] = [v2];
    else
      out[num].push(v2);
  }
  return out;
}
function write_shallow(proto) {
  var out = [];
  proto.forEach(function(field, idx) {
    field.forEach(function(item) {
      if (!item.data)
        return;
      out.push(write_varint49(idx * 8 + item.type));
      if (item.type == 2)
        out.push(write_varint49(item.data.length));
      out.push(item.data);
    });
  });
  return u8concat(out);
}
function mappa(data, cb2) {
  return (data == null ? void 0 : data.map(function(d4) {
    return cb2(d4.data);
  })) || [];
}
function parse_iwa_file(buf) {
  var _a;
  var out = [], ptr = [0];
  while (ptr[0] < buf.length) {
    var len = parse_varint49(buf, ptr);
    var ai2 = parse_shallow(buf.slice(ptr[0], ptr[0] + len));
    ptr[0] += len;
    var res = {
      id: varint_to_i32(ai2[1][0].data),
      messages: []
    };
    ai2[2].forEach(function(b2) {
      var mi2 = parse_shallow(b2.data);
      var fl2 = varint_to_i32(mi2[3][0].data);
      res.messages.push({
        meta: mi2,
        data: buf.slice(ptr[0], ptr[0] + fl2)
      });
      ptr[0] += fl2;
    });
    if ((_a = ai2[3]) == null ? void 0 : _a[0])
      res.merge = varint_to_i32(ai2[3][0].data) >>> 0 > 0;
    out.push(res);
  }
  return out;
}
function write_iwa_file(ias) {
  var bufs = [];
  ias.forEach(function(ia2) {
    var ai2 = [];
    ai2[1] = [{ data: write_varint49(ia2.id), type: 0 }];
    ai2[2] = [];
    if (ia2.merge != null)
      ai2[3] = [{ data: write_varint49(+!!ia2.merge), type: 0 }];
    var midata = [];
    ia2.messages.forEach(function(mi2) {
      midata.push(mi2.data);
      mi2.meta[3] = [{ type: 0, data: write_varint49(mi2.data.length) }];
      ai2[2].push({ data: write_shallow(mi2.meta), type: 2 });
    });
    var aipayload = write_shallow(ai2);
    bufs.push(write_varint49(aipayload.length));
    bufs.push(aipayload);
    midata.forEach(function(mid) {
      return bufs.push(mid);
    });
  });
  return u8concat(bufs);
}
function parse_snappy_chunk(type, buf) {
  if (type != 0)
    throw new Error("Unexpected Snappy chunk type ".concat(type));
  var ptr = [0];
  var usz = parse_varint49(buf, ptr);
  var chunks = [];
  while (ptr[0] < buf.length) {
    var tag = buf[ptr[0]] & 3;
    if (tag == 0) {
      var len = buf[ptr[0]++] >> 2;
      if (len < 60)
        ++len;
      else {
        var c3 = len - 59;
        len = buf[ptr[0]];
        if (c3 > 1)
          len |= buf[ptr[0] + 1] << 8;
        if (c3 > 2)
          len |= buf[ptr[0] + 2] << 16;
        if (c3 > 3)
          len |= buf[ptr[0] + 3] << 24;
        len >>>= 0;
        len++;
        ptr[0] += c3;
      }
      chunks.push(buf.slice(ptr[0], ptr[0] + len));
      ptr[0] += len;
      continue;
    } else {
      var offset2 = 0, length = 0;
      if (tag == 1) {
        length = (buf[ptr[0]] >> 2 & 7) + 4;
        offset2 = (buf[ptr[0]++] & 224) << 3;
        offset2 |= buf[ptr[0]++];
      } else {
        length = (buf[ptr[0]++] >> 2) + 1;
        if (tag == 2) {
          offset2 = buf[ptr[0]] | buf[ptr[0] + 1] << 8;
          ptr[0] += 2;
        } else {
          offset2 = (buf[ptr[0]] | buf[ptr[0] + 1] << 8 | buf[ptr[0] + 2] << 16 | buf[ptr[0] + 3] << 24) >>> 0;
          ptr[0] += 4;
        }
      }
      chunks = [u8concat(chunks)];
      if (offset2 == 0)
        throw new Error("Invalid offset 0");
      if (offset2 > chunks[0].length)
        throw new Error("Invalid offset beyond length");
      if (length >= offset2) {
        chunks.push(chunks[0].slice(-offset2));
        length -= offset2;
        while (length >= chunks[chunks.length - 1].length) {
          chunks.push(chunks[chunks.length - 1]);
          length -= chunks[chunks.length - 1].length;
        }
      }
      chunks.push(chunks[0].slice(-offset2, -offset2 + length));
    }
  }
  var o2 = u8concat(chunks);
  if (o2.length != usz)
    throw new Error("Unexpected length: ".concat(o2.length, " != ").concat(usz));
  return o2;
}
function decompress_iwa_file(buf) {
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var t3 = buf[l2++];
    var len = buf[l2] | buf[l2 + 1] << 8 | buf[l2 + 2] << 16;
    l2 += 3;
    out.push(parse_snappy_chunk(t3, buf.slice(l2, l2 + len)));
    l2 += len;
  }
  if (l2 !== buf.length)
    throw new Error("data is not a valid framed stream!");
  return u8concat(out);
}
function compress_iwa_file(buf) {
  var out = [];
  var l2 = 0;
  while (l2 < buf.length) {
    var c3 = Math.min(buf.length - l2, 268435455);
    var frame = new Uint8Array(4);
    out.push(frame);
    var usz = write_varint49(c3);
    var L3 = usz.length;
    out.push(usz);
    if (c3 <= 60) {
      L3++;
      out.push(new Uint8Array([c3 - 1 << 2]));
    } else if (c3 <= 256) {
      L3 += 2;
      out.push(new Uint8Array([240, c3 - 1 & 255]));
    } else if (c3 <= 65536) {
      L3 += 3;
      out.push(new Uint8Array([244, c3 - 1 & 255, c3 - 1 >> 8 & 255]));
    } else if (c3 <= 16777216) {
      L3 += 4;
      out.push(new Uint8Array([248, c3 - 1 & 255, c3 - 1 >> 8 & 255, c3 - 1 >> 16 & 255]));
    } else if (c3 <= 4294967296) {
      L3 += 5;
      out.push(new Uint8Array([252, c3 - 1 & 255, c3 - 1 >> 8 & 255, c3 - 1 >> 16 & 255, c3 - 1 >>> 24 & 255]));
    }
    out.push(buf.slice(l2, l2 + c3));
    L3 += c3;
    frame[0] = 0;
    frame[1] = L3 & 255;
    frame[2] = L3 >> 8 & 255;
    frame[3] = L3 >> 16 & 255;
    l2 += c3;
  }
  return u8concat(out);
}
function parse_old_storage(buf, sst, rsst, v2) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(4, true);
  var data_offset = (v2 > 1 ? 12 : 8) + popcnt(flags & (v2 > 1 ? 3470 : 398)) * 4;
  var ridx = -1, sidx = -1, ieee = NaN, dt = new Date(2001, 0, 1);
  if (flags & 512) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  data_offset += popcnt(flags & (v2 > 1 ? 12288 : 4096)) * 4;
  if (flags & 16) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 32) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 64) {
    dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  var ret;
  switch (buf[2]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: ieee };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else if (sidx > -1)
          ret = { t: "s", v: sst[sidx] };
        else if (!isNaN(ieee))
          ret = { t: "n", v: ieee };
        else
          throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
      }
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf.slice(0, 4)));
  }
  return ret;
}
function parse_new_storage(buf, sst, rsst) {
  var dv = u8_to_dataview(buf);
  var flags = dv.getUint32(8, true);
  var data_offset = 12;
  var ridx = -1, sidx = -1, d128 = NaN, ieee = NaN, dt = new Date(2001, 0, 1);
  if (flags & 1) {
    d128 = readDecimal128LE(buf, data_offset);
    data_offset += 16;
  }
  if (flags & 2) {
    ieee = dv.getFloat64(data_offset, true);
    data_offset += 8;
  }
  if (flags & 4) {
    dt.setTime(dt.getTime() + dv.getFloat64(data_offset, true) * 1e3);
    data_offset += 8;
  }
  if (flags & 8) {
    sidx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  if (flags & 16) {
    ridx = dv.getUint32(data_offset, true);
    data_offset += 4;
  }
  var ret;
  switch (buf[1]) {
    case 0:
      break;
    case 2:
      ret = { t: "n", v: d128 };
      break;
    case 3:
      ret = { t: "s", v: sst[sidx] };
      break;
    case 5:
      ret = { t: "d", v: dt };
      break;
    case 6:
      ret = { t: "b", v: ieee > 0 };
      break;
    case 7:
      ret = { t: "n", v: ieee / 86400 };
      break;
    case 8:
      ret = { t: "e", v: 0 };
      break;
    case 9:
      {
        if (ridx > -1)
          ret = { t: "s", v: rsst[ridx] };
        else
          throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
      }
      break;
    case 10:
      ret = { t: "n", v: d128 };
      break;
    default:
      throw new Error("Unsupported cell type ".concat(buf[1], " : ").concat(flags & 31, " : ").concat(buf.slice(0, 4)));
  }
  return ret;
}
function write_new_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
  out[0] = 5;
  switch (cell.t) {
    case "n":
      out[1] = 2;
      writeDecimal128LE(out, l2, cell.v);
      flags |= 1;
      l2 += 16;
      break;
    case "b":
      out[1] = 6;
      dv.setFloat64(l2, cell.v ? 1 : 0, true);
      flags |= 2;
      l2 += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[1] = 3;
      dv.setUint32(l2, sst.indexOf(cell.v), true);
      flags |= 8;
      l2 += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(8, flags, true);
  return out.slice(0, l2);
}
function write_old_storage(cell, sst) {
  var out = new Uint8Array(32), dv = u8_to_dataview(out), l2 = 12, flags = 0;
  out[0] = 3;
  switch (cell.t) {
    case "n":
      out[2] = 2;
      dv.setFloat64(l2, cell.v, true);
      flags |= 32;
      l2 += 8;
      break;
    case "b":
      out[2] = 6;
      dv.setFloat64(l2, cell.v ? 1 : 0, true);
      flags |= 32;
      l2 += 8;
      break;
    case "s":
      if (sst.indexOf(cell.v) == -1)
        throw new Error("Value ".concat(cell.v, " missing from SST!"));
      out[2] = 3;
      dv.setUint32(l2, sst.indexOf(cell.v), true);
      flags |= 16;
      l2 += 4;
      break;
    default:
      throw "unsupported cell type " + cell.t;
  }
  dv.setUint32(4, flags, true);
  return out.slice(0, l2);
}
function parse_cell_storage(buf, sst, rsst) {
  switch (buf[0]) {
    case 0:
    case 1:
    case 2:
    case 3:
      return parse_old_storage(buf, sst, rsst, buf[0]);
    case 5:
      return parse_new_storage(buf, sst, rsst);
    default:
      throw new Error("Unsupported payload version ".concat(buf[0]));
  }
}
function parse_TSP_Reference(buf) {
  var pb2 = parse_shallow(buf);
  return parse_varint49(pb2[1][0].data);
}
function parse_TST_TableDataList(M4, root) {
  var pb2 = parse_shallow(root.data);
  var type = varint_to_i32(pb2[1][0].data);
  var entries = pb2[3];
  var data = [];
  (entries || []).forEach(function(entry) {
    var le2 = parse_shallow(entry.data);
    var key = varint_to_i32(le2[1][0].data) >>> 0;
    switch (type) {
      case 1:
        data[key] = u8str(le2[3][0].data);
        break;
      case 8:
        {
          var rt = M4[parse_TSP_Reference(le2[9][0].data)][0];
          var rtp = parse_shallow(rt.data);
          var rtpref = M4[parse_TSP_Reference(rtp[1][0].data)][0];
          var mtype = varint_to_i32(rtpref.meta[1][0].data);
          if (mtype != 2001)
            throw new Error("2000 unexpected reference to ".concat(mtype));
          var tswpsa = parse_shallow(rtpref.data);
          data[key] = tswpsa[3].map(function(x3) {
            return u8str(x3.data);
          }).join("");
        }
        break;
    }
  });
  return data;
}
function parse_TST_TileRowInfo(u8, type) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  var pb2 = parse_shallow(u8);
  var R3 = varint_to_i32(pb2[1][0].data) >>> 0;
  var cnt = varint_to_i32(pb2[2][0].data) >>> 0;
  var wide_offsets = ((_b = (_a = pb2[8]) == null ? void 0 : _a[0]) == null ? void 0 : _b.data) && varint_to_i32(pb2[8][0].data) > 0 || false;
  var used_storage_u8, used_storage;
  if (((_d = (_c = pb2[7]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && type != 0) {
    used_storage_u8 = (_f = (_e = pb2[7]) == null ? void 0 : _e[0]) == null ? void 0 : _f.data;
    used_storage = (_h = (_g = pb2[6]) == null ? void 0 : _g[0]) == null ? void 0 : _h.data;
  } else if (((_j = (_i = pb2[4]) == null ? void 0 : _i[0]) == null ? void 0 : _j.data) && type != 1) {
    used_storage_u8 = (_l = (_k = pb2[4]) == null ? void 0 : _k[0]) == null ? void 0 : _l.data;
    used_storage = (_n = (_m = pb2[3]) == null ? void 0 : _m[0]) == null ? void 0 : _n.data;
  } else
    throw "NUMBERS Tile missing ".concat(type, " cell storage");
  var width = wide_offsets ? 4 : 1;
  var used_storage_offsets = u8_to_dataview(used_storage_u8);
  var offsets = [];
  for (var C2 = 0; C2 < used_storage_u8.length / 2; ++C2) {
    var off = used_storage_offsets.getUint16(C2 * 2, true);
    if (off < 65535)
      offsets.push([C2, off]);
  }
  if (offsets.length != cnt)
    throw "Expected ".concat(cnt, " cells, found ").concat(offsets.length);
  var cells = [];
  for (C2 = 0; C2 < offsets.length - 1; ++C2)
    cells[offsets[C2][0]] = used_storage.subarray(offsets[C2][1] * width, offsets[C2 + 1][1] * width);
  if (offsets.length >= 1)
    cells[offsets[offsets.length - 1][0]] = used_storage.subarray(offsets[offsets.length - 1][1] * width);
  return { R: R3, cells };
}
function parse_TST_Tile(M4, root) {
  var _a;
  var pb2 = parse_shallow(root.data);
  var storage = ((_a = pb2 == null ? void 0 : pb2[7]) == null ? void 0 : _a[0]) ? varint_to_i32(pb2[7][0].data) >>> 0 > 0 ? 1 : 0 : -1;
  var ri2 = mappa(pb2[5], function(u8) {
    return parse_TST_TileRowInfo(u8, storage);
  });
  return {
    nrows: varint_to_i32(pb2[4][0].data) >>> 0,
    data: ri2.reduce(function(acc, x3) {
      if (!acc[x3.R])
        acc[x3.R] = [];
      x3.cells.forEach(function(cell, C2) {
        if (acc[x3.R][C2])
          throw new Error("Duplicate cell r=".concat(x3.R, " c=").concat(C2));
        acc[x3.R][C2] = cell;
      });
      return acc;
    }, [])
  };
}
function parse_TST_TableModelArchive(M4, root, ws) {
  var _a;
  var pb2 = parse_shallow(root.data);
  var range = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  range.e.r = (varint_to_i32(pb2[6][0].data) >>> 0) - 1;
  if (range.e.r < 0)
    throw new Error("Invalid row varint ".concat(pb2[6][0].data));
  range.e.c = (varint_to_i32(pb2[7][0].data) >>> 0) - 1;
  if (range.e.c < 0)
    throw new Error("Invalid col varint ".concat(pb2[7][0].data));
  ws["!ref"] = encode_range(range);
  var store = parse_shallow(pb2[4][0].data);
  var sst = parse_TST_TableDataList(M4, M4[parse_TSP_Reference(store[4][0].data)][0]);
  var rsst = ((_a = store[17]) == null ? void 0 : _a[0]) ? parse_TST_TableDataList(M4, M4[parse_TSP_Reference(store[17][0].data)][0]) : [];
  var tile = parse_shallow(store[3][0].data);
  var _R = 0;
  tile[1].forEach(function(t3) {
    var tl2 = parse_shallow(t3.data);
    var ref = M4[parse_TSP_Reference(tl2[2][0].data)][0];
    var mtype = varint_to_i32(ref.meta[1][0].data);
    if (mtype != 6002)
      throw new Error("6001 unexpected reference to ".concat(mtype));
    var _tile = parse_TST_Tile(M4, ref);
    _tile.data.forEach(function(row, R3) {
      row.forEach(function(buf, C2) {
        var addr = encode_cell({ r: _R + R3, c: C2 });
        var res = parse_cell_storage(buf, sst, rsst);
        if (res)
          ws[addr] = res;
      });
    });
    _R += _tile.nrows;
  });
}
function parse_TST_TableInfoArchive(M4, root) {
  var pb2 = parse_shallow(root.data);
  var out = { "!ref": "A1" };
  var tableref = M4[parse_TSP_Reference(pb2[2][0].data)];
  var mtype = varint_to_i32(tableref[0].meta[1][0].data);
  if (mtype != 6001)
    throw new Error("6000 unexpected reference to ".concat(mtype));
  parse_TST_TableModelArchive(M4, tableref[0], out);
  return out;
}
function parse_TN_SheetArchive(M4, root) {
  var _a;
  var pb2 = parse_shallow(root.data);
  var out = {
    name: ((_a = pb2[1]) == null ? void 0 : _a[0]) ? u8str(pb2[1][0].data) : "",
    sheets: []
  };
  var shapeoffs = mappa(pb2[2], parse_TSP_Reference);
  shapeoffs.forEach(function(off) {
    M4[off].forEach(function(m4) {
      var mtype = varint_to_i32(m4.meta[1][0].data);
      if (mtype == 6e3)
        out.sheets.push(parse_TST_TableInfoArchive(M4, m4));
    });
  });
  return out;
}
function parse_TN_DocumentArchive(M4, root) {
  var out = book_new();
  var pb2 = parse_shallow(root.data);
  var sheetoffs = mappa(pb2[1], parse_TSP_Reference);
  sheetoffs.forEach(function(off) {
    M4[off].forEach(function(m4) {
      var mtype = varint_to_i32(m4.meta[1][0].data);
      if (mtype == 2) {
        var root2 = parse_TN_SheetArchive(M4, m4);
        root2.sheets.forEach(function(sheet, idx) {
          book_append_sheet(out, sheet, idx == 0 ? root2.name : root2.name + "_" + idx, true);
        });
      }
    });
  });
  if (out.SheetNames.length == 0)
    throw new Error("Empty NUMBERS file");
  return out;
}
function parse_numbers_iwa(cfb) {
  var _a, _b, _c, _d;
  var M4 = {}, indices = [];
  cfb.FullPaths.forEach(function(p2) {
    if (p2.match(/\.iwpv2/))
      throw new Error("Unsupported password protection");
  });
  cfb.FileIndex.forEach(function(s4) {
    if (!s4.name.match(/\.iwa$/))
      return;
    var o2;
    try {
      o2 = decompress_iwa_file(s4.content);
    } catch (e3) {
      return console.log("?? " + s4.content.length + " " + (e3.message || e3));
    }
    var packets;
    try {
      packets = parse_iwa_file(o2);
    } catch (e3) {
      return console.log("## " + (e3.message || e3));
    }
    packets.forEach(function(packet) {
      M4[packet.id] = packet.messages;
      indices.push(packet.id);
    });
  });
  if (!indices.length)
    throw new Error("File has no messages");
  var docroot = ((_d = (_c = (_b = (_a = M4 == null ? void 0 : M4[1]) == null ? void 0 : _a[0]) == null ? void 0 : _b.meta) == null ? void 0 : _c[1]) == null ? void 0 : _d[0].data) && varint_to_i32(M4[1][0].meta[1][0].data) == 1 && M4[1][0];
  if (!docroot)
    indices.forEach(function(idx) {
      M4[idx].forEach(function(iwam) {
        var mtype = varint_to_i32(iwam.meta[1][0].data) >>> 0;
        if (mtype == 1) {
          if (!docroot)
            docroot = iwam;
          else
            throw new Error("Document has multiple roots");
        }
      });
    });
  if (!docroot)
    throw new Error("Cannot find Document root");
  return parse_TN_DocumentArchive(M4, docroot);
}
function write_tile_row(tri, data, SST) {
  var _a, _b, _c, _d;
  if (!((_a = tri[6]) == null ? void 0 : _a[0]) || !((_b = tri[7]) == null ? void 0 : _b[0]))
    throw "Mutation only works on post-BNC storages!";
  var wide_offsets = ((_d = (_c = tri[8]) == null ? void 0 : _c[0]) == null ? void 0 : _d.data) && varint_to_i32(tri[8][0].data) > 0 || false;
  if (wide_offsets)
    throw "Math only works with normal offsets";
  var cnt = 0;
  var dv = u8_to_dataview(tri[7][0].data), last_offset = 0, cell_storage = [];
  var _dv = u8_to_dataview(tri[4][0].data), _last_offset = 0, _cell_storage = [];
  for (var C2 = 0; C2 < data.length; ++C2) {
    if (data[C2] == null) {
      dv.setUint16(C2 * 2, 65535, true);
      _dv.setUint16(C2 * 2, 65535);
      continue;
    }
    dv.setUint16(C2 * 2, last_offset, true);
    _dv.setUint16(C2 * 2, _last_offset, true);
    var celload, _celload;
    switch (typeof data[C2]) {
      case "string":
        celload = write_new_storage({ t: "s", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "s", v: data[C2] }, SST);
        break;
      case "number":
        celload = write_new_storage({ t: "n", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "n", v: data[C2] }, SST);
        break;
      case "boolean":
        celload = write_new_storage({ t: "b", v: data[C2] }, SST);
        _celload = write_old_storage({ t: "b", v: data[C2] }, SST);
        break;
      default:
        throw new Error("Unsupported value " + data[C2]);
    }
    cell_storage.push(celload);
    last_offset += celload.length;
    _cell_storage.push(_celload);
    _last_offset += _celload.length;
    ++cnt;
  }
  tri[2][0].data = write_varint49(cnt);
  for (; C2 < tri[7][0].data.length / 2; ++C2) {
    dv.setUint16(C2 * 2, 65535, true);
    _dv.setUint16(C2 * 2, 65535, true);
  }
  tri[6][0].data = u8concat(cell_storage);
  tri[3][0].data = u8concat(_cell_storage);
  return cnt;
}
function write_numbers_iwa(wb2, opts) {
  if (!opts || !opts.numbers)
    throw new Error("Must pass a `numbers` option -- check the README");
  var ws = wb2.Sheets[wb2.SheetNames[0]];
  if (wb2.SheetNames.length > 1)
    console.error("The Numbers writer currently writes only the first table");
  var range = decode_range(ws["!ref"]);
  range.s.r = range.s.c = 0;
  var trunc2 = false;
  if (range.e.c > 9) {
    trunc2 = true;
    range.e.c = 9;
  }
  if (range.e.r > 49) {
    trunc2 = true;
    range.e.r = 49;
  }
  if (trunc2)
    console.error("The Numbers writer is currently limited to ".concat(encode_range(range)));
  var data = sheet_to_json(ws, { range, header: 1 });
  var SST = ["~Sh33tJ5~"];
  data.forEach(function(row) {
    return row.forEach(function(cell) {
      if (typeof cell == "string")
        SST.push(cell);
    });
  });
  var dependents = {};
  var indices = [];
  var cfb = CFB.read(opts.numbers, { type: "base64" });
  cfb.FileIndex.map(function(fi2, idx) {
    return [fi2, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi2 = row[0], fp = row[1];
    if (fi2.type != 2)
      return;
    if (!fi2.name.match(/\.iwa/))
      return;
    var old_content = fi2.content;
    var raw1 = decompress_iwa_file(old_content);
    var x22 = parse_iwa_file(raw1);
    x22.forEach(function(packet2) {
      indices.push(packet2.id);
      dependents[packet2.id] = { deps: [], location: fp, type: varint_to_i32(packet2.messages[0].meta[1][0].data) };
    });
  });
  indices.sort(function(x22, y22) {
    return x22 - y22;
  });
  var indices_varint = indices.filter(function(x22) {
    return x22 > 1;
  }).map(function(x22) {
    return [x22, write_varint49(x22)];
  });
  cfb.FileIndex.map(function(fi2, idx) {
    return [fi2, cfb.FullPaths[idx]];
  }).forEach(function(row) {
    var fi2 = row[0];
    row[1];
    if (!fi2.name.match(/\.iwa/))
      return;
    var x22 = parse_iwa_file(decompress_iwa_file(fi2.content));
    x22.forEach(function(ia2) {
      ia2.messages.forEach(function(m4) {
        indices_varint.forEach(function(ivi) {
          if (ia2.messages.some(function(mess) {
            return varint_to_i32(mess.meta[1][0].data) != 11006 && u8contains(mess.data, ivi[1]);
          })) {
            dependents[ivi[0]].deps.push(ia2.id);
          }
        });
      });
    });
  });
  var entry = CFB.find(cfb, dependents[1].location);
  var x3 = parse_iwa_file(decompress_iwa_file(entry.content));
  var docroot;
  for (var xi2 = 0; xi2 < x3.length; ++xi2) {
    var packet = x3[xi2];
    if (packet.id == 1)
      docroot = packet;
  }
  var sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[1][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x3 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi2 = 0; xi2 < x3.length; ++xi2) {
    packet = x3[xi2];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x3 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi2 = 0; xi2 < x3.length; ++xi2) {
    packet = x3[xi2];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  sheetrootref = parse_TSP_Reference(parse_shallow(docroot.messages[0].data)[2][0].data);
  entry = CFB.find(cfb, dependents[sheetrootref].location);
  x3 = parse_iwa_file(decompress_iwa_file(entry.content));
  for (xi2 = 0; xi2 < x3.length; ++xi2) {
    packet = x3[xi2];
    if (packet.id == sheetrootref)
      docroot = packet;
  }
  var pb2 = parse_shallow(docroot.messages[0].data);
  {
    pb2[6][0].data = write_varint49(range.e.r + 1);
    pb2[7][0].data = write_varint49(range.e.c + 1);
    var cruidsref = parse_TSP_Reference(pb2[46][0].data);
    var oldbucket = CFB.find(cfb, dependents[cruidsref].location);
    var _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
    {
      for (var j2 = 0; j2 < _x.length; ++j2) {
        if (_x[j2].id == cruidsref)
          break;
      }
      if (_x[j2].id != cruidsref)
        throw "Bad ColumnRowUIDMapArchive";
      var cruids = parse_shallow(_x[j2].messages[0].data);
      cruids[1] = [];
      cruids[2] = [], cruids[3] = [];
      for (var C2 = 0; C2 <= range.e.c; ++C2) {
        var uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(C2 + 420690) }];
        cruids[1].push({ type: 2, data: write_shallow(uuid) });
        cruids[2].push({ type: 0, data: write_varint49(C2) });
        cruids[3].push({ type: 0, data: write_varint49(C2) });
      }
      cruids[4] = [];
      cruids[5] = [], cruids[6] = [];
      for (var R3 = 0; R3 <= range.e.r; ++R3) {
        uuid = [];
        uuid[1] = uuid[2] = [{ type: 0, data: write_varint49(R3 + 726270) }];
        cruids[4].push({ type: 2, data: write_shallow(uuid) });
        cruids[5].push({ type: 0, data: write_varint49(R3) });
        cruids[6].push({ type: 0, data: write_varint49(R3) });
      }
      _x[j2].messages[0].data = write_shallow(cruids);
    }
    oldbucket.content = compress_iwa_file(write_iwa_file(_x));
    oldbucket.size = oldbucket.content.length;
    delete pb2[46];
    var store = parse_shallow(pb2[4][0].data);
    {
      store[7][0].data = write_varint49(range.e.r + 1);
      var row_headers = parse_shallow(store[1][0].data);
      var row_header_ref = parse_TSP_Reference(row_headers[2][0].data);
      oldbucket = CFB.find(cfb, dependents[row_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != row_header_ref)
          throw "Bad HeaderStorageBucket";
        var base_bucket = parse_shallow(_x[0].messages[0].data);
        for (R3 = 0; R3 < data.length; ++R3) {
          var _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(R3);
          _bucket[4][0].data = write_varint49(data[R3].length);
          base_bucket[2][R3] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var col_header_ref = parse_TSP_Reference(store[2][0].data);
      oldbucket = CFB.find(cfb, dependents[col_header_ref].location);
      _x = parse_iwa_file(decompress_iwa_file(oldbucket.content));
      {
        if (_x[0].id != col_header_ref)
          throw "Bad HeaderStorageBucket";
        base_bucket = parse_shallow(_x[0].messages[0].data);
        for (C2 = 0; C2 <= range.e.c; ++C2) {
          _bucket = parse_shallow(base_bucket[2][0].data);
          _bucket[1][0].data = write_varint49(C2);
          _bucket[4][0].data = write_varint49(range.e.r + 1);
          base_bucket[2][C2] = { type: base_bucket[2][0].type, data: write_shallow(_bucket) };
        }
        _x[0].messages[0].data = write_shallow(base_bucket);
      }
      oldbucket.content = compress_iwa_file(write_iwa_file(_x));
      oldbucket.size = oldbucket.content.length;
      var sstref = parse_TSP_Reference(store[4][0].data);
      (function() {
        var sentry = CFB.find(cfb, dependents[sstref].location);
        var sx = parse_iwa_file(decompress_iwa_file(sentry.content));
        var sstroot;
        for (var sxi = 0; sxi < sx.length; ++sxi) {
          var packet2 = sx[sxi];
          if (packet2.id == sstref)
            sstroot = packet2;
        }
        var sstdata = parse_shallow(sstroot.messages[0].data);
        {
          sstdata[3] = [];
          var newsst = [];
          SST.forEach(function(str, i3) {
            newsst[1] = [{ type: 0, data: write_varint49(i3) }];
            newsst[2] = [{ type: 0, data: write_varint49(1) }];
            newsst[3] = [{ type: 2, data: stru8(str) }];
            sstdata[3].push({ type: 2, data: write_shallow(newsst) });
          });
        }
        sstroot.messages[0].data = write_shallow(sstdata);
        var sy = write_iwa_file(sx);
        var raw32 = compress_iwa_file(sy);
        sentry.content = raw32;
        sentry.size = sentry.content.length;
      })();
      var tile = parse_shallow(store[3][0].data);
      {
        var t3 = tile[1][0];
        delete tile[2];
        var tl2 = parse_shallow(t3.data);
        {
          var tileref = parse_TSP_Reference(tl2[2][0].data);
          (function() {
            var tentry = CFB.find(cfb, dependents[tileref].location);
            var tx = parse_iwa_file(decompress_iwa_file(tentry.content));
            var tileroot;
            for (var sxi = 0; sxi < tx.length; ++sxi) {
              var packet2 = tx[sxi];
              if (packet2.id == tileref)
                tileroot = packet2;
            }
            var tiledata = parse_shallow(tileroot.messages[0].data);
            {
              delete tiledata[6];
              delete tile[7];
              var rowload = new Uint8Array(tiledata[5][0].data);
              tiledata[5] = [];
              var cnt = 0;
              for (var R22 = 0; R22 <= range.e.r; ++R22) {
                var tilerow = parse_shallow(rowload);
                cnt += write_tile_row(tilerow, data[R22], SST);
                tilerow[1][0].data = write_varint49(R22);
                tiledata[5].push({ data: write_shallow(tilerow), type: 2 });
              }
              tiledata[1] = [{ type: 0, data: write_varint49(range.e.c + 1) }];
              tiledata[2] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
              tiledata[3] = [{ type: 0, data: write_varint49(cnt) }];
              tiledata[4] = [{ type: 0, data: write_varint49(range.e.r + 1) }];
            }
            tileroot.messages[0].data = write_shallow(tiledata);
            var ty = write_iwa_file(tx);
            var raw32 = compress_iwa_file(ty);
            tentry.content = raw32;
            tentry.size = tentry.content.length;
          })();
        }
        t3.data = write_shallow(tl2);
      }
      store[3][0].data = write_shallow(tile);
    }
    pb2[4][0].data = write_shallow(store);
  }
  docroot.messages[0].data = write_shallow(pb2);
  var y4 = write_iwa_file(x3);
  var raw3 = compress_iwa_file(y4);
  entry.content = raw3;
  entry.size = entry.content.length;
  return cfb;
}
function fix_opts_func(defaults) {
  return function fix_opts(opts) {
    for (var i3 = 0; i3 != defaults.length; ++i3) {
      var d4 = defaults[i3];
      if (opts[d4[0]] === void 0) opts[d4[0]] = d4[1];
      if (d4[2] === "n") opts[d4[0]] = Number(opts[d4[0]]);
    }
  };
}
function fix_read_opts(opts) {
  fix_opts_func([
    ["cellNF", false],
    /* emit cell number format string as .z */
    ["cellHTML", true],
    /* emit html string as .h */
    ["cellFormula", true],
    /* emit formulae as .f */
    ["cellStyles", false],
    /* emits style/theme as .s */
    ["cellText", true],
    /* emit formatted text as .w */
    ["cellDates", false],
    /* emit date cells with type `d` */
    ["sheetStubs", false],
    /* emit empty cells */
    ["sheetRows", 0, "n"],
    /* read n rows (0 = read all rows) */
    ["bookDeps", false],
    /* parse calculation chains */
    ["bookSheets", false],
    /* only try to get sheet names (no Sheets) */
    ["bookProps", false],
    /* only try to get properties (no Sheets) */
    ["bookFiles", false],
    /* include raw file structure (keys, files, cfb) */
    ["bookVBA", false],
    /* include vba raw data (vbaraw) */
    ["password", ""],
    /* password */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function fix_write_opts(opts) {
  fix_opts_func([
    ["cellDates", false],
    /* write date cells with type `d` */
    ["bookSST", false],
    /* Generate Shared String Table */
    ["bookType", "xlsx"],
    /* Type of workbook (xlsx/m/b) */
    ["compression", false],
    /* Use file compression */
    ["WTF", false]
    /* WTF mode (throws errors) */
  ])(opts);
}
function get_sheet_type(n2) {
  if (RELS.WS.indexOf(n2) > -1) return "sheet";
  if (n2 == RELS.CS) return "chart";
  if (n2 == RELS.DS) return "dialog";
  if (n2 == RELS.MS) return "macro";
  return n2 && n2.length ? n2 : "sheet";
}
function safe_parse_wbrels(wbrels, sheets) {
  if (!wbrels) return 0;
  try {
    wbrels = sheets.map(function pwbr(w3) {
      if (!w3.id) w3.id = w3.strRelID;
      return [w3.name, wbrels["!id"][w3.id].Target, get_sheet_type(wbrels["!id"][w3.id].Type)];
    });
  } catch (e3) {
    return null;
  }
  return !wbrels || wbrels.length === 0 ? null : wbrels;
}
function safe_parse_sheet(zip, path, relsPath, sheet, idx, sheetRels, sheets, stype, opts, wb2, themes, styles) {
  try {
    sheetRels[sheet] = parse_rels(getzipstr(zip, relsPath, true), path);
    var data = getzipdata(zip, path);
    var _ws;
    switch (stype) {
      case "sheet":
        _ws = parse_ws(data, path, idx, opts, sheetRels[sheet], wb2, themes, styles);
        break;
      case "chart":
        _ws = parse_cs(data, path, idx, opts, sheetRels[sheet], wb2, themes, styles);
        if (!_ws || !_ws["!drawel"]) break;
        var dfile = resolve_path(_ws["!drawel"].Target, path);
        var drelsp = get_rels_path(dfile);
        var draw = parse_drawing(getzipstr(zip, dfile, true), parse_rels(getzipstr(zip, drelsp, true), dfile));
        var chartp = resolve_path(draw, dfile);
        var crelsp = get_rels_path(chartp);
        _ws = parse_chart(getzipstr(zip, chartp, true), chartp, opts, parse_rels(getzipstr(zip, crelsp, true), chartp), wb2, _ws);
        break;
      case "macro":
        _ws = parse_ms(data, path, idx, opts, sheetRels[sheet], wb2, themes, styles);
        break;
      case "dialog":
        _ws = parse_ds(data, path, idx, opts, sheetRels[sheet], wb2, themes, styles);
        break;
      default:
        throw new Error("Unrecognized sheet type " + stype);
    }
    sheets[sheet] = _ws;
    var tcomments = [];
    if (sheetRels && sheetRels[sheet]) keys(sheetRels[sheet]).forEach(function(n2) {
      var dfile2 = "";
      if (sheetRels[sheet][n2].Type == RELS.CMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n2].Target, path);
        var comments = parse_cmnt(getzipdata(zip, dfile2, true), dfile2, opts);
        if (!comments || !comments.length) return;
        sheet_insert_comments(_ws, comments, false);
      }
      if (sheetRels[sheet][n2].Type == RELS.TCMNT) {
        dfile2 = resolve_path(sheetRels[sheet][n2].Target, path);
        tcomments = tcomments.concat(parse_tcmnt_xml(getzipdata(zip, dfile2, true), opts));
      }
    });
    if (tcomments && tcomments.length) sheet_insert_comments(_ws, tcomments, true, opts.people || []);
  } catch (e3) {
    if (opts.WTF) throw e3;
  }
}
function strip_front_slash(x3) {
  return x3.charAt(0) == "/" ? x3.slice(1) : x3;
}
function parse_zip(zip, opts) {
  make_ssf();
  opts = opts || {};
  fix_read_opts(opts);
  if (safegetzipfile(zip, "META-INF/manifest.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "objectdata.xml")) return parse_ods(zip, opts);
  if (safegetzipfile(zip, "Index/Document.iwa")) {
    if (typeof Uint8Array == "undefined") throw new Error("NUMBERS file parsing requires Uint8Array support");
    if (typeof parse_numbers_iwa != "undefined") {
      if (zip.FileIndex) return parse_numbers_iwa(zip);
      var _zip = CFB.utils.cfb_new();
      zipentries(zip).forEach(function(e3) {
        zip_add_file(_zip, e3, getzipbin(zip, e3));
      });
      return parse_numbers_iwa(_zip);
    }
    throw new Error("Unsupported NUMBERS file");
  }
  if (!safegetzipfile(zip, "[Content_Types].xml")) {
    if (safegetzipfile(zip, "index.xml.gz")) throw new Error("Unsupported NUMBERS 08 file");
    if (safegetzipfile(zip, "index.xml")) throw new Error("Unsupported NUMBERS 09 file");
    throw new Error("Unsupported ZIP file");
  }
  var entries = zipentries(zip);
  var dir = parse_ct(getzipstr(zip, "[Content_Types].xml"));
  var xlsb = false;
  var sheets, binname;
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.xml";
    if (getzipdata(zip, binname, true)) dir.workbooks.push(binname);
  }
  if (dir.workbooks.length === 0) {
    binname = "xl/workbook.bin";
    if (!getzipdata(zip, binname, true)) throw new Error("Could not find workbook");
    dir.workbooks.push(binname);
    xlsb = true;
  }
  if (dir.workbooks[0].slice(-3) == "bin") xlsb = true;
  var themes = {};
  var styles = {};
  if (!opts.bookSheets && !opts.bookProps) {
    strs = [];
    if (dir.sst) try {
      strs = parse_sst(getzipdata(zip, strip_front_slash(dir.sst)), dir.sst, opts);
    } catch (e3) {
      if (opts.WTF) throw e3;
    }
    if (opts.cellStyles && dir.themes.length) themes = parse_theme(getzipstr(zip, dir.themes[0].replace(/^\//, ""), true) || "", dir.themes[0], opts);
    if (dir.style) styles = parse_sty(getzipdata(zip, strip_front_slash(dir.style)), dir.style, themes, opts);
  }
  dir.links.map(function(link) {
    try {
      var rels = parse_rels(getzipstr(zip, get_rels_path(strip_front_slash(link))), link);
      return parse_xlink(getzipdata(zip, strip_front_slash(link)), rels, link, opts);
    } catch (e3) {
    }
  });
  var wb2 = parse_wb(getzipdata(zip, strip_front_slash(dir.workbooks[0])), dir.workbooks[0], opts);
  var props = {}, propdata = "";
  if (dir.coreprops.length) {
    propdata = getzipdata(zip, strip_front_slash(dir.coreprops[0]), true);
    if (propdata) props = parse_core_props(propdata);
    if (dir.extprops.length !== 0) {
      propdata = getzipdata(zip, strip_front_slash(dir.extprops[0]), true);
      if (propdata) parse_ext_props(propdata, props, opts);
    }
  }
  var custprops = {};
  if (!opts.bookSheets || opts.bookProps) {
    if (dir.custprops.length !== 0) {
      propdata = getzipstr(zip, strip_front_slash(dir.custprops[0]), true);
      if (propdata) custprops = parse_cust_props(propdata, opts);
    }
  }
  var out = {};
  if (opts.bookSheets || opts.bookProps) {
    if (wb2.Sheets) sheets = wb2.Sheets.map(function pluck(x3) {
      return x3.name;
    });
    else if (props.Worksheets && props.SheetNames.length > 0) sheets = props.SheetNames;
    if (opts.bookProps) {
      out.Props = props;
      out.Custprops = custprops;
    }
    if (opts.bookSheets && typeof sheets !== "undefined") out.SheetNames = sheets;
    if (opts.bookSheets ? out.SheetNames : opts.bookProps) return out;
  }
  sheets = {};
  var deps = {};
  if (opts.bookDeps && dir.calcchain) deps = parse_cc(getzipdata(zip, strip_front_slash(dir.calcchain)), dir.calcchain);
  var i3 = 0;
  var sheetRels = {};
  var path, relsPath;
  {
    var wbsheets = wb2.Sheets;
    props.Worksheets = wbsheets.length;
    props.SheetNames = [];
    for (var j2 = 0; j2 != wbsheets.length; ++j2) {
      props.SheetNames[j2] = wbsheets[j2].name;
    }
  }
  var wbext = xlsb ? "bin" : "xml";
  var wbrelsi = dir.workbooks[0].lastIndexOf("/");
  var wbrelsfile = (dir.workbooks[0].slice(0, wbrelsi + 1) + "_rels/" + dir.workbooks[0].slice(wbrelsi + 1) + ".rels").replace(/^\//, "");
  if (!safegetzipfile(zip, wbrelsfile)) wbrelsfile = "xl/_rels/workbook." + wbext + ".rels";
  var wbrels = parse_rels(getzipstr(zip, wbrelsfile, true), wbrelsfile.replace(/_rels.*/, "s5s"));
  if ((dir.metadata || []).length >= 1) {
    opts.xlmeta = parse_xlmeta(getzipdata(zip, strip_front_slash(dir.metadata[0])), dir.metadata[0], opts);
  }
  if ((dir.people || []).length >= 1) {
    opts.people = parse_people_xml(getzipdata(zip, strip_front_slash(dir.people[0])), opts);
  }
  if (wbrels) wbrels = safe_parse_wbrels(wbrels, wb2.Sheets);
  var nmode = getzipdata(zip, "xl/worksheets/sheet.xml", true) ? 1 : 0;
  wsloop: for (i3 = 0; i3 != props.Worksheets; ++i3) {
    var stype = "sheet";
    if (wbrels && wbrels[i3]) {
      path = "xl/" + wbrels[i3][1].replace(/[\/]?xl\//, "");
      if (!safegetzipfile(zip, path)) path = wbrels[i3][1];
      if (!safegetzipfile(zip, path)) path = wbrelsfile.replace(/_rels\/.*$/, "") + wbrels[i3][1];
      stype = wbrels[i3][2];
    } else {
      path = "xl/worksheets/sheet" + (i3 + 1 - nmode) + "." + wbext;
      path = path.replace(/sheet0\./, "sheet.");
    }
    relsPath = path.replace(/^(.*)(\/)([^\/]*)$/, "$1/_rels/$3.rels");
    if (opts && opts.sheets != null) switch (typeof opts.sheets) {
      case "number":
        if (i3 != opts.sheets) continue wsloop;
        break;
      case "string":
        if (props.SheetNames[i3].toLowerCase() != opts.sheets.toLowerCase()) continue wsloop;
        break;
      default:
        if (Array.isArray && Array.isArray(opts.sheets)) {
          var snjseen = false;
          for (var snj = 0; snj != opts.sheets.length; ++snj) {
            if (typeof opts.sheets[snj] == "number" && opts.sheets[snj] == i3) snjseen = 1;
            if (typeof opts.sheets[snj] == "string" && opts.sheets[snj].toLowerCase() == props.SheetNames[i3].toLowerCase()) snjseen = 1;
          }
          if (!snjseen) continue wsloop;
        }
    }
    safe_parse_sheet(zip, path, relsPath, props.SheetNames[i3], i3, sheetRels, sheets, stype, opts, wb2, themes, styles);
  }
  out = {
    Directory: dir,
    Workbook: wb2,
    Props: props,
    Custprops: custprops,
    Deps: deps,
    Sheets: sheets,
    SheetNames: props.SheetNames,
    Strings: strs,
    Styles: styles,
    Themes: themes,
    SSF: dup(table_fmt)
  };
  if (opts && opts.bookFiles) {
    if (zip.files) {
      out.keys = entries;
      out.files = zip.files;
    } else {
      out.keys = [];
      out.files = {};
      zip.FullPaths.forEach(function(p2, idx) {
        p2 = p2.replace(/^Root Entry[\/]/, "");
        out.keys.push(p2);
        out.files[p2] = zip.FileIndex[idx];
      });
    }
  }
  if (opts && opts.bookVBA) {
    if (dir.vba.length > 0) out.vbaraw = getzipdata(zip, strip_front_slash(dir.vba[0]), true);
    else if (dir.defaults && dir.defaults.bin === CT_VBA) out.vbaraw = getzipdata(zip, "xl/vbaProject.bin", true);
  }
  return out;
}
function parse_xlsxcfb(cfb, _opts) {
  var opts = _opts || {};
  var f2 = "Workbook", data = CFB.find(cfb, f2);
  try {
    f2 = "/!DataSpaces/Version";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    parse_DataSpaceVersionInfo(data.content);
    f2 = "/!DataSpaces/DataSpaceMap";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    var dsm = parse_DataSpaceMap(data.content);
    if (dsm.length !== 1 || dsm[0].comps.length !== 1 || dsm[0].comps[0].t !== 0 || dsm[0].name !== "StrongEncryptionDataSpace" || dsm[0].comps[0].v !== "EncryptedPackage")
      throw new Error("ECMA-376 Encrypted file bad " + f2);
    f2 = "/!DataSpaces/DataSpaceInfo/StrongEncryptionDataSpace";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    var seds = parse_DataSpaceDefinition(data.content);
    if (seds.length != 1 || seds[0] != "StrongEncryptionTransform")
      throw new Error("ECMA-376 Encrypted file bad " + f2);
    f2 = "/!DataSpaces/TransformInfo/StrongEncryptionTransform/!Primary";
    data = CFB.find(cfb, f2);
    if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
    parse_Primary(data.content);
  } catch (e3) {
  }
  f2 = "/EncryptionInfo";
  data = CFB.find(cfb, f2);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
  var einfo = parse_EncryptionInfo(data.content);
  f2 = "/EncryptedPackage";
  data = CFB.find(cfb, f2);
  if (!data || !data.content) throw new Error("ECMA-376 Encrypted file missing " + f2);
  if (einfo[0] == 4 && typeof decrypt_agile !== "undefined") return decrypt_agile(einfo[1], data.content, opts.password || "", opts);
  if (einfo[0] == 2 && typeof decrypt_std76 !== "undefined") return decrypt_std76(einfo[1], data.content, opts.password || "", opts);
  throw new Error("File is password-protected");
}
function write_zip(wb2, opts) {
  if (opts.bookType == "ods") return write_ods(wb2, opts);
  if (opts.bookType == "numbers") return write_numbers_iwa(wb2, opts);
  if (opts.bookType == "xlsb") return write_zip_xlsxb(wb2, opts);
  return write_zip_xlsx(wb2, opts);
}
function write_zip_xlsxb(wb2, opts) {
  _shapeid = 1024;
  if (wb2 && !wb2.SSF) {
    wb2.SSF = dup(table_fmt);
  }
  if (wb2 && wb2.SSF) {
    make_ssf();
    SSF_load_table(wb2.SSF);
    opts.revssf = evert_num(wb2.SSF);
    opts.revssf[wb2.SSF[65535]] = 0;
    opts.ssf = wb2.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map) opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = opts.bookType == "xlsb" ? "bin" : "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f2 = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb2.Props) wb2.Props = {};
  f2 = "docProps/core.xml";
  zip_add_file(zip, f2, write_core_props(wb2.Props, opts));
  ct.coreprops.push(f2);
  add_rels(opts.rels, 2, f2, RELS.CORE_PROPS);
  f2 = "docProps/app.xml";
  if (wb2.Props && wb2.Props.SheetNames) ;
  else if (!wb2.Workbook || !wb2.Workbook.Sheets) wb2.Props.SheetNames = wb2.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb2.SheetNames.length; ++_i)
      if ((wb2.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb2.SheetNames[_i]);
    wb2.Props.SheetNames = _sn;
  }
  wb2.Props.Worksheets = wb2.Props.SheetNames.length;
  zip_add_file(zip, f2, write_ext_props(wb2.Props));
  ct.extprops.push(f2);
  add_rels(opts.rels, 3, f2, RELS.EXT_PROPS);
  if (wb2.Custprops !== wb2.Props && keys(wb2.Custprops || {}).length > 0) {
    f2 = "docProps/custom.xml";
    zip_add_file(zip, f2, write_cust_props(wb2.Custprops));
    ct.custprops.push(f2);
    add_rels(opts.rels, 4, f2, RELS.CUST_PROPS);
  }
  for (rId = 1; rId <= wb2.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb2.Sheets[wb2.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f2 = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f2, write_ws(rId - 1, f2, opts, wb2, wsrels));
        ct.sheets.push(f2);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf2 = "";
      if (comments && comments.length > 0) {
        cf2 = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf2, write_cmnt(comments, cf2));
        ct.comments.push(cf2);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f2), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f2 = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f2, write_sst(opts.Strings, f2, opts));
    ct.strs.push(f2);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f2 = "xl/workbook." + wbext;
  zip_add_file(zip, f2, write_wb(wb2, f2));
  ct.workbooks.push(f2);
  add_rels(opts.rels, 1, f2, RELS.WB);
  f2 = "xl/theme/theme1.xml";
  zip_add_file(zip, f2, write_theme(wb2.Themes, opts));
  ct.themes.push(f2);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f2 = "xl/styles." + wbext;
  zip_add_file(zip, f2, write_sty(wb2, f2, opts));
  ct.styles.push(f2);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb2.vbaraw && vbafmt) {
    f2 = "xl/vbaProject.bin";
    zip_add_file(zip, f2, wb2.vbaraw);
    ct.vba.push(f2);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f2 = "xl/metadata." + wbext;
  zip_add_file(zip, f2, write_xlmeta(f2));
  ct.metadata.push(f2);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function write_zip_xlsx(wb2, opts) {
  _shapeid = 1024;
  if (wb2 && !wb2.SSF) {
    wb2.SSF = dup(table_fmt);
  }
  if (wb2 && wb2.SSF) {
    make_ssf();
    SSF_load_table(wb2.SSF);
    opts.revssf = evert_num(wb2.SSF);
    opts.revssf[wb2.SSF[65535]] = 0;
    opts.ssf = wb2.SSF;
  }
  opts.rels = {};
  opts.wbrels = {};
  opts.Strings = /*::((*/
  [];
  opts.Strings.Count = 0;
  opts.Strings.Unique = 0;
  if (browser_has_Map) opts.revStrings = /* @__PURE__ */ new Map();
  else {
    opts.revStrings = {};
    opts.revStrings.foo = [];
    delete opts.revStrings.foo;
  }
  var wbext = "xml";
  var vbafmt = VBAFMTS.indexOf(opts.bookType) > -1;
  var ct = new_ct();
  fix_write_opts(opts = opts || {});
  var zip = zip_new();
  var f2 = "", rId = 0;
  opts.cellXfs = [];
  get_cell_style(opts.cellXfs, {}, { revssf: { "General": 0 } });
  if (!wb2.Props) wb2.Props = {};
  f2 = "docProps/core.xml";
  zip_add_file(zip, f2, write_core_props(wb2.Props, opts));
  ct.coreprops.push(f2);
  add_rels(opts.rels, 2, f2, RELS.CORE_PROPS);
  f2 = "docProps/app.xml";
  if (wb2.Props && wb2.Props.SheetNames) ;
  else if (!wb2.Workbook || !wb2.Workbook.Sheets) wb2.Props.SheetNames = wb2.SheetNames;
  else {
    var _sn = [];
    for (var _i = 0; _i < wb2.SheetNames.length; ++_i)
      if ((wb2.Workbook.Sheets[_i] || {}).Hidden != 2) _sn.push(wb2.SheetNames[_i]);
    wb2.Props.SheetNames = _sn;
  }
  wb2.Props.Worksheets = wb2.Props.SheetNames.length;
  zip_add_file(zip, f2, write_ext_props(wb2.Props));
  ct.extprops.push(f2);
  add_rels(opts.rels, 3, f2, RELS.EXT_PROPS);
  if (wb2.Custprops !== wb2.Props && keys(wb2.Custprops || {}).length > 0) {
    f2 = "docProps/custom.xml";
    zip_add_file(zip, f2, write_cust_props(wb2.Custprops));
    ct.custprops.push(f2);
    add_rels(opts.rels, 4, f2, RELS.CUST_PROPS);
  }
  var people = ["SheetJ5"];
  opts.tcid = 0;
  for (rId = 1; rId <= wb2.SheetNames.length; ++rId) {
    var wsrels = { "!id": {} };
    var ws = wb2.Sheets[wb2.SheetNames[rId - 1]];
    var _type = (ws || {})["!type"] || "sheet";
    switch (_type) {
      case "chart":
      default:
        f2 = "xl/worksheets/sheet" + rId + "." + wbext;
        zip_add_file(zip, f2, write_ws_xml(rId - 1, opts, wb2, wsrels));
        ct.sheets.push(f2);
        add_rels(opts.wbrels, -1, "worksheets/sheet" + rId + "." + wbext, RELS.WS[0]);
    }
    if (ws) {
      var comments = ws["!comments"];
      var need_vml = false;
      var cf2 = "";
      if (comments && comments.length > 0) {
        var needtc = false;
        comments.forEach(function(carr) {
          carr[1].forEach(function(c3) {
            if (c3.T == true) needtc = true;
          });
        });
        if (needtc) {
          cf2 = "xl/threadedComments/threadedComment" + rId + "." + wbext;
          zip_add_file(zip, cf2, write_tcmnt_xml(comments, people, opts));
          ct.threadedcomments.push(cf2);
          add_rels(wsrels, -1, "../threadedComments/threadedComment" + rId + "." + wbext, RELS.TCMNT);
        }
        cf2 = "xl/comments" + rId + "." + wbext;
        zip_add_file(zip, cf2, write_comments_xml(comments));
        ct.comments.push(cf2);
        add_rels(wsrels, -1, "../comments" + rId + "." + wbext, RELS.CMNT);
        need_vml = true;
      }
      if (ws["!legacy"]) {
        if (need_vml) zip_add_file(zip, "xl/drawings/vmlDrawing" + rId + ".vml", write_comments_vml(rId, ws["!comments"]));
      }
      delete ws["!comments"];
      delete ws["!legacy"];
    }
    if (wsrels["!id"].rId1) zip_add_file(zip, get_rels_path(f2), write_rels(wsrels));
  }
  if (opts.Strings != null && opts.Strings.length > 0) {
    f2 = "xl/sharedStrings." + wbext;
    zip_add_file(zip, f2, write_sst_xml(opts.Strings, opts));
    ct.strs.push(f2);
    add_rels(opts.wbrels, -1, "sharedStrings." + wbext, RELS.SST);
  }
  f2 = "xl/workbook." + wbext;
  zip_add_file(zip, f2, write_wb_xml(wb2));
  ct.workbooks.push(f2);
  add_rels(opts.rels, 1, f2, RELS.WB);
  f2 = "xl/theme/theme1.xml";
  zip_add_file(zip, f2, write_theme(wb2.Themes, opts));
  ct.themes.push(f2);
  add_rels(opts.wbrels, -1, "theme/theme1.xml", RELS.THEME);
  f2 = "xl/styles." + wbext;
  zip_add_file(zip, f2, write_sty_xml(wb2, opts));
  ct.styles.push(f2);
  add_rels(opts.wbrels, -1, "styles." + wbext, RELS.STY);
  if (wb2.vbaraw && vbafmt) {
    f2 = "xl/vbaProject.bin";
    zip_add_file(zip, f2, wb2.vbaraw);
    ct.vba.push(f2);
    add_rels(opts.wbrels, -1, "vbaProject.bin", RELS.VBA);
  }
  f2 = "xl/metadata." + wbext;
  zip_add_file(zip, f2, write_xlmeta_xml());
  ct.metadata.push(f2);
  add_rels(opts.wbrels, -1, "metadata." + wbext, RELS.XLMETA);
  if (people.length > 1) {
    f2 = "xl/persons/person.xml";
    zip_add_file(zip, f2, write_people_xml(people));
    ct.people.push(f2);
    add_rels(opts.wbrels, -1, "persons/person.xml", RELS.PEOPLE);
  }
  zip_add_file(zip, "[Content_Types].xml", write_ct(ct, opts));
  zip_add_file(zip, "_rels/.rels", write_rels(opts.rels));
  zip_add_file(zip, "xl/_rels/workbook." + wbext + ".rels", write_rels(opts.wbrels));
  delete opts.revssf;
  delete opts.ssf;
  return zip;
}
function firstbyte(f2, o2) {
  var x3 = "";
  switch ((o2 || {}).type || "base64") {
    case "buffer":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    case "base64":
      x3 = Base64_decode(f2.slice(0, 12));
      break;
    case "binary":
      x3 = f2;
      break;
    case "array":
      return [f2[0], f2[1], f2[2], f2[3], f2[4], f2[5], f2[6], f2[7]];
    default:
      throw new Error("Unrecognized type " + (o2 && o2.type || "undefined"));
  }
  return [x3.charCodeAt(0), x3.charCodeAt(1), x3.charCodeAt(2), x3.charCodeAt(3), x3.charCodeAt(4), x3.charCodeAt(5), x3.charCodeAt(6), x3.charCodeAt(7)];
}
function read_cfb(cfb, opts) {
  if (CFB.find(cfb, "EncryptedPackage")) return parse_xlsxcfb(cfb, opts);
  return parse_xlscfb(cfb, opts);
}
function read_zip(data, opts) {
  var zip, d4 = data;
  var o2 = opts || {};
  if (!o2.type) o2.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  zip = zip_read(d4, o2);
  return parse_zip(zip, o2);
}
function read_plaintext(data, o2) {
  var i3 = 0;
  main: while (i3 < data.length) switch (data.charCodeAt(i3)) {
    case 10:
    case 13:
    case 32:
      ++i3;
      break;
    case 60:
      return parse_xlml(data.slice(i3), o2);
    default:
      break main;
  }
  return PRN.to_workbook(data, o2);
}
function read_plaintext_raw(data, o2) {
  var str = "", bytes = firstbyte(data, o2);
  switch (o2.type) {
    case "base64":
      str = Base64_decode(data);
      break;
    case "binary":
      str = data;
      break;
    case "buffer":
      str = data.toString("binary");
      break;
    case "array":
      str = cc2str(data);
      break;
    default:
      throw new Error("Unrecognized type " + o2.type);
  }
  if (bytes[0] == 239 && bytes[1] == 187 && bytes[2] == 191) str = utf8read(str);
  o2.type = "binary";
  return read_plaintext(str, o2);
}
function read_utf16(data, o2) {
  var d4 = data;
  if (o2.type == "base64") d4 = Base64_decode(d4);
  d4 = $cptable.utils.decode(1200, d4.slice(2), "str");
  o2.type = "binary";
  return read_plaintext(d4, o2);
}
function bstrify(data) {
  return !data.match(/[^\x00-\x7F]/) ? data : utf8write(data);
}
function read_prn(data, d4, o2, str) {
  if (str) {
    o2.type = "string";
    return PRN.to_workbook(data, o2);
  }
  return PRN.to_workbook(d4, o2);
}
function readSync(data, opts) {
  reset_cp();
  var o2 = opts || {};
  if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) return readSync(new Uint8Array(data), (o2 = dup(o2), o2.type = "array", o2));
  if (typeof Uint8Array !== "undefined" && data instanceof Uint8Array && !o2.type) o2.type = typeof Deno !== "undefined" ? "buffer" : "array";
  var d4 = data, n2 = [0, 0, 0, 0], str = false;
  if (o2.cellStyles) {
    o2.cellNF = true;
    o2.sheetStubs = true;
  }
  _ssfopts = {};
  if (o2.dateNF) _ssfopts.dateNF = o2.dateNF;
  if (!o2.type) o2.type = has_buf && Buffer.isBuffer(data) ? "buffer" : "base64";
  if (o2.type == "file") {
    o2.type = has_buf ? "buffer" : "binary";
    d4 = read_binary(data);
    if (typeof Uint8Array !== "undefined" && !has_buf) o2.type = "array";
  }
  if (o2.type == "string") {
    str = true;
    o2.type = "binary";
    o2.codepage = 65001;
    d4 = bstrify(data);
  }
  if (o2.type == "array" && typeof Uint8Array !== "undefined" && data instanceof Uint8Array && typeof ArrayBuffer !== "undefined") {
    var ab2 = new ArrayBuffer(3), vu = new Uint8Array(ab2);
    vu.foo = "bar";
    if (!vu.foo) {
      o2 = dup(o2);
      o2.type = "array";
      return readSync(ab2a(d4), o2);
    }
  }
  switch ((n2 = firstbyte(d4, o2))[0]) {
    case 208:
      if (n2[1] === 207 && n2[2] === 17 && n2[3] === 224 && n2[4] === 161 && n2[5] === 177 && n2[6] === 26 && n2[7] === 225) return read_cfb(CFB.read(d4, o2), o2);
      break;
    case 9:
      if (n2[1] <= 8) return parse_xlscfb(d4, o2);
      break;
    case 60:
      return parse_xlml(d4, o2);
    case 73:
      if (n2[1] === 73 && n2[2] === 42 && n2[3] === 0) throw new Error("TIFF Image File is not a spreadsheet");
      if (n2[1] === 68) return read_wb_ID(d4, o2);
      break;
    case 84:
      if (n2[1] === 65 && n2[2] === 66 && n2[3] === 76) return DIF.to_workbook(d4, o2);
      break;
    case 80:
      return n2[1] === 75 && n2[2] < 9 && n2[3] < 9 ? read_zip(d4, o2) : read_prn(data, d4, o2, str);
    case 239:
      return n2[3] === 60 ? parse_xlml(d4, o2) : read_prn(data, d4, o2, str);
    case 255:
      if (n2[1] === 254) {
        return read_utf16(d4, o2);
      } else if (n2[1] === 0 && n2[2] === 2 && n2[3] === 0) return WK_.to_workbook(d4, o2);
      break;
    case 0:
      if (n2[1] === 0) {
        if (n2[2] >= 2 && n2[3] === 0) return WK_.to_workbook(d4, o2);
        if (n2[2] === 0 && (n2[3] === 8 || n2[3] === 9)) return WK_.to_workbook(d4, o2);
      }
      break;
    case 3:
    case 131:
    case 139:
    case 140:
      return DBF.to_workbook(d4, o2);
    case 123:
      if (n2[1] === 92 && n2[2] === 114 && n2[3] === 116) return RTF.to_workbook(d4, o2);
      break;
    case 10:
    case 13:
    case 32:
      return read_plaintext_raw(d4, o2);
    case 137:
      if (n2[1] === 80 && n2[2] === 78 && n2[3] === 71) throw new Error("PNG Image File is not a spreadsheet");
      break;
  }
  if (DBF_SUPPORTED_VERSIONS.indexOf(n2[0]) > -1 && n2[2] <= 12 && n2[3] <= 31) return DBF.to_workbook(d4, o2);
  return read_prn(data, d4, o2, str);
}
function write_cfb_ctr(cfb, o2) {
  switch (o2.type) {
    case "base64":
    case "binary":
      break;
    case "buffer":
    case "array":
      o2.type = "";
      break;
    case "file":
      return write_dl(o2.file, CFB.write(cfb, { type: has_buf ? "buffer" : "" }));
    case "string":
      throw new Error("'string' output type invalid for '" + o2.bookType + "' files");
    default:
      throw new Error("Unrecognized type " + o2.type);
  }
  return CFB.write(cfb, o2);
}
function write_zip_type(wb2, opts) {
  var o2 = dup(opts || {});
  var z3 = write_zip(wb2, o2);
  return write_zip_denouement(z3, o2);
}
function write_zip_denouement(z3, o2) {
  var oopts = {};
  var ftype = has_buf ? "nodebuffer" : typeof Uint8Array !== "undefined" ? "array" : "string";
  if (o2.compression) oopts.compression = "DEFLATE";
  if (o2.password) oopts.type = ftype;
  else switch (o2.type) {
    case "base64":
      oopts.type = "base64";
      break;
    case "binary":
      oopts.type = "string";
      break;
    case "string":
      throw new Error("'string' output type invalid for '" + o2.bookType + "' files");
    case "buffer":
    case "file":
      oopts.type = ftype;
      break;
    default:
      throw new Error("Unrecognized type " + o2.type);
  }
  var out = z3.FullPaths ? CFB.write(z3, { fileType: "zip", type: (
    /*::(*/
    { "nodebuffer": "buffer", "string": "binary" }[oopts.type] || oopts.type
  ), compression: !!o2.compression }) : z3.generate(oopts);
  if (typeof Deno !== "undefined") {
    if (typeof out == "string") {
      if (o2.type == "binary" || o2.type == "base64") return out;
      out = new Uint8Array(s2ab(out));
    }
  }
  if (o2.password && typeof encrypt_agile !== "undefined") return write_cfb_ctr(encrypt_agile(out, o2.password), o2);
  if (o2.type === "file") return write_dl(o2.file, out);
  return o2.type == "string" ? utf8read(
    /*::(*/
    out
    /*:: :any)*/
  ) : out;
}
function write_cfb_type(wb2, opts) {
  var o2 = opts || {};
  var cfb = write_xlscfb(wb2, o2);
  return write_cfb_ctr(cfb, o2);
}
function write_string_type(out, opts, bom) {
  if (!bom) bom = "";
  var o2 = bom + out;
  switch (opts.type) {
    case "base64":
      return Base64_encode(utf8write(o2));
    case "binary":
      return utf8write(o2);
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, o2, "utf8");
    case "buffer": {
      if (has_buf) return Buffer_from(o2, "utf8");
      else if (typeof TextEncoder !== "undefined") return new TextEncoder().encode(o2);
      else return write_string_type(o2, { type: "binary" }).split("").map(function(c3) {
        return c3.charCodeAt(0);
      });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_stxt_type(out, opts) {
  switch (opts.type) {
    case "base64":
      return Base64_encode(out);
    case "binary":
      return out;
    case "string":
      return out;
    case "file":
      return write_dl(opts.file, out, "binary");
    case "buffer": {
      if (has_buf) return Buffer_from(out, "binary");
      else return out.split("").map(function(c3) {
        return c3.charCodeAt(0);
      });
    }
  }
  throw new Error("Unrecognized type " + opts.type);
}
function write_binary_type(out, opts) {
  switch (opts.type) {
    case "string":
    case "base64":
    case "binary":
      var bstr = "";
      for (var i3 = 0; i3 < out.length; ++i3) bstr += String.fromCharCode(out[i3]);
      return opts.type == "base64" ? Base64_encode(bstr) : opts.type == "string" ? utf8read(bstr) : bstr;
    case "file":
      return write_dl(opts.file, out);
    case "buffer":
      return out;
    default:
      throw new Error("Unrecognized type " + opts.type);
  }
}
function writeSync(wb2, opts) {
  reset_cp();
  check_wb(wb2);
  var o2 = dup(opts || {});
  if (o2.cellStyles) {
    o2.cellNF = true;
    o2.sheetStubs = true;
  }
  if (o2.type == "array") {
    o2.type = "binary";
    var out = writeSync(wb2, o2);
    o2.type = "array";
    return s2ab(out);
  }
  var idx = 0;
  if (o2.sheet) {
    if (typeof o2.sheet == "number") idx = o2.sheet;
    else idx = wb2.SheetNames.indexOf(o2.sheet);
    if (!wb2.SheetNames[idx]) throw new Error("Sheet not found: " + o2.sheet + " : " + typeof o2.sheet);
  }
  switch (o2.bookType || "xlsb") {
    case "xml":
    case "xlml":
      return write_string_type(write_xlml(wb2, o2), o2);
    case "slk":
    case "sylk":
      return write_string_type(SYLK.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "htm":
    case "html":
      return write_string_type(sheet_to_html(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "txt":
      return write_stxt_type(sheet_to_txt(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "csv":
      return write_string_type(sheet_to_csv(wb2.Sheets[wb2.SheetNames[idx]], o2), o2, "\uFEFF");
    case "dif":
      return write_string_type(DIF.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "dbf":
      return write_binary_type(DBF.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "prn":
      return write_string_type(PRN.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "rtf":
      return write_string_type(RTF.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "eth":
      return write_string_type(ETH.from_sheet(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "fods":
      return write_string_type(write_ods(wb2, o2), o2);
    case "wk1":
      return write_binary_type(WK_.sheet_to_wk1(wb2.Sheets[wb2.SheetNames[idx]], o2), o2);
    case "wk3":
      return write_binary_type(WK_.book_to_wk3(wb2, o2), o2);
    case "biff2":
      if (!o2.biff) o2.biff = 2;
    case "biff3":
      if (!o2.biff) o2.biff = 3;
    case "biff4":
      if (!o2.biff) o2.biff = 4;
      return write_binary_type(write_biff_buf(wb2, o2), o2);
    case "biff5":
      if (!o2.biff) o2.biff = 5;
    case "biff8":
    case "xla":
    case "xls":
      if (!o2.biff) o2.biff = 8;
      return write_cfb_type(wb2, o2);
    case "xlsx":
    case "xlsm":
    case "xlam":
    case "xlsb":
    case "numbers":
    case "ods":
      return write_zip_type(wb2, o2);
    default:
      throw new Error("Unrecognized bookType |" + o2.bookType + "|");
  }
}
function resolve_book_type(o2) {
  if (o2.bookType) return;
  var _BT = {
    "xls": "biff8",
    "htm": "html",
    "slk": "sylk",
    "socialcalc": "eth",
    "Sh33tJS": "WTF"
  };
  var ext = o2.file.slice(o2.file.lastIndexOf(".")).toLowerCase();
  if (ext.match(/^\.[a-z]+$/)) o2.bookType = ext.slice(1);
  o2.bookType = _BT[o2.bookType] || o2.bookType;
}
function writeFileSync(wb2, filename, opts) {
  var o2 = {};
  o2.type = "file";
  o2.file = filename;
  resolve_book_type(o2);
  return writeSync(wb2, o2);
}
function make_json_row(sheet, r2, R3, cols, header, hdr, dense, o2) {
  var rr = encode_row(R3);
  var defval = o2.defval, raw = o2.raw || !Object.prototype.hasOwnProperty.call(o2, "raw");
  var isempty = true;
  var row = header === 1 ? [] : {};
  if (header !== 1) {
    if (Object.defineProperty) try {
      Object.defineProperty(row, "__rowNum__", { value: R3, enumerable: false });
    } catch (e3) {
      row.__rowNum__ = R3;
    }
    else row.__rowNum__ = R3;
  }
  if (!dense || sheet[R3]) for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    var val = dense ? sheet[R3][C2] : sheet[cols[C2] + rr];
    if (val === void 0 || val.t === void 0) {
      if (defval === void 0) continue;
      if (hdr[C2] != null) {
        row[hdr[C2]] = defval;
      }
      continue;
    }
    var v2 = val.v;
    switch (val.t) {
      case "z":
        if (v2 == null) break;
        continue;
      case "e":
        v2 = v2 == 0 ? null : void 0;
        break;
      case "s":
      case "d":
      case "b":
      case "n":
        break;
      default:
        throw new Error("unrecognized type " + val.t);
    }
    if (hdr[C2] != null) {
      if (v2 == null) {
        if (val.t == "e" && v2 === null) row[hdr[C2]] = null;
        else if (defval !== void 0) row[hdr[C2]] = defval;
        else if (raw && v2 === null) row[hdr[C2]] = null;
        else continue;
      } else {
        row[hdr[C2]] = raw && (val.t !== "n" || val.t === "n" && o2.rawNumbers !== false) ? v2 : format_cell(val, v2, o2);
      }
      if (v2 != null) isempty = false;
    }
  }
  return { row, isempty };
}
function sheet_to_json(sheet, opts) {
  if (sheet == null || sheet["!ref"] == null) return [];
  var val = { t: "n", v: 0 }, header = 0, offset2 = 1, hdr = [], v2 = 0, vv = "";
  var r2 = { s: { r: 0, c: 0 }, e: { r: 0, c: 0 } };
  var o2 = opts || {};
  var range = o2.range != null ? o2.range : sheet["!ref"];
  if (o2.header === 1) header = 1;
  else if (o2.header === "A") header = 2;
  else if (Array.isArray(o2.header)) header = 3;
  else if (o2.header == null) header = 0;
  switch (typeof range) {
    case "string":
      r2 = safe_decode_range(range);
      break;
    case "number":
      r2 = safe_decode_range(sheet["!ref"]);
      r2.s.r = range;
      break;
    default:
      r2 = range;
  }
  if (header > 0) offset2 = 0;
  var rr = encode_row(r2.s.r);
  var cols = [];
  var out = [];
  var outi = 0, counter = 0;
  var dense = Array.isArray(sheet);
  var R3 = r2.s.r, C2 = 0;
  var header_cnt = {};
  if (dense && !sheet[R3]) sheet[R3] = [];
  var colinfo = o2.skipHidden && sheet["!cols"] || [];
  var rowinfo = o2.skipHidden && sheet["!rows"] || [];
  for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    if ((colinfo[C2] || {}).hidden) continue;
    cols[C2] = encode_col(C2);
    val = dense ? sheet[R3][C2] : sheet[cols[C2] + rr];
    switch (header) {
      case 1:
        hdr[C2] = C2 - r2.s.c;
        break;
      case 2:
        hdr[C2] = cols[C2];
        break;
      case 3:
        hdr[C2] = o2.header[C2 - r2.s.c];
        break;
      default:
        if (val == null) val = { w: "__EMPTY", t: "s" };
        vv = v2 = format_cell(val, null, o2);
        counter = header_cnt[v2] || 0;
        if (!counter) header_cnt[v2] = 1;
        else {
          do {
            vv = v2 + "_" + counter++;
          } while (header_cnt[vv]);
          header_cnt[v2] = counter;
          header_cnt[vv] = 1;
        }
        hdr[C2] = vv;
    }
  }
  for (R3 = r2.s.r + offset2; R3 <= r2.e.r; ++R3) {
    if ((rowinfo[R3] || {}).hidden) continue;
    var row = make_json_row(sheet, r2, R3, cols, header, hdr, dense, o2);
    if (row.isempty === false || (header === 1 ? o2.blankrows !== false : !!o2.blankrows)) out[outi++] = row.row;
  }
  out.length = outi;
  return out;
}
var qreg = /"/g;
function make_csv_row(sheet, r2, R3, cols, fs, rs, FS, o2) {
  var isempty = true;
  var row = [], txt = "", rr = encode_row(R3);
  for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
    if (!cols[C2]) continue;
    var val = o2.dense ? (sheet[R3] || [])[C2] : sheet[cols[C2] + rr];
    if (val == null) txt = "";
    else if (val.v != null) {
      isempty = false;
      txt = "" + (o2.rawNumbers && val.t == "n" ? val.v : format_cell(val, null, o2));
      for (var i3 = 0, cc2 = 0; i3 !== txt.length; ++i3) if ((cc2 = txt.charCodeAt(i3)) === fs || cc2 === rs || cc2 === 34 || o2.forceQuotes) {
        txt = '"' + txt.replace(qreg, '""') + '"';
        break;
      }
      if (txt == "ID") txt = '"ID"';
    } else if (val.f != null && !val.F) {
      isempty = false;
      txt = "=" + val.f;
      if (txt.indexOf(",") >= 0) txt = '"' + txt.replace(qreg, '""') + '"';
    } else txt = "";
    row.push(txt);
  }
  if (o2.blankrows === false && isempty) return null;
  return row.join(FS);
}
function sheet_to_csv(sheet, opts) {
  var out = [];
  var o2 = opts == null ? {} : opts;
  if (sheet == null || sheet["!ref"] == null) return "";
  var r2 = safe_decode_range(sheet["!ref"]);
  var FS = o2.FS !== void 0 ? o2.FS : ",", fs = FS.charCodeAt(0);
  var RS = o2.RS !== void 0 ? o2.RS : "\n", rs = RS.charCodeAt(0);
  var endregex = new RegExp((FS == "|" ? "\\|" : FS) + "+$");
  var row = "", cols = [];
  o2.dense = Array.isArray(sheet);
  var colinfo = o2.skipHidden && sheet["!cols"] || [];
  var rowinfo = o2.skipHidden && sheet["!rows"] || [];
  for (var C2 = r2.s.c; C2 <= r2.e.c; ++C2) if (!(colinfo[C2] || {}).hidden) cols[C2] = encode_col(C2);
  var w3 = 0;
  for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
    if ((rowinfo[R3] || {}).hidden) continue;
    row = make_csv_row(sheet, r2, R3, cols, fs, rs, FS, o2);
    if (row == null) {
      continue;
    }
    if (o2.strip) row = row.replace(endregex, "");
    if (row || o2.blankrows !== false) out.push((w3++ ? RS : "") + row);
  }
  delete o2.dense;
  return out.join("");
}
function sheet_to_txt(sheet, opts) {
  if (!opts) opts = {};
  opts.FS = "	";
  opts.RS = "\n";
  var s4 = sheet_to_csv(sheet, opts);
  return s4;
}
function sheet_to_formulae(sheet) {
  var y4 = "", x3, val = "";
  if (sheet == null || sheet["!ref"] == null) return [];
  var r2 = safe_decode_range(sheet["!ref"]), rr = "", cols = [], C2;
  var cmds = [];
  var dense = Array.isArray(sheet);
  for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) cols[C2] = encode_col(C2);
  for (var R3 = r2.s.r; R3 <= r2.e.r; ++R3) {
    rr = encode_row(R3);
    for (C2 = r2.s.c; C2 <= r2.e.c; ++C2) {
      y4 = cols[C2] + rr;
      x3 = dense ? (sheet[R3] || [])[C2] : sheet[y4];
      val = "";
      if (x3 === void 0) continue;
      else if (x3.F != null) {
        y4 = x3.F;
        if (!x3.f) continue;
        val = x3.f;
        if (y4.indexOf(":") == -1) y4 = y4 + ":" + y4;
      }
      if (x3.f != null) val = x3.f;
      else if (x3.t == "z") continue;
      else if (x3.t == "n" && x3.v != null) val = "" + x3.v;
      else if (x3.t == "b") val = x3.v ? "TRUE" : "FALSE";
      else if (x3.w !== void 0) val = "'" + x3.w;
      else if (x3.v === void 0) continue;
      else if (x3.t == "s") val = "'" + x3.v;
      else val = "" + x3.v;
      cmds[cmds.length] = y4 + "=" + val;
    }
  }
  return cmds;
}
function sheet_add_json(_ws, js, opts) {
  var o2 = opts || {};
  var offset2 = +!o2.skipHeader;
  var ws = _ws || {};
  var _R = 0, _C = 0;
  if (ws && o2.origin != null) {
    if (typeof o2.origin == "number") _R = o2.origin;
    else {
      var _origin = typeof o2.origin == "string" ? decode_cell(o2.origin) : o2.origin;
      _R = _origin.r;
      _C = _origin.c;
    }
  }
  var cell;
  var range = { s: { c: 0, r: 0 }, e: { c: _C, r: _R + js.length - 1 + offset2 } };
  if (ws["!ref"]) {
    var _range = safe_decode_range(ws["!ref"]);
    range.e.c = Math.max(range.e.c, _range.e.c);
    range.e.r = Math.max(range.e.r, _range.e.r);
    if (_R == -1) {
      _R = _range.e.r + 1;
      range.e.r = _R + js.length - 1 + offset2;
    }
  } else {
    if (_R == -1) {
      _R = 0;
      range.e.r = js.length - 1 + offset2;
    }
  }
  var hdr = o2.header || [], C2 = 0;
  js.forEach(function(JS, R3) {
    keys(JS).forEach(function(k3) {
      if ((C2 = hdr.indexOf(k3)) == -1) hdr[C2 = hdr.length] = k3;
      var v2 = JS[k3];
      var t3 = "z";
      var z3 = "";
      var ref = encode_cell({ c: _C + C2, r: _R + R3 + offset2 });
      cell = ws_get_cell_stub(ws, ref);
      if (v2 && typeof v2 === "object" && !(v2 instanceof Date)) {
        ws[ref] = v2;
      } else {
        if (typeof v2 == "number") t3 = "n";
        else if (typeof v2 == "boolean") t3 = "b";
        else if (typeof v2 == "string") t3 = "s";
        else if (v2 instanceof Date) {
          t3 = "d";
          if (!o2.cellDates) {
            t3 = "n";
            v2 = datenum(v2);
          }
          z3 = o2.dateNF || table_fmt[14];
        } else if (v2 === null && o2.nullError) {
          t3 = "e";
          v2 = 0;
        }
        if (!cell) ws[ref] = cell = { t: t3, v: v2 };
        else {
          cell.t = t3;
          cell.v = v2;
          delete cell.w;
          delete cell.R;
          if (z3) cell.z = z3;
        }
        if (z3) cell.z = z3;
      }
    });
  });
  range.e.c = Math.max(range.e.c, _C + hdr.length - 1);
  var __R = encode_row(_R);
  if (offset2) for (C2 = 0; C2 < hdr.length; ++C2) ws[encode_col(C2 + _C) + __R] = { t: "s", v: hdr[C2] };
  ws["!ref"] = encode_range(range);
  return ws;
}
function json_to_sheet(js, opts) {
  return sheet_add_json(null, js, opts);
}
function ws_get_cell_stub(ws, R3, C2) {
  if (typeof R3 == "string") {
    if (Array.isArray(ws)) {
      var RC = decode_cell(R3);
      if (!ws[RC.r]) ws[RC.r] = [];
      return ws[RC.r][RC.c] || (ws[RC.r][RC.c] = { t: "z" });
    }
    return ws[R3] || (ws[R3] = { t: "z" });
  }
  if (typeof R3 != "number") return ws_get_cell_stub(ws, encode_cell(R3));
  return ws_get_cell_stub(ws, encode_cell({ r: R3, c: C2 || 0 }));
}
function wb_sheet_idx(wb2, sh2) {
  if (typeof sh2 == "number") {
    if (sh2 >= 0 && wb2.SheetNames.length > sh2) return sh2;
    throw new Error("Cannot find sheet # " + sh2);
  } else if (typeof sh2 == "string") {
    var idx = wb2.SheetNames.indexOf(sh2);
    if (idx > -1) return idx;
    throw new Error("Cannot find sheet name |" + sh2 + "|");
  } else throw new Error("Cannot find sheet |" + sh2 + "|");
}
function book_new() {
  return { SheetNames: [], Sheets: {} };
}
function book_append_sheet(wb2, ws, name, roll) {
  var i3 = 1;
  if (!name) {
    for (; i3 <= 65535; ++i3, name = void 0) if (wb2.SheetNames.indexOf(name = "Sheet" + i3) == -1) break;
  }
  if (!name || wb2.SheetNames.length >= 65535) throw new Error("Too many worksheets");
  if (roll && wb2.SheetNames.indexOf(name) >= 0) {
    var m4 = name.match(/(^.*?)(\d+)$/);
    i3 = m4 && +m4[2] || 0;
    var root = m4 && m4[1] || name;
    for (++i3; i3 <= 65535; ++i3) if (wb2.SheetNames.indexOf(name = root + i3) == -1) break;
  }
  check_ws_name(name);
  if (wb2.SheetNames.indexOf(name) >= 0) throw new Error("Worksheet with name |" + name + "| already exists!");
  wb2.SheetNames.push(name);
  wb2.Sheets[name] = ws;
  return name;
}
function book_set_sheet_visibility(wb2, sh2, vis) {
  if (!wb2.Workbook) wb2.Workbook = {};
  if (!wb2.Workbook.Sheets) wb2.Workbook.Sheets = [];
  var idx = wb_sheet_idx(wb2, sh2);
  if (!wb2.Workbook.Sheets[idx]) wb2.Workbook.Sheets[idx] = {};
  switch (vis) {
    case 0:
    case 1:
    case 2:
      break;
    default:
      throw new Error("Bad sheet visibility setting " + vis);
  }
  wb2.Workbook.Sheets[idx].Hidden = vis;
}
function cell_set_number_format(cell, fmt) {
  cell.z = fmt;
  return cell;
}
function cell_set_hyperlink(cell, target, tooltip) {
  if (!target) {
    delete cell.l;
  } else {
    cell.l = { Target: target };
    if (tooltip) cell.l.Tooltip = tooltip;
  }
  return cell;
}
function cell_set_internal_link(cell, range, tooltip) {
  return cell_set_hyperlink(cell, "#" + range, tooltip);
}
function cell_add_comment(cell, text, author) {
  if (!cell.c) cell.c = [];
  cell.c.push({ t: text, a: author || "SheetJS" });
}
function sheet_set_array_formula(ws, range, formula, dynamic) {
  var rng2 = typeof range != "string" ? range : safe_decode_range(range);
  var rngstr = typeof range == "string" ? range : encode_range(range);
  for (var R3 = rng2.s.r; R3 <= rng2.e.r; ++R3) for (var C2 = rng2.s.c; C2 <= rng2.e.c; ++C2) {
    var cell = ws_get_cell_stub(ws, R3, C2);
    cell.t = "n";
    cell.F = rngstr;
    delete cell.v;
    if (R3 == rng2.s.r && C2 == rng2.s.c) {
      cell.f = formula;
      if (dynamic) cell.D = true;
    }
  }
  return ws;
}
var utils = {
  encode_col,
  encode_row,
  encode_cell,
  encode_range,
  decode_col,
  decode_row,
  split_cell,
  decode_cell,
  decode_range,
  format_cell,
  sheet_add_aoa,
  sheet_add_json,
  sheet_add_dom,
  aoa_to_sheet,
  json_to_sheet,
  table_to_sheet: parse_dom_table,
  table_to_book,
  sheet_to_csv,
  sheet_to_txt,
  sheet_to_json,
  sheet_to_html,
  sheet_to_formulae,
  sheet_to_row_object_array: sheet_to_json,
  sheet_get_cell: ws_get_cell_stub,
  book_new,
  book_append_sheet,
  book_set_sheet_visibility,
  cell_set_number_format,
  cell_set_hyperlink,
  cell_set_internal_link,
  cell_add_comment,
  sheet_set_array_formula,
  consts: {
    SHEET_VISIBLE: 0,
    SHEET_HIDDEN: 1,
    SHEET_VERY_HIDDEN: 2
  }
};
function useStateMachine(initialState, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const [content, setContent] = reactExports.useState(null);
    const [scrollbarX, setScrollbarX] = reactExports.useState(null);
    const [scrollbarY, setScrollbarY] = reactExports.useState(null);
    const [cornerWidth, setCornerWidth] = reactExports.useState(0);
    const [cornerHeight, setCornerHeight] = reactExports.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME$1 = "ScrollAreaViewport";
var ScrollAreaViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME$1, __scopeScrollArea);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref: context.onContentChange, style: { minWidth: "100%", display: "table" }, children })
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME$1;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    reactExports.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  reactExports.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  reactExports.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = reactExports.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = reactExports.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = reactExports.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = reactExports.useRef(null);
  const pointerOffsetRef = reactExports.useRef(0);
  const [sizes, setSizes] = reactExports.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition2(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition2(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition2(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = reactExports.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = reactExports.useRef(null);
  const prevWebkitUserSelectRef = reactExports.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef$1(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef$1(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x3 = event.clientX - rectRef.current.left;
      const y4 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x3, y: y4 });
    }
  }
  reactExports.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  reactExports.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef$1(onThumbChange),
      onThumbPointerUp: useCallbackRef$1(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef$1(onThumbPointerDown),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME = "ScrollAreaThumb";
var ScrollAreaThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME, props.__scopeScrollArea);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = reactExports.useRef(void 0);
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    reactExports.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x3 = event.clientX - thumbRect.left;
          const y4 = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x: x3, y: y4 });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = reactExports.useState(0);
  const [height, setHeight] = reactExports.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver(context.scrollbarX, () => {
    const height2 = context.scrollbarX?.offsetHeight || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver(context.scrollbarY, () => {
    const width2 = context.scrollbarY?.offsetWidth || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp(scrollPos, scrollClampRange);
  const interpolate = linearScale([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef$1(callback);
  const debounceTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return reactExports.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
var Root = ScrollArea$1;
var Viewport$1 = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
const ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root,
  {
    ref,
    className: cn("relative overflow-hidden", className),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport$1, { className: "h-full w-full rounded-[inherit]", children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Corner, {})
    ]
  }
));
ScrollArea.displayName = Root.displayName;
const ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollAreaScrollbar,
  {
    ref,
    orientation,
    className: cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-border" })
  }
));
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
function SystemLogs() {
  const [searchQuery, setSearchQuery] = React$1.useState("");
  const [selectedLevel, setSelectedLevel] = React$1.useState("all");
  const [selectedType, setSelectedType] = React$1.useState("all");
  const [logs, setLogs] = React$1.useState([]);
  const filteredLogs = React$1.useMemo(() => {
    return logs.filter((log) => {
      const matchesSearch = log.message.toLowerCase().includes(searchQuery.toLowerCase()) || log.details && JSON.stringify(log.details).toLowerCase().includes(searchQuery.toLowerCase());
      const matchesLevel = selectedLevel === "all" || log.level === selectedLevel;
      const matchesType = selectedType === "all" || log.type === selectedType;
      return matchesSearch && matchesLevel && matchesType;
    });
  }, [logs, searchQuery, selectedLevel, selectedType]);
  const getLogLevelColor = (level) => {
    switch (level) {
      case "error":
        return "text-red-500";
      case "warn":
        return "text-yellow-500";
      case "info":
        return "text-blue-500";
      case "debug":
        return "text-gray-500";
      default:
        return "";
    }
  };
  const getLogLevelBadge = (level) => {
    switch (level) {
      case "error":
        return "bg-red-100 text-red-800";
      case "warn":
        return "bg-yellow-100 text-yellow-800";
      case "info":
        return "bg-blue-100 text-blue-800";
      case "debug":
        return "bg-gray-100 text-gray-800";
      default:
        return "";
    }
  };
  const getLogTypeBadge = (type) => {
    switch (type) {
      case "system":
        return "bg-purple-100 text-purple-800";
      case "audit":
        return "bg-green-100 text-green-800";
      case "performance":
        return "bg-orange-100 text-orange-800";
      case "security":
        return "bg-pink-100 text-pink-800";
      default:
        return "";
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-6", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardHeader, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "System Logs" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "View and manage system logs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Settings2, { className: "h-4 w-4" }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" }) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative flex-1", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Search, { className: "absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              placeholder: "Search logs...",
              value: searchQuery,
              onChange: (e3) => setSearchQuery(e3.target.value),
              className: "pl-8"
            }
          )
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: selectedLevel,
              onChange: (e3) => setSelectedLevel(e3.target.value),
              className: "h-9 rounded-md border border-input bg-background px-3 py-1 text-sm",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Levels" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "debug", children: "Debug" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "info", children: "Info" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "warn", children: "Warning" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "error", children: "Error" })
              ]
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "select",
            {
              value: selectedType,
              onChange: (e3) => setSelectedType(e3.target.value),
              className: "h-9 rounded-md border border-input bg-background px-3 py-1 text-sm",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "all", children: "All Types" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "system", children: "System" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "audit", children: "Audit" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "performance", children: "Performance" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "security", children: "Security" })
              ]
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-[500px] rounded-md border", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-2 p-4", children: filteredLogs.length === 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-center py-8 text-muted-foreground", children: "No logs found" }) : filteredLogs.map((log, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          className: `p-4 rounded-lg border ${getLogLevelColor(log.level)}`,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between mb-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded text-xs font-medium ${getLogLevelBadge(log.level)}`, children: log.level.toUpperCase() }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: `px-2 py-1 rounded text-xs font-medium ${getLogTypeBadge(log.type)}`, children: log.type.toUpperCase() })
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "text-sm text-muted-foreground", children: format(log.timestamp, "MMM d, yyyy HH:mm:ss") })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm", children: log.message }),
            log.details && /* @__PURE__ */ jsxRuntimeExports.jsx("pre", { className: "mt-2 text-xs bg-muted p-2 rounded overflow-x-auto", children: JSON.stringify(log.details, null, 2) }),
            log.component && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-1 text-xs text-muted-foreground", children: [
              "Component: ",
              log.component
            ] })
          ]
        },
        index2
      )) }) })
    ] }) })
  ] }) });
}
const roles = [
  { value: "admin", label: "Admin" },
  { value: "user", label: "User" },
  { value: "viewer", label: "Viewer" }
];
function AddUserDialog({ open, onOpenChange, onAdd }) {
  const [username, setUsername] = reactExports.useState("");
  const [displayName, setDisplayName] = reactExports.useState("");
  const [password, setPassword] = reactExports.useState("");
  const [role, setRole] = reactExports.useState("user");
  const [securityQuestion, setSecurityQuestion] = reactExports.useState("");
  const [securityAnswer, setSecurityAnswer] = reactExports.useState("");
  const [phoneExtension, setPhoneExtension] = reactExports.useState("");
  const [isSubmitting, setIsSubmitting] = reactExports.useState(false);
  const handleSubmit = () => {
    if (!username.trim() || !displayName.trim() || !password.trim() || !securityQuestion.trim() || !securityAnswer.trim() || !phoneExtension.trim()) {
      ue.error("All fields are required.");
      return;
    }
    setIsSubmitting(true);
    onAdd({
      username: username.trim(),
      displayName: displayName.trim(),
      password: password.trim(),
      role,
      securityQuestion: securityQuestion.trim(),
      securityAnswer: securityAnswer.trim(),
      phoneExtension: phoneExtension.trim()
    });
    setIsSubmitting(false);
    setUsername("");
    setDisplayName("");
    setPassword("");
    setRole("user");
    setSecurityQuestion("");
    setSecurityAnswer("");
    setPhoneExtension("");
    onOpenChange(false);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open, onOpenChange, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Add New User" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Fill in all fields to add a new user. Phone extension can be used for password reset." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 py-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "username", children: "Username" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "username", autoComplete: "off", value: username, onChange: (e3) => setUsername(e3.target.value), autoFocus: true, required: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "displayName", children: "Display Name" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "displayName", autoComplete: "off", value: displayName, onChange: (e3) => setDisplayName(e3.target.value), required: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "password", children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "password", type: "password", autoComplete: "new-password", value: password, onChange: (e3) => setPassword(e3.target.value), required: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "role", children: "Role" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("select", { id: "role", value: role, onChange: (e3) => setRole(e3.target.value), className: "w-full border rounded px-2 py-1", children: roles.map((r2) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: r2.value, children: r2.label }, r2.value)) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "securityQuestion", children: "Security Question" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "securityQuestion", autoComplete: "off", value: securityQuestion, onChange: (e3) => setSecurityQuestion(e3.target.value), required: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "securityAnswer", children: "Security Answer" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "securityAnswer", autoComplete: "off", value: securityAnswer, onChange: (e3) => setSecurityAnswer(e3.target.value), required: true })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "phoneExtension", children: "Phone Extension (for password reset)" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { id: "phoneExtension", autoComplete: "off", value: phoneExtension, onChange: (e3) => setPhoneExtension(e3.target.value), required: true })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => onOpenChange(false), disabled: isSubmitting, children: "Cancel" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { onClick: handleSubmit, disabled: isSubmitting, children: isSubmitting ? "Adding..." : "Add User" })
    ] })
  ] }) });
}
function SettingsPage() {
  const { currentUser, logout } = useAuth();
  const [mainTab, setMainTab] = reactExports.useState(() => {
    const params = new URLSearchParams(window.location.search);
    const tab = params.get("tab");
    if (tab === "users") return "users";
    if (tab === "test") return "test";
    return "lists";
  });
  const [activeTab, setActiveTab] = reactExports.useState(() => {
    const params = new URLSearchParams(window.location.search);
    const tab = params.get("tab");
    return tab || "categories";
  });
  reactExports.useEffect(() => {
    const url2 = new URL(window.location.href);
    if (mainTab === "users") {
      url2.searchParams.set("tab", "users");
    } else {
      url2.searchParams.set("tab", activeTab);
    }
    window.history.replaceState({}, "", url2.toString());
  }, [mainTab, activeTab]);
  const [settings, setSettings] = reactExports.useState({
    categories: [],
    units: [],
    locations: [],
    suppliers: [],
    projects: []
  });
  const [showReconcileDialog, setShowReconcileDialog] = reactExports.useState(false);
  const [itemToDelete, setItemToDelete] = reactExports.useState(null);
  const [affectedItemsCount, setAffectedItemsCount] = reactExports.useState(0);
  const [reconcileAction, setReconcileAction] = reactExports.useState("delete");
  const [replacementValue, setReplacementValue] = reactExports.useState("");
  const [showAddUserDialog, setShowAddUserDialog] = reactExports.useState(false);
  const [users, setUsers] = reactExports.useState([]);
  const [editingUser, setEditingUser] = reactExports.useState(null);
  const [resettingUser, setResettingUser] = reactExports.useState(null);
  const [isCameraDialogOpen, setIsCameraDialogOpen] = reactExports.useState(false);
  const [importDuplicates, setImportDuplicates] = reactExports.useState(null);
  const [importDuplicateAction, setImportDuplicateAction] = reactExports.useState("skip");
  const [importInProgress, setImportInProgress] = reactExports.useState(null);
  const [importSuccess, setImportSuccess] = reactExports.useState(null);
  ({
    categories: {
      list: settings.categories
    },
    units: {
      list: settings.units
    },
    locations: {
      list: settings.locations
    },
    suppliers: {
      list: settings.suppliers
    },
    projects: {
      list: settings.projects
    }
  });
  const updateSettingsList = (key, newValue) => {
    setSettings((prev) => ({
      ...prev,
      [key]: newValue
    }));
    saveSettings({
      ...settings,
      [key]: newValue
    });
  };
  reactExports.useEffect(() => {
    const loadSettings = () => {
      const savedSettings = getSettings();
      setSettings(savedSettings);
    };
    loadSettings();
  }, []);
  reactExports.useEffect(() => {
    const savedUsers = localStorage.getItem("inventory-users");
    if (savedUsers) {
      setUsers(JSON.parse(savedUsers));
    }
  }, []);
  const saveAllSettings = () => {
    try {
      saveSettings(settings);
      ue.success("Settings saved successfully!");
    } catch (error) {
      console.error("Error saving settings:", error);
      ue.error("Failed to save settings");
    }
  };
  const saveUsers = (newUsers) => {
    localStorage.setItem("inventory-users", JSON.stringify(newUsers));
    setUsers(newUsers);
  };
  const handleReconcileConfirm = () => {
    if (!itemToDelete) return;
    const { type, value } = itemToDelete;
    const typeKey = type.toLowerCase();
    let settingsKey;
    switch (typeKey) {
      case "categories":
        settingsKey = "categories";
        break;
      case "units":
        settingsKey = "units";
        break;
      case "locations":
        settingsKey = "locations";
        break;
      case "suppliers":
        settingsKey = "suppliers";
        break;
      case "projects":
        settingsKey = "projects";
        break;
      default:
        settingsKey = typeKey.endsWith("y") ? typeKey.slice(0, -1) + "ies" : typeKey.endsWith("s") ? typeKey : typeKey + "s";
    }
    const newList = settings[settingsKey].filter((item) => item.name !== value);
    updateSettingsList(settingsKey, newList);
    const items = getItems();
    let updatedItems = items;
    let toastMessage = "";
    const itemKey = typeKey.endsWith("ies") ? typeKey.slice(0, -3) + "y" : typeKey.endsWith("s") ? typeKey.slice(0, -1) : typeKey;
    if (reconcileAction === "replace" && replacementValue) {
      updatedItems = items.map((item) => {
        if (item[itemKey] === value) {
          return { ...item, [itemKey]: replacementValue };
        }
        return item;
      });
      toastMessage = `Updated ${affectedItemsCount} items: Replaced "${value}" with "${replacementValue}" in ${typeKey}.`;
    } else {
      updatedItems = items.map((item) => {
        if (item[itemKey] === value) {
          const newItem = { ...item };
          delete newItem[itemKey];
          return newItem;
        }
        return item;
      });
      toastMessage = `Removed "${value}" from ${affectedItemsCount} items.`;
    }
    saveItems(updatedItems);
    ue.success(toastMessage);
    setShowReconcileDialog(false);
    setItemToDelete(null);
    setAffectedItemsCount(0);
    setReplacementValue("");
  };
  useSensors(
    useSensor(PointerSensor),
    useSensor(KeyboardSensor, {
      coordinateGetter: sortableKeyboardCoordinates
    })
  );
  const handleImportData = async (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e3) => {
        try {
          console.log("Processing JSON file:", file.name);
          const data = JSON.parse(e3.target?.result);
          if (!data || typeof data !== "object") {
            throw new Error("Invalid data format");
          }
          console.log("JSON data parsed successfully:", Object.keys(data));
          if (data.inventory && Array.isArray(data.inventory)) {
            console.log("Inventory items found in JSON:", data.inventory.length);
            data.inventory = data.inventory.map((item) => {
              if (!item.id) {
                return { ...item, id: v4() };
              }
              return item;
            });
          }
          ["categories", "units", "locations", "suppliers", "projects"].forEach((key) => {
            if (data[key] && Array.isArray(data[key])) {
              console.log(`${key} found in JSON:`, data[key].length);
              data[key] = data[key].map((item) => {
                if (!item.id) {
                  return { ...item, id: v4() };
                }
                return item;
              });
            }
          });
          if (data.inventory) {
            console.log("Inventory items found in JSON:", data.inventory.length);
          }
          setImportInProgress({
            data,
            fileType: "json",
            file
          });
          checkForDuplicates(data);
          if (!importDuplicates) {
            console.log("No duplicates found, proceeding with import");
            processImport(data);
            ue.success("Data imported successfully");
            resolve();
          } else {
            resolve();
          }
        } catch (error) {
          console.error("Error importing JSON:", error);
          reject(error);
        }
      };
      reader.onerror = () => reject(new Error("Failed to read file"));
      reader.readAsText(file);
    });
  };
  const handleImportExcel = async (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = async (e3) => {
        try {
          const data = e3.target?.result;
          if (!data) {
            throw new Error("Failed to read Excel file");
          }
          console.log("Processing Excel file:", file.name);
          const workbook = readSync(data, { type: "array" });
          console.log("Excel sheets found:", workbook.SheetNames);
          const importedData = {};
          if (workbook.SheetNames.includes("Inventory")) {
            const inventorySheet = workbook.Sheets["Inventory"];
            const inventoryItems = utils.sheet_to_json(inventorySheet);
            console.log("Inventory items found in Excel:", inventoryItems.length);
            const processedItems = inventoryItems.map((item) => {
              const processedItem = { ...item };
              if (!processedItem.id) {
                processedItem.id = v4();
                console.log("Generated new ID for item:", processedItem.name || "unnamed item");
              }
              ["lastUpdated", "dateInService", "lastMaintenanceDate", "nextMaintenanceDate", "expectedDeliveryDate"].forEach((field) => {
                if (processedItem[field]) {
                  if (typeof processedItem[field] === "number") {
                    processedItem[field] = new Date(Math.round((processedItem[field] - 25569) * 86400 * 1e3));
                  } else {
                    processedItem[field] = new Date(processedItem[field]);
                  }
                }
              });
              return processedItem;
            });
            importedData.inventory = processedItems;
          }
          ["Categories", "Units", "Locations", "Suppliers", "Projects"].forEach((sheetName) => {
            if (workbook.SheetNames.includes(sheetName)) {
              const sheet = workbook.Sheets[sheetName];
              const items = utils.sheet_to_json(sheet);
              console.log(`${sheetName} found in Excel:`, items.length);
              const itemsWithIds = items.map((item) => {
                if (!item.id) {
                  return { ...item, id: v4() };
                }
                return item;
              });
              importedData[sheetName.toLowerCase()] = itemsWithIds;
            }
          });
          setImportInProgress({
            data: importedData,
            fileType: "excel",
            file
          });
          checkForDuplicates(importedData);
          if (!importDuplicates) {
            console.log("No duplicates found, proceeding with import");
            processImport(importedData);
            ue.success("Data imported from Excel successfully");
            resolve();
          } else {
            resolve();
          }
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = () => reject(new Error("Failed to read Excel file"));
      reader.readAsArrayBuffer(file);
    });
  };
  const checkForDuplicates = (data) => {
    console.log("Checking for duplicates in imported data:", data);
    const settingsKeys = ["categories", "units", "locations", "suppliers", "projects"];
    if (data.inventory && Array.isArray(data.inventory)) {
      const existingItems = getItems();
      console.log("Existing inventory items:", existingItems.length);
      if (existingItems.length > 0) {
        const duplicateItems = data.inventory.filter(
          (imported) => existingItems.some((existing) => existing.id === imported.id)
        );
        if (duplicateItems.length > 0) {
          console.log("Found duplicate inventory items:", duplicateItems.length);
          setImportDuplicates({
            type: "inventory",
            existing: existingItems.filter(
              (existing) => duplicateItems.some((dup2) => dup2.id === existing.id)
            ),
            imported: duplicateItems
          });
          return;
        }
      }
    }
    for (const key of settingsKeys) {
      if (!data[key] || !Array.isArray(data[key])) continue;
      const existingItems = settings[key];
      console.log(`Checking ${key}:`, data[key].length, "against", existingItems.length);
      const importedItems = data[key];
      const duplicateItems = importedItems.filter(
        (imported) => existingItems.some(
          (existing) => existing.id === imported.id || existing.name === imported.name
        )
      );
      if (duplicateItems.length > 0) {
        console.log(`Found duplicate ${key}:`, duplicateItems.length);
        const existingDuplicates = existingItems.filter(
          (existing) => importedItems.some(
            (imported) => existing.id === imported.id || existing.name === imported.name
          )
        );
        setImportDuplicates({
          type: key,
          existing: existingDuplicates,
          imported: duplicateItems
        });
        return;
      }
    }
    console.log("No duplicates found in import data");
    setImportDuplicates(null);
  };
  const processImport = (data) => {
    const settingsKeys = ["categories", "units", "locations", "suppliers", "projects"];
    const importedCounts = {};
    if (data.inventory && Array.isArray(data.inventory)) {
      console.log(`Processing ${data.inventory.length} inventory items with action: ${importDuplicateAction}`);
      if (importDuplicateAction === "replace") {
        console.log("Replacing all inventory items");
        saveItems(data.inventory);
        importedCounts.inventory = data.inventory.length;
      } else if (importDuplicateAction === "merge") {
        const existingItems = getItems();
        console.log("Merging inventory: existing:", existingItems.length);
        const newItems = data.inventory.filter(
          (imported) => !existingItems.some((existing) => existing.id === imported.id)
        );
        console.log("New items to add:", newItems.length);
        saveItems([...existingItems, ...newItems]);
        importedCounts.inventory = newItems.length;
      } else if (importDuplicateAction === "skip") {
        const existingItems = getItems();
        console.log("Skipping duplicates: existing:", existingItems.length);
        const newItems = data.inventory.filter(
          (imported) => !existingItems.some((existing) => existing.id === imported.id)
        );
        console.log("New non-duplicate items to add:", newItems.length);
        if (newItems.length > 0) {
          saveItems([...existingItems, ...newItems]);
          importedCounts.inventory = newItems.length;
        }
      }
    }
    for (const key of settingsKeys) {
      if (!data[key] || !Array.isArray(data[key])) continue;
      if (importDuplicateAction === "replace" || !importDuplicates) {
        updateSettingsList(key, data[key]);
        importedCounts[key] = data[key].length;
      } else if (importDuplicateAction === "merge") {
        const existingItems = settings[key];
        const newItems = data[key].filter(
          (imported) => !existingItems.some(
            (existing) => existing.id === imported.id || existing.name === imported.name
          )
        );
        updateSettingsList(key, [...existingItems, ...newItems]);
        importedCounts[key] = newItems.length;
      } else if (importDuplicateAction === "skip") {
        if (importDuplicates && importDuplicates.type === key) {
          const importedWithoutDuplicates = data[key].filter(
            (imported) => !importDuplicates.existing.some(
              (existing) => existing.id === imported.id || existing.name === imported.name
            )
          );
          updateSettingsList(key, [...settings[key], ...importedWithoutDuplicates]);
          importedCounts[key] = importedWithoutDuplicates.length;
        } else {
          updateSettingsList(key, [...settings[key], ...data[key]]);
          importedCounts[key] = data[key].length;
        }
      }
    }
    setImportSuccess({
      itemCounts: importedCounts,
      fileType: importInProgress?.fileType || "json"
    });
    setImportDuplicates(null);
    setImportInProgress(null);
    setImportDuplicateAction("skip");
  };
  const handleImportConfirm = () => {
    if (!importInProgress) return;
    processImport(importInProgress.data);
    ue.success(`Import complete. Check the summary for details.`);
  };
  const handleAddUser = (newUser) => {
    const userExists = users.some((u3) => u3.username === newUser.username);
    if (userExists) {
      ue.error("Username already exists");
      return;
    }
    const user = {
      ...newUser,
      id: crypto.randomUUID()
    };
    saveUsers([...users, user]);
    ue.success("User added successfully");
  };
  const handleEditUser = (userId, updates) => {
    if (updates.role && currentUser?.role !== "admin") {
      ue.error("Only administrators can change user roles");
      return;
    }
    if (userId !== currentUser?.id && currentUser?.role !== "admin") {
      ue.error("You can only edit your own profile");
      return;
    }
    if (userId === currentUser?.id && updates.role && updates.role !== currentUser.role) {
      ue.error("You cannot change your own role");
      return;
    }
    const updatedUsers = users.map(
      (u3) => u3.id === userId ? { ...u3, ...updates } : u3
    );
    saveUsers(updatedUsers);
    ue.success("User profile updated");
  };
  const handleRemoveUser = (userId) => {
    if (currentUser?.role !== "admin") {
      ue.error("Only administrators can remove users");
      return;
    }
    if (userId === currentUser?.id) {
      ue.error("You cannot remove your own account");
      return;
    }
    const updatedUsers = users.filter((u3) => u3.id !== userId);
    saveUsers(updatedUsers);
    ue.success("User removed");
  };
  const handleResetPassword = async (username, newPassword) => {
    try {
      ue.success("Password reset functionality not implemented yet");
    } catch (error) {
      ue.error("Failed to reset password");
    }
  };
  const renderUsersList = () => {
    if (!currentUser) return null;
    return users.map((u3) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "div",
      {
        className: "flex items-center justify-between p-4 rounded-lg border cursor-pointer hover:bg-accent/50 transition-colors",
        onClick: () => {
          if (u3.id === currentUser.id || currentUser.role === "admin") {
            setEditingUser(u3);
          }
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: u3.displayName }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground", children: [
                "@",
                u3.username
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(Badge, { variant: u3.role === "admin" ? "default" : u3.role === "user" ? "secondary" : "outline", children: u3.role })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center gap-2", children: currentUser.role === "admin" && u3.id !== currentUser.id && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "ghost",
                size: "icon",
                onClick: (e3) => {
                  e3.stopPropagation();
                  setResettingUser(u3);
                },
                title: "Reset Password",
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { className: "h-4 w-4" })
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "ghost",
                size: "icon",
                onClick: (e3) => {
                  e3.stopPropagation();
                  handleRemoveUser(u3.id);
                },
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4 text-destructive" })
              }
            )
          ] }) })
        ]
      },
      u3.id
    ));
  };
  const handleExportData = () => {
    try {
      const data = {
        locations: settings.locations,
        categories: settings.categories,
        units: settings.units,
        suppliers: settings.suppliers,
        projects: settings.projects,
        // Include any other data you want to export
        settings: {}
        // Add your settings here
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url2 = URL.createObjectURL(blob);
      const a4 = document.createElement("a");
      a4.href = url2;
      a4.download = "trackIT-data-export.json";
      document.body.appendChild(a4);
      a4.click();
      document.body.removeChild(a4);
      URL.revokeObjectURL(url2);
      ue.success("Data exported successfully");
    } catch (error) {
      ue.error(error instanceof Error ? error.message : "An unknown error occurred");
    }
  };
  const handleBackupData = () => {
    try {
      const backupData = {
        version: "1.0",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        data: {
          locations: settings.locations,
          categories: settings.categories,
          units: settings.units,
          suppliers: settings.suppliers,
          projects: settings.projects,
          // Add other data you want to backup
          settings: {}
          // Add your settings here
        }
      };
      const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: "application/json" });
      const url2 = URL.createObjectURL(blob);
      const a4 = document.createElement("a");
      a4.href = url2;
      a4.download = `trackIT-backup-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.backup`;
      document.body.appendChild(a4);
      a4.click();
      document.body.removeChild(a4);
      URL.revokeObjectURL(url2);
      ue.success("Backup created successfully");
    } catch (error) {
      ue.error(error instanceof Error ? error.message : "An unknown error occurred");
    }
  };
  const handleRestoreData = async (file) => {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e3) => {
        try {
          const backupData = JSON.parse(e3.target?.result);
          if (!backupData || !backupData.version || !backupData.data) {
            throw new Error("Invalid backup format");
          }
          const { data } = backupData;
          setSettings({
            locations: data.locations || [],
            categories: data.categories || [],
            units: data.units || [],
            suppliers: data.suppliers || [],
            projects: data.projects || []
          });
          ue.success("Backup restored successfully");
          resolve();
        } catch (error) {
          reject(error);
        }
      };
      reader.onerror = () => reject(new Error("Failed to read file"));
      reader.readAsText(file);
    });
  };
  const handleExportExcel = () => {
    try {
      const data = {
        locations: settings.locations,
        categories: settings.categories,
        units: settings.units,
        suppliers: settings.suppliers,
        projects: settings.projects,
        inventory: getItems()
      };
      const workbook = utils.book_new();
      const inventoryWorksheet = utils.json_to_sheet(data.inventory);
      utils.book_append_sheet(workbook, inventoryWorksheet, "Inventory");
      const categoriesWorksheet = utils.json_to_sheet(data.categories);
      utils.book_append_sheet(workbook, categoriesWorksheet, "Categories");
      const unitsWorksheet = utils.json_to_sheet(data.units);
      utils.book_append_sheet(workbook, unitsWorksheet, "Units");
      const locationsWorksheet = utils.json_to_sheet(data.locations);
      utils.book_append_sheet(workbook, locationsWorksheet, "Locations");
      const suppliersWorksheet = utils.json_to_sheet(data.suppliers);
      utils.book_append_sheet(workbook, suppliersWorksheet, "Suppliers");
      const projectsWorksheet = utils.json_to_sheet(data.projects);
      utils.book_append_sheet(workbook, projectsWorksheet, "Projects");
      writeFileSync(workbook, `trackIT-data-export-${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}.xlsx`);
      ue.success("Data exported to Excel successfully");
    } catch (error) {
      ue.error(error instanceof Error ? error.message : "An unknown error occurred during Excel export");
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container max-w-6xl py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold tracking-tight text-gray-800", children: "Settings" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex gap-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: saveAllSettings, className: "bg-gray-800 hover:bg-gray-700", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Save, { className: "h-4 w-4 mr-2" }),
        "Save Settings"
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { className: "mb-6 bg-gray-50 text-gray-800 border-gray-300", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCircle, { className: "h-4 w-4 text-gray-700" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Important" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "text-gray-600", children: "Changes to categories, units, and other settings may affect existing inventory items. When removing a value that's in use, you'll be prompted to either remove it from items or replace it. Consider exporting your configuration before making significant changes." })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { defaultValue: "general", className: "border-gray-200", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "mb-4 bg-gray-100", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "general", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "General Settings" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "categories", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Categories" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "suppliers", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Suppliers" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "units", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Units" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "locations", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Locations" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "projects", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Projects" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "cabinets", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Cabinets" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "users", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Users" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "data", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "Data Management" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "logs", className: "data-[state=active]:bg-gray-800 data-[state=active]:text-white", children: "System Logs" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "general", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GeneralSettingsTab, { onOpenCameraSettings: () => setIsCameraDialogOpen(true) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsContent, { value: "categories", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Categories" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Define and organize categories for inventory items" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              EditableItemWithSubcategoriesList,
              {
                items: settings.categories,
                setItems: (newItems) => updateSettingsList("categories", newItems),
                title: "Categories",
                onCheckBeforeDelete: (value, onSafeToDelete) => {
                  const items = getItems();
                  const affectedItems = items.filter((item) => item.category === value);
                  if (affectedItems.length > 0) {
                    setItemToDelete({ type: "Categories", value });
                    setAffectedItemsCount(affectedItems.length);
                    setReconcileAction("delete");
                    setReplacementValue("");
                    setShowReconcileDialog(true);
                  } else {
                    onSafeToDelete();
                  }
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 border-t pt-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-md font-medium mb-2 text-gray-800", children: "Fix Unreconciled Items" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "If you have inventory items showing categories that no longer exist in your list, you can clean them up with this tool." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  onClick: () => {
                    const items = getItems();
                    const validCategories = settings.categories.map((cat) => cat.name);
                    const itemsWithInvalidCategories = items.filter(
                      (item) => item.category && !validCategories.includes(item.category)
                    );
                    if (itemsWithInvalidCategories.length === 0) {
                      ue.info("No inventory items with invalid categories found");
                      return;
                    }
                    const fixedItems = items.map((item) => {
                      if (item.category && !validCategories.includes(item.category)) {
                        const newItem = { ...item };
                        newItem.customFields = {
                          ...newItem.customFields,
                          previousCategory: item.category
                        };
                        delete newItem.category;
                        return newItem;
                      }
                      return item;
                    });
                    saveItems(fixedItems);
                    ue.success(`Fixed ${itemsWithInvalidCategories.length} items with invalid categories`);
                  },
                  children: "Fix Unreconciled Items"
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { className: "bg-gray-50 text-gray-800 border-gray-300", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCircle, { className: "h-4 w-4 text-gray-700" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Important" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "text-gray-600", children: "Changes to categories may affect existing inventory items. When removing a category that's in use, you'll be prompted to either remove it from items or replace it." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsContent, { value: "suppliers", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Suppliers" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage suppliers for your inventory items" })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              EditableItemWithSubcategoriesList,
              {
                items: settings.suppliers,
                setItems: (newItems) => updateSettingsList("suppliers", newItems),
                title: "Suppliers",
                enableSubcategories: false,
                onCheckBeforeDelete: (value, onSafeToDelete) => {
                  const items = getItems();
                  const affectedItems = items.filter((item) => item.supplier === value);
                  if (affectedItems.length > 0) {
                    setItemToDelete({ type: "Suppliers", value });
                    setAffectedItemsCount(affectedItems.length);
                    setReconcileAction("delete");
                    setReplacementValue("");
                    setShowReconcileDialog(true);
                  } else {
                    onSafeToDelete();
                  }
                }
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 border-t pt-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-md font-medium mb-2 text-gray-800", children: "Fix Unreconciled Items" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "If you have inventory items showing suppliers that no longer exist in your list, you can clean them up with this tool." }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                  onClick: () => {
                    const items = getItems();
                    const validSuppliers = settings.suppliers.map((sup) => sup.name);
                    const itemsWithInvalidSuppliers = items.filter(
                      (item) => item.supplier && !validSuppliers.includes(item.supplier)
                    );
                    if (itemsWithInvalidSuppliers.length === 0) {
                      ue.info("No inventory items with invalid suppliers found");
                      return;
                    }
                    const fixedItems = items.map((item) => {
                      if (item.supplier && !validSuppliers.includes(item.supplier)) {
                        const newItem = { ...item };
                        newItem.customFields = {
                          ...newItem.customFields,
                          previousSupplier: item.supplier
                        };
                        delete newItem.supplier;
                        return newItem;
                      }
                      return item;
                    });
                    saveItems(fixedItems);
                    ue.success(`Fixed ${itemsWithInvalidSuppliers.length} items with invalid suppliers`);
                  },
                  children: "Fix Unreconciled Items"
                }
              )
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Alert, { className: "bg-gray-50 text-gray-800 border-gray-300", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertCircle, { className: "h-4 w-4 text-gray-700" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertTitle, { children: "Important" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(AlertDescription, { className: "text-gray-600", children: "Changes to suppliers may affect existing inventory items. When removing a supplier that's in use, you'll be prompted to either remove it from items or replace it." })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "units", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Units" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage units of measurement for your inventory items" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            EditableItemWithSubcategoriesList,
            {
              items: settings.units,
              setItems: (newItems) => updateSettingsList("units", newItems),
              title: "Units",
              onCheckBeforeDelete: (value, onSafeToDelete) => {
                const items = getItems();
                const affectedItems = items.filter((item) => item.unit === value);
                if (affectedItems.length > 0) {
                  setItemToDelete({ type: "Units", value });
                  setAffectedItemsCount(affectedItems.length);
                  setReconcileAction("delete");
                  setReplacementValue("");
                  setShowReconcileDialog(true);
                } else {
                  onSafeToDelete();
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 border-t pt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-md font-medium mb-2 text-gray-800", children: "Fix Unreconciled Items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "If you have inventory items showing units that no longer exist in your list, you can clean them up with this tool." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                onClick: () => {
                  const items = getItems();
                  const validUnits = settings.units.map((unit) => unit.name);
                  const itemsWithInvalidUnits = items.filter(
                    (item) => item.unit && !validUnits.includes(item.unit)
                  );
                  if (itemsWithInvalidUnits.length === 0) {
                    ue.info("No inventory items with invalid units found");
                    return;
                  }
                  const defaultUnit = validUnits.length > 0 ? validUnits[0] : "each";
                  const fixedItems = items.map((item) => {
                    if (item.unit && !validUnits.includes(item.unit)) {
                      const newItem = { ...item };
                      newItem.customFields = {
                        ...newItem.customFields,
                        previousUnit: item.unit
                      };
                      newItem.unit = defaultUnit;
                      return newItem;
                    }
                    return item;
                  });
                  saveItems(fixedItems);
                  ue.success(`Fixed ${itemsWithInvalidUnits.length} items with invalid units`);
                },
                children: "Fix Unreconciled Items"
              }
            )
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "locations", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Locations" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage storage locations for your inventory items" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            EditableItemWithSubcategoriesList,
            {
              items: settings.locations,
              setItems: (newItems) => updateSettingsList("locations", newItems),
              title: "Locations",
              onCheckBeforeDelete: (value, onSafeToDelete) => {
                const items = getItems();
                const affectedItems = items.filter((item) => item.location === value);
                if (affectedItems.length > 0) {
                  setItemToDelete({ type: "Locations", value });
                  setAffectedItemsCount(affectedItems.length);
                  setReconcileAction("delete");
                  setReplacementValue("");
                  setShowReconcileDialog(true);
                } else {
                  onSafeToDelete();
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 border-t pt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-md font-medium mb-2 text-gray-800", children: "Fix Unreconciled Items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "If you have inventory items showing locations that no longer exist in your list, you can clean them up with this tool." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                onClick: () => {
                  const items = getItems();
                  const validLocations = settings.locations.map((loc) => loc.name);
                  const itemsWithInvalidLocations = items.filter(
                    (item) => item.location && !validLocations.includes(item.location)
                  );
                  if (itemsWithInvalidLocations.length === 0) {
                    ue.info("No inventory items with invalid locations found");
                    return;
                  }
                  const fixedItems = items.map((item) => {
                    if (item.location && !validLocations.includes(item.location)) {
                      const newItem = { ...item };
                      newItem.customFields = {
                        ...newItem.customFields,
                        previousLocation: item.location
                      };
                      delete newItem.location;
                      return newItem;
                    }
                    return item;
                  });
                  saveItems(fixedItems);
                  ue.success(`Fixed ${itemsWithInvalidLocations.length} items with invalid locations`);
                },
                children: "Fix Unreconciled Items"
              }
            )
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "projects", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { className: "mb-6", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Projects" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage projects for your inventory items" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            EditableItemWithSubcategoriesList,
            {
              items: settings.projects,
              setItems: (newItems) => updateSettingsList("projects", newItems),
              title: "Projects",
              onCheckBeforeDelete: (value, onSafeToDelete) => {
                const items = getItems();
                const affectedItems = items.filter((item) => item.project === value);
                if (affectedItems.length > 0) {
                  setItemToDelete({ type: "Projects", value });
                  setAffectedItemsCount(affectedItems.length);
                  setReconcileAction("delete");
                  setReplacementValue("");
                  setShowReconcileDialog(true);
                } else {
                  onSafeToDelete();
                }
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6 border-t pt-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("h3", { className: "text-md font-medium mb-2 text-gray-800", children: "Fix Unreconciled Items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500 mb-4", children: "If you have inventory items showing projects that no longer exist in your list, you can clean them up with this tool." }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                onClick: () => {
                  const items = getItems();
                  const validProjects = settings.projects.map((proj) => proj.name);
                  const itemsWithInvalidProjects = items.filter(
                    (item) => item.project && !validProjects.includes(item.project)
                  );
                  if (itemsWithInvalidProjects.length === 0) {
                    ue.info("No inventory items with invalid projects found");
                    return;
                  }
                  const fixedItems = items.map((item) => {
                    if (item.project && !validProjects.includes(item.project)) {
                      const newItem = { ...item };
                      newItem.customFields = {
                        ...newItem.customFields,
                        previousProject: item.project
                      };
                      delete newItem.project;
                      return newItem;
                    }
                    return item;
                  });
                  saveItems(fixedItems);
                  ue.success(`Fixed ${itemsWithInvalidProjects.length} items with invalid projects`);
                },
                children: "Fix Unreconciled Items"
              }
            )
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "cabinets", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Storage Cabinet Management" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Manage storage cabinets and their locations. Cabinets are assigned to existing locations from the Location Management list." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          CabinetManagement,
          {
            locations: settings.locations.map((loc) => loc.name)
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "users", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { className: "flex flex-row items-center justify-between space-y-0 pb-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "User Management" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: () => setShowAddUserDialog(true), className: "flex items-center", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(UserPlus, { className: "mr-2 h-4 w-4" }),
            "Add User"
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: renderUsersList() })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "data", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        DataBackupTab,
        {
          onExportData: handleExportData,
          onExportExcel: handleExportExcel,
          onImportData: handleImportData,
          onImportExcel: handleImportExcel,
          onBackupData: handleBackupData,
          onRestoreData: handleRestoreData
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "logs", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "System Logs" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "View system activity and troubleshoot issues" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SystemLogs, {}) })
      ] }) })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      AddUserDialog,
      {
        open: showAddUserDialog,
        onOpenChange: setShowAddUserDialog,
        onAdd: handleAddUser
      }
    ),
    editingUser && /* @__PURE__ */ jsxRuntimeExports.jsx(
      EditUserDialog,
      {
        open: !!editingUser,
        onOpenChange: (open) => !open && setEditingUser(null),
        user: editingUser,
        onSave: handleEditUser
      }
    ),
    resettingUser && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AdminResetPasswordDialog,
      {
        open: !!resettingUser,
        onOpenChange: (open) => !open && setResettingUser(null),
        user: resettingUser,
        onReset: handleResetPassword
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: showReconcileDialog, onOpenChange: setShowReconcileDialog, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "bg-gray-50 border-gray-300", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "text-gray-800", children: "Confirm Removal" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { className: "text-gray-600", children: [
          "The ",
          itemToDelete?.type.toLowerCase().slice(0, -1),
          ' "',
          itemToDelete?.value,
          '" is used by ',
          affectedItemsCount,
          " inventory items. What would you like to do?"
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 py-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "radio",
              id: "delete-option",
              name: "reconcile-action",
              checked: reconcileAction === "delete",
              onChange: () => setReconcileAction("delete"),
              className: "mt-1"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "delete-option", className: "font-medium text-gray-800", children: "Remove from items" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500", children: [
              "Remove this ",
              itemToDelete?.type.toLowerCase().slice(0, -1),
              " from all items that use it."
            ] })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            "input",
            {
              type: "radio",
              id: "replace-option",
              name: "reconcile-action",
              checked: reconcileAction === "replace",
              onChange: () => setReconcileAction("replace"),
              className: "mt-1"
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex-1", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "replace-option", className: "font-medium text-gray-800", children: "Replace with another value" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-500 mb-2", children: [
              "Replace with another ",
              itemToDelete?.type.toLowerCase().slice(0, -1),
              " in all affected items."
            ] }),
            reconcileAction === "replace" && itemToDelete && /* @__PURE__ */ jsxRuntimeExports.jsxs(
              "select",
              {
                className: "w-full p-2 border border-gray-300 rounded bg-white text-gray-800",
                value: replacementValue,
                onChange: (e3) => setReplacementValue(e3.target.value),
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "", children: "Select replacement..." }),
                  settings[itemToDelete.type.toLowerCase()].filter((item) => item.name !== itemToDelete.value).map((item) => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: item.name, children: item.name }, item.id))
                ]
              }
            )
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            onClick: () => setShowReconcileDialog(false),
            className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
            children: "Cancel"
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: handleReconcileConfirm,
            disabled: reconcileAction === "replace" && !replacementValue,
            className: "bg-gray-800 hover:bg-gray-700",
            children: "Confirm"
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: !!importDuplicates,
        onOpenChange: (open) => {
          if (!open) {
            setImportDuplicates(null);
            setImportInProgress(null);
          }
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "bg-gray-50 border-gray-300 max-w-2xl", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "text-gray-800", children: "Duplicate Items Found" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { className: "text-gray-600", children: importDuplicates && `Found ${importDuplicates.imported.length} duplicate ${importDuplicates.type} 
              in the import file that conflict with existing items. How would you like to handle these?` })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-4 py-4 max-h-96 overflow-auto", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  id: "skip-option",
                  name: "import-action",
                  checked: importDuplicateAction === "skip",
                  onChange: () => setImportDuplicateAction("skip"),
                  className: "mt-1"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "skip-option", className: "font-medium text-gray-800", children: "Skip duplicates" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Import only new items and skip any duplicates found." })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  id: "replace-option",
                  name: "import-action",
                  checked: importDuplicateAction === "replace",
                  onChange: () => setImportDuplicateAction("replace"),
                  className: "mt-1"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "replace-option", className: "font-medium text-gray-800", children: "Replace existing items" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Replace existing items with the imported versions." })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-start space-x-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                "input",
                {
                  type: "radio",
                  id: "merge-option",
                  name: "import-action",
                  checked: importDuplicateAction === "merge",
                  onChange: () => setImportDuplicateAction("merge"),
                  className: "mt-1"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("label", { htmlFor: "merge-option", className: "font-medium text-gray-800", children: "Merge and keep existing" }),
                /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-500", children: "Import all items, but keep existing versions when duplicates are found." })
              ] })
            ] }),
            importDuplicates && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "mt-6", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsxs("h4", { className: "font-medium text-gray-800 mb-2", children: [
                "Duplicate ",
                importDuplicates.type,
                ":"
              ] }),
              /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "border rounded overflow-hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("table", { className: "w-full text-sm", children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx("thead", { className: "bg-gray-100", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-left", children: "Name" }),
                  /* @__PURE__ */ jsxRuntimeExports.jsx("th", { className: "px-4 py-2 text-left", children: "Status" })
                ] }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs("tbody", { children: [
                  importDuplicates.imported.slice(0, 10).map((item, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("tr", { className: "border-t", children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-2", children: item.name }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx("td", { className: "px-4 py-2 text-amber-600", children: "Duplicate" })
                  ] }, index2)),
                  importDuplicates.imported.length > 10 && /* @__PURE__ */ jsxRuntimeExports.jsx("tr", { className: "border-t", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("td", { colSpan: 2, className: "px-4 py-2 text-gray-500 italic", children: [
                    "And ",
                    importDuplicates.imported.length - 10,
                    " more..."
                  ] }) })
                ] })
              ] }) })
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                variant: "outline",
                onClick: () => {
                  setImportDuplicates(null);
                  setImportInProgress(null);
                },
                className: "bg-gray-100 hover:bg-gray-200 text-gray-800 border-gray-300",
                children: "Cancel"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              Button,
              {
                onClick: handleImportConfirm,
                className: "bg-gray-800 hover:bg-gray-700",
                children: "Confirm Import"
              }
            )
          ] })
        ] })
      }
    ),
    isCameraDialogOpen && /* @__PURE__ */ jsxRuntimeExports.jsx(
      CameraSettingsDialog,
      {
        isOpen: isCameraDialogOpen,
        onClose: () => setIsCameraDialogOpen(false)
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Dialog,
      {
        open: !!importSuccess,
        onOpenChange: (open) => {
          if (!open) {
            setImportSuccess(null);
          }
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "bg-gray-50 border-gray-300 max-w-md", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { className: "text-gray-800", children: "Import Successful" }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { className: "text-gray-600", children: [
              "The following items were imported from ",
              importSuccess?.fileType === "excel" ? "Excel" : "JSON",
              " file:"
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "py-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
            importSuccess && Object.entries(importSuccess.itemCounts).map(([key, count2]) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center py-2 border-b", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "font-medium capitalize", children: key }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs("span", { className: "text-gray-900", children: [
                count2,
                " items"
              ] })
            ] }, key)),
            importSuccess && Object.keys(importSuccess.itemCounts).length === 0 && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-amber-600 italic text-center py-2", children: "No items were imported. Check if your file has the correct format." })
          ] }) }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(DialogFooter, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              onClick: () => setImportSuccess(null),
              className: "bg-gray-800 hover:bg-gray-700",
              children: "Close"
            }
          ) })
        ] })
      }
    )
  ] });
}
function ReportsPage() {
  const [items] = useLocalStorage("inventoryItems", []);
  const { toast: toast2 } = useToast();
  const generateCSV = (data, headers, filename) => {
    const csvContent = [
      headers.join(","),
      ...data.map((row) => headers.map((header) => JSON.stringify(row[header] || "")).join(","))
    ].join("\n");
    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
    const link = document.createElement("a");
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    link.click();
    URL.revokeObjectURL(url);
    toast2({
      title: "Report Generated",
      description: `${filename} has been downloaded.`
    });
  };
  const handleProjectStatusReport = () => {
    const projectStats = items.reduce((acc, item) => {
      const project = item.project || "Unassigned";
      if (!acc[project]) {
        acc[project] = {
          totalItems: 0,
          pendingOrder: 0,
          backOrdered: 0,
          inStock: 0,
          needsReorder: 0,
          totalValue: 0
        };
      }
      acc[project].totalItems++;
      acc[project].totalValue += (item.costPerUnit || 0) * (item.quantity || 0);
      if (item.status === "pending") acc[project].pendingOrder++;
      if (item.status === "backorder") acc[project].backOrdered++;
      if ((item.quantity || 0) > 0) acc[project].inStock++;
      if ((item.quantity || 0) <= (item.minQuantity || 0)) acc[project].needsReorder++;
      return acc;
    }, {});
    const reportData = Object.entries(projectStats).map(([project, stats]) => ({
      project,
      ...stats
    }));
    generateCSV(
      reportData,
      ["project", "totalItems", "pendingOrder", "backOrdered", "inStock", "needsReorder", "totalValue"],
      "project_status_report.csv"
    );
  };
  const handleCriticalItemsReport = () => {
    const criticalItems = items.filter(
      (item) => (item.quantity || 0) <= (item.minQuantity || 0) || item.status === "backorder" || (item.quantity || 0) === 0 && item.status !== "pending"
    ).map((item) => ({
      ...item,
      criticalReason: (item.quantity || 0) <= (item.minQuantity || 0) ? "Low Stock" : item.status === "backorder" ? "Back Ordered" : "Out of Stock",
      daysToReorder: item.expectedDeliveryDate ? Math.ceil((new Date(item.expectedDeliveryDate).getTime() - (/* @__PURE__ */ new Date()).getTime()) / (1e3 * 60 * 60 * 24)) : "N/A"
    }));
    generateCSV(
      criticalItems,
      ["name", "project", "quantity", "minQuantity", "criticalReason", "status", "daysToReorder", "location"],
      "critical_items_report.csv"
    );
  };
  const handleProductionPlanningReport = () => {
    const planningData = items.map((item) => ({
      ...item,
      stockStatus: (item.quantity || 0) <= (item.minQuantity || 0) ? "Reorder Required" : (item.quantity || 0) === 0 ? "Out of Stock" : "In Stock",
      availableForProduction: Math.max(0, (item.quantity || 0) - (item.minQuantity || 0)),
      nextDelivery: item.expectedDeliveryDate ? new Date(item.expectedDeliveryDate).toLocaleDateString() : "Not Scheduled"
    }));
    generateCSV(
      planningData,
      ["name", "project", "quantity", "stockStatus", "availableForProduction", "nextDelivery", "location", "supplier"],
      "production_planning_report.csv"
    );
  };
  const handleSupplierOrderReport = () => {
    const pendingOrders = items.filter((item) => item.status === "pending" || item.status === "backorder").map((item) => ({
      ...item,
      orderStatus: item.status,
      expectedDelivery: item.expectedDeliveryDate ? new Date(item.expectedDeliveryDate).toLocaleDateString() : "Not Scheduled",
      daysOverdue: item.expectedDeliveryDate && new Date(item.expectedDeliveryDate) < /* @__PURE__ */ new Date() ? Math.ceil(((/* @__PURE__ */ new Date()).getTime() - new Date(item.expectedDeliveryDate).getTime()) / (1e3 * 60 * 60 * 24)) : 0
    }));
    generateCSV(
      pendingOrders,
      ["name", "supplier", "project", "orderStatus", "expectedDelivery", "daysOverdue", "quantity", "costPerUnit"],
      "supplier_order_status_report.csv"
    );
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold", children: "Production Reports" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { defaultValue: "project", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-2 lg:grid-cols-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "project", children: "Project Status" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "critical", children: "Critical Items" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "planning", children: "Production Planning" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "orders", children: "Order Status" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "project", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Project Status Overview" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Comprehensive status report for all projects" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground mb-4", children: [
            "This report includes:",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Total items per project",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Items pending order/back-ordered",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Current stock levels",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Items needing reorder",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Total project value"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleProjectStatusReport, className: "w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
            "Generate Project Status Report"
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "critical", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Critical Items Report" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Items requiring immediate attention" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground mb-4", children: [
            "Identifies items that are:",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Below minimum quantity",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Back-ordered",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Out of stock",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Expected delivery dates"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleCriticalItemsReport, className: "w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
            "Generate Critical Items Report"
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "planning", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Production Planning Report" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Stock availability for production" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground mb-4", children: [
            "Details include:",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Current stock status",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Available quantity for production",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Next scheduled deliveries",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Location and supplier information"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleProductionPlanningReport, className: "w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
            "Generate Production Planning Report"
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "orders", className: "space-y-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Supplier Order Status" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Track pending and back-ordered items" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground mb-4", children: [
            "Report includes:",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Pending orders by supplier",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Back-ordered items",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Expected delivery dates",
            /* @__PURE__ */ jsxRuntimeExports.jsx("br", {}),
            "• Days overdue for late items"
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleSupplierOrderReport, className: "w-full", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Download, { className: "mr-2 h-4 w-4" }),
            "Generate Order Status Report"
          ] })
        ] })
      ] }) })
    ] })
  ] });
}
var PROVIDER_NAME = "ToastProvider";
var [Collection, useCollection, createCollectionScope] = createCollection("Toast");
var [createToastContext, createToastScope] = createContextScope("Toast", [createCollectionScope]);
var [ToastProviderProvider, useToastProviderContext] = createToastContext(PROVIDER_NAME);
var ToastProvider$1 = (props) => {
  const {
    __scopeToast,
    label = "Notification",
    duration = 5e3,
    swipeDirection = "right",
    swipeThreshold = 50,
    children
  } = props;
  const [viewport, setViewport] = reactExports.useState(null);
  const [toastCount, setToastCount] = reactExports.useState(0);
  const isFocusedToastEscapeKeyDownRef = reactExports.useRef(false);
  const isClosePausedRef = reactExports.useRef(false);
  if (!label.trim()) {
    console.error(
      `Invalid prop \`label\` supplied to \`${PROVIDER_NAME}\`. Expected non-empty \`string\`.`
    );
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ToastProviderProvider,
    {
      scope: __scopeToast,
      label,
      duration,
      swipeDirection,
      swipeThreshold,
      toastCount,
      viewport,
      onViewportChange: setViewport,
      onToastAdd: reactExports.useCallback(() => setToastCount((prevCount) => prevCount + 1), []),
      onToastRemove: reactExports.useCallback(() => setToastCount((prevCount) => prevCount - 1), []),
      isFocusedToastEscapeKeyDownRef,
      isClosePausedRef,
      children
    }
  ) });
};
ToastProvider$1.displayName = PROVIDER_NAME;
var VIEWPORT_NAME = "ToastViewport";
var VIEWPORT_DEFAULT_HOTKEY = ["F8"];
var VIEWPORT_PAUSE = "toast.viewportPause";
var VIEWPORT_RESUME = "toast.viewportResume";
var ToastViewport$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      hotkey = VIEWPORT_DEFAULT_HOTKEY,
      label = "Notifications ({hotkey})",
      ...viewportProps
    } = props;
    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);
    const getItems2 = useCollection(__scopeToast);
    const wrapperRef = reactExports.useRef(null);
    const headFocusProxyRef = reactExports.useRef(null);
    const tailFocusProxyRef = reactExports.useRef(null);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    const hotkeyLabel = hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
    const hasToasts = context.toastCount > 0;
    reactExports.useEffect(() => {
      const handleKeyDown = (event) => {
        const isHotkeyPressed = hotkey.length !== 0 && hotkey.every((key) => event[key] || event.code === key);
        if (isHotkeyPressed) ref.current?.focus();
      };
      document.addEventListener("keydown", handleKeyDown);
      return () => document.removeEventListener("keydown", handleKeyDown);
    }, [hotkey]);
    reactExports.useEffect(() => {
      const wrapper = wrapperRef.current;
      const viewport = ref.current;
      if (hasToasts && wrapper && viewport) {
        const handlePause = () => {
          if (!context.isClosePausedRef.current) {
            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);
            viewport.dispatchEvent(pauseEvent);
            context.isClosePausedRef.current = true;
          }
        };
        const handleResume = () => {
          if (context.isClosePausedRef.current) {
            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);
            viewport.dispatchEvent(resumeEvent);
            context.isClosePausedRef.current = false;
          }
        };
        const handleFocusOutResume = (event) => {
          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget);
          if (isFocusMovingOutside) handleResume();
        };
        const handlePointerLeaveResume = () => {
          const isFocusInside = wrapper.contains(document.activeElement);
          if (!isFocusInside) handleResume();
        };
        wrapper.addEventListener("focusin", handlePause);
        wrapper.addEventListener("focusout", handleFocusOutResume);
        wrapper.addEventListener("pointermove", handlePause);
        wrapper.addEventListener("pointerleave", handlePointerLeaveResume);
        window.addEventListener("blur", handlePause);
        window.addEventListener("focus", handleResume);
        return () => {
          wrapper.removeEventListener("focusin", handlePause);
          wrapper.removeEventListener("focusout", handleFocusOutResume);
          wrapper.removeEventListener("pointermove", handlePause);
          wrapper.removeEventListener("pointerleave", handlePointerLeaveResume);
          window.removeEventListener("blur", handlePause);
          window.removeEventListener("focus", handleResume);
        };
      }
    }, [hasToasts, context.isClosePausedRef]);
    const getSortedTabbableCandidates = reactExports.useCallback(
      ({ tabbingDirection }) => {
        const toastItems = getItems2();
        const tabbableCandidates = toastItems.map((toastItem) => {
          const toastNode = toastItem.ref.current;
          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];
          return tabbingDirection === "forwards" ? toastTabbableCandidates : toastTabbableCandidates.reverse();
        });
        return (tabbingDirection === "forwards" ? tabbableCandidates.reverse() : tabbableCandidates).flat();
      },
      [getItems2]
    );
    reactExports.useEffect(() => {
      const viewport = ref.current;
      if (viewport) {
        const handleKeyDown = (event) => {
          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;
          const isTabKey = event.key === "Tab" && !isMetaKey;
          if (isTabKey) {
            const focusedElement = document.activeElement;
            const isTabbingBackwards = event.shiftKey;
            const targetIsViewport = event.target === viewport;
            if (targetIsViewport && isTabbingBackwards) {
              headFocusProxyRef.current?.focus();
              return;
            }
            const tabbingDirection = isTabbingBackwards ? "backwards" : "forwards";
            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });
            const index2 = sortedCandidates.findIndex((candidate) => candidate === focusedElement);
            if (focusFirst(sortedCandidates.slice(index2 + 1))) {
              event.preventDefault();
            } else {
              isTabbingBackwards ? headFocusProxyRef.current?.focus() : tailFocusProxyRef.current?.focus();
            }
          }
        };
        viewport.addEventListener("keydown", handleKeyDown);
        return () => viewport.removeEventListener("keydown", handleKeyDown);
      }
    }, [getItems2, getSortedTabbableCandidates]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      Branch,
      {
        ref: wrapperRef,
        role: "region",
        "aria-label": label.replace("{hotkey}", hotkeyLabel),
        tabIndex: -1,
        style: { pointerEvents: hasToasts ? void 0 : "none" },
        children: [
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: headFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "forwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.ol, { tabIndex: -1, ...viewportProps, ref: composedRefs }) }),
          hasToasts && /* @__PURE__ */ jsxRuntimeExports.jsx(
            FocusProxy,
            {
              ref: tailFocusProxyRef,
              onFocusFromOutsideViewport: () => {
                const tabbableCandidates = getSortedTabbableCandidates({
                  tabbingDirection: "backwards"
                });
                focusFirst(tabbableCandidates);
              }
            }
          )
        ]
      }
    );
  }
);
ToastViewport$1.displayName = VIEWPORT_NAME;
var FOCUS_PROXY_NAME = "ToastFocusProxy";
var FocusProxy = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;
    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      VisuallyHidden,
      {
        "aria-hidden": true,
        tabIndex: 0,
        ...proxyProps,
        ref: forwardedRef,
        style: { position: "fixed" },
        onFocus: (event) => {
          const prevFocusedElement = event.relatedTarget;
          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);
          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();
        }
      }
    );
  }
);
FocusProxy.displayName = FOCUS_PROXY_NAME;
var TOAST_NAME = "Toast";
var TOAST_SWIPE_START = "toast.swipeStart";
var TOAST_SWIPE_MOVE = "toast.swipeMove";
var TOAST_SWIPE_CANCEL = "toast.swipeCancel";
var TOAST_SWIPE_END = "toast.swipeEnd";
var Toast$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;
    const [open, setOpen] = useControllableState({
      prop: openProp,
      defaultProp: defaultOpen ?? true,
      onChange: onOpenChange,
      caller: TOAST_NAME
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      ToastImpl,
      {
        open,
        ...toastProps,
        ref: forwardedRef,
        onClose: () => setOpen(false),
        onPause: useCallbackRef$1(props.onPause),
        onResume: useCallbackRef$1(props.onResume),
        onSwipeStart: composeEventHandlers(props.onSwipeStart, (event) => {
          event.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: composeEventHandlers(props.onSwipeMove, (event) => {
          const { x: x3, y: y4 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "move");
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${x3}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y4}px`);
        }),
        onSwipeCancel: composeEventHandlers(props.onSwipeCancel, (event) => {
          event.currentTarget.setAttribute("data-swipe", "cancel");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: composeEventHandlers(props.onSwipeEnd, (event) => {
          const { x: x3, y: y4 } = event.detail.delta;
          event.currentTarget.setAttribute("data-swipe", "end");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-x");
          event.currentTarget.style.removeProperty("--radix-toast-swipe-move-y");
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${x3}px`);
          event.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y4}px`);
          setOpen(false);
        })
      }
    ) });
  }
);
Toast$1.displayName = TOAST_NAME;
var [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {
  onClose() {
  }
});
var ToastImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeToast,
      type = "foreground",
      duration: durationProp,
      open,
      onClose,
      onEscapeKeyDown,
      onPause,
      onResume,
      onSwipeStart,
      onSwipeMove,
      onSwipeCancel,
      onSwipeEnd,
      ...toastProps
    } = props;
    const context = useToastProviderContext(TOAST_NAME, __scopeToast);
    const [node, setNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const pointerStartRef = reactExports.useRef(null);
    const swipeDeltaRef = reactExports.useRef(null);
    const duration = durationProp || context.duration;
    const closeTimerStartTimeRef = reactExports.useRef(0);
    const closeTimerRemainingTimeRef = reactExports.useRef(duration);
    const closeTimerRef = reactExports.useRef(0);
    const { onToastAdd, onToastRemove } = context;
    const handleClose = useCallbackRef$1(() => {
      const isFocusInToast = node?.contains(document.activeElement);
      if (isFocusInToast) context.viewport?.focus();
      onClose();
    });
    const startTimer = reactExports.useCallback(
      (duration2) => {
        if (!duration2 || duration2 === Infinity) return;
        window.clearTimeout(closeTimerRef.current);
        closeTimerStartTimeRef.current = (/* @__PURE__ */ new Date()).getTime();
        closeTimerRef.current = window.setTimeout(handleClose, duration2);
      },
      [handleClose]
    );
    reactExports.useEffect(() => {
      const viewport = context.viewport;
      if (viewport) {
        const handleResume = () => {
          startTimer(closeTimerRemainingTimeRef.current);
          onResume?.();
        };
        const handlePause = () => {
          const elapsedTime = (/* @__PURE__ */ new Date()).getTime() - closeTimerStartTimeRef.current;
          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;
          window.clearTimeout(closeTimerRef.current);
          onPause?.();
        };
        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);
        viewport.addEventListener(VIEWPORT_RESUME, handleResume);
        return () => {
          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);
          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);
        };
      }
    }, [context.viewport, duration, onPause, onResume, startTimer]);
    reactExports.useEffect(() => {
      if (open && !context.isClosePausedRef.current) startTimer(duration);
    }, [open, duration, context.isClosePausedRef, startTimer]);
    reactExports.useEffect(() => {
      onToastAdd();
      return () => onToastRemove();
    }, [onToastAdd, onToastRemove]);
    const announceTextContent = reactExports.useMemo(() => {
      return node ? getAnnounceTextContent(node) : null;
    }, [node]);
    if (!context.viewport) return null;
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      announceTextContent && /* @__PURE__ */ jsxRuntimeExports.jsx(
        ToastAnnounce,
        {
          __scopeToast,
          role: "status",
          "aria-live": type === "foreground" ? "assertive" : "polite",
          "aria-atomic": true,
          children: announceTextContent
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ToastInteractiveProvider, { scope: __scopeToast, onClose: handleClose, children: reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: __scopeToast, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$9,
          {
            asChild: true,
            onEscapeKeyDown: composeEventHandlers(onEscapeKeyDown, () => {
              if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();
              context.isFocusedToastEscapeKeyDownRef.current = false;
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": true,
                tabIndex: 0,
                "data-state": open ? "open" : "closed",
                "data-swipe-direction": context.swipeDirection,
                ...toastProps,
                ref: composedRefs,
                style: { userSelect: "none", touchAction: "none", ...props.style },
                onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
                  if (event.key !== "Escape") return;
                  onEscapeKeyDown?.(event.nativeEvent);
                  if (!event.nativeEvent.defaultPrevented) {
                    context.isFocusedToastEscapeKeyDownRef.current = true;
                    handleClose();
                  }
                }),
                onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
                  if (event.button !== 0) return;
                  pointerStartRef.current = { x: event.clientX, y: event.clientY };
                }),
                onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
                  if (!pointerStartRef.current) return;
                  const x3 = event.clientX - pointerStartRef.current.x;
                  const y4 = event.clientY - pointerStartRef.current.y;
                  const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);
                  const isHorizontalSwipe = ["left", "right"].includes(context.swipeDirection);
                  const clamp2 = ["left", "up"].includes(context.swipeDirection) ? Math.min : Math.max;
                  const clampedX = isHorizontalSwipe ? clamp2(0, x3) : 0;
                  const clampedY = !isHorizontalSwipe ? clamp2(0, y4) : 0;
                  const moveStartBuffer = event.pointerType === "touch" ? 10 : 2;
                  const delta = { x: clampedX, y: clampedY };
                  const eventDetail = { originalEvent: event, delta };
                  if (hasSwipeMoveStarted) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {
                      discrete: false
                    });
                  } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {
                    swipeDeltaRef.current = delta;
                    handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {
                      discrete: false
                    });
                    event.target.setPointerCapture(event.pointerId);
                  } else if (Math.abs(x3) > moveStartBuffer || Math.abs(y4) > moveStartBuffer) {
                    pointerStartRef.current = null;
                  }
                }),
                onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
                  const delta = swipeDeltaRef.current;
                  const target = event.target;
                  if (target.hasPointerCapture(event.pointerId)) {
                    target.releasePointerCapture(event.pointerId);
                  }
                  swipeDeltaRef.current = null;
                  pointerStartRef.current = null;
                  if (delta) {
                    const toast2 = event.currentTarget;
                    const eventDetail = { originalEvent: event, delta };
                    if (isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)) {
                      handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {
                        discrete: true
                      });
                    } else {
                      handleAndDispatchCustomEvent(
                        TOAST_SWIPE_CANCEL,
                        onSwipeCancel,
                        eventDetail,
                        {
                          discrete: true
                        }
                      );
                    }
                    toast2.addEventListener("click", (event2) => event2.preventDefault(), {
                      once: true
                    });
                  }
                })
              }
            )
          }
        ) }),
        context.viewport
      ) })
    ] });
  }
);
var ToastAnnounce = (props) => {
  const { __scopeToast, children, ...announceProps } = props;
  const context = useToastProviderContext(TOAST_NAME, __scopeToast);
  const [renderAnnounceText, setRenderAnnounceText] = reactExports.useState(false);
  const [isAnnounced, setIsAnnounced] = reactExports.useState(false);
  useNextFrame(() => setRenderAnnounceText(true));
  reactExports.useEffect(() => {
    const timer = window.setTimeout(() => setIsAnnounced(true), 1e3);
    return () => window.clearTimeout(timer);
  }, []);
  return isAnnounced ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$3, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { ...announceProps, children: renderAnnounceText && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    context.label,
    " ",
    children
  ] }) }) });
};
var TITLE_NAME = "ToastTitle";
var ToastTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...titleProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...titleProps, ref: forwardedRef });
  }
);
ToastTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "ToastDescription";
var ToastDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...descriptionProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...descriptionProps, ref: forwardedRef });
  }
);
ToastDescription$1.displayName = DESCRIPTION_NAME;
var ACTION_NAME = "ToastAction";
var ToastAction$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { altText, ...actionProps } = props;
    if (!altText.trim()) {
      console.error(
        `Invalid prop \`altText\` supplied to \`${ACTION_NAME}\`. Expected non-empty \`string\`.`
      );
      return null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { altText, asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose$1, { ...actionProps, ref: forwardedRef }) });
  }
);
ToastAction$1.displayName = ACTION_NAME;
var CLOSE_NAME = "ToastClose";
var ToastClose$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeToast, ...closeProps } = props;
    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(ToastAnnounceExclude, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, interactiveContext.onClose)
      }
    ) });
  }
);
ToastClose$1.displayName = CLOSE_NAME;
var ToastAnnounceExclude = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeToast, altText, ...announceExcludeProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": altText || void 0,
      ...announceExcludeProps,
      ref: forwardedRef
    }
  );
});
function getAnnounceTextContent(container) {
  const textContent = [];
  const childNodes = Array.from(container.childNodes);
  childNodes.forEach((node) => {
    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);
    if (isHTMLElement(node)) {
      const isHidden2 = node.ariaHidden || node.hidden || node.style.display === "none";
      const isExcluded = node.dataset.radixToastAnnounceExclude === "";
      if (!isHidden2) {
        if (isExcluded) {
          const altText = node.dataset.radixToastAnnounceAlt;
          if (altText) textContent.push(altText);
        } else {
          textContent.push(...getAnnounceTextContent(node));
        }
      }
    }
  });
  return textContent;
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const currentTarget = detail.originalEvent.currentTarget;
  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });
  if (handler) currentTarget.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(currentTarget, event);
  } else {
    currentTarget.dispatchEvent(event);
  }
}
var isDeltaInDirection = (delta, direction, threshold = 0) => {
  const deltaX = Math.abs(delta.x);
  const deltaY = Math.abs(delta.y);
  const isDeltaX = deltaX > deltaY;
  if (direction === "left" || direction === "right") {
    return isDeltaX && deltaX > threshold;
  } else {
    return !isDeltaX && deltaY > threshold;
  }
};
function useNextFrame(callback = () => {
}) {
  const fn = useCallbackRef$1(callback);
  useLayoutEffect2(() => {
    let raf1 = 0;
    let raf2 = 0;
    raf1 = window.requestAnimationFrame(() => raf2 = window.requestAnimationFrame(fn));
    return () => {
      window.cancelAnimationFrame(raf1);
      window.cancelAnimationFrame(raf2);
    };
  }, [fn]);
}
function isHTMLElement(node) {
  return node.nodeType === node.ELEMENT_NODE;
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function focusFirst(candidates) {
  const previouslyFocusedElement = document.activeElement;
  return candidates.some((candidate) => {
    if (candidate === previouslyFocusedElement) return true;
    candidate.focus();
    return document.activeElement !== previouslyFocusedElement;
  });
}
var Provider = ToastProvider$1;
var Viewport = ToastViewport$1;
var Root2 = Toast$1;
var Title = ToastTitle$1;
var Description = ToastDescription$1;
var Action = ToastAction$1;
var Close = ToastClose$1;
const ToastProvider = Provider;
const ToastViewport = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Viewport,
  {
    ref,
    className: cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    ),
    ...props
  }
));
ToastViewport.displayName = Viewport.displayName;
const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
      }
    },
    defaultVariants: {
      variant: "default"
    }
  }
);
const Toast = reactExports.forwardRef(({ className, variant, ...props }, ref) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Root2,
    {
      ref,
      className: cn(toastVariants({ variant }), className),
      ...props
    }
  );
});
Toast.displayName = Root2.displayName;
const ToastAction = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Action,
  {
    ref,
    className: cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    ),
    ...props
  }
));
ToastAction.displayName = Action.displayName;
const ToastClose = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Close,
  {
    ref,
    className: cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    ),
    "toast-close": "",
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, { className: "h-4 w-4" })
  }
));
ToastClose.displayName = Close.displayName;
const ToastTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref,
    className: cn("text-sm font-semibold", className),
    ...props
  }
));
ToastTitle.displayName = Title.displayName;
const ToastDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref,
    className: cn("text-sm opacity-90", className),
    ...props
  }
));
ToastDescription.displayName = Description.displayName;
function Toaster() {
  const { toasts } = useToast();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(ToastProvider, { children: [
    toasts.map(function({ id: id2, title, description, action, ...props }) {
      return /* @__PURE__ */ jsxRuntimeExports.jsxs(Toast, { ...props, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-1", children: [
          title && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastTitle, { children: title }),
          description && /* @__PURE__ */ jsxRuntimeExports.jsx(ToastDescription, { children: description })
        ] }),
        action,
        /* @__PURE__ */ jsxRuntimeExports.jsx(ToastClose, {})
      ] }, id2);
    }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(ToastViewport, {})
  ] });
}
const templateFormSchema = objectType({
  templateName: stringType().min(2, "Template name must be at least 2 characters"),
  name: stringType().min(2, "Item name must be at least 2 characters"),
  description: stringType().optional(),
  category: stringType().min(1, "Category is required"),
  unit: stringType().min(1, "Unit is required"),
  minQuantity: numberType().min(0).optional(),
  reorderLevel: numberType().min(0).optional(),
  location: stringType().min(1, "Location is required"),
  locationSubcategory: stringType().optional(),
  supplier: stringType().optional(),
  supplierWebsite: stringType().url().optional(),
  notes: stringType().optional(),
  orderStatus: nativeEnumType(OrderStatus).optional(),
  barcode: stringType().optional()
});
function TemplateForm({
  template,
  onSubmit,
  onCancel,
  categories: categories2,
  units: units2,
  locations: locations2,
  suppliers: suppliers2,
  cabinets = [],
  projects: projects2 = [],
  isSubmitting = false
}) {
  const { toast: toast2 } = useToast();
  const [activeTab, setActiveTab] = reactExports.useState("details");
  const [isScannerOpen, setIsScannerOpen] = reactExports.useState(false);
  const form = useForm({
    resolver: t2(templateFormSchema),
    defaultValues: {
      templateName: template?.templateName || "",
      name: template?.name || "",
      description: template?.description || "",
      category: template?.category || "",
      unit: template?.unit || "",
      minQuantity: template?.minQuantity || 0,
      reorderLevel: template?.reorderLevel || 0,
      location: template?.location || "",
      locationSubcategory: template?.locationSubcategory || "",
      supplier: template?.supplier || "",
      supplierWebsite: template?.supplierWebsite || "",
      notes: template?.notes || "",
      orderStatus: template?.orderStatus || OrderStatus.PENDING,
      barcode: template?.barcode || ""
    }
  });
  const handleScanResult = (result) => {
    form.setValue("barcode", result);
    toast2({
      title: "Barcode Scanned",
      description: `Successfully scanned barcode: ${result}`
    });
    setIsScannerOpen(false);
  };
  const handleSubmit = (data) => {
    const templateData = {
      templateId: template?.templateId || crypto.randomUUID(),
      templateName: data.templateName,
      name: data.name,
      description: data.description || "",
      category: data.category,
      unit: data.unit,
      minQuantity: data.minQuantity || 0,
      reorderLevel: data.reorderLevel || 0,
      location: data.location,
      locationSubcategory: data.locationSubcategory || "",
      supplier: data.supplier || "",
      supplierWebsite: data.supplierWebsite || "",
      notes: data.notes || "",
      orderStatus: data.orderStatus || OrderStatus.PENDING,
      quantity: 0,
      costPerUnit: 0,
      price: 0,
      barcode: data.barcode || "",
      project: "",
      deliveryPercentage: 0
    };
    onSubmit(templateData);
    toast2({
      title: template ? "Template Updated" : "Template Created",
      description: `Successfully ${template ? "updated" : "created"} template "${data.templateName}"`
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Form, { ...form, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: form.handleSubmit(handleSubmit), className: "space-y-4 max-h-[80vh] overflow-y-auto p-4", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "mb-6 border-b pb-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        FormField,
        {
          control: form.control,
          name: "templateName",
          render: ({ field }) => /* @__PURE__ */ jsxRuntimeExports.jsxs(FormItem, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormLabel, { children: "Template Name*" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(Input, { ...field, placeholder: "Enter template name" }) }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormDescription, { children: "Give your template a unique name to identify it later" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {})
          ] })
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Tabs, { value: activeTab, onValueChange: setActiveTab, className: "space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(TabsList, { className: "grid w-full grid-cols-3", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "details", children: "Item Details" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "inventory", children: "Inventory & Supply" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(TabsTrigger, { value: "additional", children: "Additional Info" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "details", className: "space-y-4 mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          BasicDetailsTab,
          {
            form,
            categories: categories2,
            locations: locations2,
            cabinets,
            projects: projects2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "inventory", className: "space-y-4 mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          InventorySupplyTab$1,
          {
            form,
            units: units2,
            suppliers: suppliers2
          }
        ) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(TabsContent, { value: "additional", className: "space-y-4 mt-4", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          AdditionalInfoTab$1,
          {
            form,
            onScanBarcode: () => setIsScannerOpen(true)
          }
        ) })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2 mt-6 sticky bottom-0 bg-background py-4 border-t", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: onCancel, type: "button", children: "Cancel" }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { type: "submit", disabled: isSubmitting, children: [
          isSubmitting && /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
          template ? "Update Template" : "Create Template"
        ] })
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      BarcodeScannerDialog,
      {
        open: isScannerOpen,
        onOpenChange: setIsScannerOpen,
        onScan: handleScanResult
      }
    )
  ] });
}
function TemplatesPage() {
  const [templates, setTemplates] = reactExports.useState([]);
  const [isCreateDialogOpen, setIsCreateDialogOpen] = reactExports.useState(false);
  const [isAddItemDialogOpen, setIsAddItemDialogOpen] = reactExports.useState(false);
  const [selectedTemplate, setSelectedTemplate] = reactExports.useState(null);
  const { toast: toast2 } = useToast();
  const navigate = useNavigate();
  const { items: existingItems } = useInventory();
  const settings = getSettings();
  const { categories: categories2, units: units2, locations: locations2, suppliers: suppliers2, projects: projects2 } = settings;
  reactExports.useEffect(() => {
    try {
      const loadedTemplates = getTemplates();
      console.log("Loaded templates:", loadedTemplates);
      setTemplates(loadedTemplates);
    } catch (error) {
      console.error("Error loading templates:", error);
      toast2({
        title: "Error",
        description: "Failed to load templates",
        variant: "destructive"
      });
    }
  }, []);
  const handleCreateTemplate = () => {
    setSelectedTemplate(null);
    setIsCreateDialogOpen(true);
  };
  const handleEditTemplate = (template) => {
    setSelectedTemplate(template);
    setIsCreateDialogOpen(true);
  };
  const handleDeleteTemplate = (templateId) => {
    try {
      const newTemplates = templates.filter((t3) => t3.templateId !== templateId);
      saveTemplates(newTemplates);
      setTemplates(newTemplates);
      toast2({
        title: "Template Deleted",
        description: "The template has been successfully deleted."
      });
    } catch (error) {
      console.error("Error deleting template:", error);
      toast2({
        title: "Error",
        description: "Failed to delete template",
        variant: "destructive"
      });
    }
  };
  const handleUseTemplate = (template) => {
    setSelectedTemplate(template);
    setIsAddItemDialogOpen(true);
  };
  const handleAddItem = async (newItemData) => {
    try {
      navigate("/inventory", { state: { newItem: newItemData } });
    } catch (error) {
      console.error("Error adding item:", error);
      toast2({
        title: "Error",
        description: "Failed to add item",
        variant: "destructive"
      });
    }
  };
  const handleSubmitTemplate = (templateData) => {
    try {
      let newTemplates;
      if (selectedTemplate) {
        newTemplates = templates.map(
          (t3) => t3.templateId === templateData.templateId ? templateData : t3
        );
      } else {
        const newTemplate = {
          ...templateData,
          templateId: v4()
        };
        newTemplates = [...templates, newTemplate];
      }
      saveTemplates(newTemplates);
      setTemplates(newTemplates);
      setIsCreateDialogOpen(false);
      toast2({
        title: selectedTemplate ? "Template Updated" : "Template Created",
        description: `Template has been ${selectedTemplate ? "updated" : "created"} successfully.`
      });
    } catch (error) {
      console.error("Error saving template:", error);
      toast2({
        title: "Error",
        description: "Failed to save template",
        variant: "destructive"
      });
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container mx-auto py-6", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold", children: "Item Templates" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: "Create and manage templates for frequently added items" })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Button, { onClick: handleCreateTemplate, children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, { className: "mr-2 h-4 w-4" }),
        "Create Template"
      ] })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: templates.map((template) => /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: template.templateName }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: template.category })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground mb-4", children: template.description }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-end space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => handleEditTemplate(template),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(PenSquare, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Button,
            {
              variant: "outline",
              size: "sm",
              onClick: () => handleDeleteTemplate(template.templateId),
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" })
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsxs(
            Button,
            {
              variant: "default",
              size: "sm",
              onClick: () => handleUseTemplate(template),
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(Copy, { className: "h-4 w-4 mr-2" }),
                "Use Template"
              ]
            }
          )
        ] })
      ] })
    ] }, template.templateId)) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: isCreateDialogOpen, onOpenChange: setIsCreateDialogOpen, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "max-w-3xl", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: selectedTemplate ? "Edit Template" : "Create Template" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Fill in the template details below. Templates can be used to quickly create new inventory items." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        TemplateForm,
        {
          template: selectedTemplate || void 0,
          onSubmit: handleSubmitTemplate,
          onCancel: () => setIsCreateDialogOpen(false),
          categories: categories2,
          units: units2,
          locations: locations2,
          suppliers: suppliers2,
          projects: projects2
        }
      )
    ] }) }),
    selectedTemplate && /* @__PURE__ */ jsxRuntimeExports.jsx(
      AddItemDialog,
      {
        open: isAddItemDialogOpen,
        onOpenChange: setIsAddItemDialogOpen,
        onSubmit: handleAddItem,
        categories: categories2,
        units: units2,
        locations: locations2,
        suppliers: suppliers2,
        projects: projects2,
        selectedTemplate,
        existingItems
      }
    )
  ] });
}
function CheckoutPage() {
  const [items, setItems] = reactExports.useState([]);
  const [selectedItemId, setSelectedItemId] = reactExports.useState("");
  const [selectedCabinetId, setSelectedCabinetId] = reactExports.useState("");
  const [quantity, setQuantity] = reactExports.useState("");
  const [cabinets, setCabinets] = reactExports.useState([]);
  const [recentActivities, setRecentActivities] = reactExports.useState([]);
  const { currentUser } = useAuth();
  const [settings, setSettings] = reactExports.useState({
    requireCheckoutForSecureCabinets: true
  });
  reactExports.useEffect(() => {
    const loadData = async () => {
      const inventoryItems = getItems();
      const loadedCabinets = await SettingsService.getCabinets();
      const loadedSettings = SettingsService.loadDefaultSettings();
      setItems(inventoryItems);
      setCabinets(loadedCabinets);
      setSettings(loadedSettings);
    };
    loadData();
  }, []);
  reactExports.useEffect(() => {
    const logs = logger.getLogs();
    const checkoutLogs = logs.filter(
      (log) => log.message === "ITEM_CHECKOUT" || log.message === "ITEM_CHECKIN"
    );
    setRecentActivities(checkoutLogs);
  }, []);
  const handleAction = async (action) => {
    try {
      console.log(`[${action.toUpperCase()}] Starting ${action} action`, {
        itemId: selectedItemId,
        quantity,
        cabinetId: selectedCabinetId
      });
      if (!selectedItemId || !quantity || isNaN(Number(quantity)) || Number(quantity) <= 0) {
        const error = "Invalid item or quantity";
        console.log(`[ERROR] ${error}`, { selectedItemId, quantity });
        logger.error("audit", error, { selectedItemId, quantity }, "CheckoutPage");
        ue.error("Please select an item and enter a valid quantity");
        return;
      }
      if (!selectedCabinetId) {
        const error = "No cabinet selected";
        console.log(`[ERROR] ${error}`);
        logger.error("audit", error, {}, "CheckoutPage");
        ue.error("Please select a cabinet");
        return;
      }
      const selectedCabinet = cabinets.find((c3) => c3.id === selectedCabinetId);
      if (!selectedCabinet) {
        const error = "Selected cabinet not found";
        console.log(`[ERROR] ${error}`, { cabinetId: selectedCabinetId });
        logger.error("audit", error, { cabinetId: selectedCabinetId }, "CheckoutPage");
        ue.error("Selected cabinet not found");
        return;
      }
      if (settings.requireCheckoutForSecureCabinets && selectedCabinet.isSecure) {
        console.log("[INFO] Processing secure cabinet transaction", {
          cabinet: selectedCabinet.name,
          isSecure: selectedCabinet.isSecure
        });
      } else {
        const error = "Cabinet does not require check-in/out";
        console.log(`[ERROR] ${error}`, { cabinet: selectedCabinet });
        logger.error("audit", error, { cabinetId: selectedCabinetId, cabinetName: selectedCabinet.name, isSecure: selectedCabinet.isSecure }, "CheckoutPage");
        ue.error("This cabinet does not require check-in/out");
        return;
      }
      const numQuantity = Number(quantity);
      const selectedItem = items.find((item) => item.id === selectedItemId);
      if (!selectedItem) {
        ue.error("Selected item not found");
        return;
      }
      if (action === "check-out" && (selectedItem.quantity || 0) < numQuantity) {
        ue.error("Not enough items available");
        return;
      }
      const updatedItems = items.map((item) => {
        if (item.id === selectedItemId) {
          const newQuantity = action === "check-out" ? Math.max(0, (item.quantity || 0) - numQuantity) : (item.quantity || 0) + numQuantity;
          return {
            ...item,
            quantity: newQuantity,
            lastUpdated: /* @__PURE__ */ new Date()
          };
        }
        return item;
      });
      saveItems(updatedItems);
      setItems(updatedItems);
      logger.info("audit", action === "check-out" ? "ITEM_CHECKOUT" : "ITEM_CHECKIN", {
        itemId: selectedItemId,
        itemName: selectedItem?.name,
        quantity: numQuantity,
        cabinetId: selectedCabinetId,
        cabinetName: selectedCabinet.name,
        performedBy: currentUser?.username
      }, "CheckoutPage");
      ue.success(`Successfully ${action === "check-out" ? "checked out" : "checked in"} ${numQuantity} ${selectedItem?.name}`);
      setSelectedItemId("");
      setSelectedCabinetId("");
      setQuantity("");
      const logs = logger.getLogs();
      const checkoutLogs = logs.filter(
        (log) => log.message === "ITEM_CHECKOUT" || log.message === "ITEM_CHECKIN"
      );
      setRecentActivities(checkoutLogs);
    } catch (error) {
      console.error("Error during check-in/out:", error);
      ue.error("Failed to process check-in/out");
    }
  };
  cabinets.filter((cabinet) => cabinet.isSecure);
  const handleCabinetChange = async (cabinetId) => {
    console.log("[INFO] Cabinet selected", { cabinetId });
    logger.info("audit", "CABINET_SELECTED", { cabinetId, cabinetName: cabinets.find((c3) => c3.id === cabinetId)?.name }, "CheckoutPage");
    setSelectedCabinetId(cabinetId);
  };
  const handleItemChange = async (itemId) => {
    console.log("[INFO] Item selected", { itemId });
    logger.info("audit", "ITEM_SELECTED", { itemId, itemName: items.find((i3) => i3.id === itemId)?.name }, "CheckoutPage");
    setSelectedItemId(itemId);
  };
  const handleQuantityChange = async (value) => {
    console.log("[INFO] Quantity changed", { value });
    setQuantity(value);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "container max-w-4xl py-8", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-between items-center mb-6", children: /* @__PURE__ */ jsxRuntimeExports.jsx("h1", { className: "text-3xl font-bold tracking-tight", children: "Secure Cabinet Check-In/Out" }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-6", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Check In/Out Items" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Select a secure cabinet and item to check in or out." })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardContent, { className: "relative", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-4", children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Cabinet" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedCabinetId, onValueChange: handleCabinetChange, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select a cabinet" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: cabinets.map((cabinet) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: cabinet.id, children: [
                  cabinet.name,
                  " ",
                  cabinet.isSecure ? "(Secure)" : ""
                ] }, cabinet.id)) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Item" }),
              /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: selectedItemId, onValueChange: handleItemChange, children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, { placeholder: "Select an item" }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: items.map((item) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectItem, { value: item.id, children: [
                  item.name,
                  " (",
                  item.quantity || 0,
                  " available)"
                ] }, item.id)) })
              ] })
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx("label", { className: "text-sm font-medium", children: "Quantity" }),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Input,
                {
                  type: "number",
                  min: "1",
                  value: quantity,
                  onChange: (e3) => handleQuantityChange(e3.target.value),
                  placeholder: "Enter quantity"
                }
              )
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-4 pt-4", children: [
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "flex-1 bg-gray-100 hover:bg-gray-200",
                  onClick: () => handleAction("check-in"),
                  children: "Check In"
                }
              ),
              /* @__PURE__ */ jsxRuntimeExports.jsx(
                Button,
                {
                  variant: "outline",
                  className: "flex-1 bg-gray-100 hover:bg-gray-200",
                  onClick: () => handleAction("check-out"),
                  children: "Check Out"
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            DebugLogsButton,
            {
              onDownload: async () => {
                try {
                  logger.info("audit", "DOWNLOAD_LOGS", { page: "checkout", timestamp: (/* @__PURE__ */ new Date()).toISOString() }, "CheckoutPage");
                } catch (error) {
                  console.error("Error downloading logs:", error);
                  ue.error("Failed to download logs");
                }
              },
              context: "checkout"
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { children: "Recent Activity" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { children: "Recent check-ins and check-outs from secure cabinets" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { className: "relative", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "space-y-4", children: recentActivities.length > 0 ? recentActivities.map((activity, index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center py-2 border-b last:border-0", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "font-medium", children: [
              activity.message === "ITEM_CHECKOUT" ? "Checked Out" : "Checked In",
              ": ",
              activity.details.quantity,
              "x ",
              activity.details.itemName
            ] }),
            /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "text-sm text-muted-foreground", children: [
              "Cabinet: ",
              activity.details.cabinetName,
              " | By: ",
              activity.details.performedBy
            ] })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "text-sm text-muted-foreground", children: format(new Date(activity.timestamp), "MMM d, h:mm a") })
        ] }, index2)) : /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: "No recent activity" }) }) })
      ] })
    ] })
  ] });
}
class ErrorBoundary extends reactExports.Component {
  state = {
    hasError: false,
    error: null
  };
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  componentDidCatch(error, errorInfo) {
    console.error("Error caught by boundary:", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "min-h-screen flex items-center justify-center bg-background", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "max-w-md w-full p-6 space-y-4", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2 text-center", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold tracking-tight", children: "Something went wrong" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-muted-foreground", children: this.state.error?.message || "An unexpected error occurred" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            onClick: () => {
              this.setState({ hasError: false, error: null });
              window.location.reload();
            },
            children: "Try again"
          }
        ) })
      ] }) });
    }
    return this.props.children;
  }
}
function ProtectedRoute({ children }) {
  const { currentUser } = useAuth();
  const location2 = useLocation();
  if (!currentUser) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/login", state: { from: location2 }, replace: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
}
function App() {
  reactExports.useEffect(() => {
    initializeSettings();
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ErrorBoundary, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "min-h-screen bg-background", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Navigation, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "container mx-auto py-6 px-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Routes, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(DashboardPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/inventory",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(InventoryPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/checkout",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckoutPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/templates",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TemplatesPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/reports",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReportsPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Route,
        {
          path: "/settings",
          element: /* @__PURE__ */ jsxRuntimeExports.jsx(ProtectedRoute, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(SettingsPage, {}) })
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/", replace: true }) })
    ] }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Toaster, {})
  ] }) }) });
}
logger$1.setContext("login");
const loginSchema = z2.object({
  username: z2.string().min(1, "Username is required"),
  password: z2.string().min(1, "Password is required"),
  remember: z2.boolean().default(false)
});
const resetPasswordSchema = z2.object({
  username: z2.string().min(1, "Username is required"),
  securityAnswer: z2.string().min(1, "Security answer is required"),
  newPassword: z2.string().min(4, "Password must be at least 4 characters")
});
function LoginForm() {
  const { login, resetPassword } = useAuth();
  const [isLoading, setIsLoading] = reactExports.useState(false);
  const [showResetDialog, setShowResetDialog] = reactExports.useState(false);
  const [isResetting, setIsResetting] = reactExports.useState(false);
  const [loginError, setLoginError] = reactExports.useState(null);
  const [resetError, setResetError] = reactExports.useState(null);
  const { register, handleSubmit, formState: { errors }, getValues } = useForm({
    resolver: t2(loginSchema),
    defaultValues: {
      username: "",
      password: "",
      remember: false
    }
  });
  const { register: registerReset, handleSubmit: handleResetSubmit, formState: { errors: resetErrors }, watch } = useForm({
    resolver: t2(resetPasswordSchema),
    defaultValues: {
      username: "",
      securityAnswer: "",
      newPassword: ""
    }
  });
  const [securityQuestion, setSecurityQuestion] = reactExports.useState("");
  const username = watch("username");
  reactExports.useEffect(() => {
    const fetchSecurityQuestion = async () => {
      if (!username) {
        setSecurityQuestion("");
        return;
      }
      const storedUsers = localStorage.getItem("inventory-users");
      if (!storedUsers) return;
      const users = JSON.parse(storedUsers);
      const user = users.find((u3) => u3.username.toLowerCase() === username.toLowerCase());
      setSecurityQuestion(user?.securityQuestion || "");
    };
    fetchSecurityQuestion();
  }, [username]);
  const onSubmit = async (data) => {
    console.log("Form submitted with:", { username: data.username, remember: data.remember });
    logger$1.log(`Login attempt for user: ${data.username}`);
    setIsLoading(true);
    setLoginError(null);
    try {
      console.log("Attempting login...");
      const success = await login(data.username, data.password, data.remember);
      console.log("Login result:", success);
      logger$1.log(`Login ${success ? "successful" : "failed"} for user: ${data.username}`);
      if (!success) {
        console.log("Login failed, setting error state");
        setLoginError("Invalid username or password. Please try again.");
        ue.error("Invalid username or password");
      }
    } catch (error) {
      console.error("Login error:", error);
      logger$1.error("Login error", error);
      setLoginError("An error occurred during login. Please try again.");
      ue.error("Login failed. Please try again.");
    } finally {
      console.log("Login attempt completed");
      setIsLoading(false);
    }
  };
  const onResetSubmit = async (data) => {
    logger$1.log(`Password reset attempt for user: ${data.username}`);
    setIsResetting(true);
    setResetError(null);
    try {
      const success = await resetPassword(data.username, data.securityAnswer, data.newPassword);
      if (success) {
        logger$1.log(`Password reset successful for user: ${data.username}`);
        setShowResetDialog(false);
        ue.success("Password has been reset successfully. Please log in with your new password.");
      } else {
        logger$1.log(`Password reset failed for user: ${data.username} - Incorrect security answer`);
        setResetError("Incorrect security answer. Please try again.");
        ue.error("Incorrect security answer");
      }
    } catch (error) {
      logger$1.error("Password reset error", error);
      setResetError("An error occurred while resetting password. Please try again.");
      ue.error("Password reset failed");
    } finally {
      setIsResetting(false);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "relative min-h-[400px] p-6 bg-white rounded-lg shadow-sm", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleSubmit(onSubmit), className: "space-y-6", children: [
      loginError && /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "p-4 mb-4 text-sm border rounded-md bg-destructive/10 text-destructive border-destructive flex items-center space-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Login Failed" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: loginError })
      ] }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "username", className: "text-sm font-medium", children: "Username" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: "username",
            type: "text",
            placeholder: "Enter your username",
            ...register("username"),
            disabled: isLoading,
            className: `h-10 ${loginError ? "border-destructive" : ""}`
          }
        ),
        errors.username && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-destructive mt-1", children: errors.username.message })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "password", className: "text-sm font-medium", children: "Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Input,
          {
            id: "password",
            type: "password",
            placeholder: "Enter your password",
            ...register("password"),
            disabled: isLoading,
            className: `h-10 ${loginError ? "border-destructive" : ""}`
          }
        ),
        errors.password && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-destructive mt-1", children: errors.password.message })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center justify-between", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Checkbox, { id: "remember", ...register("remember"), disabled: isLoading }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "remember", className: "text-sm flex items-center", children: "Remember me" })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            type: "button",
            variant: "link",
            className: "text-sm",
            onClick: () => {
              setShowResetDialog(true);
              setResetError(null);
            },
            disabled: isLoading,
            children: "Forgot password?"
          }
        )
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Button,
        {
          type: "submit",
          className: "w-full h-10",
          disabled: isLoading,
          variant: loginError ? "destructive" : "default",
          children: isLoading ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
            "Logging in..."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(LogIn, { className: "mr-2 h-4 w-4" }),
            loginError ? "Try Again" : "Log In"
          ] })
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-2 left-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      DebugLogsButton,
      {
        onDownload: () => {
          logger$1.log("Debug logs downloaded");
          logger$1.downloadLogs();
        },
        context: "login"
      }
    ) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "absolute bottom-2 right-2 text-sm text-muted-foreground/80 font-mono", children: "rev.005" }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Dialog, { open: showResetDialog, onOpenChange: setShowResetDialog, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: "Reset Password" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: "Enter your username and security answer to reset your password." })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsxs("form", { onSubmit: handleResetSubmit(onResetSubmit), className: "space-y-4", children: [
        resetError && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "p-4 text-sm border rounded-md bg-destructive/10 text-destructive border-destructive flex items-center space-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-1 h-full bg-destructive rounded-full" }),
          /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "font-medium", children: "Reset Failed" }),
            /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: resetError })
          ] })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "reset-username", children: "Username" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "reset-username",
              type: "text",
              placeholder: "Enter your username",
              ...registerReset("username"),
              disabled: isResetting
            }
          ),
          resetErrors.username && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-destructive", children: resetErrors.username.message })
        ] }),
        securityQuestion && /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { children: "Security Question" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm text-muted-foreground", children: securityQuestion })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "security-answer", children: "Security Answer" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "security-answer",
              type: "text",
              placeholder: "Enter your security answer",
              ...registerReset("securityAnswer"),
              disabled: isResetting,
              className: resetError ? "border-destructive" : ""
            }
          ),
          resetErrors.securityAnswer && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-destructive", children: resetErrors.securityAnswer.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "space-y-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label$1, { htmlFor: "new-password", children: "New Password" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Input,
            {
              id: "new-password",
              type: "password",
              placeholder: "Enter new password (minimum 4 characters)",
              ...registerReset("newPassword"),
              disabled: isResetting
            }
          ),
          resetErrors.newPassword && /* @__PURE__ */ jsxRuntimeExports.jsx("p", { className: "text-sm font-medium text-destructive", children: resetErrors.newPassword.message })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => setShowResetDialog(false), type: "button", children: "Cancel" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", disabled: isResetting, children: isResetting ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Loader2, { className: "mr-2 h-4 w-4 animate-spin" }),
            "Resetting..."
          ] }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(Key, { className: "mr-2 h-4 w-4" }),
            "Reset Password"
          ] }) })
        ] })
      ] })
    ] }) })
  ] });
}
function LoginPage() {
  const { isAuthenticated, isLoading } = useAuth();
  if (isAuthenticated && !isLoading) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Navigate, { to: "/dashboard", replace: true });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-muted/30", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "w-full max-w-md p-4", children: /* @__PURE__ */ jsxRuntimeExports.jsxs(Card, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs(CardHeader, { className: "space-y-1", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardTitle, { className: "text-2xl font-bold text-center", children: "TEd_trackIT" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(CardDescription, { className: "text-center", children: "Enter your credentials to access your inventory" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(CardContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginForm, {}) })
  ] }) }) });
}
const router = createBrowserRouter(
  createRoutesFromChildren(
    /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/login", element: /* @__PURE__ */ jsxRuntimeExports.jsx(LoginPage, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Route, { path: "/*", element: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
    ] })
  )
);
createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AuthProvider, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      $e,
      {
        position: "top-right",
        richColors: true,
        expand: true,
        closeButton: true,
        duration: 4e3,
        theme: "light",
        style: { zIndex: 9999 }
      }
    )
  ] }) })
);
